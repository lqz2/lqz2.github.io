

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.jpg">
  <link rel="icon" href="/img/avatar.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="zql">
  <meta name="keywords" content="">
  
    <meta name="description" content="Java  JDK、JRE和JVM是什么？  JDK JRE JVM   字节码 为什么说Java“编译与解释共存”？ AOT和JIT Java内存区域  程序计数器 虚拟机栈 本地方法栈 堆 方法区 运行时常量池和字符串常量池 直接内存 为什么要将永久代替换为元空间？   JVM垃圾回收  内存分配和回收原则 死亡对象的判断方法 垃圾回收算法 垃圾回收器有哪些？ 垃圾回收器CMS和G1的区别">
<meta property="og:type" content="article">
<meta property="og:title" content="常见问题">
<meta property="og:url" content="http://lqz2.github.io/2022/08/26/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="my blogs">
<meta property="og:description" content="Java  JDK、JRE和JVM是什么？  JDK JRE JVM   字节码 为什么说Java“编译与解释共存”？ AOT和JIT Java内存区域  程序计数器 虚拟机栈 本地方法栈 堆 方法区 运行时常量池和字符串常量池 直接内存 为什么要将永久代替换为元空间？   JVM垃圾回收  内存分配和回收原则 死亡对象的判断方法 垃圾回收算法 垃圾回收器有哪些？ 垃圾回收器CMS和G1的区别">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1715930589177-73932d2c-b0c0-4f58-a5c1-ab514b1a389c.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png">
<meta property="article:published_time" content="2022-08-26T13:10:10.000Z">
<meta property="article:modified_time" content="2025-03-08T08:07:25.077Z">
<meta property="article:author" content="zql">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png">
  
  
  
  <title>常见问题 - my blogs</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.15.6/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lqz2.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>my blogs</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/1r.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="常见问题"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-26 21:10" pubdate>
          2022年8月26日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          29k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          240 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">常见问题</h1>
            
            
              <div class="markdown-body">
                
                <!-- TOC -->
<ul>
<li><a href="#java">Java</a>
<ul>
<li><a href="#jdkjre%E5%92%8Cjvm%E6%98%AF%E4%BB%80%E4%B9%88">JDK、JRE和JVM是什么？</a>
<ul>
<li><a href="#jdk">JDK</a></li>
<li><a href="#jre">JRE</a></li>
<li><a href="#jvm">JVM</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E8%8A%82%E7%A0%81">字节码</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4java%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%85%B1%E5%AD%98">为什么说Java“编译与解释共存”？</a></li>
<li><a href="#aot%E5%92%8Cjit">AOT和JIT</a></li>
<li><a href="#java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F">Java内存区域</a>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">程序计数器</a></li>
<li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">虚拟机栈</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">本地方法栈</a></li>
<li><a href="#%E5%A0%86">堆</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a></li>
<li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0">运行时常量池和字符串常量池</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">直接内存</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%86%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%85%83%E7%A9%BA%E9%97%B4">为什么要将永久代替换为元空间？</a></li>
</ul>
</li>
<li><a href="#jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">JVM垃圾回收</a>
<ul>
<li><a href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E5%88%99">内存分配和回收原则</a></li>
<li><a href="#%E6%AD%BB%E4%BA%A1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95">死亡对象的判断方法</a></li>
<li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95">垃圾回收算法</a></li>
<li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B">垃圾回收器有哪些？</a></li>
<li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8cms%E5%92%8Cg1%E7%9A%84%E5%8C%BA%E5%88%AB">垃圾回收器CMS和G1的区别?</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8">如何选择合适的垃圾回收器？</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基础数据类型</a></li>
<li><a href="#%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%A6%E7%94%9F%E7%B1%BB%E6%83%B3%E6%8C%89%E7%85%A7%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F%E5%86%8D%E6%8C%89%E5%AD%A6%E5%8F%B7%E6%8E%92%E5%BA%8F%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A">有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</a></li>
<li><a href="#java%E9%9B%86%E5%90%88">Java集合</a>
<ul>
<li><a href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB">数组和集合的区别？</a></li>
<li><a href="#arraylist%E5%92%8Clinkedlist%E7%9A%84%E5%8C%BA%E5%88%AB">ArrayList和LinkedList的区别？</a></li>
<li><a href="#arraylist%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88">ArrayList的扩容机制是什么？</a></li>
<li><a href="#copyonwritearraylist%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84">CopyonWriteArraylist是如何实现线程安全的？</a></li>
<li><a href="#hashmap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B">HashMap实现原理介绍一下？</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">解决哈希冲突的方法有哪些？</a></li>
<li><a href="#hashmap%E7%9A%84put%E8%BF%87%E7%A8%8B">HashMap的put过程？</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88hashmap%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8D%E7%94%A8%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">为什么HashMap用红黑树不用平衡二叉树？</a></li>
<li><a href="#hashmap-key%E5%8F%AF%E4%BB%A5%E4%B8%BAnull%E5%90%97">HashMap key可以为null吗？</a></li>
<li><a href="#%E9%87%8D%E5%86%99hashmap%E7%9A%84equals%E5%92%8Chashcode%E6%96%B9%E6%B3%95%E6%97%B6%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88">重写HashMap的equals和hashCode方法时，要注意什么？</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88hashmap%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9">为什么HashMap的大小是2的幂次方？</a></li>
<li><a href="#concurrenthashmap%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84">ConcurrentHashMap是如何实现线程安全的？</a></li>
<li><a href="#%E5%88%86%E6%AE%B5%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84">分段锁是怎么加锁的？</a></li>
<li><a href="#concurrenthashmap%E7%94%A8%E7%9A%84%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%E8%BF%98%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81">ConcurrentHashMap用的是乐观锁还是悲观锁？</a></li>
<li><a href="#hashtable%E5%92%8Cconcurrenthashmap%E7%9A%84%E5%8C%BA%E5%88%AB">hashtable和ConcurrentHashMap的区别？</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>
<ul>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B">面向对象的设计原则有哪些？</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB">抽象类和接口的区别</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%90%97">抽象类可以被实例化吗？</a></li>
<li><a href="#java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">Java深拷贝的方式有哪些？</a></li>
</ul>
</li>
<li><a href="#java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1">Java中的对象</a>
<ul>
<li><a href="#java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F">Java中创建对象有哪些方式？</a></li>
<li><a href="#new%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9B%9E%E6%94%B6">new的对象什么时候回收？</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6">反射机制</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6">什么是反射机制？</a></li>
<li><a href="#%E5%8F%8D%E5%B0%84%E5%9C%A8%E4%BD%A0%E5%B9%B3%E6%97%B6%E5%86%99%E4%BB%A3%E7%A0%81%E6%88%96%E8%80%85%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B">反射在你平时写代码或者框架中的应用场景有哪些?</a></li>
</ul>
</li>
<li><a href="#java%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86">Java注解的原理</a></li>
<li><a href="#-%E4%B8%8E-equals-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">== 与 equals 有什么区别？</a></li>
<li><a href="#stringbuffer%E5%92%8Cstringbuilder%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">StringBuffer和StringBuilder区别是什么？</a></li>
<li><a href="#%E5%B9%B6%E5%8F%91">并发</a>
<ul>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2">线程安全体现在哪些方面？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFcas%E6%93%8D%E4%BD%9C">什么是CAS操作？</a></li>
<li><a href="#cas%E7%9A%84%E7%BC%BA%E7%82%B9">CAS的缺点？</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">线程创建方式有哪些？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B">如何停止线程？</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B">线程的状态有哪些？</a></li>
<li><a href="#blocked%E5%92%8Cwaiting%E7%9A%84%E5%8C%BA%E5%88%AB">blocked和waiting的区别？</a></li>
<li><a href="#notify%E5%92%8Cnotifyall%E7%9A%84%E5%8C%BA%E5%88%AB">notify和notifyAll的区别？</a></li>
<li><a href="#%E5%86%99%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%A5%87%E5%81%B6%E6%95%B0">写一段代码，实现线程交替打印奇偶数</a></li>
<li><a href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">怎么保证多线程安全？</a></li>
<li><a href="#java%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88">java中有哪些常用的锁？使用场景是什么？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81">什么是公平锁和非公平锁？</a></li>
<li><a href="#%E8%AE%B2%E8%AE%B2reentrantlock">讲讲ReentrantLock？</a></li>
<li><a href="#synchronized%E5%92%8Creentrantlock%E7%9A%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C">synchronized和ReentrantLock的的应用场景有什么不同？</a></li>
<li><a href="#synchronized%E5%92%8Creentrantlock%E7%9A%84%E5%8C%BA%E5%88%AB">synchronized和ReentrantLock的区别？</a></li>
<li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Baqs">介绍一下AQS?</a></li>
<li><a href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8">volatile关键字的作用？</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6">死锁产生的条件？</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86">线程池的原理？</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B">线程池的参数有哪些？</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B">线程池的拒绝策略有哪些？</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE">核心线程数如何设置？</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B">线程池种类有哪些？</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95">多线程顺序执行的几种写法?</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADshutdown%E5%92%8Cshutdownnow%E7%9A%84%E5%8C%BA%E5%88%AB">线程池中shutdown和shutdownNow的区别？</a></li>
<li><a href="#%E6%8F%90%E4%BA%A4%E7%BB%99%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%92%A4%E5%9B%9E%E5%90%97">提交给线程池的任务可以被撤回吗？</a></li>
<li><a href="#threadlocal%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">ThreadLocal为什么会发生内存泄漏？</a></li>
<li><a href="#threadlocal%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%A7%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">ThreadLocal的继承性问题以及解决方法？</a></li>
</ul>
</li>
<li><a href="#mysql">MYSQL</a>
<ul>
<li><a href="#mybatis%E4%B8%AD%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB">MyBatis中#{}和${}的区别？</a></li>
<li><a href="#sql%E6%B3%A8%E5%85%A5%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90">SQL注入是什么？举个例子？</a></li>
<li><a href="#mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">mysql的事务隔离级别</a>
<ul>
<li><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7">事务的四个特性</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">事务隔离解决的问题</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务隔离级别</a></li>
</ul>
</li>
<li><a href="#mysql%E7%9A%84%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%BC%95%E6%93%8E">MYSQL的有哪几种引擎？</a></li>
<li><a href="#mysql%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E6%97%A5%E5%BF%97">MYSQL了解哪些日志？</a></li>
<li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bbin-log">介绍一下bin log？</a></li>
<li><a href="#mysql%E6%80%8E%E4%B9%88%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2">MYSQL怎么连表查询？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">如何避免重复插入数据？</a></li>
<li><a href="#in%E5%92%8Cexists%E7%9A%84%E5%8C%BA%E5%88%AB">in和exists的区别？</a></li>
<li><a href="#sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">SQL查询语句的执行顺序？</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88innodb%E6%98%AF%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">为什么InnoDB是默认存储引擎？</a></li>
<li><a href="#innodb%E5%92%8Cmyisam%E7%9A%84%E5%8C%BA%E5%88%AB">InnoDB和MyISAM的区别？</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB">索引的分类？</a></li>
<li><a href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB">聚簇索引和非聚簇索引的区别？</a></li>
<li><a href="#b%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7">B+树的特性？</a></li>
<li><a href="#b%E6%A0%91%E5%92%8Cb%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB">B+树和B树的区别？</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8">为什么MYSQL不用跳表？</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%87%AA%E5%A2%9Eid%E5%BF%AB%E4%B8%80%E4%BA%9B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8uuid">为什么自增ID快一些？为什么不用UUID？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">什么是覆盖索引？</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88">创建联合索引要注意什么？</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%9C%89%E9%82%A3%E4%BA%9B%E6%83%85%E5%86%B5">索引失效有那些情况？</a></li>
<li><a href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">慢查询如何解决？</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9">索引的缺点</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%82%E5%90%88%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95">什么时候适合建立索引？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95">什么时候不需要索引？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96">如何对索引进行优化？</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84">事务的四个特性是如何实现的？</a></li>
<li><a href="#mvcc%E7%9A%84readview%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B">MVCC的ReadView介绍一下？</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E7%89%B9%E5%88%AB%E5%A4%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%8A%E7%AB%AF">事务特别多有哪些弊端？</a></li>
<li><a href="#mysql%E9%87%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81">MYSQL里有哪些锁？</a></li>
<li><a href="#mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B">MYSQL主从复制过程？</a></li>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">主从延迟有哪些解决方法？</a></li>
<li><a href="#%E5%88%86%E5%BA%93%E5%92%8C%E5%88%86%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB">分库和分表的区别？</a></li>
</ul>
</li>
<li><a href="#redis">Redis</a>
<ul>
<li><a href="#redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">Redis的数据结构以及应用场景？</a>
<ul>
<li><a href="#string">String</a></li>
<li><a href="#list">List:</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#set">Set</a></li>
<li><a href="#zset">zset</a></li>
<li><a href="#bitmap">Bitmap</a></li>
<li><a href="#hyperloglog">hyperloglog</a></li>
<li><a href="#geo">GEO</a></li>
<li><a href="#stream">Stream</a></li>
</ul>
</li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88redis%E7%94%A8%E8%B7%B3%E8%A1%A8%E8%80%8C%E4%B8%8D%E6%98%AFb%E6%A0%91">为什么Redis用跳表而不是B+树？</a></li>
<li><a href="#%E8%B7%B3%E8%A1%A8%E7%9A%84%E5%B1%82%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E7%9A%84">跳表的层数是怎么设置的？</a></li>
<li><a href="#redis%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%E7%9A%84">Redis的哈希表是怎么扩容的？</a></li>
<li><a href="#redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB">Redis为什么快？</a></li>
<li><a href="#redis%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B">Redis哪里用到了多线程？</a></li>
<li><a href="#io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0">IO多路复用怎么实现？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0redis%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7">如何实现Redis的原子性？</a></li>
<li><a href="#redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8Baof">Redis持久化之AOF？</a></li>
<li><a href="#redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8Brdb">Redis持久化之RDB?</a></li>
<li><a href="#bgsave%E6%97%B6%E6%95%B0%E6%8D%AE%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%97">bgsave时，数据能被修改吗？</a></li>
<li><a href="#aof%E5%92%8Crdb%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">AOF和RDB的优缺点？</a></li>
<li><a href="#%E8%AE%B2%E8%AE%B2redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">讲讲Redis的内存淘汰策略？</a></li>
<li><a href="#redis%E7%9A%84%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5">Redis的过期删除策略？</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AB%8B%E5%88%BB%E5%88%A0%E9%99%A4%E8%BF%87%E6%9C%9Fkey">为什么不立刻删除过期key？</a></li>
<li><a href="#redis%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5">Redis全量同步？</a></li>
<li><a href="#redis%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5">Redis增量同步？</a></li>
<li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bredis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6">介绍一下Redis哨兵机制？</a></li>
<li><a href="#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7">哨兵机制如何监控？</a></li>
<li><a href="#%E5%93%A8%E5%85%B5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%96%B0%E7%9A%84%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8">哨兵如何选择新的主服务器？</a></li>
<li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4">介绍一下分片集群？</a></li>
<li><a href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86">Redis分布式锁的原理？</a>
<ul>
<li><a href="#%E5%8A%A0%E9%94%81">加锁</a></li>
<li><a href="#%E8%A7%A3%E9%94%81">解锁</a></li>
</ul>
</li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7key%E9%97%AE%E9%A2%98">什么是大Key问题？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%A7key%E9%97%AE%E9%A2%98">如何解决大Key问题？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%83%ADkey%E9%97%AE%E9%A2%98">如何解决热key问题？</a></li>
<li><a href="#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E5%88%A0%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E6%AD%A3%E7%A1%AE%E5%88%A0%E9%99%A4">先更新数据库再删缓存，如何保证缓存正确删除？</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">缓存雪崩如何解决？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98">如何设计秒杀场景处理高并发和超卖问题？</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">动态代理</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">什么是动态代理？</a></li>
</ul>
</li>
<li><a href="#aop">AOP</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFaop">什么是AOP？</a></li>
<li><a href="#aop%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD%E6%9C%89%E5%93%AA%E4%BA%9B">AOP的一些术语有哪些？</a></li>
<li><a href="#aop%E7%9A%84%E9%80%9A%E7%9F%A5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B">AOP的通知都有哪些类型？</a></li>
<li><a href="#aop%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">AOP的应用场景？</a></li>
<li><a href="#aop%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B">AOP实现方式都有哪些？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#cs%E5%9F%BA%E7%A1%80">CS基础</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">进程和线程的区别</a></li>
<li><a href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB">硬链接和软链接的区别</a>
<ul>
<li><a href="#%E7%A1%AC%E9%93%BE%E6%8E%A5">硬链接</a></li>
<li><a href="#%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5">软链接（符号链接）</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A1%AC%E8%BF%9E%E6%8E%A5%E4%B8%8D%E8%83%BD%E8%B7%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">为什么硬连接不能跨文件系统？</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91">动态编译和静态编译</a>
<ul>
<li><a href="#%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91">静态编译</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%97%B6%E7%BC%96%E8%AF%91">动态编译(运行时编译)</a></li>
</ul>
</li>
<li><a href="#tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP三次握手</a>
<ul>
<li><a href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">三次握手</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">为什么要三次握手？</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%8F%91%E9%80%81%E4%BA%86ack%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E5%8F%91%E9%80%81syn">第二次发送了ACK，为什么还要发送SYN？</a></li>
<li><a href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%90%97">三次握手过程可以携带数据吗？</a></li>
</ul>
</li>
<li><a href="#tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP四次挥手</a>
<ul>
<li><a href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">四次挥手</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">为什么要四次挥手？</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8D%E6%8A%8A-ack-%E5%92%8C-fin-%E4%B8%80%E8%B5%B7%E5%8F%91%E9%80%81%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B">为什么服务端不把 ACK 和 FIN 一起发送，变成三次挥手？</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%91%E9%80%81ack%E6%B2%A1%E6%9C%89%E5%88%B0%E8%BE%BE%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7">第二次挥手服务端发送ACK没有到达会怎么样？</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%A6%81%E7%AD%89%E5%BE%85-2msl%E6%8A%A5%E6%96%87%E6%9C%80%E9%95%BF%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4%E6%89%8D%E8%BF%9B%E5%85%A5closed%E7%8A%B6%E6%80%81">为什么第四次挥手，客户端要等待 2MSL（报文最长存活时间）才进入CLOSED状态？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c">C++</a>
<ul>
<li><a href="#c%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97">c++中的static关键字</a></li>
<li><a href="#c%E6%A8%A1%E6%9D%BF">c++模板</a></li>
<li><a href="#c%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB">c++深拷贝和浅拷贝的区别</a></li>
<li><a href="#c%E5%A4%9A%E6%80%81">c++多态</a></li>
<li><a href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0">虚函数与纯虚函数</a></li>
<li><a href="#c%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">c++智能指针</a></li>
<li><a href="#const-%E5%92%8C-volatile%E8%BE%A8%E6%9E%90">const 和 volatile辨析</a></li>
<li><a href="#null-%E5%92%8C-nullptr%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5nulllptr">NULL 和 nullptr的区别是什么，为什么引入nulllptr？</a></li>
<li><a href="#git-fetch%E5%92%8Cgit-pull%E7%9A%84%E5%8C%BA%E5%88%AB">git fetch和git pull的区别</a></li>
<li><a href="#delete%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9F%A5%E9%81%93%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E7%9A%84">delete[]是怎样知道数组长度的？</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E6%98%AF%E4%BB%8Emain-%E5%87%BD%E6%95%B0%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E5%90%97">程序是从main 函数开始执行的吗？</a></li>
</ul>
</li>
<li><a href="#python">python</a>
<ul>
<li><a href="#python%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">python的垃圾回收机制</a></li>
</ul>
</li>
<li><a href="#deep-learning">deep learning</a>
<ul>
<li><a href="#%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B">判别模型和生成模型</a></li>
<li><a href="#%E8%BD%AC%E7%BD%AE%E5%8D%B7%E7%A7%AF%E5%92%8C%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF">转置卷积和空洞卷积</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">数据集不平衡的处理方式</a></li>
<li><a href="#tensorflow%E5%92%8Cpytorch%E7%9A%84%E5%8C%BA%E5%88%AB">tensorflow和pytorch的区别</a></li>
<li><a href="#transformer%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81">transformer中的位置编码</a></li>
<li><a href="#%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%92%8C%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%9A%84%E5%8C%BA%E5%88%AB">自注意力和注意力的区别</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h1>
<h2 id="jdk-jre和jvm是什么"><a class="markdownIt-Anchor" href="#jdk-jre和jvm是什么"></a> JDK、JRE和JVM是什么？</h2>
<h3 id="jdk"><a class="markdownIt-Anchor" href="#jdk"></a> JDK</h3>
<p>JDK（Java Development Kit）是一个功能齐全的 Java 开发工具包，供开发者使用，用于创建和编译 Java 程序。<br />
它包含了 JRE（Java Runtime Environment），以及编译器 javac 和其他工具，如 javadoc（文档生成器）、jdb（调试器）、jconsole（监控工具）、javap（反编译工具）等。</p>
<h3 id="jre"><a class="markdownIt-Anchor" href="#jre"></a> JRE</h3>
<p>JRE 是运行已编译 Java 程序所需的环境，主要包含以下两个部分：</p>
<ul>
<li>JVM : 也就是我们上面提到的 Java 虚拟机。</li>
<li>Java 基础类库（Class Library）：一组标准的类库，提供常用的功能和 API（如 I/O 操作、网络通信、数据结构等）。</li>
</ul>
<h3 id="jvm"><a class="markdownIt-Anchor" href="#jvm"></a> JVM</h3>
<p>Java 虚拟机（Java Virtual Machine, JVM）是运行 Java 字节码的虚拟机。<br />
JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。<br />
字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。<br />
不同编程语言（Java、Groovy、Kotlin、JRuby、Clojure …）通过各自的编译器编译成 .class 文件，并最终通过 JVM 在不同平台（Windows、Mac、Linux）上运行。</p>
<h2 id="字节码"><a class="markdownIt-Anchor" href="#字节码"></a> 字节码</h2>
<p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。<br />
Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p>
<p>Java程序运行流程如下图:<br />
<img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png" srcset="/img/loading.gif" lazyload alt="Java程序运行流程" /></p>
<p>需要格外注意的是 .class-&gt;机器码 这一步。</p>
<ul>
<li>在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。</li>
<li>而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（Just in Time Compilation） 编译器，而 JIT 属于运行时编译。</li>
<li>当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</li>
<li>机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言 。</li>
</ul>
<h2 id="为什么说java编译与解释共存"><a class="markdownIt-Anchor" href="#为什么说java编译与解释共存"></a> 为什么说Java“编译与解释共存”？</h2>
<ul>
<li>编译型语言：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li>
<li>解释型语言：解释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li>
</ul>
<p>Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h2 id="aot和jit"><a class="markdownIt-Anchor" href="#aot和jit"></a> AOT和JIT</h2>
<ul>
<li>
<p>AOT（Ahead of Time）：提前编译，是指在程序运行之前，将字节码编译成机器码，然后直接运行机器码。这样做的好处是可以提高程序的启动速度，减少内存占用。</p>
</li>
<li>
<p>JIT(Just in Time)：即时编译，是指在程序运行时，将热点代码（被频繁调用的代码）编译成机器码，然后再执行。这样做的好处是可以提高程序的执行效率。</p>
</li>
</ul>
<p>为什么AOT没有完全代替JIT?</p>
<ul>
<li>AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。但是，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载等，很多框架和库都用到了这些特性。只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。</li>
</ul>
<h2 id="java内存区域"><a class="markdownIt-Anchor" href="#java内存区域"></a> Java内存区域</h2>
<p>JVM 在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域，主要包括以下几个区域：</p>
<ul>
<li>线程私有的：程序计数器、虚拟机栈、本地方法栈</li>
<li>线程共享的：堆、方法区、直接内存</li>
</ul>
<h3 id="程序计数器"><a class="markdownIt-Anchor" href="#程序计数器"></a> 程序计数器</h3>
<ul>
<li>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ul>
<blockquote>
<p>程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
</blockquote>
<h3 id="虚拟机栈"><a class="markdownIt-Anchor" href="#虚拟机栈"></a> 虚拟机栈</h3>
<ul>
<li>虚拟机栈由一个个栈帧组成，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。</li>
</ul>
<h3 id="本地方法栈"><a class="markdownIt-Anchor" href="#本地方法栈"></a> 本地方法栈</h3>
<ul>
<li>本地方法栈和虚拟机栈所发挥的作用相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法(非Java语言编写的方法)服务。</li>
</ul>
<h3 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h3>
<ul>
<li>堆是 Java 虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，几乎所有的对象实例都在这里分配内存。</li>
<li>堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”。</li>
<li>在jdk7及以前，堆中内存被分为新生代、老年代和永久代，实际上永久代处于方法区，与堆是隔离的，但是内存上是连续的。在jdk8中，<strong>永久代被元空间取代</strong>，元空间位于本地内存，因此堆中主要分为新生代和老年代。</li>
</ul>
<h3 id="方法区"><a class="markdownIt-Anchor" href="#方法区"></a> 方法区</h3>
<ul>
<li>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域</li>
<li>当JVM要使用一个类时，会检查并解析字节码文件的相关信息，并将信息存储在方法区中</li>
</ul>
<h3 id="运行时常量池和字符串常量池"><a class="markdownIt-Anchor" href="#运行时常量池和字符串常量池"></a> 运行时常量池和字符串常量池</h3>
<ul>
<li>常量池表主要存放编译期生成的各种字面量和符号引用。</li>
<li>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</li>
</ul>
<p>jdk7中，运行时常量池存放在方法区中，而字符串常量池存放在堆中。在jdk8中，运行时常量池存放在元空间中。</p>
<h3 id="直接内存"><a class="markdownIt-Anchor" href="#直接内存"></a> 直接内存</h3>
<ul>
<li>直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。</li>
<li>直接内存是本地内存的一部分。</li>
</ul>
<h3 id="为什么要将永久代替换为元空间"><a class="markdownIt-Anchor" href="#为什么要将永久代替换为元空间"></a> 为什么要将永久代替换为元空间？</h3>
<ul>
<li>永久代有一个 JVM 本身设置的固定上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li>
<li>永久代会为 GC 带来不必要的复杂度，例如永久代的 GC 会因为频繁的类加载而导致 Full GC，而元空间的 GC 将会更简单高效。</li>
</ul>
<h2 id="jvm垃圾回收"><a class="markdownIt-Anchor" href="#jvm垃圾回收"></a> JVM垃圾回收</h2>
<p>在堆的新生代中，由Eden 区、两个 Survivor 区组成， 两个 Survivor 区中包括S0 和 S1。</p>
<h3 id="内存分配和回收原则"><a class="markdownIt-Anchor" href="#内存分配和回收原则"></a> 内存分配和回收原则</h3>
<ul>
<li>对象优先在 Eden 区分配，当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC，Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。</li>
<li>大对象直接进入老年代，大对象是指需要大量连续内存空间的对象，比如一个很长的字符串或数组。</li>
<li>长期存活的对象将进入老年代，虚拟机给每个对象定义了一个年龄计数器，对象在 Eden 区出生后，经过一次 Minor GC 仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 区，并且年龄设为 1，对象在 Survivor 区每熬过一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代。</li>
</ul>
<h3 id="死亡对象的判断方法"><a class="markdownIt-Anchor" href="#死亡对象的判断方法"></a> 死亡对象的判断方法</h3>
<ul>
<li>引用计数法：当对象被引用时，计数器加 1，当引用失效时，计数器减 1，当计数器为 0 时，说明对象不再被引用，可以被回收。但这种方法无法解决循环引用的问题。</li>
<li>可达性分析法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。即GC roots到某个对象不可达，则说明此对象是可以被回收的。</li>
<li>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；</li>
</ul>
<h3 id="垃圾回收算法"><a class="markdownIt-Anchor" href="#垃圾回收算法"></a> 垃圾回收算法</h3>
<ul>
<li>标记-清除算法：标记出所有活动对象，然后统一回收未标记对象。这种算法会产生大量不连续的内存碎片，导致以后在分配大对象时可能出现内存不足的情况。</li>
<li>复制算法：将内存分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，就将还存活的对象复制到另一块上面，然后把已使用的内存空间一次清理掉。这种算法没有内存碎片问题，但是会浪费一半的内存空间。</li>
<li>标记-整理算法：标记出所有活动对象，然后将存活的对象向一端移动，然后直接清理掉端边界以外的内存。这种算法没有内存碎片问题，也不会浪费内存，但是需要移动对象，所以比较耗时。</li>
<li>分代收集算法：根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，新生代由于每次收集会有大量对象死去，所以可选用复制算法，而老年代因为对象存活率高，所以可选用标记清除或标记整理算法。</li>
</ul>
<h3 id="垃圾回收器有哪些"><a class="markdownIt-Anchor" href="#垃圾回收器有哪些"></a> 垃圾回收器有哪些？</h3>
<ul>
<li>Serial收集器 (复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>
<li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>
<li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li>
<li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li>
<li>Parallel Old收集器 (标记-整理算法): 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li>
<li>CMS(Concurrent Mark Sweep)收集器 (标记-清除算法): 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li>
<li>G1(Garbage First)收集器 (标记-整理算法): Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li>
<li>ZGC: 低延迟垃圾收集器，回收停顿时间小于1ms，支持超大堆内存，适用于大规模服务</li>
</ul>
<h3 id="垃圾回收器cms和g1的区别"><a class="markdownIt-Anchor" href="#垃圾回收器cms和g1的区别"></a> 垃圾回收器CMS和G1的区别?</h3>
<ol>
<li>使用范围不同，CMS主要用于老年代收集，G1可以收集老年代和新生代</li>
<li>CMS基于“标记-清除”算法实现，G1基于“标记-整理”算法实现</li>
<li>CMS以最小停顿时间为目标，G1可设置垃圾回收的停顿时间</li>
</ol>
<p>使用场景不同：</p>
<ul>
<li>CMS适合低延迟、老年代收集、对内存碎片不敏感的场景</li>
<li>G1适合大堆内存，对内存碎片敏感，需要平衡性能的场景</li>
</ul>
<h3 id="如何选择合适的垃圾回收器"><a class="markdownIt-Anchor" href="#如何选择合适的垃圾回收器"></a> 如何选择合适的垃圾回收器？</h3>
<ul>
<li>小堆+单核心CPU使用Serial</li>
<li>高吞吐量（批处理任务）使用Parallel</li>
<li>低延迟应用使用CMS</li>
<li>大堆（大于10G）内存+综合场景使用G1</li>
<li>超大堆（大于100G）+低延迟使用ZGC</li>
</ul>
<h2 id="基础数据类型"><a class="markdownIt-Anchor" href="#基础数据类型"></a> 基础数据类型</h2>
<p>java中八种基础数据类型如下图：<br />
<img src="https://cdn.xiaolincoding.com//picgo/1715930589177-73932d2c-b0c0-4f58-a5c1-ab514b1a389c.png" srcset="/img/loading.gif" lazyload alt="基础数据类型" /></p>
<p>值得注意的是：</p>
<ul>
<li>1个字节的有boolean和byte,2个字节的有short和char,4个字节的有int和float,8个字节的有long和double。</li>
<li>浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）。</li>
<li>整数的默认类型为int（声明Long型在末尾加上l或者L）</li>
<li>8种基本类型的包装类，除了char是Character，int是Integer，其余的都是首字母大写。</li>
<li>char是无符号的，最小值是0</li>
</ul>
<p>long和int可以互转吗？<br />
答：可以，long的范围更大，int可以直接赋值给long,long转int需要强制类型转换。</p>
<p>字节支付实习一面：String类可以被继承吗？<br />
答：String类是final类，不可以被继承。所有基本数据类型对应的包装类都是final类，不可以被继承。</p>
<p>为什么用bigDecimal 不用double ？<br />
答：double类型是不精确的，因为double类型是采用二进制浮点数进行计算的，而二进制浮点数无法精确表示大部分的十进制小数，所以在计算时会有精度丢失的问题。而BigDecimal是采用十进制浮点数进行计算的，可以精确表示大部分的十进制小数。</p>
<p>为什么要有Integer？<br />
答：Integer是int的包装类，封装之后包含一些数据处理的方法，便于处理数据;<br />
Java中大部分方法和类以及集合只能处理类型对象，比如ArrayList；<br />
基本类型和引用类型不能直接转换，比如int要转为String类需要先专程Integer。</p>
<h2 id="有一个学生类想按照分数排序再按学号排序应该怎么做"><a class="markdownIt-Anchor" href="#有一个学生类想按照分数排序再按学号排序应该怎么做"></a> 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</h2>
<p>答：可以让学生类实现Comparable接口，重写compareTo方法，然后在compareTo方法中按照分数排序，再按照学号排序。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Student</span>&gt;</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Student t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.score!=t.score)&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">return</span> Integer.<span class="hljs-title">compare</span><span class="hljs-params">(t.score,<span class="hljs-keyword">this</span>.score)</span></span>; <span class="hljs-comment">//按分数降序</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">return</span> Integer.<span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">this</span>.id,t.id)</span></span>; <span class="hljs-comment">//分数相同按学号升序</span><br>        &#125;<br>    &#125;<br>&#125;<br>List&lt;Student&gt; st = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>Collections.sort(st);<br></code></pre></td></tr></table></figure>
<h2 id="java集合"><a class="markdownIt-Anchor" href="#java集合"></a> Java集合</h2>
<h3 id="数组和集合的区别"><a class="markdownIt-Anchor" href="#数组和集合的区别"></a> 数组和集合的区别？</h3>
<ul>
<li>数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素。</li>
<li>数组可以包含基本数据类型和对象，而集合只能包含对象。</li>
<li>数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。</li>
</ul>
<h3 id="arraylist和linkedlist的区别"><a class="markdownIt-Anchor" href="#arraylist和linkedlist的区别"></a> ArrayList和LinkedList的区别？</h3>
<ul>
<li>ArrayList基于数组，而LinkedList基于链表实现。</li>
<li>插入删除、随机访问效率不同</li>
<li>ArrayList创建时要分配一段连续空间，占用空间更大</li>
<li>前者适合需要频繁随机访问的场景，后者适合需要频繁插入删除的场景。</li>
</ul>
<h3 id="arraylist的扩容机制是什么"><a class="markdownIt-Anchor" href="#arraylist的扩容机制是什么"></a> ArrayList的扩容机制是什么？</h3>
<p>如果当前元素数量达到内部数组容量上限，就会触发扩容机制。分以下几步骤：</p>
<ul>
<li>计算新的容量，一般会扩大1.5倍</li>
<li>创建新的数组</li>
<li>将旧数组元素复制到新数组</li>
<li>更新引用指向新数组</li>
</ul>
<p>之所以扩容是 1.5 倍，是因为 1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。</p>
<h3 id="copyonwritearraylist是如何实现线程安全的"><a class="markdownIt-Anchor" href="#copyonwritearraylist是如何实现线程安全的"></a> CopyonWriteArraylist是如何实现线程安全的？</h3>
<ul>
<li>CopyonWriteArraylist底层也是通过一个数组保存数据，使用volatile修饰，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。</li>
<li>对读操作没有加锁，对写操作加了一个ReentrantLock锁，保证写操作的线程安全。</li>
</ul>
<h3 id="hashmap实现原理介绍一下"><a class="markdownIt-Anchor" href="#hashmap实现原理介绍一下"></a> HashMap实现原理介绍一下？</h3>
<ul>
<li>早期HashMap是数组+链表，通过哈希算法将元素映射到数组中，如果发生冲突，就会在链表中存储多个元素，当链表元素过多查询效率会降低很多。</li>
<li>JDK1.8之后，HashMap引入了红黑树，当链表长度超过8时，链表会转换为红黑树，提高查询效率（查询复杂度<code>log n</code>）,数量少于6会转回链表。</li>
</ul>
<h3 id="解决哈希冲突的方法有哪些"><a class="markdownIt-Anchor" href="#解决哈希冲突的方法有哪些"></a> 解决哈希冲突的方法有哪些？</h3>
<ul>
<li>链地址法：将哈希冲突的元素存储的在链表或其他数据结构中</li>
<li>开放寻址法：找到另一个可用的位置来存储，包括线性探测、二次探测、双重散列等。</li>
<li>再哈希法：使用另一个哈希函数计算新的哈希值。</li>
<li>哈希桶扩容：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对。</li>
</ul>
<h3 id="hashmap的put过程"><a class="markdownIt-Anchor" href="#hashmap的put过程"></a> HashMap的put过程？</h3>
<ol>
<li>计算要添加的key的哈希值，找到在数组中的索引</li>
<li>如果该索引位置没有元素，直接添加</li>
<li>如果该索引位置有元素，检查key是否相等，如果相等，直接覆盖value，如果不相等，发生哈希冲突，通过链表或红黑树中查找这个key，找到则更新value，为找到则添加</li>
<li>检查链表长度是否超过8，超过则转换为红黑树</li>
<li>检查负载因子是否超过0.75，超过则扩容</li>
<li>扩容时，首先创建一个新的数组，大小是原数组的2倍，然后重新计算旧数组的哈希值分配到新数组中，更新引用。</li>
</ol>
<h3 id="为什么hashmap用红黑树不用平衡二叉树"><a class="markdownIt-Anchor" href="#为什么hashmap用红黑树不用平衡二叉树"></a> 为什么HashMap用红黑树不用平衡二叉树？</h3>
<ul>
<li>平衡二叉树追求完全平衡的状态，左右子树的高度差不超过1，每次插入删除都需要左旋右旋调整，效率很低</li>
<li>红黑树追求一种弱平衡状态，整个树的最长路径不超过最短路径的2倍，插入删除效率更高。</li>
</ul>
<h3 id="hashmap-key可以为null吗"><a class="markdownIt-Anchor" href="#hashmap-key可以为null吗"></a> HashMap key可以为null吗？</h3>
<p>答：HashMap的key可以为null，HashMap使用hash()方法计算key的哈希值，如果key为null，哈希值为0。不会去调用hashCode()方法。</p>
<h3 id="重写hashmap的equals和hashcode方法时要注意什么"><a class="markdownIt-Anchor" href="#重写hashmap的equals和hashcode方法时要注意什么"></a> 重写HashMap的equals和hashCode方法时，要注意什么？</h3>
<ul>
<li>HashMap在比较元素时，一般先比较hashCode，如果hashCode相等，再通过equals方法比较。</li>
<li>hashCode相等，equals不一定相等，但是equals相等，hashCode一定相等。</li>
<li>重写了equals方法，如果不重写hashCode方法，可能会导致相等的两个对象的hashCode不相等，从而导致相同的key被重复添加。</li>
</ul>
<h3 id="为什么hashmap的大小是2的幂次方"><a class="markdownIt-Anchor" href="#为什么hashmap的大小是2的幂次方"></a> 为什么HashMap的大小是2的幂次方？</h3>
<p>答：为了加速计算以及减少哈希冲突，计算哈希时一般按照<code>hash(key)%n</code>计算索引，如果n是2的幂次方，等价于<code>hash(key)&amp;(n-1)</code>，这样可以加快计算速度;<br />
此外，这种与运算的方式可以让元素分布更加均匀，减少哈希冲突。</p>
<h3 id="concurrenthashmap是如何实现线程安全的"><a class="markdownIt-Anchor" href="#concurrenthashmap是如何实现线程安全的"></a> ConcurrentHashMap是如何实现线程安全的？</h3>
<p>ConcurrentHashMap主要通过volatile+CAS或者synchronized来保证线程安全。<br />
添加元素时，先判断容器是否为空？</p>
<ul>
<li>为空则用volatile和CAS来初始化</li>
<li>不为空则计算该位置是否为空
<ul>
<li>为空则用CAS添加元素</li>
<li>不为空则使用synchronized来更新或添加元素</li>
</ul>
</li>
</ul>
<p>锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。</p>
<h3 id="分段锁是怎么加锁的"><a class="markdownIt-Anchor" href="#分段锁是怎么加锁的"></a> 分段锁是怎么加锁的？</h3>
<ul>
<li>ConcurrentHashMap在JDK1.7之前使用分段锁，将整个数据分为若干个Segment，每个Segment都是一个小的HashMap，每个Segment都有自己的锁，不同 Segment 之间的操作互不影响，从而提高并发性能。</li>
<li>当进行增删改操作时，首先定位到具体的Segment，然后对这个Segment加锁，其他Segment不受影响，可以并发操作。</li>
</ul>
<h3 id="concurrenthashmap用的是乐观锁还是悲观锁"><a class="markdownIt-Anchor" href="#concurrenthashmap用的是乐观锁还是悲观锁"></a> ConcurrentHashMap用的是乐观锁还是悲观锁？</h3>
<p>答：都有用到。</p>
<ul>
<li>初始化时如果容器为空，通过volatile+CAS(乐观锁)初始化</li>
<li>如果不为空，则判断元素要添加的位置是否为空，为空则用CAS添加，不为空则用synchronized(悲观锁)添加或更新。</li>
</ul>
<h3 id="hashtable和concurrenthashmap的区别"><a class="markdownIt-Anchor" href="#hashtable和concurrenthashmap的区别"></a> hashtable和ConcurrentHashMap的区别？</h3>
<ul>
<li>从结构上看，hashtable是数组+链表，ConcurrentHashMap是数组+链表/红黑树</li>
<li>都是线程安全的，但hashtable所有方法都是synchronized，效率低，ConcurrentHashMap使用volatile+CAS或synchronized，效率更高</li>
</ul>
<h2 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h2>
<h3 id="面向对象的设计原则有哪些"><a class="markdownIt-Anchor" href="#面向对象的设计原则有哪些"></a> 面向对象的设计原则有哪些？</h3>
<ul>
<li>单一职责原则（SRP）：一个类只负责一个功能领域中的相应职责。</li>
<li>开放封闭原则（OCP）：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</li>
<li>里氏替换原则（LSP）：子类对象应该能够替换掉所有父类对象。</li>
<li>依赖隔离原则（ISP）：客户端不应该依赖那些它不需要的接口，接口应该而专。</li>
<li>依赖倒置原则（DIP）：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</li>
<li>最少知识原则（迪米特法则，LoD）：一个对象应该对其他对象有最少的了解。</li>
</ul>
<h3 id="抽象类和接口的区别"><a class="markdownIt-Anchor" href="#抽象类和接口的区别"></a> 抽象类和接口的区别</h3>
<p>抽象类：</p>
<ul>
<li>抽象类是包含至少一个抽象方法的类，抽象方法是没有方法体的方法。</li>
<li>抽象类可以包含具体的方法（有方法体的），也可以包含成员变量。</li>
<li>抽象类可以被继承，一个子类必须实现抽象类中的所有抽象方法，除非该子类也是抽象类。</li>
</ul>
<p>接口：</p>
<ul>
<li>接口是一个完全抽象的类，所有的方法默认是抽象的（Java 8 后，可以包含默认方法和静态方法）。</li>
<li>接口只能包含常量和抽象方法（除非定义了默认方法和静态方法）。</li>
</ul>
<p>特点：</p>
<ul>
<li>抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。</li>
<li>接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。适用于定义类的能力或功能</li>
</ul>
<p>区别：</p>
<ul>
<li>实现方式：实现接口的关键字为 implements，继承抽象类的关键字为 extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li>
<li>方法方式：接口只有定义，不能有方法的实现，java 1.8 中可以定义 default 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</li>
<li>访问修饰符：接口成员变量默认为 public static final，必须赋初值，不能被修改；其所有的成员方法都是 public、abstract 的。抽象类中成员变量默认 default，可在子类中被重新定义，也可被重新赋值；抽象方法被 abstract 修饰，不能被 private、static、synchronized 和 native 等修饰，必须以分号结尾，不带花括号。</li>
<li>变量：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态常量）。</li>
</ul>
<h3 id="抽象类可以被实例化吗"><a class="markdownIt-Anchor" href="#抽象类可以被实例化吗"></a> 抽象类可以被实例化吗？</h3>
<p>答：抽象类不能被实例化，通常由子类继承实现。<strong>抽象类中可以有构造方法</strong>，但是构造方法实例化的是子类对象。接口没有构造方法。</p>
<h3 id="java深拷贝的方式有哪些"><a class="markdownIt-Anchor" href="#java深拷贝的方式有哪些"></a> Java深拷贝的方式有哪些？</h3>
<ul>
<li>实现Cloneable接口，重写clone()方法</li>
<li>使用序列化和反序列化</li>
<li>手动递归复制</li>
</ul>
<h2 id="java中的对象"><a class="markdownIt-Anchor" href="#java中的对象"></a> Java中的对象</h2>
<h3 id="java中创建对象有哪些方式"><a class="markdownIt-Anchor" href="#java中创建对象有哪些方式"></a> Java中创建对象有哪些方式？</h3>
<ul>
<li>使用new关键字:通过new关键字直接调用类的构造方法来创建对象。</li>
</ul>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">MyClass</span> obj = <span class="hljs-built_in">new</span> <span class="hljs-keyword">MyClass</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>使用Class类的newInstance()方法:通过反射机制调用newInstance()方法来创建对象。</li>
</ul>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">MyClass</span> obj = (<span class="hljs-keyword">MyClass</span>) <span class="hljs-keyword">Class</span>.forName(<span class="hljs-string">&quot;com.example.MyClass&quot;</span>).newInstance();<br></code></pre></td></tr></table></figure>
<ul>
<li>使用Constructor类的newInstance()方法：同样通过反射机制调用Constructor类的newInstance()方法来创建对象。</li>
</ul>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;<span class="hljs-title">MyClass</span>&gt; <span class="hljs-title">constructor</span> = <span class="hljs-title">MyClass</span>.<span class="hljs-title">class</span>.<span class="hljs-title">getConstructor</span><span class="hljs-params">()</span>;</span><br>MyClass obj = <span class="hljs-keyword">constructor</span>.newInstance();<br></code></pre></td></tr></table></figure>
<ul>
<li>使用clone()方法：如果类实现了Cloneable接口，可以使用clone()方法复制对象。</li>
</ul>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">MyClass</span> obj1 = <span class="hljs-built_in">new</span> <span class="hljs-keyword">MyClass</span>();<br><span class="hljs-keyword">MyClass</span> obj2 = (<span class="hljs-keyword">MyClass</span>) obj1.clone();<br></code></pre></td></tr></table></figure>
<ul>
<li>使用反序列化</li>
</ul>
<h3 id="new的对象什么时候回收"><a class="markdownIt-Anchor" href="#new的对象什么时候回收"></a> new的对象什么时候回收？</h3>
<p>主要由GC回收，分为以下几种情况：</p>
<ol>
<li>引用计数法：某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。</li>
<li>可达性分析算法：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。</li>
<li>终结器（Finalizer）：如果对象重写了finalize()方法，垃圾回收器会在回收该对象之前调用finalize()方法，对象可以在finalize()方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。</li>
</ol>
<h2 id="反射机制"><a class="markdownIt-Anchor" href="#反射机制"></a> 反射机制</h2>
<h3 id="什么是反射机制"><a class="markdownIt-Anchor" href="#什么是反射机制"></a> 什么是反射机制？</h3>
<p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；<br />
对于任意一个对象，都能够调用它的任意一个方法和属性；<br />
这种<strong>动态获取的信息以及动态调用对象的方法</strong>的功能称为 Java 语言的反射机制。</p>
<p>反射具有以下特性：</p>
<ul>
<li>运行时类信息访问：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。</li>
<li>动态对象创建：可以使用反射 API 动态地创建对象实例，即使在编译时不知道具体的类名。这是通过 Class 类的 newInstance() 方法或 Constructor 对象的 newInstance() 方法实现的。</li>
<li>动态方法调用：可以在运行时动态地调用对象的方法，包括私有方法。这通过 Method 类的 invoke() 方法实现，允许你传入对象实例和参数值来执行方法。</li>
<li>访问和修改字段值：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过 Field 类的 get() 和 set() 方法完成的。</li>
</ul>
<h3 id="反射在你平时写代码或者框架中的应用场景有哪些"><a class="markdownIt-Anchor" href="#反射在你平时写代码或者框架中的应用场景有哪些"></a> 反射在你平时写代码或者框架中的应用场景有哪些?</h3>
<ol>
<li>加载数据库驱动</li>
</ol>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li>配置文件加载<br />
Spring 通过 XML 配置模式装载 Bean 的过程：</li>
</ol>
<ul>
<li>将程序中所有 XML 或 properties 配置文件加载入内存</li>
<li>Java 类里面解析 xml 或者 properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</li>
<li>使用反射机制，根据这个字符串获得某个类的 Class 实例</li>
<li>动态配置实例的属性</li>
</ul>
<h2 id="java注解的原理"><a class="markdownIt-Anchor" href="#java注解的原理"></a> Java注解的原理</h2>
<p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。</p>
<p>我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。<br />
通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。<br />
该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>
<h2 id="与-equals-有什么区别"><a class="markdownIt-Anchor" href="#与-equals-有什么区别"></a> == 与 equals 有什么区别？</h2>
<p>==对于基本数据类型和引用类型有不同的作用：</p>
<ul>
<li>对于基本数据类型，==比较的是值是否相等。</li>
<li>对于引用类型，==比较的是对象的内存地址</li>
</ul>
<p>equals不能比较基本数据类型，只能用来判断两个对象是否相等</p>
<ul>
<li>当类没有重写equals方法时，equals方法比较的是两个对象的内存地址</li>
<li>当类重写了equals方法时，equals方法一般比较的是两个对象的属性是否相等</li>
</ul>
<p>一般String类、Integer类等都重写了equals方法，比较的是对象的属性是否相等。</p>
<h2 id="stringbuffer和stringbuilder区别是什么"><a class="markdownIt-Anchor" href="#stringbuffer和stringbuilder区别是什么"></a> StringBuffer和StringBuilder区别是什么？</h2>
<p>区别：</p>
<ul>
<li>String 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以<strong>拼接字符串时会产生很多无用的中间对象，如果频繁地进行这样的操作对性能有所影响</strong>。</li>
<li>StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个<strong>线程安全</strong>的可修改的字符序列。在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。</li>
<li>StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是<strong>去掉了保证线程安全</strong>的那部分，减少了开销。</li>
</ul>
<blockquote>
<p>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。</p>
</blockquote>
<h2 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h2>
<h3 id="线程安全体现在哪些方面"><a class="markdownIt-Anchor" href="#线程安全体现在哪些方面"></a> 线程安全体现在哪些方面？</h3>
<ul>
<li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作；</li>
<li>可见性：一个线程对主内存的修改可以及时地被其他线程看到；</li>
<li>有序性：保证线程按照代码顺序执行。</li>
</ul>
<h3 id="什么是cas操作"><a class="markdownIt-Anchor" href="#什么是cas操作"></a> 什么是CAS操作？</h3>
<p>CAS叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：</p>
<ul>
<li>V：要更新的值</li>
<li>A：预期值</li>
<li>B：新值<br />
当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。</li>
</ul>
<h3 id="cas的缺点"><a class="markdownIt-Anchor" href="#cas的缺点"></a> CAS的缺点？</h3>
<ul>
<li>ABA问题：如果一个值原来是A，准备修改前短暂变成了B，然后又变成了A，那么CAS操作会错误地认为这个值没有发生变化；解决方法是加入预期标志和更新后标志，更新时不光检查值，还要检查标志是否相等。</li>
<li>循环时间长开销大：CAS操作如果长时间不成功，会一直自旋，占用CPU，降低性能。</li>
<li>只能保证一个共享变量的原子操作：对多个共享变量操作时，需要加锁。</li>
</ul>
<h3 id="线程创建方式有哪些"><a class="markdownIt-Anchor" href="#线程创建方式有哪些"></a> 线程创建方式有哪些？</h3>
<ul>
<li>继承 Thread 类</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    public void run()&#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;MyThread run&quot;</span>);<br>    &#125;<br>&#125;<br><br>public static void main(<span class="hljs-type">String</span>[] args) &#123;<br>    <span class="hljs-type">MyThread</span> t=<span class="hljs-keyword">new</span> <span class="hljs-type">MyThread</span>();<br>    t.start();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>实现 Runnable 接口</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;MyRunnable run&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)&#123;<br>    <span class="hljs-title class_">Thread</span> t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>    t.<span class="hljs-title function_">start</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>实现Callable接口与FutureTask</li>
<li>使用线程池</li>
</ul>
<h3 id="如何停止线程"><a class="markdownIt-Anchor" href="#如何停止线程"></a> 如何停止线程？</h3>
<ul>
<li>异常停止法：调用interupt方法, 在run方法中判断当前对象的中断状态，如果是中断状态则抛出异常，达到中断线程的效果。</li>
<li>沉睡中停止：先将线程sleep，然后调用interrupt标记中断状态，interrupt会将阻塞状态的线程中断。会抛出中断异常，达到停止线程的效果</li>
<li>stop()暴力停止</li>
<li>使用return停止：调用interupt标记中断状态后，在run方法中判断中断状态，如果是中断状态则return。</li>
</ul>
<h3 id="线程的状态有哪些"><a class="markdownIt-Anchor" href="#线程的状态有哪些"></a> 线程的状态有哪些？</h3>
<ul>
<li>NEW：新创建的线程，还未执行</li>
<li>RUNNABLE：就绪和正在执行的线程</li>
<li>BLOCKED：阻塞状态，等待锁的释放</li>
<li>WAITING：等待状态，等待其他线程的通知</li>
<li>TIMED_WAITING：具有指定等待时间的等待状态</li>
<li>TERMINATED：线程执行完毕</li>
</ul>
<h3 id="blocked和waiting的区别"><a class="markdownIt-Anchor" href="#blocked和waiting的区别"></a> blocked和waiting的区别？</h3>
<ul>
<li>blocked 一般是因为获取锁失败，在等待其他线程释放锁后，会重新进入runnable状态</li>
<li>waiting 状态不参与锁的竞争，而是在等待其他线程的通知，比如调用wait()方法，join()方法，或者LockSupport.park()方法，不会占用CPU资源，当其他线程调用notify()方法后，会重新进入runnable状态</li>
</ul>
<h3 id="notify和notifyall的区别"><a class="markdownIt-Anchor" href="#notify和notifyall的区别"></a> notify和notifyAll的区别？</h3>
<ul>
<li>notify()方法会随机唤醒一个处于waitting的线程，其他线程仍然处于waiting状态。</li>
<li>notifyAll()方法会唤醒所有waitting的线程，让他们开始竞争锁</li>
</ul>
<h3 id="写一段代码实现线程交替打印奇偶数"><a class="markdownIt-Anchor" href="#写一段代码实现线程交替打印奇偶数"></a> 写一段代码，实现线程交替打印奇偶数</h3>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PrintEvenOdd</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> cnt=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final Object <span class="hljs-keyword">lock</span>=<span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-built_in">int</span> MX=<span class="hljs-number">100</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>&#123;<br>        Runnable printOdd=()-&gt;&#123;<br>            synchronized(<span class="hljs-keyword">lock</span>)&#123;<br>                    <span class="hljs-keyword">while</span>(cnt&lt;=MX)&#123;<br>                    <span class="hljs-keyword">if</span>(cnt%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)&#123;<br>                        System.<span class="hljs-keyword">out</span>.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+cnt++);<br>                        <span class="hljs-keyword">lock</span>.notify();<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">try</span>&#123;<br>                            <span class="hljs-keyword">lock</span>.wait();<br>                        &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;     <br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        Runnable printEven=()-&gt;&#123;<br>            synchronized(<span class="hljs-keyword">lock</span>)&#123;<br>                <span class="hljs-keyword">while</span>(cnt&lt;=MX)&#123;<br>                    <span class="hljs-keyword">if</span>(cnt%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                        System.<span class="hljs-keyword">out</span>.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+cnt++);<br>                        <span class="hljs-keyword">lock</span>.notify();<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">try</span>&#123;<br>                            <span class="hljs-keyword">lock</span>.wait();<br>                        &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        Thread t1=<span class="hljs-keyword">new</span> Thread(printOdd,<span class="hljs-string">&quot;奇数线程&quot;</span>);<br>        Thread t2=<span class="hljs-keyword">new</span> Thread(printEven,<span class="hljs-string">&quot;偶数线程&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="怎么保证多线程安全"><a class="markdownIt-Anchor" href="#怎么保证多线程安全"></a> 怎么保证多线程安全？</h3>
<ul>
<li>使用synchronized关键字，保证同一时刻只有一个线程访问共享资源</li>
<li>使用volatile关键字，保证变量的可见性</li>
<li>使用Lock接口，比如ReentrantLock类就是Lock接口的一个实现</li>
<li>使用原子类，比如AtomicInteger类</li>
<li>使用TreadLocal</li>
<li>使用线程安全的集合类，比如ConcurrentHashMap、CopyOnWriteArrayList等</li>
</ul>
<h3 id="java中有哪些常用的锁使用场景是什么"><a class="markdownIt-Anchor" href="#java中有哪些常用的锁使用场景是什么"></a> java中有哪些常用的锁？使用场景是什么？</h3>
<ul>
<li>synchronized：用于修饰代码块或方法，保证同一时刻只有一个线程访问共享资源。</li>
<li>ReentrantLock：是Lock接口的一个实现，提供了更多的功能，比如可以设置超时时间、中断等待锁的线程、公平锁等。</li>
<li>读写锁：允许多个线程读，但只允许一个线程写，适用于读多写少的场景。</li>
<li>乐观锁和悲观锁：乐观锁不锁定资源，<strong>只在写数据时</strong>检查资源是否被其他线程修改；悲观锁在访问数据时会锁定资源，总是假设最坏的情况。</li>
<li>自旋锁：未获取到锁时线程不会放弃CPU资源，而是一直循环检查锁是否可用，直到获取到锁，通常用CAS实现。</li>
</ul>
<h3 id="什么是公平锁和非公平锁"><a class="markdownIt-Anchor" href="#什么是公平锁和非公平锁"></a> 什么是公平锁和非公平锁？</h3>
<ul>
<li>公平锁：按照线程请求的顺序来获取锁，先到先得，整体执行速度慢，吞吐量小，因为涉及线程从休眠到运行状态的转换。</li>
<li>非公平锁：多个线程争抢锁，整体执行速度快，吞吐量大。</li>
</ul>
<h3 id="讲讲reentrantlock"><a class="markdownIt-Anchor" href="#讲讲reentrantlock"></a> 讲讲ReentrantLock？</h3>
<p>ReentrantLock底层主要依赖AQS抽象类，AQS提供了一些基本的同步机制如队列、状态等。ReentrantLock具有以下特性：</p>
<ul>
<li>可中断：线程在等待锁的过程中，可以被其他线程中断而提前结束等待。</li>
<li>设置超时时间：尝试获取锁时，可以设置超时时间，超过时间后自动放弃等待。</li>
<li>公平锁和非公平锁：ReentrantLock默认是非公平锁，可以通过传入true参数创建公平锁。如<code>ReentrantLock lock=new ReentrantLock(true);</code></li>
<li>支持多个条件变量，可以更灵活的执行等待与唤醒操作。主要通过Condition接口实现。</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ReentrantLock lock<span class="hljs-operator">=</span>new ReentrantLock()<span class="hljs-comment">;</span><br>Condition condition<span class="hljs-operator">=</span>lock.newCondition()<span class="hljs-comment">;</span><br>//等待与唤醒<br>condition.await()<span class="hljs-comment">;</span><br>condition.signal()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>支持可重入性，同一个线程可以多次获取同一把锁，不会造成死锁。每次获取锁时，holdCount递增，释放锁时递减，当holdCount为0时，其他线程才能获取锁。</li>
</ul>
<h3 id="synchronized和reentrantlock的的应用场景有什么不同"><a class="markdownIt-Anchor" href="#synchronized和reentrantlock的的应用场景有什么不同"></a> synchronized和ReentrantLock的的应用场景有什么不同？</h3>
<ul>
<li>synchronized适合简单的同步场景，代码块或方法级别的同步，使用方便，但功能有限。</li>
<li>ReentrantLock适合复杂同步的场景，提供了一些高级功能，如可中断、超时、公平锁、多条件变量等。</li>
</ul>
<h3 id="synchronized和reentrantlock的区别"><a class="markdownIt-Anchor" href="#synchronized和reentrantlock的区别"></a> synchronized和ReentrantLock的区别？</h3>
<ul>
<li>synchronized可修饰代码块和方法，ReentrantLock只能修饰代码块</li>
<li>synchronized可以自动加锁和释放锁，ReentrantLock需要手动加锁和释放锁</li>
<li>前者只能是非公平锁，后者可以是公平锁或非公平锁</li>
<li>前者不能响应中断，后者可以响应中断</li>
<li>synchronized是JVM层面通过监视器实现的锁，ReentrantLock是基于AQS实现的锁</li>
</ul>
<h3 id="介绍一下aqs"><a class="markdownIt-Anchor" href="#介绍一下aqs"></a> 介绍一下AQS?</h3>
<p>答：AQS是Java中的一个抽象类，提供了一些基本的同步机制，AQS的核心思想是：</p>
<ul>
<li>如果被请求的资源空闲，就将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态；</li>
<li>如果被请求的资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制是通过内部的双向队列来实现的。</li>
</ul>
<h3 id="volatile关键字的作用"><a class="markdownIt-Anchor" href="#volatile关键字的作用"></a> volatile关键字的作用？</h3>
<ul>
<li>保证变量对所有线程的可见性</li>
<li>禁止指令重排序</li>
</ul>
<p>指令重排序是编译器为了提升指令执行效率而做的优化，一般需要两个条件：</p>
<ul>
<li>单线程下不会改变程序执行结果</li>
<li>重排序的指令不存在数据的相互依赖</li>
</ul>
<h3 id="死锁产生的条件"><a class="markdownIt-Anchor" href="#死锁产生的条件"></a> 死锁产生的条件？</h3>
<ul>
<li>互斥条件：多个线程不能同时使用同一资源</li>
<li>持有和等待条件：线程持有资源，同时等待其他线程持有的资源</li>
<li>不可剥夺条件：线程持有的资源在使用完之前不能被其他线程抢占</li>
<li>循环等待条件：多个线程形成循环等待资源的关系</li>
</ul>
<h3 id="线程池的原理"><a class="markdownIt-Anchor" href="#线程池的原理"></a> 线程池的原理？</h3>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clean">提交任务 -&gt; 核心线程是否已满？<br><br>├── 未满 -&gt; 创建核心线程执行<br><br>└── 已满 -&gt; 任务入队<br><br>    ├── 队列未满 -&gt; 等待执行<br><br>    └── 队列已满 -&gt; 创建非核心线程<br><br>        ├── 未达最大线程数 -&gt; 执行任务<br><br>        └── 已达最大线程数 -&gt; 执行拒绝策略<br><br></code></pre></td></tr></table></figure>
<h3 id="线程池的参数有哪些"><a class="markdownIt-Anchor" href="#线程池的参数有哪些"></a> 线程池的参数有哪些？</h3>
<ul>
<li>corePoolSize：核心线程数，线程池中一直存活的线程数量</li>
<li>maximumPoolSize：最大线程数，线程池中最大的线程数量</li>
<li>keepAliveTime：线程空闲时间，超过这个时间，多余的线程会被回收</li>
<li>unit：时间单位</li>
<li>workQueue：工作队列，存放等待执行的任务</li>
</ul>
<h3 id="线程池的拒绝策略有哪些"><a class="markdownIt-Anchor" href="#线程池的拒绝策略有哪些"></a> 线程池的拒绝策略有哪些？</h3>
<ul>
<li>CallerRunsPolicy：使用线程池的调用者所在线程去执行对应任务</li>
<li>AbortPolicy：拒绝并抛出异常</li>
<li>DiscardPolicy：不做任何处理，直接拒绝</li>
<li>DiscardOldestPolicy：抛弃最老的任务执行该任务。</li>
<li>自定义策略</li>
</ul>
<h3 id="核心线程数如何设置"><a class="markdownIt-Anchor" href="#核心线程数如何设置"></a> 核心线程数如何设置？</h3>
<ul>
<li>CPU密集型任务：核心线程数设置为CPU核心数+1</li>
<li>IO密集型任务：核心线程数设置为CPU核心数*2</li>
</ul>
<h3 id="线程池种类有哪些"><a class="markdownIt-Anchor" href="#线程池种类有哪些"></a> 线程池种类有哪些？</h3>
<ul>
<li>ScheduledThreadPool：支持定时和周期性执行任务</li>
<li>FixedThreadPool：核心线程数和最大线程数相等，最大线程数满了后会进入队列等待</li>
<li>CachedThreadPool：核心线程数为0，最大线程数为Integer.MAX_VALUE，适用于执行大量短期异步任务</li>
<li>SingleThreadPool：只有一个核心线程，确保所有任务按照指定顺序执行</li>
</ul>
<h3 id="多线程顺序执行的几种写法"><a class="markdownIt-Anchor" href="#多线程顺序执行的几种写法"></a> 多线程顺序执行的几种写法?</h3>
<ul>
<li>使用join方法，join方法会阻塞当前线程，等待调用join方法的线程执行完毕，类似于让调用join方法的线程“插队”。</li>
<li>使用线程池，将核心线程数和最大线程数都设置为1，然后按顺序提交任务。</li>
<li>使用wait()和notify，创建两个lock，分别是lock1和lock2，线程1和线程2共用lock1,线程2和线程3共用lock2。实现如下：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintOrder</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">Object</span> lock1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">Object</span> lock2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-title class_">String</span> name;<br>        <span class="hljs-title class_">Object</span> preLock;<br>        <span class="hljs-title class_">Object</span> postLock;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-title class_">String</span> name,<span class="hljs-title class_">Object</span> preLock, <span class="hljs-title class_">Object</span> postLock)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">preLock</span>=preLock;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">postLock</span>=postLock;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">if</span>(preLock!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">preLock</span>)&#123;<br>                    preLock.<span class="hljs-title function_">wait</span>();<br>                &#125;<br>            &#125;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(name+<span class="hljs-string">&quot;执行&quot;</span>);<br>            <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">if</span>(postLock!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">postLock</span>)&#123;<br>                    postLock.<span class="hljs-title function_">notify</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)&#123;<br>        <span class="hljs-title class_">Thread</span> t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程1&quot;</span>,<span class="hljs-literal">null</span>,lock1));<br>        <span class="hljs-title class_">Thread</span> t2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程2&quot;</span>,lock1,lock2));<br>        <span class="hljs-title class_">Thread</span> t3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程3&quot;</span>,lock2,<span class="hljs-literal">null</span>));<br>        t2.<span class="hljs-title function_">start</span>();<br>        t1.<span class="hljs-title function_">start</span>();<br>        t3.<span class="hljs-title function_">start</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>使用countDownLatch，通过await()方法阻塞线程，通过countDown()方法将计数器减1。实现方式和wait()和notify()类似，把wait()换成了await()，把notify()换成了countdown()。</li>
</ul>
<h3 id="线程池中shutdown和shutdownnow的区别"><a class="markdownIt-Anchor" href="#线程池中shutdown和shutdownnow的区别"></a> 线程池中shutdown和shutdownNow的区别？</h3>
<ul>
<li>shutdown会将状态置为SHUTDOWN状态，正在执行的任务会继续执行，无法向线程池添加新任务。</li>
<li>shutdownNow会将状态置为STOP状态，会尝试中断正在执行的任务。</li>
</ul>
<h3 id="提交给线程池的任务可以被撤回吗"><a class="markdownIt-Anchor" href="#提交给线程池的任务可以被撤回吗"></a> 提交给线程池的任务可以被撤回吗？</h3>
<p>答：可以。向线程池提交任务后，会返回一个Future对象，通过Future对象的cancel()方法可以取消任务的执行。</p>
<h3 id="threadlocal为什么会发生内存泄漏"><a class="markdownIt-Anchor" href="#threadlocal为什么会发生内存泄漏"></a> ThreadLocal为什么会发生内存泄漏？</h3>
<p>ThreadLocalMap的键为ThreadLocal的弱引用，而值是强引用。如果ThreadLocal对象被回收，其对应的Entry键会变为null，如果此时不删除对应的Entry，则Value仍然被Thread上的ThreadLocalMap引用，而Value往往占用较大内存，这就会导致内存泄漏。</p>
<p>为了解决这个问题，ThreadLocal在调用set、get、remove方法时，会清理掉ThreadLocalMap中所有键为null的Entry。但如果没有调用这些方法，那么清理工作就不会进行，从而可能导致内存泄漏。</p>
<h3 id="threadlocal的继承性问题以及解决方法"><a class="markdownIt-Anchor" href="#threadlocal的继承性问题以及解决方法"></a> ThreadLocal的继承性问题以及解决方法？</h3>
<ul>
<li>同一个ThreadLocal变量在父线程中设置值，在子线程中获取不到值。</li>
<li>解决方法：使用InheritableThreadLocal类，它是ThreadLocal的子类，可以在子线程中获取父线程中设置的值。</li>
</ul>
<h2 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MYSQL</h2>
<h3 id="mybatis中和的区别"><a class="markdownIt-Anchor" href="#mybatis中和的区别"></a> MyBatis中#{}和${}的区别？</h3>
<ul>
<li><code>#&#123;&#125;：预编译处理，会将#&#123;&#125;替换为?，然后使用PreparedStatement的set方法设置参数，可以防止SQL注入。</code></li>
<li><code>$&#123;&#125;：字符串替换，会将$&#123;&#125;替换为实际的值，存在SQL注入的风险。</code></li>
<li><code>#&#123;&#125;不用加单引号，$&#123;&#125;需要加单引号</code></li>
</ul>
<h3 id="sql注入是什么举个例子"><a class="markdownIt-Anchor" href="#sql注入是什么举个例子"></a> SQL注入是什么？举个例子？</h3>
<p>指的是攻击者通过恶意构造输入参数，使得正常SQL语句被修改</p>
<p>例如<code>SELECT * FROM Users WHERE Username = '' AND Password = '' OR '' = ''</code><br />
由于<code>&quot;=&quot;</code>永远为真，所以这个SQL语句会返回所有的用户信息</p>
<h3 id="mysql的事务隔离级别"><a class="markdownIt-Anchor" href="#mysql的事务隔离级别"></a> mysql的事务隔离级别</h3>
<h4 id="事务的四个特性"><a class="markdownIt-Anchor" href="#事务的四个特性"></a> 事务的四个特性</h4>
<ul>
<li>原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li>
<li>一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另一个一致性状态。</li>
<li>隔离性（Isolation）：一个事务的执行不能被其他事务干扰。</li>
<li>持久性（Durability）：事务一旦提交，它对数据库的改变就应该是永久性的。</li>
</ul>
<h4 id="事务隔离解决的问题"><a class="markdownIt-Anchor" href="#事务隔离解决的问题"></a> 事务隔离解决的问题</h4>
<ul>
<li>脏读：一个事务读取到另一个事务未提交的数据，读到了最终可能不存在的数据</li>
<li>可重复读：同一事务中多次读取同一数据时，结果是一致的，即使其他事务修改了该数据，当前事务仍然看到最初读取的值</li>
<li>不可重复读：同一事务在不同的时刻读到的同一批数据可能是不一样的，比如其他事务改了这批数据并提交了（针对update）</li>
<li>幻读：同一事务在不同的时刻读到的同一批数据可能是不一样的，比如其他事务插入了一些数据并提交了（针对insert）</li>
</ul>
<h4 id="事务隔离级别"><a class="markdownIt-Anchor" href="#事务隔离级别"></a> 事务隔离级别</h4>
<p>mysql中有四种事务隔离级别，级别由低到高分别是：</p>
<ul>
<li>读未提交（Read Uncommitted）：允许脏读，一个事务还没提交时，另一个事务就可以看到它做的变更，存在脏读、不可重复读、幻读的问题</li>
<li>读提交（Read Committed）：只能读取已经提交的数据，可以避免脏读，但是不可重复读和幻读仍然存在</li>
<li>可重复读（Repeatable Read）：对同一字段的多次读取结果是一致的，除非数据被当前事务自己改变，可以避免脏读和不可重复读，但幻读仍然存在</li>
<li>串行化（Serializable）：最高的隔离级别，所有事务依次执行，可以避免脏读、不可重复读、幻读</li>
</ul>
<h3 id="mysql的有哪几种引擎"><a class="markdownIt-Anchor" href="#mysql的有哪几种引擎"></a> MYSQL的有哪几种引擎？</h3>
<ul>
<li>InnoDB：InnoDB是MySQL的默认存储引擎，具有ACID事务支持、行级锁、外键约束等特性。它适用于高并发的读写操作，支持较好的数据完整性和并发控制。</li>
<li>MyISAM：MyISAM是MySQL的另一种常见的存储引擎，具有较低的存储空间和内存消耗，适用于大量读操作的场景。然而，MyISAM不支持事务、行级锁和外键约束，因此在并发写入和数据完整性方面有一定的限制。</li>
<li>Memory：Memory引擎将数据存储在内存中，适用于对性能要求较高的读操作，但是在服务器重启或崩溃时数据会丢失。它不支持事务、行级锁和外键约束。</li>
</ul>
<h3 id="mysql了解哪些日志"><a class="markdownIt-Anchor" href="#mysql了解哪些日志"></a> MYSQL了解哪些日志？</h3>
<ul>
<li>redo log 重做日志，是 InnoDB 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复，是循环写；</li>
<li>undo log 回滚日志，是 InnoDB 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。</li>
<li>bin log 二进制日志，是 Server 层生成的日志，主要用于数据备份和主从复制，是追加写；</li>
<li>relay log 中继日志，用于主从复制场景下，slave 通过 io 线程拷贝 master 的 bin log 后本地生成的日志</li>
<li>慢查询日志，用于记录执行时间过长的 SQL，需要设置阈值后手动开启</li>
</ul>
<h3 id="介绍一下bin-log"><a class="markdownIt-Anchor" href="#介绍一下bin-log"></a> 介绍一下bin log？</h3>
<p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog<br />
binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、MIXED，区别如下：</p>
<ul>
<li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式，binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li>
<li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li>
<li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li>
</ul>
<h3 id="mysql怎么连表查询"><a class="markdownIt-Anchor" href="#mysql怎么连表查询"></a> MYSQL怎么连表查询？</h3>
<ul>
<li>内连接：返回两个表中有匹配关系的行</li>
<li>左外连接：返回左表所有的行，右表中没有匹配的行返回 NULL</li>
<li>右外连接：返回右表所有的行，左表中没有匹配的行返回 NULL</li>
<li>全外连接：返回两个表中所有的行，没有匹配的行返回 NULL</li>
</ul>
<h3 id="如何避免重复插入数据"><a class="markdownIt-Anchor" href="#如何避免重复插入数据"></a> 如何避免重复插入数据？</h3>
<ul>
<li>使用unique约束</li>
<li>使用insert … on duplicate key update，当key冲突时，执行update操作</li>
<li>使用insert ignore，忽略因key重复导致的错误</li>
</ul>
<h3 id="in和exists的区别"><a class="markdownIt-Anchor" href="#in和exists的区别"></a> in和exists的区别？</h3>
<ul>
<li>in用于检查左边的表达式存在于某结果集中的数据</li>
<li>exists不关心具体数据，只关心结果集是否为空</li>
</ul>
<h3 id="sql查询语句的执行顺序"><a class="markdownIt-Anchor" href="#sql查询语句的执行顺序"></a> SQL查询语句的执行顺序？</h3>
<ul>
<li>from：指定要查询的表</li>
<li>on: 主表保留</li>
<li>join: 连接其他表</li>
<li>where: 对表进行筛选</li>
<li>group by: 分组</li>
<li>AGG FUNC：聚合函数（AVG,COUNT,MAX,MIN,SUM）</li>
<li>having: 对分组后的结果进行筛选</li>
<li>select: 选择要查询的列</li>
<li>distinct: 去重</li>
<li>order by: 对结果进行排序</li>
<li>limit: 限制返回结果的数量，分页</li>
</ul>
<h3 id="为什么innodb是默认存储引擎"><a class="markdownIt-Anchor" href="#为什么innodb是默认存储引擎"></a> 为什么InnoDB是默认存储引擎？</h3>
<p>InnoDB在事务支持、并发性能、崩溃恢复能力等方面具有良好特性：</p>
<ul>
<li>事务支持：支持事务的ACID特性，保证数据的一致性和完整性</li>
<li>并发性能：支持行级锁，而MyISAM只支持表级锁，锁粒度更小，并发性能更好</li>
<li>崩溃恢复：通过redolog实现崩溃恢复，保证数据的持久性</li>
</ul>
<h3 id="innodb和myisam的区别"><a class="markdownIt-Anchor" href="#innodb和myisam的区别"></a> InnoDB和MyISAM的区别？</h3>
<ul>
<li>事务：InnoDB支持事务，MyISAM不支持事务</li>
<li>索引结构：InnoDB使用聚簇索引，索引建立在主键上，MyISAM使用非聚簇索引</li>
<li>锁粒度：InnoDB支持行级锁，MyISAM支持表级锁</li>
<li>count效率：InnoDB执行count要做全表扫描，MyISAM用一个变量保存了整个表行数，count效率更高</li>
</ul>
<h3 id="索引的分类"><a class="markdownIt-Anchor" href="#索引的分类"></a> 索引的分类？</h3>
<ul>
<li>按数据结构分类：B+树索引、哈希索引、全文索引</li>
<li>按物理存储分类：聚簇索引、非聚簇索引</li>
<li>按字段特性分类: 分为主键索引、唯一索引、普通索引、前缀索引</li>
<li>按索引的数量分类：单列索引、联合索引</li>
</ul>
<h3 id="聚簇索引和非聚簇索引的区别"><a class="markdownIt-Anchor" href="#聚簇索引和非聚簇索引的区别"></a> 聚簇索引和非聚簇索引的区别？</h3>
<ul>
<li>数据存储：聚簇索引的叶子节点存储了数据行，非聚簇索引的叶子节点存储了指向数据行的指针或者主键</li>
<li>索引与数据的关系：聚簇索引可以直接查找到数据行，非聚簇索引需要先查找到主键，再通过主键回溯到聚簇索引中查找数据行，称为回表。</li>
<li>唯一性：聚簇索引建立在主键上是唯一的，非聚簇索引可以有多个</li>
<li>查询效率：对于需要回表的查询，聚簇索引效率更高，对于不需要回表的查询，非聚簇索引效率更高</li>
</ul>
<h3 id="b树的特性"><a class="markdownIt-Anchor" href="#b树的特性"></a> B+树的特性？</h3>
<ul>
<li>所有叶子节点都在同一层，叶子节点之间形成双向链表，便于范围查询和排序</li>
<li>非叶子节点不存储数据，只存储主键和子节点的指针</li>
<li>叶子节点储存实际的数据行</li>
<li>在插入、删除、更新后会进行平衡操作，保证树的高度相对稳定，每个节点最少有<code>M/2</code>个子节点，最多有<code>M</code>个子节点，M是树的阶数</li>
</ul>
<h3 id="b树和b树的区别"><a class="markdownIt-Anchor" href="#b树和b树的区别"></a> B+树和B树的区别？</h3>
<ul>
<li>B+树的非叶子节点不存储数据，而B树的非叶子节点会存储部分数据</li>
<li>B+树的叶子节点之间形成双向链表，便于范围查询和排序，B树叶子节点没有链表</li>
<li>B+树每次都要查到叶子节点，B树可能会在非叶子节点找到数据</li>
</ul>
<h3 id="为什么mysql不用跳表"><a class="markdownIt-Anchor" href="#为什么mysql不用跳表"></a> 为什么MYSQL不用跳表？</h3>
<p>B+树在3层时存储的数据可以达到千万级别，跳表要维护同样级别的数据需要的层数更多，导致性能下降。</p>
<h3 id="为什么自增id快一些为什么不用uuid"><a class="markdownIt-Anchor" href="#为什么自增id快一些为什么不用uuid"></a> 为什么自增ID快一些？为什么不用UUID？</h3>
<p>自增ID更快的原因：</p>
<ul>
<li>下一条记录会写入新的页中，提升了页面的利用率</li>
<li>新插入的记录一定会在原有最大ID的后面，便于定位和寻址</li>
<li>减少了页分裂</li>
</ul>
<p>不用UUID的原因：</p>
<ul>
<li>无序，每次插入数据可能插入到页面中间，导致页分裂</li>
<li>占用空间大，UUID是的长度更长，每个页能存放的记录数更少，导致树的高度更高，影响性能</li>
</ul>
<h3 id="什么是覆盖索引"><a class="markdownIt-Anchor" href="#什么是覆盖索引"></a> 什么是覆盖索引？</h3>
<p>覆盖索引是指<strong>索引包含了查询需要的所有字段，不需要回表查询</strong>，减少了IO操作，提升了查询性能。</p>
<h3 id="创建联合索引要注意什么"><a class="markdownIt-Anchor" href="#创建联合索引要注意什么"></a> 创建联合索引要注意什么？</h3>
<p><code>区分度=distinct(col)/count(*)</code></p>
<ul>
<li>建立联合索引时，要把区分度大(重复值少)的字段排在前面，这样可以过滤掉更多的数据，提升查询性能</li>
<li>如果区分度很小，比如性别字段，无论搜索哪一个值都会返回大量数据</li>
<li>MYSQL有一个查询优化器，如果某个值在表中的出现比例很高（超过30%），那么就会不走索引而是全表扫描</li>
</ul>
<h3 id="索引失效有那些情况"><a class="markdownIt-Anchor" href="#索引失效有那些情况"></a> 索引失效有那些情况？</h3>
<ul>
<li>使用左或者左右模糊匹配的时候</li>
<li>在查询中对索引列使用函数时</li>
<li>联合索引没有遵循最左匹配原则</li>
<li>where子句中，OR前面是索引列，OR后面不是索引列</li>
</ul>
<h3 id="慢查询如何解决"><a class="markdownIt-Anchor" href="#慢查询如何解决"></a> 慢查询如何解决？</h3>
<ul>
<li>通过 explain 执行结果，查看 sql 是否走索引，如果不走索引，考虑增加索引。</li>
<li>可以通过建立联合索引，实现覆盖索引优化，减少回表，使用联合索引符合最左匹配原则，不然会索引失效</li>
<li>避免索引失效，比如不要用左模糊匹配、函数计算、表达式计算等等。</li>
<li>联表查询最好要以小表驱动大表，并且被驱动表的字段要有索引，当然最好通过冗余字段的设计，避免联表查询。</li>
<li>针对 limit n,y 深分页的查询优化，可以把 Limit 查询转换成某个位置的查询：select * from tb_sku where id&gt;20000 limit 10，该方案适用于主键自增的表，</li>
<li>将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开</li>
</ul>
<h3 id="索引的缺点"><a class="markdownIt-Anchor" href="#索引的缺点"></a> 索引的缺点</h3>
<ul>
<li>占用存储空间</li>
<li>创建和维护索引需要时间</li>
<li>索引会降低表的增删改的性能</li>
</ul>
<h3 id="什么时候适合建立索引"><a class="markdownIt-Anchor" href="#什么时候适合建立索引"></a> 什么时候适合建立索引？</h3>
<ul>
<li>字段有唯一性限制</li>
<li>经常用于where查询条件的字段</li>
<li>经常用order by、group by的字段</li>
</ul>
<h3 id="什么时候不需要索引"><a class="markdownIt-Anchor" href="#什么时候不需要索引"></a> 什么时候不需要索引？</h3>
<ul>
<li>where、group by、order by用不到的字段</li>
<li>字段存在大量重复值，区分度低</li>
<li>表数据很少，不需要创建索引</li>
<li>经常进行更新的字段不用建立索引</li>
</ul>
<h3 id="如何对索引进行优化"><a class="markdownIt-Anchor" href="#如何对索引进行优化"></a> 如何对索引进行优化？</h3>
<ul>
<li>前缀索引优化，前缀索引通过减少索引字段的长度，从而使索引页包含的索引键增多，提高查询效率</li>
<li>覆盖索引优化，减少回表操作</li>
<li>最好采用自增主键，减少页分裂</li>
<li>防止索引失效</li>
</ul>
<h3 id="事务的四个特性是如何实现的"><a class="markdownIt-Anchor" href="#事务的四个特性是如何实现的"></a> 事务的四个特性是如何实现的？</h3>
<ul>
<li>原子性：通过undo log实现，事务回滚时，通过undo log将数据恢复到事务开始之前的状态</li>
<li>持久性：通过redo log实现，事务提交时，将redo log写入磁盘，保证事务的持久性</li>
<li>隔离性：通过MVCC实现，每个事务都有自己的版本号，读取数据时，只能读取版本号小于等于当前事务版本号的数据</li>
<li>持久性: 通过原子性+持久性+隔离性实现</li>
</ul>
<h3 id="mvcc的readview介绍一下"><a class="markdownIt-Anchor" href="#mvcc的readview介绍一下"></a> MVCC的ReadView介绍一下？</h3>
<p>有四个重要的字段：</p>
<ul>
<li>m_ids: 活跃且未提交的事务ID列表</li>
<li>min_trx_id：m_ids中最小值</li>
<li>max_trx_id：给下一个事务的id值，也就是最大事务的id+1</li>
<li>creator_trx_id：创建该ReadView的事务ID</li>
</ul>
<h3 id="事务特别多有哪些弊端"><a class="markdownIt-Anchor" href="#事务特别多有哪些弊端"></a> 事务特别多有哪些弊端？</h3>
<ul>
<li>如果一个事务特别多，锁定的资源也会很多，容易造成死锁和锁超时</li>
<li>事务回滚记录会占用大量空间，回滚时间长</li>
<li>执行时间长，容易造成主从延迟</li>
</ul>
<h3 id="mysql里有哪些锁"><a class="markdownIt-Anchor" href="#mysql里有哪些锁"></a> MYSQL里有哪些锁？</h3>
<ul>
<li>全局锁，主要用于全库逻辑备份</li>
<li>表级锁，包括表锁和元数据锁和意向锁</li>
<li>行级锁</li>
<li>记录锁，锁住某条记录</li>
<li>间隙锁，只存在于可重复读隔离级别，用于解决幻读</li>
<li>next-key锁，记录锁和间隙锁的结和，锁定一个范围</li>
</ul>
<h3 id="mysql主从复制过程"><a class="markdownIt-Anchor" href="#mysql主从复制过程"></a> MYSQL主从复制过程？</h3>
<ul>
<li>写入binlog，主库将数据写入binlog，更新本地数据存储</li>
<li>同步binlog，主库将binlog复制到所有从库</li>
<li>回放binlog，更新本地数据</li>
</ul>
<h3 id="主从延迟有哪些解决方法"><a class="markdownIt-Anchor" href="#主从延迟有哪些解决方法"></a> 主从延迟有哪些解决方法？</h3>
<ul>
<li>强制走主库，对于资源密集型操作，直接在主库上执行</li>
</ul>
<h3 id="分库和分表的区别"><a class="markdownIt-Anchor" href="#分库和分表的区别"></a> 分库和分表的区别？</h3>
<p>分库将数据按照一定规则分布到不同的数据库中，分表是将单个表拆分成多个表</p>
<ul>
<li>垂直分库指的是将数据按照业务和功能维度划分到不同的数据库中，但仍然会有单表数据量过大的问题</li>
<li>水平分库指的是将同一张表按照一定规则分布到不同的数据库中，每个数据库中的表结构相同，但数据不同</li>
<li>垂直分表针对单表字段过多的问题，一般将单表中比较独立的字段或者不常用的字段拆分到不同的表中</li>
<li>水平分表是在同一个数据库内，把一张大数据量的表按一定规则，切分成多个结构完全相同表。</li>
</ul>
<h2 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h2>
<h3 id="redis的数据结构以及应用场景"><a class="markdownIt-Anchor" href="#redis的数据结构以及应用场景"></a> Redis的数据结构以及应用场景？</h3>
<h4 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h4>
<p>基本的key-value结构，应用场景有：</p>
<ul>
<li>缓存对象，有两种方式：
<ul>
<li>直接缓存json字符串如<code>set user:1 &#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18&#125;</code></li>
<li>使用Mset和Mget，如<code>mset user:1:name zhangsan user:1:age 18</code></li>
</ul>
</li>
<li>常规计数，比如点赞、阅读量、转发等,如<code>incr article:1:like</code></li>
<li>分布式锁，通过NX参数实现key不存在才插入，key不存在则插入成功（加锁成功），否则插入失败（加锁失败）</li>
</ul>
<h4 id="list"><a class="markdownIt-Anchor" href="#list"></a> List:</h4>
<p>简单的字符串列表，按照插入顺序排序，应用场景主要有消息队列</p>
<p>消息队列存取消息必须要满足三个需求，分别是<strong>消息保序、处理重复消息、消息可靠性</strong></p>
<ul>
<li>消息保序，通过lpush和rpop实现消息的先入先出，同时为了提高性能，可以使用BRPOP进行阻塞读取，也就是队列为空时自动阻塞</li>
<li>处理重复消息，需要为每个消息生成一个全局唯一ID，比如通过时间戳+计数器的方式生产全局唯一ID，然后将消息和全局唯一ID一起存入redis</li>
<li>为了保证消息可靠性，可以使用BRPOPLPUSH，每次取一个消息后，将消息放入一个备份队列，这样即使消费者没有读了消息没有成功处理，也可以从备份队列中重新读取消息</li>
</ul>
<p>List实现消费队列有什么缺陷？</p>
<ul>
<li>不允许多个消费者消费同一条消息</li>
<li>不支持消费组</li>
</ul>
<h4 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> Hash</h4>
<p>键值对集合key-field-value，应用场景有：</p>
<ul>
<li>缓存对象，通过HMSET进行缓存对象，如<code>hmset uid:1 name zhangsan age 18</code></li>
<li>购物车，一般以用户id为key，商品id为field，商品数量为value，如<code>hset cart:1 1001 2</code></li>
</ul>
<h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h4>
<p>无序且唯一的键值集合，应用场景有：</p>
<ul>
<li>点赞，以key为文章id，value为用户id，如<code>sadd article:1 uid:1</code></li>
<li>共同关注，以用户id为key，以用户关注的公众号id为value，通过sinter可以求不同用户的交集</li>
<li>抽奖，因为set的不可重复性，一个用户不会被重复抽中，可以将抽奖活动名作为key，所有用户名作为value，如果是允许重复中奖就使用srandmember，如果不允许重复中奖就使用spop</li>
</ul>
<h4 id="zset"><a class="markdownIt-Anchor" href="#zset"></a> zset</h4>
<p>比set多了一个排序属性score，主要包括member和score两个属性，member是唯一的，应用场景有：</p>
<ul>
<li>适合排序的场景，如排行榜，将用户id作为member，分数作为score，通过zadd添加分数，通过zrevrange获取排行榜</li>
</ul>
<h4 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> Bitmap</h4>
<p>一串连续的二进制数组，通过offset定位元素，应用场景有：</p>
<ul>
<li>用户签到，通过setbit设置用户签到，通过bitcount统计签到次数</li>
<li>判断登陆状态</li>
</ul>
<p>如何统计当月首次签到时间？<br />
通过bitpos获取第一个为1的位置，即为首次签到时间<br />
<code>bitpos uid:sign:100:202403 1</code></p>
<p>如何统计连续七天打卡的用户总数？<br />
以每天的日期为key，以用户的id为offset，通过bitop AND将七天的bitmap进行按位与操作，如果某个位结果为1，说明这个用户连续七天打卡<br />
然后通过bitcount统计七天连续打卡的用户总数</p>
<h4 id="hyperloglog"><a class="markdownIt-Anchor" href="#hyperloglog"></a> hyperloglog</h4>
<p>用于提供不精确的去重计数</p>
<h4 id="geo"><a class="markdownIt-Anchor" href="#geo"></a> GEO</h4>
<p>存储地理信息</p>
<h4 id="stream"><a class="markdownIt-Anchor" href="#stream"></a> Stream</h4>
<p>用于实现消息队列，支持消息持久化、全局唯一ID自动生成、消息确认机制、消费组等功能</p>
<h3 id="为什么redis用跳表而不是b树"><a class="markdownIt-Anchor" href="#为什么redis用跳表而不是b树"></a> 为什么Redis用跳表而不是B+树？</h3>
<ul>
<li>B+树目的是优化磁盘IO，通过降低树的高度来减少磁盘寻道次数，而Redis是基于内存的，更符合内存访问的局部性原理</li>
<li>跳表实现简单，而B+树节点分裂合并逻辑复杂</li>
<li>跳表插入删除效率更高，B+树插入删除需要维护平衡</li>
<li>跳表内存占用更紧凑，B+树索引页未填满可能存在内存碎片</li>
</ul>
<h3 id="跳表的层数是怎么设置的"><a class="markdownIt-Anchor" href="#跳表的层数是怎么设置的"></a> 跳表的层数是怎么设置的？</h3>
<p>跳表创建节点时，会随机生产一个0-1之间的随机数，如果小于某个0.25，则层数+1，直到生成的随机数大于阈值，层数的最大值是64</p>
<h3 id="redis的哈希表是怎么扩容的"><a class="markdownIt-Anchor" href="#redis的哈希表是怎么扩容的"></a> Redis的哈希表是怎么扩容的？</h3>
<p>主要分三步：</p>
<ul>
<li>创建新哈希表，一般大小为之前的2倍</li>
<li>将旧哈希表的数据重新迁移到新哈希表</li>
<li>释放旧哈希表，将新哈希表设置为当前哈希表</li>
</ul>
<p>注意，如果旧哈希表数据量非常大，迁移过程中可能就会导致Redis阻塞，影响性能，所以采用<strong>渐进式扩容</strong>，步骤如下：</p>
<ul>
<li>创建新哈希表，大小为旧哈希表的2倍</li>
<li>分多次迁移数据，期间如果有<strong>删改查</strong>请求，会先在旧哈希表操作，并将对应的数据迁移到新哈希表，如果数据已经迁移到新哈希表，就直接在新哈希表操作，<strong>增</strong>操作直接在新哈希表操作</li>
<li>迁移完成后，释放旧哈希表，将新哈希表设置为当前哈希表</li>
</ul>
<h3 id="redis为什么快"><a class="markdownIt-Anchor" href="#redis为什么快"></a> Redis为什么快？</h3>
<ul>
<li>基于内存，内存访问速度快</li>
<li>单线程，避免了多线程切换带来的开销</li>
<li>IO多路复用，一个线程处理多个IO流</li>
</ul>
<h3 id="redis哪里用到了多线程"><a class="markdownIt-Anchor" href="#redis哪里用到了多线程"></a> Redis哪里用到了多线程？</h3>
<p>Redis单线程一般指的是执行命令的线程是单线程，Redis6.0之后引入了多线程IO，主要用于网络IO，提升网络IO性能</p>
<h3 id="io多路复用怎么实现"><a class="markdownIt-Anchor" href="#io多路复用怎么实现"></a> IO多路复用怎么实现？</h3>
<ul>
<li>多个客户端与redis服务端建立连接时，服务端会将每个客户端的socket对应的FD注册到一个事件监听器中</li>
<li>事件监听器会监听所有的FD，当有FD有事件发生时，会通知事件处理器处理该事件</li>
<li>避免了服务端一直等待某个客户端数据的问题</li>
</ul>
<h3 id="如何实现redis的原子性"><a class="markdownIt-Anchor" href="#如何实现redis的原子性"></a> 如何实现Redis的原子性？</h3>
<ul>
<li>如果执行一条命令，由于redis是单线程的，所以是原子性的</li>
<li>如果执行两个命令，可以通过lua脚本</li>
<li>如果执行多个命令，可以通过事务，如果事务正常执行，通过multi和exec命令，可以保证多个命令的原子性，如果某一个操作执行失败，就无法保证原子性了</li>
</ul>
<h3 id="redis持久化之aof"><a class="markdownIt-Anchor" href="#redis持久化之aof"></a> Redis持久化之AOF？</h3>
<p>每执行一条写操作，就会将命令以追加写的方式写入AOF文件，当Redis重启时，会逐一执行AOF文件中的命令，恢复数据<br />
有三种写回策略</p>
<ul>
<li>always：每次写操作都会同步写入AOF文件，保证数据的完整性</li>
<li>everysec：每次写操作执行完后，先将命令写入内核缓冲区，然后每隔一秒将内核缓冲区的数据写入AOF文件</li>
<li>no：每次写操作执行完后，将命令写入内核缓冲区，然后由操作系统决定何时将数据写入AOF文件</li>
</ul>
<table>
<thead>
<tr>
<th>写回策略</th>
<th>写回时机</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Always</td>
<td>同步写回</td>
<td>可靠性高、最大程度保证数据不丢失</td>
<td>每个写命令都要写回硬盘，性能开销大</td>
</tr>
<tr>
<td>Everysec</td>
<td>每秒写回</td>
<td>性能适中</td>
<td>宕机时会丢失1秒内的数据</td>
</tr>
<tr>
<td>No</td>
<td>由操作系统控制写回</td>
<td>性能好</td>
<td>宕机时丢失的数据可能会很多</td>
</tr>
</tbody>
</table>
<p>AOF重写机制？</p>
<ul>
<li>当AOF命令过大时，就会触发重写机制，用最新的写入命令重写AOF文件，减小AOF文件的大小</li>
<li>一般重写机制在后台子进程执行，在大部分时候不会阻塞主进程</li>
</ul>
<h3 id="redis持久化之rdb"><a class="markdownIt-Anchor" href="#redis持久化之rdb"></a> Redis持久化之RDB?</h3>
<p>将某一时刻的内存数据以二进制形式写入磁盘<br />
Redis提供了save和bgsave两种方式生成RDB文件，他们的区别是是否在主进程中执行</p>
<ul>
<li>save会同步的执行保存操作，会阻塞主进程</li>
<li>bgsave会在后台子进程执行，不会阻塞主进程(异步)</li>
<li>RDB快照是全量快照，频繁执行会影响性能</li>
</ul>
<h3 id="bgsave时数据能被修改吗"><a class="markdownIt-Anchor" href="#bgsave时数据能被修改吗"></a> bgsave时，数据能被修改吗？</h3>
<p>答：可以。bgsave时，Redis会fork一个子进程，子进程会复制父进程的页表，但是指向同一个物理内存。<br />
但是当父进程数据要被修改时，会发生写时复制，数据所在的物理内存会被复制一份，然后主进程在数据的副本上修改，子进程仍然把旧的数据写入RDB。<br />
所以如果修改的数据过多，就会导致bgsave过程中内存占用过多。</p>
<h3 id="aof和rdb的优缺点"><a class="markdownIt-Anchor" href="#aof和rdb的优缺点"></a> AOF和RDB的优缺点？</h3>
<p>AOF</p>
<ul>
<li>优点：可靠性高，每次写操作都会写入AOF文件，即使服务器宕机，也只会丢失最后一次写操作，还可以通过选择合适的写回策略来平衡性能和可靠性</li>
<li>缺点：AOF文件体积更大，恢复速度慢，如果使用的是always策略，性能开销大</li>
</ul>
<p>RDB：</p>
<ul>
<li>优点：RDB文件体积小，恢复速度快</li>
<li>缺点：RDB是全量快照，如果宕机时，会丢失最后一次快照之后的数据，如果发生写时复制，会导致内存占用过多</li>
</ul>
<h3 id="讲讲redis的内存淘汰策略"><a class="markdownIt-Anchor" href="#讲讲redis的内存淘汰策略"></a> 讲讲Redis的内存淘汰策略？</h3>
<p>不进行数据淘汰的策略：</p>
<ul>
<li>noeviction，当内存不足时，不淘汰任何数据。有新的输入写入会报错通知禁止写入<br />
进行数据淘汰的策略：</li>
<li>针对设置了过期时间的数据：
<ul>
<li>volatile-random：随机淘汰设置了过期时间的数据</li>
<li>volatile-ttl：优先淘汰快过期的数据</li>
<li>volatile-lru：优先淘汰最久未使用的数据</li>
<li>volatile-lfu：优先淘汰最少使用的数据</li>
</ul>
</li>
<li>针对所有范围数据：
<ul>
<li>allkeys-random：随机淘汰任意数据</li>
<li>allkeys-lru：优先淘汰最久未使用的数据</li>
<li>allkeys-lfu：优先淘汰最少使用的数据</li>
</ul>
</li>
</ul>
<h3 id="redis的过期删除策略"><a class="markdownIt-Anchor" href="#redis的过期删除策略"></a> Redis的过期删除策略？</h3>
<p>过期删除采用惰性删除和定期删除两种方式</p>
<ul>
<li>惰性删除：只有在使用key时，才会检查key是否过期，如果过期才删除</li>
<li>定期删除：每隔一段时间（每秒10次，可以在redis.conf配置），会随机抽取一些key（一般为20个）检查是否过期，如果过期就删除</li>
</ul>
<h3 id="为什么不立刻删除过期key"><a class="markdownIt-Anchor" href="#为什么不立刻删除过期key"></a> 为什么不立刻删除过期key？</h3>
<p>答：当过期的key很多时，立刻删除会占用一定CPU，影响性能</p>
<h3 id="redis全量同步"><a class="markdownIt-Anchor" href="#redis全量同步"></a> Redis全量同步？</h3>
<p>全量同步一般发生在下面的情况：</p>
<ul>
<li>第一次同步</li>
<li>从服务器数据丢失</li>
<li>主从数据差异太大</li>
</ul>
<p>全量同步的过程：</p>
<ul>
<li>从服务器发送同步请求</li>
<li>主服务器生成RDB文件，发送给从服务器</li>
<li>从服务器接收RDB文件，并载入数据</li>
<li>主服务器生成和传输RDB期间，写操作会记录在replication backlog中</li>
<li>从服务器载入完RDB后，主服务器将replication backlog发送给从服务器，从服务器执行这些命令，保证数据一致</li>
</ul>
<h3 id="redis增量同步"><a class="markdownIt-Anchor" href="#redis增量同步"></a> Redis增量同步？</h3>
<p>增量同步主要通过replication backlog和两个offset实现：<br />
replication backlog实际上是一个环形数组，其中master offset记录了主服务器写的位置，slave offset记录了从服务器读的位置<br />
如果主服务器写的太快，从服务器读的太慢（网络原因），那么slave offset就会被覆盖，这时候就会发生全量同步</p>
<h3 id="介绍一下redis哨兵机制"><a class="markdownIt-Anchor" href="#介绍一下redis哨兵机制"></a> 介绍一下Redis哨兵机制？</h3>
<p>哨兵机制主要用于监控Redis集群的状态，主要作用是<code>监控、故障转移、通知</code></p>
<ul>
<li>监控：哨兵会定时检查主从集群的状态</li>
<li>故障转移：当主服务器宕机时，哨兵会选举一个从服务器作为新的主服务器</li>
<li>通知：当主从集群状态发生变化时，哨兵会通知客户端</li>
</ul>
<h3 id="哨兵机制如何监控"><a class="markdownIt-Anchor" href="#哨兵机制如何监控"></a> 哨兵机制如何监控？</h3>
<p>首先哨兵会基于心跳检测来判断节点状态</p>
<ul>
<li>主观下线：如果某个哨兵发现某个节点长时间未响应，就会认为该节点主观下线</li>
<li>客观下线：当超过一定数量的哨兵认为某个节点主观下线，就会认为该节点客观下线</li>
</ul>
<h3 id="哨兵如何选择新的主服务器"><a class="markdownIt-Anchor" href="#哨兵如何选择新的主服务器"></a> 哨兵如何选择新的主服务器？</h3>
<ul>
<li>首先哨兵需要选出一个leader，当一个哨兵认为主节点主观下线了，它会请求其他哨兵选自己为leader,被请求的哨兵如果没有投过票，则当前哨兵票数+1，一般票数超过半数，则选举成功</li>
<li>leader会根据策略选出新的主节点
<ul>
<li>首先排除故障的节点</li>
<li>选择优先级最大的节点</li>
<li>如果优先级相同，选择复制偏移量最大的节点</li>
<li>如果以上都相同，选择runid最小的节点</li>
</ul>
</li>
</ul>
<h3 id="介绍一下分片集群"><a class="markdownIt-Anchor" href="#介绍一下分片集群"></a> 介绍一下分片集群？</h3>
<p>redis分片集群主要用于解决单机内存有限的问题，通过分片将数据分布到多个节点中，提高了内存的使用率，提高了读写性能</p>
<p>分片集群一共有16384个槽，每个节点都包含若干个槽<br />
当添加数据时，步骤如下：</p>
<ul>
<li>通过CRC16算法计算key的哈希值</li>
<li>将哈希值对16384取模，得到槽号</li>
</ul>
<p>如何将同一类数据固定的保存在同一个Redis节点？<br />
答：使用<code>&#123;&#125;</code>将key中的部分字符串包裹，如<code>&#123;user:101&#125;:name</code>，这样只根据<code>user:101</code>来计算哈希值，保证<code>user:101</code>的数据都保存在同一个节点</p>
<h3 id="redis分布式锁的原理"><a class="markdownIt-Anchor" href="#redis分布式锁的原理"></a> Redis分布式锁的原理？</h3>
<h4 id="加锁"><a class="markdownIt-Anchor" href="#加锁"></a> 加锁</h4>
<p>Redis分布式锁主要用于控制某个资源在同一时刻只能被一个应用使用。<br />
NX参数实现<strong>key不存在才插入</strong>，可以通过它实现分布式锁</p>
<ul>
<li>key不存在，则插入成功，表示加锁成功</li>
<li>key存在，则插入失败，表示加锁失败</li>
</ul>
<p>使用分布式锁的条件：</p>
<ul>
<li>加锁需要以原子操作完成，通过set 命令带上NX参数实现</li>
<li>锁需要设置过期时间，可以通过PX参数设置</li>
<li>锁需要区分不同的客户端，所以需要一个唯一ID来标识客户端</li>
</ul>
<p>所以一个加锁的命令如下：<br />
<code>set lock_key 101 NX PX 30000</code></p>
<h4 id="解锁"><a class="markdownIt-Anchor" href="#解锁"></a> 解锁</h4>
<p>解锁需要两步操作：</p>
<ul>
<li>判断执行解锁操作的客户端就是加锁的客户端</li>
<li>删除lock_key</li>
</ul>
<p>由于是两个操作，为了保证原子性，一般用lua脚本实现</p>
<h3 id="什么是大key问题"><a class="markdownIt-Anchor" href="#什么是大key问题"></a> 什么是大Key问题？</h3>
<p>大Key问题指的是Redis中某个key的value过大，导致Redis处理这个key时，会占用大量的内存，影响Redis的性能</p>
<ul>
<li>高并发、低延迟场景中，超过10kb可能就构成大key</li>
<li>低并发、高容量场景中，超过100kb可能才构成大key</li>
</ul>
<p>一般会造成以下影响：</p>
<ul>
<li>内存占用过大</li>
<li>读写性能下降</li>
<li>可能阻塞其他操作</li>
<li>造成网络拥塞</li>
<li>造成主从延迟</li>
<li>造成Redis集群不均衡</li>
</ul>
<h3 id="如何解决大key问题"><a class="markdownIt-Anchor" href="#如何解决大key问题"></a> 如何解决大Key问题？</h3>
<ul>
<li>对大key进行拆分</li>
<li>对大key进行删除，要用异步删除</li>
<li>监控redis内存状态，及时发现大key</li>
<li>对过期数据定期进行清理</li>
</ul>
<h3 id="如何解决热key问题"><a class="markdownIt-Anchor" href="#如何解决热key问题"></a> 如何解决热key问题？</h3>
<p>热key指某个key的访问频率过高</p>
<p>解决方法：</p>
<ul>
<li>将热key复制并迁移到多个数据分片</li>
<li>使用读写分离架构，将热key读请求分发到多个从节点</li>
</ul>
<h3 id="先更新数据库再删缓存如何保证缓存正确删除"><a class="markdownIt-Anchor" href="#先更新数据库再删缓存如何保证缓存正确删除"></a> 先更新数据库再删缓存，如何保证缓存正确删除？</h3>
<p>可以通过消息队列和订阅binlog的方式实现</p>
<p>消息队列：</p>
<ul>
<li>删除缓存失败，从消息队重新取出消息，重新删除缓存，如果多次重试还是失败，需要手动处理</li>
<li>删除成功，就从消息队列中删除消息</li>
</ul>
<p>订阅binlog：<br />
更新数据库时会产生一条变更日志，记录在binlog里。因此可以订阅binlog，当有新的变更日志时，就删除对应的缓存，一般订阅通过canal实现</p>
<h3 id="缓存雪崩如何解决"><a class="markdownIt-Anchor" href="#缓存雪崩如何解决"></a> 缓存雪崩如何解决？</h3>
<p>缓存雪崩指的是大量key在同一时间失效，导致请求全部落到数据库上，引起数据库压力过大，甚至宕机</p>
<p>解决方法：</p>
<ul>
<li>随机设置不同的过期时间，避免同一时间大量key失效</li>
<li>添加降级或者限流策略，保护数据库避免宕机</li>
<li>使用多级缓存，如本地缓存等，分担redis的压力</li>
</ul>
<h3 id="如何设计秒杀场景处理高并发和超卖问题"><a class="markdownIt-Anchor" href="#如何设计秒杀场景处理高并发和超卖问题"></a> 如何设计秒杀场景处理高并发和超卖问题？</h3>
<ul>
<li>在数据库层面，查询时通过for update增加排他锁，其他线程无法删改数据，更新库存时添加判断，保证库存为正数</li>
<li>利用Redis分布式锁，同一个时间只有一个客户端能获得锁</li>
<li>利用分布式锁+分段缓存，将数据分段，每个段拥有独立的锁，避免锁的粒度过大</li>
<li>利用incr、decr的原子性+异步队列，步骤如下：
<ul>
<li>初始化时，将库存数量写入Redis</li>
<li>用户请求时，通过decr预减库存，如果库存小于0，说明超卖，返回失败</li>
<li>将请求放入异步队列</li>
<li>从队列取出请求，更新数据库库存</li>
<li>用户端通过轮询判断是否秒杀成功</li>
</ul>
</li>
</ul>
<h2 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h2>
<h3 id="什么是动态代理"><a class="markdownIt-Anchor" href="#什么是动态代理"></a> 什么是动态代理？</h3>
<p>动态代理是一种在运行时创建代理对象的机制，主要用于在不修改原始类的情况下对方法调用进行拦截和增强<br />
主要分为两种类型：</p>
<ul>
<li>JDK动态代理：这种类型要求目标类必须实现至少一个接口。通过Proxy类和InvocationHandler接口实现，当通过代理对象调用方法时，会转发到由InvocationHandler接口的invoke()方法调用。</li>
<li>CGLIB动态代理：CGLIB可以在运行时动态生成一个目标类的子类，不需要目标类实现接口，而是通过继承的方式实现代理。</li>
</ul>
<h2 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h2>
<h3 id="什么是aop"><a class="markdownIt-Anchor" href="#什么是aop"></a> 什么是AOP？</h3>
<p>AOP是将一些横切关注点如日志、事务、权限控制等与核心业务逻辑分离，通过动态代理等技术实现代码的复用和解耦，提高代码的可维护性和可扩展性。</p>
<h3 id="aop的一些术语有哪些"><a class="markdownIt-Anchor" href="#aop的一些术语有哪些"></a> AOP的一些术语有哪些？</h3>
<ul>
<li>横切关注点：多个类或者对象的公共行为，如日志、事务、权限控制等</li>
<li>切面：对横切关注点进行封装的类，一个切面是一个类</li>
<li>连接点：程序执行的某个特定的时刻，如方法的调用、异常的处理等</li>
<li>通知：在某个连接点要执行的操作</li>
<li>切点：一个切点是一个表达式，用来匹配连接点</li>
<li>织入：将切面和目标对象连接起来的过程</li>
</ul>
<h3 id="aop的通知都有哪些类型"><a class="markdownIt-Anchor" href="#aop的通知都有哪些类型"></a> AOP的通知都有哪些类型？</h3>
<ul>
<li>前置通知：在目标对象的方法调用前触发</li>
<li>后置通知：在目标对象的方法调用后触发</li>
<li>返回通知：目标对象的方法正常返回后触发</li>
<li>异常通知：目标对象的方法抛出异常后触发</li>
<li>环绕通知：手动控制触发的时机</li>
</ul>
<h3 id="aop的应用场景"><a class="markdownIt-Anchor" href="#aop的应用场景"></a> AOP的应用场景？</h3>
<ul>
<li>日志记录</li>
<li>性能统计</li>
<li>事务管理：如<code>@Transactional</code>注解就是基于AOP实现的</li>
<li>权限控制：利用 AOP 在目标方法执行前判断用户是否具备所需要的权限</li>
<li>接口限流</li>
</ul>
<h3 id="aop实现方式都有哪些"><a class="markdownIt-Anchor" href="#aop实现方式都有哪些"></a> AOP实现方式都有哪些？</h3>
<p>AOP的实现依赖于动态代理技术，动态代理是运行时动态生成代理对象，允许开发者在运行时指定要代理的接口和行为，从而实现在不修改源码的情况下增强方法的功能。</p>
<ul>
<li>JDK动态代理：使用java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口实现，需要实现一个或者多个接口</li>
<li>基于CGLIB的动态代理：使用CGLIB库实现，可以代理没有实现接口的类</li>
</ul>
<h1 id="cs基础"><a class="markdownIt-Anchor" href="#cs基础"></a> CS基础</h1>
<h2 id="进程和线程的区别"><a class="markdownIt-Anchor" href="#进程和线程的区别"></a> 进程和线程的区别</h2>
<blockquote>
<p>进程是资源分配的基本单位，线程是资源调度的基本单位(轻量级进程)</p>
</blockquote>
<ul>
<li>多个线程共享地址空间/资源，而进程之间的地址空间/资源是独立的</li>
<li>一个线程只能属于一个进程，一个进程可以有多个线程</li>
<li>创建/撤销线程的系统开销明显小于进程</li>
</ul>
<h2 id="硬链接和软链接的区别"><a class="markdownIt-Anchor" href="#硬链接和软链接的区别"></a> 硬链接和软链接的区别</h2>
<h3 id="硬链接"><a class="markdownIt-Anchor" href="#硬链接"></a> 硬链接</h3>
<ul>
<li>在 Linux/类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。</li>
<li>硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删。</li>
<li>只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。</li>
<li>硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。</li>
<li><code>ln</code> 命令用于创建硬链接。</li>
</ul>
<h3 id="软链接符号链接"><a class="markdownIt-Anchor" href="#软链接符号链接"></a> 软链接（符号链接）</h3>
<ul>
<li>软链接和源文件的 inode 节点号不同，而是指向一个文件路径。</li>
<li>源文件删除后，软链接依然存在，但是指向的是一个无效的文件路径。</li>
<li>软连接类似于 Windows 系统中的快捷方式。</li>
<li>不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，软链接可以跨越文件系统。</li>
<li>ln -s 命令用于创建软链接</li>
</ul>
<h3 id="为什么硬连接不能跨文件系统"><a class="markdownIt-Anchor" href="#为什么硬连接不能跨文件系统"></a> 为什么硬连接不能跨文件系统？</h3>
<ul>
<li>硬链接是通过 inode 节点号建立连接的，而硬链接和源文件共享相同的 inode 节点号。</li>
<li>然而，每个文件系统都有自己的独立 inode 表，且每个 inode 表只维护该文件系统内的 inode。</li>
<li>如果在不同的文件系统之间创建硬链接，可能会导致 inode 节点号冲突的问题，即目标文件的 inode 节点号已经在该文件系统中被使用。</li>
</ul>
<h2 id="动态编译和静态编译"><a class="markdownIt-Anchor" href="#动态编译和静态编译"></a> 动态编译和静态编译</h2>
<h3 id="静态编译"><a class="markdownIt-Anchor" href="#静态编译"></a> 静态编译</h3>
<p>在编译时将程序与其所有依赖项（包括库）链接在一起，形成一个单独的可执行文件。这个可执行文件包含了所有代码和数据，因此它是一个完全独立的二进制文件。</p>
<p>静态编译启动速度快，不需要依赖外部库，但可执行文件体积较大。</p>
<h3 id="动态编译运行时编译"><a class="markdownIt-Anchor" href="#动态编译运行时编译"></a> 动态编译(运行时编译)</h3>
<p>在编译时只创建程序的框架，而不将所有依赖项包含在可执行文件中。实际的库文件是在运行时加载的，程序在需要时动态链接到这些库。</p>
<h2 id="tcp三次握手"><a class="markdownIt-Anchor" href="#tcp三次握手"></a> TCP三次握手</h2>
<h3 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h3>
<p>三次握手的过程如图：<br />
<img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" srcset="/img/loading.gif" lazyload alt="三次握手" /></p>
<ul>
<li>一次握手:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&gt; 服务端，然后客户端进入 SYN_SEND 状态，等待服务端的确认；</li>
<li>二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 SYN_RECV 状态；</li>
<li>三次握手:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务端都进入ESTABLISHED 状态，完成 TCP 三次握手。</li>
</ul>
<h3 id="为什么要三次握手"><a class="markdownIt-Anchor" href="#为什么要三次握手"></a> 为什么要三次握手？</h3>
<p>三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<ul>
<li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ul>
<h3 id="第二次发送了ack为什么还要发送syn"><a class="markdownIt-Anchor" href="#第二次发送了ack为什么还要发送syn"></a> 第二次发送了ACK，为什么还要发送SYN？</h3>
<p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p>
<h3 id="三次握手过程可以携带数据吗"><a class="markdownIt-Anchor" href="#三次握手过程可以携带数据吗"></a> 三次握手过程可以携带数据吗？</h3>
<p>在 TCP 三次握手过程中，第三次握手是可以携带数据的(客户端发送完 ACK 确认包之后就进入 ESTABLISHED 状态了)</p>
<p>如果第三次握手的 ACK 确认包丢失，但是客户端已经开始发送携带数据的包，那么服务端在收到这个携带数据的包时，如果该包中包含了 ACK 标记，服务端会将其视为有效的第三次握手确认。这样，连接就被认为是建立的，服务端会处理该数据包，并继续正常的数据传输流程。</p>
<h2 id="tcp四次挥手"><a class="markdownIt-Anchor" href="#tcp四次挥手"></a> TCP四次挥手</h2>
<h3 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h3>
<p>TCP 四次挥手的过程如图：<br />
<img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png" srcset="/img/loading.gif" lazyload alt="四次挥手" /></p>
<ul>
<li>第一次挥手：客户端发送一个 FIN（SEQ=x） 标志的数据包-&gt;服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 FIN-WAIT-1 状态。</li>
<li>第二次挥手：服务端收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包-&gt;客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。</li>
<li>第三次挥手：服务端发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。</li>
<li>第四次挥手：客户端发送 ACK (ACK=y+1)标志的数据包-&gt;服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li>
</ul>
<blockquote>
<p>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</p>
</blockquote>
<h3 id="为什么要四次挥手"><a class="markdownIt-Anchor" href="#为什么要四次挥手"></a> 为什么要四次挥手？</h3>
<p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后。</p>
<ul>
<li>第一次挥手：A 说“我没啥要说的了”</li>
<li>第二次挥手：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li>
<li>第三次挥手：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li>
<li>第四次挥手：A 回答“知道了”，这样通话才算结束</li>
</ul>
<h3 id="为什么服务端不把-ack-和-fin-一起发送变成三次挥手"><a class="markdownIt-Anchor" href="#为什么服务端不把-ack-和-fin-一起发送变成三次挥手"></a> 为什么服务端不把 ACK 和 FIN 一起发送，变成三次挥手？</h3>
<p>因为服务端收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务端到客户端的数据传送。</p>
<h3 id="第二次挥手服务端发送ack没有到达会怎么样"><a class="markdownIt-Anchor" href="#第二次挥手服务端发送ack没有到达会怎么样"></a> 第二次挥手服务端发送ACK没有到达会怎么样？</h3>
<p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>
<h3 id="为什么第四次挥手客户端要等待-2msl报文最长存活时间才进入closed状态"><a class="markdownIt-Anchor" href="#为什么第四次挥手客户端要等待-2msl报文最长存活时间才进入closed状态"></a> 为什么第四次挥手，客户端要等待 2MSL（报文最长存活时间）才进入CLOSED状态？</h3>
<p>第四次挥手时，客户端发送给服务端的 ACK 有可能丢失。</p>
<ul>
<li>如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN</li>
<li>如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</li>
</ul>
<h1 id="c"><a class="markdownIt-Anchor" href="#c"></a> C++</h1>
<h2 id="c中的static关键字"><a class="markdownIt-Anchor" href="#c中的static关键字"></a> c++中的static关键字</h2>
<p>加载顺序（面向对象）</p>
<ul>
<li>静态-&gt;非静态-&gt;构造方法</li>
<li>父类静态-子类静态-父类非静态-父类构造-子类非静态-子类构造</li>
</ul>
<p>静态成员变量(面向对象)</p>
<ul>
<li>所有对象共享,不属于某个对象，可以通过类名访问，也可通过对象访问</li>
<li>在编译阶段分配内存，分配在数据区（全局区）</li>
<li>类内声明，类外初始化(class::var)</li>
<li>sizeof不会计算静态成员变量</li>
</ul>
<p>静态成员函数(面向对象)</p>
<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
<li>不含this指针(不能被实例使用)</li>
</ul>
<p>静态全局变量(面向过程)</p>
<ul>
<li>在数据区分配内存</li>
<li>未初始化会自动初始化为0</li>
<li>整个文件内可见，文件外不可见</li>
</ul>
<p>静态局部变量(面向过程)</p>
<ul>
<li>在数据区分配内存</li>
<li>一般在声明处初始化，未初始化会自动初始化为0</li>
<li>静态局部变量始终驻留在数据区，但他的作用域是局部作用域，当定义它的函数或语句块结束，其作用域随之结束</li>
</ul>
<blockquote>
<p>总结：静态变量具有全局变量的生命周期，但只能作用于自己的作用域。</p>
</blockquote>
<hr />
<h2 id="c模板"><a class="markdownIt-Anchor" href="#c模板"></a> c++模板</h2>
<blockquote>
<p>模板是c++泛型编程的主要使用的技术</p>
</blockquote>
<p><strong>函数模板</strong></p>
<p>创建一个通用的函数，函数返回值类型和形参可以不指定，用一个虚拟的类型来表示</p>
<p>声明一个模板<code>template&lt;typename T&gt;</code>或者<code>template&lt;class T&gt;</code></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">double</span> a=<span class="hljs-number">10.5</span>,b=<span class="hljs-number">20.00002</span>;<br>	cout&lt;&lt;<span class="hljs-string">&quot;自动类型推导&quot;</span>&lt;&lt;endl;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,<span class="hljs-built_in">sum</span>(a,b));<br>	cout&lt;&lt;<span class="hljs-string">&quot;显示指定类型&quot;</span>&lt;&lt;endl;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,<span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">double</span>&gt;(a,b));<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>
<p>注意</p>
<ul>
<li>自动推导类型需要推导出一致的类型</li>
<li>函数模板使用时必须确定<code>T</code>的类型</li>
<li>普通函数和函数模板都可调用时，先调用普通函数</li>
<li>如果类型和函数模板更匹配，则优先调用函数模板</li>
</ul>
<p><strong>类模板</strong></p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">M</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	T name;<br>	M age;<br>	<span class="hljs-built_in">person</span>(T a,M b):<span class="hljs-built_in">name</span>(a),<span class="hljs-built_in">age</span>(b)&#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;cndh&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>	cout&lt;&lt;p.name&lt;&lt;endl;<br>	cout&lt;&lt;p.age&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>类模板不能自动推导类型</li>
<li>类模板可以在模板参数列表中指定默认类型</li>
<li>类模板中定义的函数在调用时才创建</li>
</ul>
<hr />
<h2 id="c深拷贝和浅拷贝的区别"><a class="markdownIt-Anchor" href="#c深拷贝和浅拷贝的区别"></a> c++深拷贝和浅拷贝的区别</h2>
<blockquote>
<p><strong>浅拷贝</strong> （默认方式）：将原对象的引用直接赋给新对象，只是原对象的一个引用。</p>
</blockquote>
<blockquote>
<p><strong>深拷贝</strong>： 创建一个新的对象，将原对象的各项属性拷贝过来，深拷贝会在堆中额外申请内存来储存数据，当数据成员中有指针时，必须要用深拷贝。</p>
</blockquote>
<ul>
<li>因为申请了新的内存，所以深拷贝改变新对象的属性对原对象没有影响，但是浅拷贝会影响</li>
<li>当成员中有指针时，必须用深拷贝。因为浅拷贝的新指针和旧指针都指向同一块内存，在新对象和旧对象析构时，已经释放的内存会被再次释放，这时会出现错误。</li>
</ul>
<hr />
<h2 id="c多态"><a class="markdownIt-Anchor" href="#c多态"></a> c++多态</h2>
<p>编译时多态：</p>
<ul>
<li>编译器多态是通过函数重载和模板实现的。在编译时，根据函数的参数类型或模板参数类型，编译器会选择合适的函数或模板实例化。</li>
<li>编译器多态是在编译时确定函数调用，因此它的性能较高。</li>
<li>编译器多态不需要使用虚函数和基类指针或引用，可以直接根据函数的参数类型或模板参数类型来确定函数调用。</li>
</ul>
<p>运行时多态：</p>
<ul>
<li>运行时多态是通过继承和虚函数实现的。当基类的指针或引用指向派生类对象时，通过虚函数的动态绑定，可以在运行时确定要调用的函数实现。</li>
<li>运行时多态需要使用虚函数和基类指针或引用来实现，这样可以在运行时根据实际对象的类型来确定调用哪个函数。</li>
<li>运行时多态在运行时才能确定具体的函数调用，因此它的性能相对较低。</li>
</ul>
<p><em><strong>override的作用</strong></em></p>
<p>保证在派生类中声明的重载函数，与基类的虚函数有相同的签名，核心作用就是用于编译期代码检查。</p>
<p><em><strong>final</strong></em></p>
<p>阻止类的进一步派生和虚函数的进一步重写，同时也是一种名为去虚拟化的优化技巧，相当于把运行期多态转换为了编译期多态，提高了执行效率。</p>
<p><em><strong>多继承存在的问题</strong></em></p>
<p>命名冲突</p>
<p><em><strong>向上转型</strong></em></p>
<p>向上转型是子类指针转换成父类指针</p>
<p><code>Parent* p =new son();</code></p>
<p><em><strong>向下转型</strong></em></p>
<p>因为父类指针不能操作子类独有的函数，即使父类指针指向子类的对象也不行，所以需要向下转型</p>
<p>向下转型有两种方式<code>dynamic_cast</code>和<code>static_cast</code>,前者更加安全一些</p>
<p>例如：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">Parent* pS<span class="hljs-keyword">on</span>=new S<span class="hljs-keyword">on</span>();<br>S<span class="hljs-keyword">on</span>* s=dynamic_cast<span class="hljs-variable">&lt;Son*&gt;</span>(pS<span class="hljs-keyword">on</span>);<br></code></pre></td></tr></table></figure>
<hr />
<h2 id="虚函数与纯虚函数"><a class="markdownIt-Anchor" href="#虚函数与纯虚函数"></a> 虚函数与纯虚函数</h2>
<p><strong>虚函数</strong><br />
在类中声明时前面带有virtual关键字的函数，如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">example</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>纯虚函数</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">在虚函数后面加`=<span class="hljs-number">0</span>`<br><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">example</span>()</span> = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>虚函数可以在父类中实现，也可以被子类重写实现，是实现运行时多态的方式之一</li>
<li>纯虚函数不可以在父类实现，必须由子类重写</li>
<li>含有纯虚函数的类被称为抽象类，抽象类不能实例化</li>
<li>抽象类的子类如果要实例化，则必须重写纯虚函数</li>
</ul>
<p><strong>虚函数怎么实现的？真的更慢吗？</strong></p>
<ul>
<li>虚函数是通过虚函数表实现的，每个类都有自己的虚表，对象的首地址处存放有指向虚表的指针。</li>
<li>当具体调用哪个虚函数可以在编译期间确定的时候，虚函数不一定更慢。</li>
</ul>
<h2 id="c智能指针"><a class="markdownIt-Anchor" href="#c智能指针"></a> c++智能指针</h2>
<p><strong>内存泄漏</strong>：</p>
<ul>
<li>
<p>指因某些原因造成程序未能释放已不再使用的内存。内存泄漏并不是内存消失了，而是由于程序设计的问题，失去对某块内存的控制，导致无法利用该块内存。</p>
</li>
<li>
<p>内存泄漏会导致程序响应越来越慢，甚至崩溃</p>
</li>
<li>
<p>一般有2种内存泄漏，一种是堆区分配的内存没有及时释放，一种是套接字、文件描述符等没有释放，2种情形都会导致资源的浪费</p>
</li>
</ul>
<p><strong>RALL</strong></p>
<ul>
<li>RAII（Resource Acquisition Is Initialization）是一种将对象生命周期和资源绑定的技术</li>
<li>对象创建时获取资源，析构时释放资源</li>
</ul>
<p>智能指针就具有RALL的特性</p>
<p><strong>auto_ptr</strong></p>
<p>c++98中就已经提供了智能指针auto_ptr</p>
<p>例如：<code>auto_ptr&lt;int&gt; p(new int)</code>就相当于 <code>int * p=new int</code></p>
<p>auto_ptr的局限性：</p>
<ul>
<li>拷贝或者赋值会导致原指针变为<code>NULL</code>，如<code>p1=p2</code>后，<code>p2变成了NULL</code></li>
<li>不支持对象数组的内存管理</li>
</ul>
<p><strong>unique_ptr</strong></p>
<p>不能直接进行赋值或者拷贝构造，如：<code>p1 = p2</code>和<code>unique_ptr&lt;int&gt; p1(p2)</code></p>
<p>如果要强行执行的话要加上<code>move</code>，如：<code>p1 = std::move(p2)</code>和<code>unique_ptr&lt;int&gt; p1(std::move(p2))</code></p>
<p><strong>shared_ptr</strong></p>
<p>通过<strong>引用计数</strong>(<code>use_count()</code>)的方式来实现多个<code>shared_ptr</code>对象之间共享资源</p>
<ul>
<li>shared_ptr在其内部，给每个资源都有一份计数表，用来记录该份资源被几个指针共享</li>
<li>在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一</li>
<li>如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源</li>
<li>如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了</li>
</ul>
<p>注意：两个对象交叉使用<strong>shared_ptr</strong>(互相获得对方的share指针),会导致内存泄漏</p>
<p><strong>weak_ptr</strong></p>
<p>专门为了解决上面的<strong>shared_ptr</strong>的问题，不支持RALL，不释放资源，不增加或减少引用计数</p>
<p>具体参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/cpp_learner/article/details/118912592?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166191088916782414982504%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166191088916782414982504&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118912592-null-null.142%5Ev42%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=c%2B%2B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4187">相关链接</a></p>
<hr />
<h2 id="const-和-volatile辨析"><a class="markdownIt-Anchor" href="#const-和-volatile辨析"></a> const 和 volatile辨析</h2>
<p><strong>const</strong></p>
<ul>
<li>被const修饰的变量被视为一个常量，使得变量具有只读属性</li>
<li>const修饰的变量不是一个真正的只读变量，它只是告诉编译器该变量<strong>不能出现在赋值符号的左边</strong></li>
</ul>
<p><em><strong>const修饰指针变量有以下3种情况</strong></em></p>
<ol>
<li>const 修饰指针指向的内容，则内容为不可变量。</li>
</ol>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const int *p <span class="hljs-operator">=</span> <span class="hljs-number">8</span><span class="hljs-comment">; //指向的内容8不可变</span><br>*p<span class="hljs-operator">=</span><span class="hljs-number">6</span><span class="hljs-comment">; //错误</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li>const 修饰指针，则指针不可变</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a=<span class="hljs-number">8</span>;<br><span class="hljs-built_in">int</span>* <span class="hljs-keyword">const</span> p = &amp;a;<br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-built_in">int</span>  b = <span class="hljs-number">7</span>;<br>p = &amp;b; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure>
<ol start="3">
<li>const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a = <span class="hljs-number">8</span>, b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> * <span class="hljs-keyword">const</span>  p = &amp;a;<br>*p=<span class="hljs-number">1</span>; <span class="hljs-comment">//错误</span><br>p=&amp;b; <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure>
<p><em><strong>const 修饰对象和成员函数</strong></em></p>
<ul>
<li>被const修饰的对象(常对象)或者成员函数(常函数)内不能修改类的成员变量，如果要修改需要给对应的成员变量加mutable关键字</li>
<li>常对象只能修改常函数</li>
</ul>
<p><strong>volatile</strong></p>
<p>本意为易变的，有以下特点</p>
<ul>
<li>volatile指出变量是随时可能变化的，每次使用需要重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。</li>
<li>被volatile修饰的变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</li>
</ul>
<blockquote>
<p><em><strong>一个变量可以同时被const和volatile修饰吗？</strong></em></p>
</blockquote>
<p>可以。const volatile表示一个变量在程序编译期不能被修改且不能被优化；在程序运行期，每次必须从内存中加载变量的值。</p>
<h2 id="null-和-nullptr的区别是什么为什么引入nulllptr"><a class="markdownIt-Anchor" href="#null-和-nullptr的区别是什么为什么引入nulllptr"></a> NULL 和 nullptr的区别是什么，为什么引入nulllptr？</h2>
<ul>
<li>主流编译器中，<code>NULL</code>实际上是一个整数常量，被定义为 0，在 C++11 之前，当我们想要将一个指针初始化为空时，我们通常使用 NULL；</li>
<li><code>nullptr</code> 是 C++11 中引入的新的关键字，专门用于表示空指针，它不是整数类型，而是特殊的指针类型<code>nullptr_t</code>。</li>
</ul>
<p><em><strong>引入nullptr的原因</strong></em></p>
<ol>
<li>NULL是整数类型，用户调用foo(NULL)的时候，不能区分调用的是foo(int)还是foo(int*)函数；</li>
<li>主流编译器中NULL值为0，通过0表示一个无效地址，但是有的架构下，0地址有特定用途，而<code>nullptr</code>指向的永远是一个无效地址。</li>
</ol>
<h2 id="git-fetch和git-pull的区别"><a class="markdownIt-Anchor" href="#git-fetch和git-pull的区别"></a> git fetch和git pull的区别</h2>
<ul>
<li>git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</li>
<li>而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</li>
</ul>
<blockquote>
<p>git 连接/添加远程仓库<br />
git remote add 仓库名 地址</p>
</blockquote>
<h2 id="delete是怎样知道数组长度的"><a class="markdownIt-Anchor" href="#delete是怎样知道数组长度的"></a> delete[]是怎样知道数组长度的？</h2>
<p>没有标准实现，一种常见的实现方法是，申请内存时，会在返回的指针前面存放这段内存的大小，调用delete[]的时候，就可以知道数组长度了。</p>
<h2 id="程序是从main-函数开始执行的吗"><a class="markdownIt-Anchor" href="#程序是从main-函数开始执行的吗"></a> 程序是从main 函数开始执行的吗？</h2>
<p>不是，程序在执行前，会经历一个从磁盘加载程序到内存的过程，这个过程会执行非静态全局变量的初始化。</p>
<h1 id="python"><a class="markdownIt-Anchor" href="#python"></a> python</h1>
<h2 id="python的垃圾回收机制"><a class="markdownIt-Anchor" href="#python的垃圾回收机制"></a> python的垃圾回收机制</h2>
<blockquote>
<p>python采用的是<strong>引用计数</strong>为主，<strong>标记—清除</strong>和<strong>分代收集</strong>为辅的策略。</p>
</blockquote>
<p><strong>引用计数</strong><br />
每个对象维护一个字段来记录对象被引用的次数，当新的引用指向该对象的时候，引用计数的值加1,当某个引用失效时，引用计数值减一。当引用计数的值为0时，会释放占用的内存空间。</p>
<p>缺点：</p>
<ul>
<li>需要额外的空间维护引用次数</li>
<li>对象的循环引用会导致内存泄漏</li>
</ul>
<p>引用计数增加的情况：</p>
<ul>
<li>对象被创建，例如 a = 23</li>
<li>对象被引用，例如 b = a</li>
<li>对象被作为参数，传入到一个函数中，例如 fun(a)</li>
<li>对象被作为一个元素，存储在容器中</li>
</ul>
<p>引用计数减少的情况：</p>
<ul>
<li>对象的别名被显式销毁，例如 del a</li>
<li>对象的别名被赋予新的对象，例如 a = 24</li>
<li>一个对象离开它的作用域，例如 f 的函数执行完毕时，func函数中的局部变量</li>
<li>对象所在的容器被销毁，或从容器中删除对象</li>
</ul>
<p><strong>分代回收</strong></p>
<ul>
<li>
<p>分代回收是一种以空间换时间的方式，Python将内存根据对象的存活时间划分为不同的集合，每一个集合称为一个代，Python将内存分为了3“代”，分别代表<strong>年轻代</strong>（第0代）、<strong>中年代</strong>（第1代）、<strong>老年代</strong>（第2代），它们对应的是3个链表，它们的垃圾收集频率随着对象的存活时间的增大而减小</p>
</li>
<li>
<p>新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾回收机制就会被触发，把那些可以被回收的对象被回收掉，而那些不会被回收的对象就会被移动到中年代，依次类推， 老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期中。</p>
</li>
</ul>
<p><strong>标记–清除</strong></p>
<p>是一种基于追踪回收（tracking GC）技术实现的垃圾回收算法。它分为两个阶段：</p>
<ol>
<li>标记阶段，GC会把所有的活动对象打上标记</li>
<li>把那些没有标记的对象（非活动对象）进行回收</li>
</ol>
<p><strong>如何判断哪些是活动对象，哪些是非活动对象？</strong></p>
<p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从跟对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。</p>
<h1 id="deep-learning"><a class="markdownIt-Anchor" href="#deep-learning"></a> deep learning</h1>
<h2 id="判别模型和生成模型"><a class="markdownIt-Anchor" href="#判别模型和生成模型"></a> 判别模型和生成模型</h2>
<p>判别模型：直接学习条件概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(y|x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><br />
生成模型：学习联合概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，然后可以计算条件概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(y|x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>以及其他信息，需要的数据量较大</p>
<p>简单说，要判断一个苹果是好是坏，判别模型会直接给出是好的概率和是坏的概率，而生成模型分别学习出两种苹果各自对应的模型，然后将要预测的苹果的特征分别输入不同模型，然后比较两个模型输出概率的大小，选出合适的类别</p>
<p>判别模型：</p>
<ul>
<li>感知机</li>
<li>k近邻</li>
<li>决策树</li>
<li>逻辑思蒂回归</li>
<li>svm</li>
<li>boosting</li>
<li>最大熵模型</li>
</ul>
<p>生成模型：</p>
<ul>
<li>朴素贝叶斯</li>
<li>混合高斯模型</li>
<li>隐马尔可夫模型</li>
</ul>
<h2 id="转置卷积和空洞卷积"><a class="markdownIt-Anchor" href="#转置卷积和空洞卷积"></a> 转置卷积和空洞卷积</h2>
<p><em><strong>转置卷积</strong></em></p>
<blockquote>
<p>在语义分割中，会使用卷积层进行特征提取，然后通过转置卷积做上采样，恢复为原先的尺寸，这样才可以对原来的图像中每个像素都进行分类。<strong>转置卷积不是卷积的逆运算</strong></p>
</blockquote>
<p>基本步骤：</p>
<ul>
<li>在特征图<strong>中间</strong>(元素和元素之间)填充s-1行，s为步长</li>
<li>在特征图<strong>四周</strong>填充k-p-1行，k为卷积核大小，p为padding</li>
<li>将kernel上下、左右翻转（中心对称，顺时针旋转180度）</li>
<li>做kernel_size不变，s和p均为1的卷积即可</li>
</ul>
<p><em><strong>空洞卷积</strong></em></p>
<ul>
<li>在卷积核相邻元素之间插入0,具体插入膨胀率(dilation rate)-1个0，然后再做卷积</li>
<li>主要目的是扩大感受野</li>
</ul>
<h2 id="数据集不平衡的处理方式"><a class="markdownIt-Anchor" href="#数据集不平衡的处理方式"></a> 数据集不平衡的处理方式</h2>
<ol>
<li>数据增广
<ul>
<li>进行一定的旋转缩放</li>
<li>RGB三通道提取三张图片</li>
<li>高斯模糊</li>
</ul>
</li>
<li>人工合成数据</li>
<li>给每种类别赋予权值，样本少的类别权值可以大一些，样本多的类别权值小一些</li>
</ol>
<h2 id="tensorflow和pytorch的区别"><a class="markdownIt-Anchor" href="#tensorflow和pytorch的区别"></a> tensorflow和pytorch的区别</h2>
<ol>
<li>tf是谷歌开源的深度学习框架，pytorch是facebook开源的深度学习框架</li>
<li>在tf1.0时，tf只支持静态的计算图，而pytorch支持动态的计算图，但是tf2.0也支持动态计算图了</li>
<li>tf的api更详细更丰富，pytorch的代码更简洁</li>
<li>tf有tensorboard这样的可视化工具，但实际上现在pytorch也能使用tensorboard</li>
</ol>
<h2 id="transformer中的位置编码"><a class="markdownIt-Anchor" href="#transformer中的位置编码"></a> transformer中的位置编码</h2>
<blockquote>
<p>为什么需要位置编码？</p>
</blockquote>
<ul>
<li>位置和词语的顺序是任何语言的重要组成部分。它们定义了语法，从而决定了句子的实际语义。循环神经网络（RNN）本质上考虑了词语的顺序；它们按照顺序逐个解析句子中的词语。这样可以将词语的顺序整合到RNN的主干中。</li>
<li>Transformer架构放弃了循环机制，转而采用<strong>多头自注意机制</strong>，大大加快训练时间。从理论上讲，它可以捕捉到句子中更长的依赖关系。由于句子中的<strong>每个词语同时通过Transformer的编码器/解码器，模型本身对于每个词语的位置/顺序没有任何概念。</strong></li>
</ul>
<blockquote>
<p>位置编码的计算？</p>
</blockquote>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mover accent="true"><msub><mi>p</mi><mi>t</mi></msub><mo stretchy="true">→</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><msup><mo stretchy="false">)</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>:</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>k</mi></msub><mi mathvariant="normal">.</mi><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mtext> </mtext></mrow><mi>i</mi><mo>=</mo><mn>2</mn><mi>k</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>k</mi></msub><mi mathvariant="normal">.</mi><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mtext> </mtext></mrow><mi>i</mi><mo>=</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\left.\overrightarrow{p_t}^{(i)}=f(t)^{(i)}:=\left\{\begin{array}{ll}\sin(\omega_k.t),&amp;\mathrm{if~}i=2k\\\cos(\omega_k.t),&amp;\mathrm{if~}i=2k+1\end{array}\right.\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9525600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span class="svg-align" style="top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.23046em;"><span style="top:-3.40546em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mspace nobreak"> </span></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mspace nobreak"> </span></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中，t代表位置，i代表维度。p代表第t个位置，第i个维度的值。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\omega_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的计算如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>ω</mi><mi>k</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1000</mn><msup><mn>0</mn><mrow><mn>2</mn><mi>k</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\omega_k=\frac1{10000^{2k/d}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.0254399999999997em;vertical-align:-0.704em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2960000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.814em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">/</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.704em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>有以下特点：</p>
<ul>
<li>奇数维度之间或者偶数维度之间周期不同。</li>
<li>除了表示绝对位置信息外，还可以很好的表示相对位置信息。给定k,存在一个固定的与k相关的线性变换矩阵，从而由pos的位置编码线性变换而得到pos+k的位置编码。这个相对位置信息可能可以被模型发现而利用。因为绝对位置信息只保证了各个位置不一样，但是并不是像0,1,2这样的有明确前后关系的编码。</li>
</ul>
<blockquote>
<p>CV中使用位置编码</p>
</blockquote>
<p>与nlp中类似，cv中的每个像素和patch也有自己的位置信息，通常cv中位置编码有以下两种：</p>
<ul>
<li>绝对位置编码：一般是可学习的，实现非常简洁，初始化一个形状和经过patch_embedding后的输出x相同的参数，然后直接加到x上，在训练阶段一起训练，有点像加了一个可学习的bias，VIT中使用的就是这种方式。</li>
<li>相对位置编码：绝对位置编码是在patch_embedding之后，计算自注意力(Q,K,V)之前，而相对位置编码是在计算自注意力的时候加入的，如下式</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Attention</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>SoftMax</mtext><mo stretchy="false">(</mo><mfrac><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><msqrt><mi>d</mi></msqrt></mfrac><mo>+</mo><mi>B</mi><mo stretchy="false">)</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\text{Attention}(Q,K,V)=\text{SoftMax}(\frac{QK^T}{\sqrt{d}}+B)V
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Attention</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.448331em;vertical-align:-0.93em;"></span><span class="mord text"><span class="mord">SoftMax</span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.17778em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.93222em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">d</span></span></span><span style="top:-2.89222em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.10777999999999999em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p>
<p>在swin transformer中，将二维位置信息转换为一维位置信息，然后去根据相对位置偏移表查询具体的值，位置偏移表的值是训练出来的，在文章中，相对位置编码效果好于绝对位置编码。具体参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43733107/article/details/127077056">这里</a></p>
<blockquote>
<p>为什么往往小数据集上卷积效果好于tranformer?</p>
</blockquote>
<ul>
<li>在小数据集上，相比卷积transformer缺少内在偏置，因此需要加入相对位置编码来解决这个问题，而对于特大数据集，transformer就可以学习到卷积的内在偏置，即这也是为什么在小数据集上transformer的效果不如卷积，而在大数据集上，transformer效果优于卷积。</li>
</ul>
<h2 id="自注意力和注意力的区别"><a class="markdownIt-Anchor" href="#自注意力和注意力的区别"></a> 自注意力和注意力的区别</h2>
<p>注意力机制的查询和键是不同来源的，而自注意力机制的查询和键则都是来自于同一组的元素，如对于一张图片，q和k都来自于这张图片的patch或者特征。</p>
<blockquote>
<p>个人对于DETR的decoder中的q，k,v的理解</p>
</blockquote>
<p>query是每张图设置的预测的proposals的数量，例如一张图的gt有20个bbox，然后query为100，那么网络会产生100个proposals，然后用匈牙利算法求得100个query和20个bbox的最优匹配</p>
<p>对于decoder的多头注意力，我理解的是kv来自encoder是因为encoder中将图像的特征进行了编码，然后由于需要产生100个proposals，所以就用外部的q来计算encoder产生的k的权重信息，比如qk^T-&gt;[16,100,32]*[16,32,576]=[16,100,576]，这里[100,576]代表了100个query在576个特征上的权重或者相似度信息，然后乘v[16,576,32]，输出是[16,100,32]，reshape为[100,2,256]，encoder的输出[576,2,256]经过decoder后映射为[100,2,256]，因此加入的query可能是为了学习encoder的输出中的特征信息，然后将特征的维度降到100，然后从这100个proposals中取匹配最佳的gt。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0/" class="category-chain-item">学习</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>常见问题</div>
      <div>http://lqz2.github.io/2022/08/26/常见问题/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>zql</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/27/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%A4%A7%E9%98%B6%E4%B9%98/" title="进制转换与大阶乘">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">进制转换与大阶乘</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集">
                        <span class="hidden-mobile">并查集</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
