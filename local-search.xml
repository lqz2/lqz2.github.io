<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>交换得到字典序最小的数组</title>
    <link href="/2023/11/26/%E4%BA%A4%E6%8D%A2%E5%BE%97%E5%88%B0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <url>/2023/11/26/%E4%BA%A4%E6%8D%A2%E5%BE%97%E5%88%B0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BA%A4%E6%8D%A2%E5%BE%97%E5%88%B0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E7%BB%84">交换得到字典序最小的数组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="交换得到字典序最小的数组"><a class="markdownIt-Anchor" href="#交换得到字典序最小的数组"></a> 交换得到字典序最小的数组</h2><p><a href="https://leetcode.cn/problems/make-lexicographically-smallest-array-by-swapping-elements/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个下标从 0 开始的 正整数 数组 nums 和一个 正整数 limit 。</p><p>在一次操作中，你可以选择任意两个下标 i 和 j，如果 满足 |nums[i] - nums[j]| &lt;= limit ，则交换 nums[i] 和 nums[j] 。</p><p>返回执行任意次操作后能得到的 字典序最小的数组 。</p><p>如果在数组 a 和数组 b 第一个不同的位置上，数组 a 中的对应字符比数组 b 中的对应字符的字典序更小，则认为数组 a 就比数组 b 字典序更小。例如，数组 [2,10,3] 比数组 [10,2,3] 字典序更小，下标 0 处是两个数组第一个不同的位置，且 2 &lt; 10 。</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,5,3,9,8]</span>, limit = 2<br>输出：<span class="hljs-comment">[1,3,5,8,9]</span><br>解释：执行 2 次操作：<br>- 交换 nums<span class="hljs-comment">[1]</span> 和 nums<span class="hljs-comment">[2]</span> 。数组变为 <span class="hljs-comment">[1,3,5,9,8]</span> 。<br>- 交换 nums<span class="hljs-comment">[3]</span> 和 nums<span class="hljs-comment">[4]</span> 。数组变为 <span class="hljs-comment">[1,3,5,8,9]</span> 。<br>即便执行更多次操作，也无法得到字典序更小的数组。<br>注意，执行不同的操作也可能会得到相同的结果。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要思路是分组排序和二分。首先需要对数组进行排序，接下来将他们分组，分组的原则是组内升序且各个组之间，不存在任何一对可以交换的元素<code>(tmp[j]-tmp[i]&gt;limit,j&gt;i)</code>，然后用数组idx[]记录每个组的第一个元素在有序数组中的下标，offset[]记录偏移量。接下来遍历nums数组，每个元素先二分查找在有序数组中的下标j，然后再二分查找j属于哪个组，然后根据组内起始下标和组内偏移确定在有序数组中的下标，然后添加到ans中。总的来说，每次遍历元素放置的是元素所在组内能交换的较小值，因此保证了字典序较小。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lexicographicallySmallestArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; tmp=nums;<br>        <span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; idx;<br>        idx.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tmp[i]-tmp[t]&gt;limit)<br>            &#123;<br>                idx.<span class="hljs-built_in">push_back</span>(i);<br>                t=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> m=idx.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">offset</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> j=<span class="hljs-built_in">upper_bound</span>(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>(),nums[i])-tmp.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-type">int</span> k=<span class="hljs-built_in">lower_bound</span>(idx.<span class="hljs-built_in">begin</span>(),idx.<span class="hljs-built_in">end</span>(),j)-idx.<span class="hljs-built_in">begin</span>();<br>            ans[i]=tmp[idx[k<span class="hljs-number">-1</span>]+offset[k<span class="hljs-number">-1</span>]];<br>            ++offset[k<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网格中最小路径代价</title>
    <link href="/2023/11/22/%E7%BD%91%E6%A0%BC%E4%B8%AD%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%BB%A3%E4%BB%B7/"/>
    <url>/2023/11/22/%E7%BD%91%E6%A0%BC%E4%B8%AD%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BD%91%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%BB%A3%E4%BB%B7">网格中的最小路径代价</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="网格中的最小路径代价"><a class="markdownIt-Anchor" href="#网格中的最小路径代价"></a> 网格中的最小路径代价</h2><p><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个下标从 0 开始的整数矩阵 grid ，矩阵大小为 m x n ，由从 0 到 m * n - 1 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 下一行 的任何其他单元格。如果你位于单元格 (x, y) ，且满足 x &lt; m - 1 ，你可以移动到 (x + 1, 0), (x + 1, 1), …, (x + 1, n - 1) 中的任何一个单元格。注意： 在最后一行中的单元格不能触发移动。</p><p>每次可能的移动都需要付出对应的代价，代价用一个下标从 0 开始的二维数组 moveCost 表示，该数组大小为 (m * n) x n ，其中 moveCost[i][j] 是从值为 i 的单元格移动到下一行第 j 列单元格的代价。从 grid 最后一行的单元格移动的代价可以忽略。</p><p>grid 一条路径的代价是：所有路径经过的单元格的 值之和 加上 所有移动的 代价之和 。从 第一行 任意单元格出发，返回到达 最后一行 任意单元格的最小路径代价。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题关键在于理解moveCost的意思。可以用dp[i][j]表示从第0行某元素到第i行第j列元素的代价，状态方程可以表示为：<code> dp[i][j]=min(dp[i][j],dp[i-1][k]+grid[i][j]+moveCost[grid[i-1][k]][j]);</code>，注意这里moveCost的行索引是元素的值。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> minPathCost(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-keyword">grid</span>, <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; moveCost) &#123;<br>        <span class="hljs-keyword">int</span> m=<span class="hljs-keyword">grid</span>.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">int</span> n=<span class="hljs-keyword">grid</span>[<span class="hljs-number">0</span>].<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp(m,<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,INT_MAX));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            dp[<span class="hljs-number">0</span>][j]=<span class="hljs-keyword">grid</span>[<span class="hljs-number">0</span>][j];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k)<br>                    dp[i][j]=<span class="hljs-keyword">min</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][k]+<span class="hljs-keyword">grid</span>[i][j]+moveCost[<span class="hljs-keyword">grid</span>[i<span class="hljs-number">-1</span>][k]][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *min_element(dp[m<span class="hljs-number">-1</span>].begin(),dp[m<span class="hljs-number">-1</span>].end());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法作业3</title>
    <link href="/2023/11/15/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A3/"/>
    <url>/2023/11/15/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A3/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B9%A6%E7%B1%8D%E5%BD%92%E6%A1%A3">书籍归档</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E5%81%9C%E8%BD%A6%E5%9C%BA%E7%AE%A1%E7%90%86%E5%91%98">停车场管理员</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E5%AF%B9">服务器配对</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-2">代码</a></li></ul></li><li><a href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">哈夫曼编码</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-3">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-3">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="书籍归档"><a class="markdownIt-Anchor" href="#书籍归档"></a> 书籍归档</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你是一名图书馆管理员，负责归档书籍。你有一个书架，它能承载一定量的重量。给定一个整数数组 books，其中 books[i] 表示第 i 本书的重量。书架的承重限制为 5000 单位。返回你最多可以归档的书籍数量。<br />input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">900 </span><span class="hljs-number">950</span> <span class="hljs-number">800</span> <span class="hljs-number">1000</span> <span class="hljs-number">700</span> <span class="hljs-number">800</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>比较简单，排序然后统计一下…</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a) != EOF)<br>        v.<span class="hljs-built_in">push_back</span>(a);<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> w = <span class="hljs-number">5000</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (w &gt;= v[i])<br>        &#123;<br>            w -= v[i];<br>            ++ans;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="停车场管理员"><a class="markdownIt-Anchor" href="#停车场管理员"></a> 停车场管理员</h2><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>你是一家购物中心的停车场管理员，需要安排各辆车的停车时段。每辆车的停车时段可以用一个时间数组来表示，数组中包括车辆进入和离开的时间 ，你的任务是确定购物中心所需的最小停车位数量。</p><p>e.g.</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<span class="hljs-number">0,30 5,10</span> <span class="hljs-number">15</span>,<span class="hljs-number">20</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>定义一个数组，用每个时间段对数组进行填充，统计数组的最大值即可，注意填充是要左闭右开。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">int</span> d[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; v;<br>    string s;<br>    <span class="hljs-type">int</span> a, b;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-built_in">getline</span>(cin, s);<br>    <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(s)</span></span>;<br>    <span class="hljs-keyword">while</span> (ss &gt;&gt; a &gt;&gt; c &gt;&gt; b)<br>        v.<span class="hljs-built_in">push_back</span>(&#123;a, b&#125;);<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (PII p : v)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p.first; i &lt; p.second; ++i)<br>        &#123;<br>            ++d[i];<br>            ans = <span class="hljs-built_in">max</span>(ans, d[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="服务器配对"><a class="markdownIt-Anchor" href="#服务器配对"></a> 服务器配对</h2><h3 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h3><p>在一个大型的数据中心，服务器是成对安置的，以便进行数据镜像和冗余备份。每对服务器由一对连续的整数表示，如第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。由于配置错误，服务器的配对顺序被打乱了。现在，需要通过网络中的虚拟交换，重新配置服务器，使得每对服务器可以重新成对工作。虚拟交换可以在任意两台服务器之间进行，而不管它们的位置如何。返回最少交换次数，以便每对服务器可以重新配对工作。<br />e.g.</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：1<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 0 </span>2 5<br>输出：2<br></code></pre></td></tr></table></figure><h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3><p>用一个数组pos来记录每个元素的位置，然后遍历数组，对于每个元素a，和他配对的元素是a^1，如1配对0，2配对3，3配对2。遍历时只用遍历偶数下标i的元素，如果i+1元素无法配对，那么交换i+1位置的元素和配对元素，同时交换他们在pos数组中的位置。</p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; a)<br>        v.<span class="hljs-built_in">push_back</span>(a);<br>    <span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pos</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        pos[v[i]] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> match = v[i] ^ <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (v[i + <span class="hljs-number">1</span>] != match)<br>        &#123;<br>            ++ans;<br>            <span class="hljs-built_in">swap</span>(v[i + <span class="hljs-number">1</span>], v[pos[match]]);<br>            <span class="hljs-built_in">swap</span>(pos[v[i + <span class="hljs-number">1</span>]], pos[v[pos[match]]]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈夫曼编码"><a class="markdownIt-Anchor" href="#哈夫曼编码"></a> 哈夫曼编码</h2><h3 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4"></a> 题目描述</h3><p>请以霍夫曼编码方式压缩《傲慢与偏见》，为了将编码文本写入文件（以&quot;wb&quot;二进制模式写入文件）。</p><h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3><p>用优先级队列模拟元素插入的过程，辅助建树，注意代码中文件读写的实现和建树过程。</p><h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-type">int</span> freq;<br>    Node *left, *right;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">char</span> c, <span class="hljs-type">int</span> f, Node *l = <span class="hljs-literal">nullptr</span>, Node *r = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">ch</span>(c), <span class="hljs-built_in">freq</span>(f), <span class="hljs-built_in">left</span>(l), <span class="hljs-built_in">right</span>(r) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 定义排序规则(小顶堆)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">compare</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Node *l, Node *r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> l-&gt;freq &gt; r-&gt;freq;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 递归获取哈夫曼编码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Node *root, string str, map&lt;<span class="hljs-type">char</span>, string&gt; &amp;huffmanCode)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)<br>        huffmanCode[root-&gt;ch] = str;<br>    <span class="hljs-built_in">encode</span>(root-&gt;left, str + <span class="hljs-string">&quot;0&quot;</span>, huffmanCode);<br>    <span class="hljs-built_in">encode</span>(root-&gt;right, str + <span class="hljs-string">&quot;1&quot;</span>, huffmanCode);<br>&#125;<br><br><span class="hljs-comment">// 哈夫曼编码压缩，返回平均编码长度</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">huffmanCompress</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;filename)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">file</span><span class="hljs-params">(filename, ios::in)</span></span>;<br>    map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; freq;<br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 统计出现频率</span><br>    <span class="hljs-keyword">while</span> (file.<span class="hljs-built_in">get</span>(ch))<br>    &#123;<br>        freq[ch]++;<br>        ++cnt;<br>    &#125;<br><br>    priority_queue&lt;Node *, vector&lt;Node *&gt;, compare&gt; pq;<br>    <span class="hljs-comment">// 初始化叶子节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : freq)<br>        pq.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(it.first, it.second));<br>    <span class="hljs-comment">// 构建哈夫曼树</span><br>    <span class="hljs-keyword">while</span> (pq.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>)<br>    &#123;<br>        Node *left = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        Node *right = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> sum = left-&gt;freq + right-&gt;freq;<br>        pq.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-string">&#x27;\0&#x27;</span>, sum, left, right));<br>    &#125;<br><br>    Node *root = pq.<span class="hljs-built_in">top</span>();<br>    map&lt;<span class="hljs-type">char</span>, string&gt; huffmanCode; <span class="hljs-comment">// 保存每个字符对应的哈夫曼编码</span><br>    <span class="hljs-built_in">encode</span>(root, <span class="hljs-string">&quot;&quot;</span>, huffmanCode);<br><br>    <span class="hljs-comment">// 计算平均编码长度</span><br>    <span class="hljs-type">double</span> avgLen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : huffmanCode)<br>        avgLen += it.second.<span class="hljs-built_in">size</span>() * freq[it.first];<br>    avgLen /= cnt;<br><br>    file.<span class="hljs-built_in">clear</span>();<br>    file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-function">ofstream <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-string">&quot;text.huff&quot;</span>, ios::out | ios::binary)</span></span>;<br>    <span class="hljs-comment">// 写入二进制文件</span><br>    <span class="hljs-type">char</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (file.<span class="hljs-built_in">get</span>(ch))<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : huffmanCode[ch])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                buffer |= (<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">7</span> - index));<br>            index++;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">8</span>)<br>            &#123;<br>                output &lt;&lt; buffer;<br>                index = <span class="hljs-number">0</span>;<br>                buffer = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    file.<span class="hljs-built_in">close</span>();<br>    output.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> avgLen;<br>&#125;<br><span class="hljs-comment">// 计算压缩比率</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getCompressRate</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;filename)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">file</span><span class="hljs-params">(filename, ios::in)</span></span>;<br>    file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::end);<br>    <span class="hljs-type">double</span> originSize = file.<span class="hljs-built_in">tellg</span>(); <span class="hljs-comment">// 返回文件字节数</span><br>    file.<span class="hljs-built_in">close</span>();<br>    file.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;text.huff&quot;</span>, ios::in);<br>    file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::end);<br>    <span class="hljs-type">double</span> compressSize = file.<span class="hljs-built_in">tellg</span>();<br>    file.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> compressSize / originSize;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">huffmanCompress</span>(<span class="hljs-string">&quot;Pride and Prejudice.txt&quot;</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Compress Rate: &quot;</span> &lt;&lt; <span class="hljs-built_in">getCompressRate</span>(<span class="hljs-string">&quot;Pride and Prejudice.txt&quot;</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文本左右对齐</title>
    <link href="/2023/11/13/%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90/"/>
    <url>/2023/11/13/%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90">文本左右对齐</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="文本左右对齐"><a class="markdownIt-Anchor" href="#文本左右对齐"></a> 文本左右对齐</h2><p><a href="https://leetcode.cn/problems/text-justification/description/?envType=study-plan-v2&amp;envId=top-interview-150">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</p><p>你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ’ ’ 填充，使得每行恰好有 maxWidth 个字符。</p><p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p><p>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</p><p>注意:</p><p>单词是指由非空格字符组成的字符序列。<br />每个单词的长度大于 0，小于等于 maxWidth。<br />输入单词数组 words 至少包含一个单词。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: words = [<span class="hljs-string">&quot;This&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;of&quot;</span>, <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-string">&quot;justification.&quot;</span>], maxWidth = <span class="hljs-number">16</span><br>输出:<br>[<br>   <span class="hljs-string">&quot;This    is    an&quot;</span>,<br>   <span class="hljs-string">&quot;example  of text&quot;</span>,<br>   <span class="hljs-string">&quot;justification.  &quot;</span><br>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题不涉及什么算法，主要考察字符串处理能力。可以按行来处理，首先记录要加入每行的单词有哪些，可以遍历单词，累加遍历过的单词长度，如果加入下一个单词后总长度大于maxWidth，或者下一个单词是最后一个单词，那么就将现有区间的所有单词生成一行并返回。</p><p>对于空格，我们可以先统计每行总的空格数量spnum，然后计算每个字符串后跟的基本空格数<code>base_space=(wordnum==1)? spnum:spnum/(wordnum-1)</code>，还需额外的空格数为<code>extra_space=(wordnum==1)? 0:spnum%(wordnum-1);</code>，每个单词后面补的空格数为<code>string(base_space+((i-start)&lt;extra_space),' ')</code>。在处理时要注意，如果是处理最后一行，则每个单词后面加一个空格就行，然后每行最后一个单词根据当前行的长度在后面补上对应数量的空格。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">getline</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end, <span class="hljs-type">int</span> width,<span class="hljs-type">bool</span> last)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> wordnum= end-start+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;=end;++i)<br>            sum+=words[i].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> spnum=width-sum;<br>        <span class="hljs-type">int</span> base_space=(wordnum==<span class="hljs-number">1</span>)? spnum:spnum/(wordnum<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> extra_space=(wordnum==<span class="hljs-number">1</span>)? <span class="hljs-number">0</span>:spnum%(wordnum<span class="hljs-number">-1</span>);<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;end;++i)<br>        &#123;<br>            res+=words[i];<br>            <span class="hljs-keyword">if</span>(last)<br>            &#123;<br>                res+=<span class="hljs-string">&#x27; &#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            res+=<span class="hljs-built_in">string</span>(base_space+((i-start)&lt;extra_space),<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>        res+=words[end];<br>        res+=<span class="hljs-built_in">string</span>(width-res.<span class="hljs-built_in">size</span>(),<span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">fullJustify</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> maxWidth)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=words.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            sum+=words[i].<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>==n||sum+words[i+<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()&gt;maxWidth)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">getline</span>(words,start,i,maxWidth,i+<span class="hljs-number">1</span>==n));<br>                start=i+<span class="hljs-number">1</span>;<br>                sum=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;      <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分发糖果</title>
    <link href="/2023/11/08/%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
    <url>/2023/11/08/%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C">分发糖果</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="分发糖果"><a class="markdownIt-Anchor" href="#分发糖果"></a> 分发糖果</h2><p><a href="https://leetcode.cn/problems/candy/description/?envType=study-plan-v2&amp;envId=top-interview-150">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br />相邻两个孩子评分更高的孩子会获得更多的糖果。<br />请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><p>e.g.</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：ratings </span>=<span class="hljs-string"> [1,0,2]</span><br><span class="hljs-string">输出：5</span><br><span class="hljs-string">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>可以分别从左右两边开始遍历，当满足顺序要求时，糖果数加1，当不满足时糖果数为1，然后统计每个人左右两种顺序下的最大值累加到答案中即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    <span class="hljs-built_in">int</span> candy(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; ratings) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>=ratings.size();<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">left</span>(<span class="hljs-built_in">n</span>);<br>        <span class="hljs-built_in">left</span>[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">n</span>;++i)<br>        &#123;<br>            <span class="hljs-built_in">if</span>(ratings[i]&gt;ratings[i-<span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">left</span>[i]=<span class="hljs-built_in">left</span>[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            else<br>                <span class="hljs-built_in">left</span>[i]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> r=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-built_in">if</span>(i+<span class="hljs-number">1</span>&lt;<span class="hljs-built_in">n</span>&amp;&amp;ratings[i]&gt;ratings[i+<span class="hljs-number">1</span>])<br>                ++r;<br>            else<br>                r=<span class="hljs-number">1</span>;<br>            res+=<span class="hljs-built_in">max</span>(r,<span class="hljs-built_in">left</span>[i]);            <br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加油站</title>
    <link href="/2023/11/06/%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <url>/2023/11/06/%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h2 id="加油站"><a class="markdownIt-Anchor" href="#加油站"></a> 加油站</h2><p><a href="https://leetcode.cn/problems/gas-station/description/?envType=study-plan-v2&amp;envId=top-interview-150">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i]升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则保证它是唯一的。</p><p>e.g.</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]<br>输出: 3<br>解释:<br>从<span class="hljs-number"> 3 </span>号加油站(索引为<span class="hljs-number"> 3 </span>处)出发，可获得<span class="hljs-number"> 4 </span>升汽油。此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 4 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 8 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 8 </span>-<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 7 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>升汽油<br>开往<span class="hljs-number"> 2 </span>号加油站，此时油箱有<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>升汽油<br>开往<span class="hljs-number"> 3 </span>号加油站，你需要消耗<span class="hljs-number"> 5 </span>升汽油，正好足够你返回到<span class="hljs-number"> 3 </span>号加油站。<br>因此，3 可为起始索引。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>首先根据题意，一次只能到达相邻的加油站，而且当总的gas小于总cost，则无论如何都不能绕行一周。因此我们可以遍历所有起点，用cos和rest分别保存某起点开始的剩余油量和总的剩余油量，当cos &lt; 0时，说明当前i位置无法到达i+1位置，因此把i+1设置为start起点，并把cos置为0，遍历完成之后，如果rest &lt; 0，说明总的gas小于总cost，返回-1，否则返回start。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>, cos=<span class="hljs-number">0</span>,rest=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;gas.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            cos+=gas[i]-cost[i];<br>            rest+=gas[i]-cost[i];<br>            <span class="hljs-keyword">if</span>(cos&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                start=i+<span class="hljs-number">1</span>;<br>                cos=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rest&lt;<span class="hljs-number">0</span>?<span class="hljs-number">-1</span>:start;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>矩阵链乘法</title>
    <link href="/2023/11/03/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/"/>
    <url>/2023/11/03/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵链乘法"><a class="markdownIt-Anchor" href="#矩阵链乘法"></a> 矩阵链乘法</h2><h3 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h3><p>矩阵乘法的计算复杂度与相乘顺序有关，可以通过适当的结合降低计算复杂度。<br />给你一系列的矩阵A1,A2,A3,…,An和一系列的整数P0,P1,P2…,Pn，每个矩阵 Ai 的规模为Pi-1 * Pi, 1 &lt;=i &lt; n。<br />现在，请你计算这些矩阵连乘所需要的最少的计算次数是多少？</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用d[i][j]表示相乘后矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的计算次数，对于i~j(1 &lt;=i &lt; j &lt; n)的矩阵，可以在中间找到第k个矩阵进行切割，此时所需计算次数为d[i][k]+d[k+1][j]+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>p</mi><mi>k</mi></msub><msub><mi>p</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">p_{i-1}p_{k}p_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，可以遍历i~j之间所有k，找到使计算次数最小的k。递推关系如下：</p><ul><li>若 i== j，d[i][j]==0</li><li>若i &lt; j, d[i][j]=din(d[i][k]+d[k+1][j]+p(i-1)p(k)p(j))， i &lt;= k &lt; j</li></ul><p>经过以上步骤，可以找出i～j个矩阵相乘的子问题的最优解，该子问题包含j-i+1个矩阵，因此矩阵链的长度为l=j-i+1，为了求出总体的最优解，还需要遍历所有子链的长度l(1~n)</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs prolog">void <span class="hljs-symbol">MATRIX_CHAIN_ORDER</span>(int *p,int <span class="hljs-symbol">Length</span>,int d[][<span class="hljs-symbol">M</span>],int s[][<span class="hljs-symbol">M</span>])<br>&#123;<br>    //d保存最少计算次数，s保存划分位置(跟踪矩阵)<br>int q,n=<span class="hljs-symbol">Length</span><span class="hljs-number">-1</span>;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++) d[i][i]=<span class="hljs-number">0</span>;<br>for(int l=<span class="hljs-number">2</span>;l&lt;=n;l++) <span class="hljs-comment">/* 矩阵链的长度 */</span><br>&#123;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n-l+<span class="hljs-number">1</span>;i++) <br>&#123;<br>int j=i+l<span class="hljs-number">-1</span>;         <span class="hljs-comment">/* 等价于 l=j-i+1 */</span><br>d[i][j]=<span class="hljs-symbol">INT_MAX</span>;<br>for(int k=i;k&lt;=j<span class="hljs-number">-1</span>;k++)<br>&#123;<br>q=d[i][k]+d[k+<span class="hljs-number">1</span>][j]+p[i<span class="hljs-number">-1</span>]*p[k]*p[j];<br>if(q&lt;d[i][j])<br>&#123;<br>d[i][j]=q;<br>s[i][j]=k;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法作业2</title>
    <link href="/2023/10/20/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A2/"/>
    <url>/2023/10/20/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%95%B0%E4%B8%80%E6%95%B0">数“一”数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2">最大矩形</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li><li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D">正则表达式匹配</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-2">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="数一数"><a class="markdownIt-Anchor" href="#数一数"></a> 数“一”数</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>编写一个函数，输入一个整数 n，返回一个长度为 n + 1 的数组，其中每个元素表示对应整数二进制中 “1” 的数量。</p><p>input:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[0, 1, 1, 2, 1, 2]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>可以用数组res保存每个数字的二进制表示的1的数量</p><ul><li>对于偶数<code>a</code>，他的二进制表示中1的数量和<code>a/2</code>相同</li><li>对于奇数<code>a</code>,他的二进制表示中1的数量比<code>a/2</code>多1</li></ul><p>因此有递推式：<code>res[i]=res[i&gt;&gt;1]+(i&amp;1)</code></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        res[i] = res[i &gt;&gt; <span class="hljs-number">1</span>] + i &amp; <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;[&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i != n)<br>            cout &lt;&lt; res[i] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; res[i];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;]&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最大矩形"><a class="markdownIt-Anchor" href="#最大矩形"></a> 最大矩形</h2><p><a href="https://leetcode.cn/problems/maximal-rectangle/description/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]<br>输出：<span class="hljs-number">6</span><br>解释：最大矩形如上图所示。<br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>这道题需要用到单调栈，在<a href="https://lqz2.github.io/2022/09/13/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a>中，通过单调栈，可以求得柱状图中的最大矩形。对于这道题，需要先把矩阵按每一行连续的1处理成柱状图，例如一行是<code>1 0 1 1 1</code>，处理后变成<code>1 0 1 2 3</code>。接下来，将每一列视为一个柱状图，这道题可以视为寻找所有列对应的柱状图中的最大子矩形，因此，需要遍历每列柱状图的最大子矩形，然后求得最大值后返回。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;</span><br><span class="hljs-class">public:</span><br><span class="hljs-class">    int maximalRectangle(<span class="hljs-title">vector</span>&lt;<span class="hljs-title">vector</span>&lt;<span class="hljs-title">char</span>&gt;&gt;&amp; <span class="hljs-title">matrix</span>) &#123;</span><br><span class="hljs-class">        int m=matrix.size(),n=matrix[0].size();</span><br><span class="hljs-class">        vector&lt;vector&lt;int&gt;&gt; a(<span class="hljs-title">m</span>,<span class="hljs-title">vector</span>&lt;<span class="hljs-title">int</span>&gt;(<span class="hljs-title">n</span>));</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                if(<span class="hljs-title">matrix</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>]==&#x27;1&#x27;)</span><br><span class="hljs-class">                    a[i][j]=(<span class="hljs-title">j</span>==0?0:<span class="hljs-title">a</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>-1])+1;</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        int res=0,area=0;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            vector&lt;int&gt; up(<span class="hljs-title">m</span>),down(<span class="hljs-title">m</span>);</span><br><span class="hljs-class">            stack&lt;int&gt; ust,dst;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                while(!<span class="hljs-title">ust</span>.<span class="hljs-title">empty</span>()&amp;&amp;a[ust.top()][j]&gt;=a[i][j])</span><br><span class="hljs-class">                    ust.pop();</span><br><span class="hljs-class">                up[i]=ust.empty()?-1:ust.top();</span><br><span class="hljs-class">                ust.push(<span class="hljs-title">i</span>);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=<span class="hljs-title">m</span>-1;<span class="hljs-title">i</span>&gt;=0;<span class="hljs-comment">--i)</span></span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                <span class="hljs-title">while</span>(!<span class="hljs-title">dst</span>.<span class="hljs-title">empty</span>()&amp;&amp;a[dst.top()][j]&gt;=a[i][j])</span><br><span class="hljs-class">                    dst.pop();</span><br><span class="hljs-class">                down[i]=dst.empty()?m:dst.top();</span><br><span class="hljs-class">                dst.push(<span class="hljs-title">i</span>);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                area=a[i][j]*(<span class="hljs-title">down</span>[<span class="hljs-title">i</span>]-<span class="hljs-title">up</span>[<span class="hljs-title">i</span>]-1);</span><br><span class="hljs-class">                res=max(<span class="hljs-title">res</span>,<span class="hljs-title">area</span>);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        return res;</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">&#125;;</span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure><h2 id="正则表达式匹配"><a class="markdownIt-Anchor" href="#正则表达式匹配"></a> 正则表达式匹配</h2><p><a href="https://leetcode.cn/problems/regular-expression-matching/">原题</a></p><h3 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><p>‘.’ 匹配任意单个字符<br />‘*’ 匹配零个或多个前面的那一个元素<br />所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p>e.g.</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;aa&quot;</span>, p = <span class="hljs-string">&quot;a*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-string">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。<br><br>输入：s = <span class="hljs-string">&quot;ab&quot;</span>, p = <span class="hljs-string">&quot;.*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="hljs-string">&#x27;*&#x27;</span>）任意字符（<span class="hljs-string">&#x27;.&#x27;</span>）。<br></code></pre></td></tr></table></figure><h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3><p>用到动态规划的思想。用dp[i][j]表示s中前i个字符和p中前j个字符是否匹配,接下来分情况讨论</p><ul><li>当s[i]和p[j]匹配时<code>(s[i-1]=p[j-1]或者p[j-1]=='.')</code>，<code>dp[i][j]=dp[i-1][j-1]</code></li><li>否则，如果p[j]当前字符p[j-1]==‘*’<ul><li>如果s[i]和p[j]的前一个字符匹配<code>(s[i-1]=p[j-2]或者p[j-2]=='.')</code>，此时可以匹配一个或多个s[i]，也可以不匹配s[i]，状态方程为<code>dp[i][j]=dp[i][j-2]||dp[i-1][j]</code></li><li>如果s[i]和p[j]的前一个字符不匹配，那么不匹配s[i]，<code>dp[i][j]=dp[i][j-2]</code></li></ul></li></ul><p>总的状态方程如下：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi></mrow><msup><mrow><mo fence="true">(</mo><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo></mrow><mo lspace="0em" rspace="0em">∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>s</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mrow><mtext> </mtext><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mtext> </mtext></mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>s</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f[i][j]=\begin{cases}\mathrm{if}\left(p[j]\neq\right.^{*})=\begin{cases}f[i-1][j-1],&amp;matches(s[i],p[j])\\\mathrm{false},&amp;\mathrm{otherwise}&amp;\end{cases}\\\mathrm{otherwise}=\begin{cases}f[i-1][j]\mathrm{~or~}f[i][j-2],&amp;matches(s[i],p[j-1])\\f[i][j-2],&amp;\mathrm{otherwise}&amp;\end{cases}\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:6.0000599999999995em;vertical-align:-2.7500299999999998em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2500200000000006em;"><span style="top:-1.2999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.2949899999999999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.58999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.8849900000000002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.17999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.2049900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.29501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.59001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.885010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.180010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.205010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.50002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2500299999999998em;"><span style="top:-5.25003em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mclose nulldelimiter"></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.828596em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">o</span><span class="mord mathrm">t</span><span class="mord mathrm">h</span><span class="mord mathrm">e</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="mord mathrm">i</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">o</span><span class="mord mathrm">t</span><span class="mord mathrm">h</span><span class="mord mathrm">e</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="mord mathrm">i</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord"><span class="mspace nobreak"> </span><span class="mord mathrm">o</span><span class="mord mathrm">r</span><span class="mspace nobreak"> </span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">o</span><span class="mord mathrm">t</span><span class="mord mathrm">h</span><span class="mord mathrm">e</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="mord mathrm">i</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7500299999999998em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs prolog">class <span class="hljs-symbol">Solution</span> &#123;<br>public:<br>    bool isMatch(string s, string p) &#123;<br>        int m = s.size();<br>        int n = p.size(); <br>        vector&lt;vector&lt;bool&gt;&gt; dp(m+<span class="hljs-number">1</span>,vector&lt;bool&gt;(n+<span class="hljs-number">1</span>,false));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = true;<br>        //初始化dp,匹配空串时,*可以消除前一个字符，因此状态与前前一个状态相等<br>        for(int j =<span class="hljs-number">2</span>;j &lt;=n ;j++)<br>        &#123;<br>            if(p[j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;*&#x27;</span>)<br>                dp[<span class="hljs-number">0</span>][j]=dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-2</span>];<br>        &#125;<br>        function&lt;bool(int,int)&gt; match=[&amp;](int i,int j)&#123;<br>            if(s[i<span class="hljs-number">-1</span>]==p[j<span class="hljs-number">-1</span>]||p[j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>                return true;<br>            return false;<br>        &#125;;<br>        for (int i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        &#123;<br>            for (int j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            &#123;<br>                //如果当前s[i]和p[j]匹配,则与上一个状态相等<br>                if (match(i,j))<br>                        dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]; <br>                else if (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)//如果当前p[j]为*<br>                &#123;<br>                    if(match(i,j<span class="hljs-number">-1</span>))//如果*前面的字符可以匹配s[i]<br>                        //匹配<span class="hljs-number">0</span>次：dp[i][j<span class="hljs-number">-2</span>],相当于删除*前面的字符<br>                        //匹配<span class="hljs-number">1</span>次或以上：dp[i<span class="hljs-number">-1</span>][j]<br>                        dp[i][j]=dp[i][j<span class="hljs-number">-2</span>]||dp[i<span class="hljs-number">-1</span>][j];<br>                    else//相当于匹配了<span class="hljs-number">0</span>次<br>                        dp[i][j]=dp[i][j<span class="hljs-number">-2</span>];<br>                &#125;      <br>            &#125;<br>        &#125;<br>        return dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>矩阵打印问题</title>
    <link href="/2023/10/19/%E7%9F%A9%E9%98%B5%E6%89%93%E5%8D%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/19/%E7%9F%A9%E9%98%B5%E6%89%93%E5%8D%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%9F%A9%E9%98%B5%E6%89%93%E5%8D%B0%E9%97%AE%E9%A2%98">矩阵打印问题</a><ul><li><a href="#%E4%B8%8A%E4%B8%89%E8%A7%92%E9%98%B5">上三角阵</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E4%B8%80">螺旋矩阵一</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li><li><a href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E4%BA%8C">螺旋矩阵二</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-2">代码</a></li></ul></li><li><a href="#z%E5%AD%97%E5%9E%8B%E8%9B%87%E5%9E%8B">Z字型(蛇型)</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-3">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-3">代码</a></li></ul></li></ul></li></ul><!-- /TOC --><h2 id="矩阵打印问题"><a class="markdownIt-Anchor" href="#矩阵打印问题"></a> 矩阵打印问题</h2><h3 id="上三角阵"><a class="markdownIt-Anchor" href="#上三角阵"></a> 上三角阵</h3><p><a href="https://www.nowcoder.com/practice/649b210ef44446e3b1cd1be6fa4cab5e?tpId=37&amp;tqId=21258&amp;ru=/exam/oj">原题</a></p><h4 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h4><p>输入描述：<br />输入正整数N（N不大于100）</p><p>输出描述：<br />输出一个N行的上三角矩阵</p><p>input</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><p>output</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">8</span><br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><p>根据题目描述，输出上三角阵只用考虑右上方向，因此每输出一个数就<code>--i,++j</code>，超出上边界(i&lt;0)时，将j置为0，然后更新i的起始点即可。</p><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>int a[101][101];<br>int main()<br>&#123;<br>    int n;<br>    cin&gt;&gt;n;<br>    int num=(n+1)*n/2;<br>    int <span class="hljs-attribute">cnt</span>=0,i=0,j=0,pre=0,k=1;<br>    <br>    <span class="hljs-keyword">while</span>(cnt&lt;num)<br>    &#123;<br>        a[i][j]=k++;<br>        ++cnt;<br>        --i;++j;<br>        <span class="hljs-keyword">if</span>(i&lt;0)<br>        &#123;<br>            <span class="hljs-attribute">j</span>=0;<br>            <span class="hljs-attribute">i</span>=pre+1;<br>            <span class="hljs-attribute">pre</span>=i;<br>        &#125;<br>    &#125;<br>    int <span class="hljs-attribute">nn</span>=n;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=0;j&lt;nn;++j)<br>            cout&lt;&lt;a[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        --nn;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="螺旋矩阵一"><a class="markdownIt-Anchor" href="#螺旋矩阵一"></a> 螺旋矩阵一</h3><p><a href="https://leetcode.cn/problems/spiral-matrix/description/">原题</a></p><h4 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h4><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[4,5,6]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br></code></pre></td></tr></table></figure><h4 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h4><p>这道题首先要设置上下左右四个边界，然后按照上，右，下，左，四个边界打印，每便利完一个边界判断一下边界有没有越界<br />例如</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(int i=l;i&lt;=r;++i)<br>    cout&lt;&lt;<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[u]</span><span class="hljs-selector-attr">[i]</span>;<br><span class="hljs-built_in">if</span>(++u&gt;d) break;<br></code></pre></td></tr></table></figure><h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; spiralOrder(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-keyword">matrix</span>) &#123;<br>        <span class="hljs-keyword">int</span> m=<span class="hljs-keyword">matrix</span>.<span class="hljs-keyword">size</span>(),n=<span class="hljs-keyword">matrix</span>[<span class="hljs-number">0</span>].<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>,u=<span class="hljs-number">0</span>,d=m<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span>(true)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;++i)<br>                ans.push_back(<span class="hljs-keyword">matrix</span>[u][i]);<br>            <span class="hljs-keyword">if</span>(++u&gt;d) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=u;i&lt;=d;++i)<br>                ans.push_back(<span class="hljs-keyword">matrix</span>[i][r]);<br>            <span class="hljs-keyword">if</span>(--r&lt;l) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=r;i&gt;=l;--i)<br>                ans.push_back(<span class="hljs-keyword">matrix</span>[d][i]);<br>            <span class="hljs-keyword">if</span>(--d&lt;u) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=d;i&gt;=u;--i)<br>                ans.push_back(<span class="hljs-keyword">matrix</span>[i][l]);<br>            <span class="hljs-keyword">if</span>(++l&gt;r) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="螺旋矩阵二"><a class="markdownIt-Anchor" href="#螺旋矩阵二"></a> 螺旋矩阵二</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-iii/description/">原题</a></p><h4 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h4><p>在 rows x cols 的网格上，你从单元格 (rStart, cStart) 面朝东面开始。网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p><p>你需要以顺时针按螺旋状行走，访问此网格中的每个位置。每当移动到网格的边界之外时，需要继续在网格之外行走（但稍后可能会返回到网格边界）。</p><p>最终，我们到过网格的所有 rows x cols 个空间。</p><p>按照访问顺序返回表示网格位置的坐标列表。<br />e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：rows = 5, cols = 6, rStart = 1, cStart = 4<br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[1,5]</span>,<span class="hljs-comment">[2,5]</span>,<span class="hljs-comment">[2,4]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[0,3]</span>,<span class="hljs-comment">[0,4]</span>,<span class="hljs-comment">[0,5]</span>,<span class="hljs-comment">[3,5]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[3,3]</span>,<span class="hljs-comment">[3,2]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[0,2]</span>,<span class="hljs-comment">[4,5]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[4,3]</span>,<span class="hljs-comment">[4,2]</span>,<span class="hljs-comment">[4,1]</span>,<span class="hljs-comment">[3,1]</span>,<span class="hljs-comment">[2,1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[4,0]</span>,<span class="hljs-comment">[3,0]</span>,<span class="hljs-comment">[2,0]</span>,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[0,0]</span>]</span><br></code></pre></td></tr></table></figure><h4 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h4><p>这道题实际上是从中心向四周遍历螺旋方阵，然后输出在矩阵内的数。<br />首先根据起始点的坐标，初始化上下左右四个边界(起始点周围第一层数)，并初始化方向为右(0,1,2,3四个方向)<br />接下来分情况讨论：</p><ul><li>如果方向向右且已经到达右边界，右边界+1，方向转为向下</li><li>如果方向向下且已经到达下边界，下边界+1，方向转为向左</li><li>如果方向向左且已经到达左边界，左边界-1，方向转为向上</li><li>如果方向向上且已经到达上边界，上边界-1，方向转为向右</li><li>根据当前方向更新坐标</li></ul><p>打印时只需要判断当前坐标在矩阵内即可打印</p><h4 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">spiralMatrixIII</span>(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> rStart, <span class="hljs-type">int</span> cStart) &#123;<br>        <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,di=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i=rStart,j=cStart,l=cStart<span class="hljs-number">-1</span>,r=cStart+<span class="hljs-number">1</span>,u=rStart<span class="hljs-number">-1</span>,d=rStart+<span class="hljs-number">1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">while</span>(cnt&lt;rows*cols)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;i&lt;rows&amp;&amp;j&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;cols)<br>            &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;i,j&#125;);<br>                ++cnt;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(di==<span class="hljs-number">0</span>&amp;&amp;j==r)<br>            &#123;<br>                di=(di+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;<br>                ++r;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(di==<span class="hljs-number">1</span>&amp;&amp;i==d)<br>            &#123;<br>                di=(di+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;<br>                ++d;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(di==<span class="hljs-number">2</span>&amp;&amp;j==l)<br>            &#123;<br>                di=(di+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;<br>                --l;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(di==<span class="hljs-number">3</span>&amp;&amp;i==u)<br>            &#123;<br>                di=(di+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;<br>                --u;<br>            &#125;<br>            i+=dir[di][<span class="hljs-number">0</span>];<br>            j+=dir[di][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="z字型蛇型"><a class="markdownIt-Anchor" href="#z字型蛇型"></a> Z字型(蛇型)</h3><p><a href="https://www.acwing.com/problem/content/description/3211/">原题</a></p><h4 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4"></a> 题目描述</h4><p>对于下面的 4×4的矩阵，</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>对其进行 Z字形扫描后得到长度为16的序列：1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3。<br />请实现一个Z字形扫描的程序，给定一个 n×n的矩阵，输出对这个矩阵进行 Z字形扫描的结果。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">9</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h4><p>一共有两种方向，右上或者左下，因此需要设置一个flag，当flag为true时表示右上，否则表示左下，初始化方向为右上。</p><ul><li>每当坐标i,j在矩阵范围内，就打印该位置的值</li><li>每打印一个值，根据方向更改坐标i,j的值</li><li>如果i&lt;0，i置为0，方向取反，如果j&lt;0，j置为0，方向取反。</li></ul><p>重复以上步骤，直到打印出所有元素</p><h4 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">501</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            cin&gt;&gt;a[i][j];<br>    &#125;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//true 右上，false左下</span><br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(cnt&lt;n*n)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;j&lt;n)<br>        &#123;<br>            cout&lt;&lt;a[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>            ++cnt;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag)<br>        &#123;<br>            --i;++j;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ++i;--j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            i=<span class="hljs-number">0</span>;<br>            flag=!flag;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            j=<span class="hljs-number">0</span>;<br>            flag=!flag;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动机器人</title>
    <link href="/2023/10/17/%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <url>/2023/10/17/%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="移动机器人"><a class="markdownIt-Anchor" href="#移动机器人"></a> 移动机器人</h2><p><a href="https://leetcode.cn/problems/movement-of-robots/?envType=daily-question&amp;envId=2023-10-10">原题</a></p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>有一些机器人分布在一条无限长的数轴上，他们初始坐标用一个下标从 0 开始的整数数组 nums 表示。当你给机器人下达命令时，它们以每秒钟一单位的速度开始移动。</p><p>给你一个字符串 s ，每个字符按顺序分别表示每个机器人移动的方向。‘L’ 表示机器人往左或者数轴的负方向移动，‘R’ 表示机器人往右或者数轴的正方向移动。</p><p>当两个机器人相撞时，它们开始沿着原本相反的方向移动。</p><p>请你返回指令重复执行 d 秒后，所有机器人之间两两距离之和。由于答案可能很大，请你将答案对 109 + 7 取余后返回。</p><p>注意：</p><p>对于坐标在 i 和 j 的两个机器人，(i,j) 和 (j,i) 视为相同的坐标对。也就是说，机器人视为无差别的。<br />当机器人相撞时，它们 立即改变 它们的前进方向，这个过程不消耗任何时间。<br />当两个机器人在同一时刻占据相同的位置时，就会相撞。</p><p>例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 2 并往左移动，下一秒，它们都将占据位置 1，并改变方向。再下一秒钟后，第一个机器人位于位置 0 并往左移动，而另一个机器人位于位置 2 并往右移动。</p><p>例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 1 并往左移动，下一秒，第一个机器人位于位置 0 并往左行驶，而另一个机器人位于位置 1 并往右移动。</p><p>e.g.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[1,0]</span>, s = <span class="hljs-string">&quot;RL&quot;</span>, d = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span><br>解释：<br><span class="hljs-number">1</span> 秒后，机器人的位置为 <span class="hljs-selector-attr">[2,-1]</span> 。<br><span class="hljs-number">2</span> 秒后，机器人的位置为 <span class="hljs-selector-attr">[3,-2]</span> 。<br>两个机器人的距离为 <span class="hljs-built_in">abs</span>(-<span class="hljs-number">2</span> - <span class="hljs-number">3</span>) = <span class="hljs-number">5</span> 。<br></code></pre></td></tr></table></figure><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>可以看作机器人相撞后穿透了对方，然后可以直接计算出每个机器人d秒后的位置pos[]，接下来计算两两之和。</p><p>对于第i个机器人，他的左边有i个机器人，右边有n-i个机器人，在计算左右两边的距离和时，<code>pos[i]-pos[i-1]</code>这段距离被计算了<code>i*(n-i)</code>次，因此将所有的距离累加即可。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumDistance</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, string s, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>        <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">pos</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;R&#x27;</span>)<br>                pos[i]=(ll)nums[i]+d;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;L&#x27;</span>)<br>                pos[i]=(ll)nums[i]-d;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(pos.<span class="hljs-built_in">begin</span>(),pos.<span class="hljs-built_in">end</span>());<br>        ll ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)<br>        &#123;<br>            ans+=(pos[i]-pos[i<span class="hljs-number">-1</span>])*i%mod*(n-i)%mod;<br>            ans%=mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最短且字典序最小的美丽字符串</title>
    <link href="/2023/10/16/%E6%9C%80%E7%9F%AD%E4%B8%94%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E7%BE%8E%E4%B8%BD%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/10/16/%E6%9C%80%E7%9F%AD%E4%B8%94%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E7%BE%8E%E4%B8%BD%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E7%9F%AD%E4%B8%94%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E7%BE%8E%E4%B8%BD%E5%AD%97%E7%AC%A6%E4%B8%B2">最短且字典序最小的美丽字符串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><strong>题目描述</strong></a></li><li><a href="#%E6%80%9D%E8%B7%AF"><strong>思路</strong></a></li><li><a href="#%E4%BB%A3%E7%A0%81"><strong>代码</strong></a></li></ul></li><li><a href="#%E6%89%BE%E5%87%BA%E6%BB%A1%E8%B6%B3%E5%B7%AE%E5%80%BC%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%B8%8B%E6%A0%87">找出满足差值条件的下标</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><strong>题目描述</strong></a></li><li><a href="#%E6%80%9D%E8%B7%AF-1"><strong>思路</strong></a></li></ul></li></ul><!-- /TOC --><h2 id="最短且字典序最小的美丽字符串"><a class="markdownIt-Anchor" href="#最短且字典序最小的美丽字符串"></a> 最短且字典序最小的美丽字符串</h2><p><a href="https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> <strong>题目描述</strong></h3><p>给你一个二进制字符串 s 和一个正整数 k 。</p><p>如果 s 的某个子字符串中 1 的个数恰好等于 k ，则称这个子字符串是一个 美丽子字符串 。</p><p>令 len 等于 最短 美丽子字符串的长度。</p><p>返回长度等于 len 且字典序 最小 的美丽子字符串。如果 s 中不含美丽子字符串，则返回一个 空 字符串。</p><p>对于相同长度的两个字符串 a 和 b ，如果在 a 和 b 出现不同的第一个位置上，a 中该位置上的字符严格大于 b 中的对应字符，则认为字符串 a 字典序 大于 字符串 b 。</p><p>例如，“abcd” 的字典序大于 “abcc” ，因为两个字符串出现不同的第一个位置对应第四个字符，而 d 大于 c 。</p><p>e.g.</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;1011&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">&quot;11&quot;</span><br>解释：示例中共有 <span class="hljs-number">3</span> 个美丽子字符串：<br><span class="hljs-number">1</span>. 子字符串 <span class="hljs-string">&quot;1011&quot;</span> 。<br><span class="hljs-number">2</span>. 子字符串 <span class="hljs-string">&quot;1011&quot;</span> 。<br><span class="hljs-number">3</span>. 子字符串 <span class="hljs-string">&quot;1011&quot;</span> 。<br>最短美丽子字符串的长度是 <span class="hljs-number">2</span> 。<br>长度为 <span class="hljs-number">2</span> 且字典序最小的美丽子字符串是子字符串 <span class="hljs-string">&quot;11&quot;</span> 。 <br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> <strong>思路</strong></h3><p>此题主要使用双指针加滑动窗口解决，定义两个指针<code>l,r</code>，然后用cnt统计<code>1</code>的个数，用r遍历字符串，如果当前元素是<code>1</code>那么<code>cnt++</code>，然后开始缩小窗口，当<code>cnt&gt;k||s[l]=='0'</code>时，<code>--l</code>，此时如果<code>cnt==k</code>，如果当前子串<code>l~r</code>之间的子串小于res的长度，或者长度相等字典序小于res，那么更新res为当前子串。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> <strong>代码</strong></h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    string shortestBeautifulSubstring(string s, int k) &#123;<br>        <span class="hljs-keyword">if</span>(count(s.begin(),s.end(),<span class="hljs-string">&#x27;1&#x27;</span>)&lt;k)<br>            return <span class="hljs-string">&quot;&quot;</span>;<br>        int <span class="hljs-attribute">n</span>=s.size();<br>        int <span class="hljs-attribute">l</span>=0,r=0;<br>        string <span class="hljs-attribute">res</span>=s;<br>        int <span class="hljs-attribute">cnt</span>=0;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-attribute">r</span>=0;r&lt;n;++r)<br>        &#123;   <br>            cnt+=s[r]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">while</span>(cnt&gt;k||s[l]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            &#123;<br>                <span class="hljs-attribute">cnt-</span>=s[l]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                ++l;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-attribute">cnt</span>==k)<br>            &#123;<br>                string <span class="hljs-attribute">t</span>=s.substr(l,r-l+1);<br>                <span class="hljs-keyword">if</span>(t.size()&lt;res.size()||t.size()==res.size()&amp;&amp;t&lt;res)<br>                    <span class="hljs-attribute">res</span>=t;<br>            &#125;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="找出满足差值条件的下标"><a class="markdownIt-Anchor" href="#找出满足差值条件的下标"></a> 找出满足差值条件的下标</h2><p><a href="https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/description/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> <strong>题目描述</strong></h3><p>给你一个下标从 0 开始、长度为 n 的整数数组 nums ，以及整数 indexDifference 和整数 valueDifference 。</p><p>你的任务是从范围 [0, n - 1] 内找出  2 个满足下述所有条件的下标 i 和 j ：</p><p>abs(i - j) &gt;= indexDifference 且<br />abs(nums[i] - nums[j]) &gt;= valueDifference<br />返回整数数组 answer。如果存在满足题目要求的两个下标，则 answer = [i, j] ；否则，answer = [-1, -1] 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。</p><p>注意：i 和 j 可能 相等，请实现O(n)时间复杂度的算法。</p><p>e.g.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[5,1,4,1]</span>, indexDifference = <span class="hljs-number">2</span>, valueDifference = <span class="hljs-number">4</span><br>输出：<span class="hljs-selector-attr">[0,3]</span><br>解释：在示例中，可以选择 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span> 和 j = <span class="hljs-number">3</span> 。<br><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-number">0</span> - <span class="hljs-number">3</span>)</span></span> &gt;= <span class="hljs-number">2</span> 且 <span class="hljs-built_in">abs</span>(nums<span class="hljs-selector-attr">[0]</span> - nums<span class="hljs-selector-attr">[3]</span>) &gt;= <span class="hljs-number">4</span> 。<br>因此，<span class="hljs-selector-attr">[0,3]</span> 是一个符合题目要求的答案。<br><span class="hljs-selector-attr">[3,0]</span> 也是符合题目要求的答案。<br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> <strong>思路</strong></h3><p>这道题要求用O(n)时间复杂度实现，自己没有想到，参考大佬的解法恍然大悟。<br />可以记录<strong>之前的间隔index_gap的元素中最大值和最小值下标</strong>，然后与当前值nums[j]对比如果<code>max-nums[j]&gt;=valueDifference</code>或者<code>nums[j]-min&gt;=valueDifference</code>，那么即可返回对应的最大/最小值下标和当前下标j<br /><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findIndices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> indexDifference, <span class="hljs-type">int</span> valueDifference)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> mx_idx=<span class="hljs-number">0</span>,mn_idx=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=indexDifference;j&lt;n;++j)<br>        &#123;<br>            i=j-indexDifference;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;nums[mx_idx])<br>                mx_idx=i;<br>            <span class="hljs-keyword">if</span>(nums[i]&lt;nums[mn_idx])<br>                mn_idx=i;<br>            <span class="hljs-keyword">if</span>(nums[mx_idx]-nums[j]&gt;=valueDifference)<br>                <span class="hljs-keyword">return</span> &#123;mx_idx,j&#125;;<br>            <span class="hljs-keyword">if</span>(nums[j]-nums[mn_idx]&gt;=valueDifference)<br>                <span class="hljs-keyword">return</span> &#123;mn_idx,j&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法作业1</title>
    <link href="/2023/09/25/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A1/"/>
    <url>/2023/09/25/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A1/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%85%83%E7%B4%A0">出现最多的元素</a></li><li><a href="#%E5%AF%84%E5%8C%85%E8%A3%B9">寄包裹</a></li><li><a href="#%E7%BF%BB%E8%BD%AC%E5%AF%B9">翻转对</a></li></ul><!-- /TOC --><h2 id="出现最多的元素"><a class="markdownIt-Anchor" href="#出现最多的元素"></a> 出现最多的元素</h2><p><strong>题目描述</strong><br />提供一个包含 n 个元素的数组，要求返回其中出现次数大于半数（大于 ⌊n/2⌋）的元素。假设数组中一定存在这样的元素。</p><p>Input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p><strong>思路</strong><br />这道题要求找出现次数大于半数的数，例如数组有<code>n</code>个数，那么就返回唯一的出现次数大于<code>n/2</code>的数，也就是出现次数最多的数。</p><p>首先想到的思路是用哈系表记录每个出现次数，然后遍历找到出现次数最多的数。</p><p>这里还可以用投票法，因为由题目已知这里的出现次数最多的数，它所出现的次数是大于<code>n/2</code>的，也就是说其他数的出现次数之和也小于它的出现次数。因此，可以维护两个变量cnt和candidate(初始都为0)，然后遍历数组，当cnt为0时更新candidate，然后如果<code>num==candidate</code>，则cnt加1，否则减1。这样，最后的candidate即出现最多的数。由于这道题输出是唯一的(出现次数大于<code>n/2</code>)，所以可以用投票法解决。</p><p>代码(附哈系表解法)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a) != EOF)<br>        v.<span class="hljs-built_in">push_back</span>(a);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, cand = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : v)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>)<br>            cand = c;<br>        cnt += c == cand ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>    &#125;<br>    cout &lt;&lt; cand &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> cand;<br>&#125;<br><span class="hljs-comment">// int main()</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//     vector&lt;int&gt; v;</span><br><span class="hljs-comment">//     int a;</span><br><span class="hljs-comment">//     while (scanf(&quot;%d&quot;, &amp;a) != EOF)</span><br><span class="hljs-comment">//         v.push_back(a);</span><br><span class="hljs-comment">//     int n = v.size();</span><br><span class="hljs-comment">//     unordered_map&lt;int, int&gt; m;</span><br><span class="hljs-comment">//     for (int i = 0; i &lt; n; i++)</span><br><span class="hljs-comment">//         ++m[v[i]];</span><br><br><span class="hljs-comment">//     int max = 0, res = 0;</span><br><br><span class="hljs-comment">//     for (auto it = m.begin(); it != m.end(); it++)</span><br><span class="hljs-comment">//     &#123;</span><br><span class="hljs-comment">//         if (it-&gt;second &gt; max)</span><br><span class="hljs-comment">//         &#123;</span><br><span class="hljs-comment">//             max = it-&gt;second;</span><br><span class="hljs-comment">//             res = it-&gt;first;</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//     cout &lt;&lt; res;</span><br><span class="hljs-comment">//     return res;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h2 id="寄包裹"><a class="markdownIt-Anchor" href="#寄包裹"></a> 寄包裹</h2><p><strong>题目描述</strong><br />现在有 n 个不同的包裹，需要寄给 n 个不同的地址，请编程求出每个包裹都送错地址的情况共有多少种。</p><p>Input:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">44<br></code></pre></td></tr></table></figure><p><strong>思路</strong><br />这道题属于错排问题，关于错排问题，有公式$D(n)=(n-1)(D(n-1)+D(n-2)) $，参考<a href="https://zhuanlan.zhihu.com/p/466098489">这里</a></p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// int f(int a)</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//     if (a == 1)</span><br><span class="hljs-comment">//         return 0;</span><br><span class="hljs-comment">//     else if (a == 2)</span><br><span class="hljs-comment">//         return 1;</span><br><span class="hljs-comment">//     else</span><br><span class="hljs-comment">//         return (a - 1) * (f(a - 1) + f(a - 2));</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; ++i)<br>        dp[i] = (i - <span class="hljs-number">1</span>) * (dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]);<br>    cout &lt;&lt; dp[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="翻转对"><a class="markdownIt-Anchor" href="#翻转对"></a> 翻转对</h2><p><strong>题目描述</strong><br />现在有 n 个不同的包裹，需要寄给 n 个不同的地址，请编程求出每个包裹都送错地址的情况共有多少种。<br />给定一个数组nums，如果 i &lt; j 且 nums[i] &gt; 3*nums[j] 我们就将 (i, j) 称作一个重要翻转对。</p><p>你需要返回给定数组中的重要翻转对的数量。</p><p><strong>思路</strong><br />这道题是求逆序对数的小变形，求逆序对的主要思想是归并排序，对于已经有序的区间<code>[l,mid]</code>和<code>[mid+1,r]</code>，当<code>nums[i]&gt;3*nums[j]</code>，说明<code>[i,mid]</code>区间的元素都大于<code>3*nums[j]</code>，因此逆序对数增加<code>mid-i+1</code>，其余部分进行归并排序即可。</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> cnt;<br>vector&lt;<span class="hljs-type">int</span>&gt; num;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> nl = mid - l + <span class="hljs-number">1</span>, nr = r - mid;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">al</span><span class="hljs-params">(nl)</span>, <span class="hljs-title">ar</span><span class="hljs-params">(nr)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nl; ++i)<br>        al[i] = num[l + i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nr; ++i)<br>        ar[i] = num[mid + <span class="hljs-number">1</span> + i];<br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (num[i] &gt; <span class="hljs-number">3</span> * num[j])<br>        &#123;<br>            cnt += mid - i + <span class="hljs-number">1</span>;<br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            ++i;<br>    &#125;<br>    i = <span class="hljs-number">0</span>;<br>    j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; nl &amp;&amp; j &lt; nr)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (al[i] &lt;= ar[j])<br>            num[l++] = al[i++];<br>        <span class="hljs-keyword">else</span><br>            num[l++] = ar[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt; nl)<br>        num[l++] = al[i++];<br>    <span class="hljs-keyword">while</span> (j &lt; nr)<br>        num[l++] = ar[j++];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">mergesort</span>(l, mid);<br>        <span class="hljs-built_in">mergesort</span>(mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">merge</span>(l, mid, r);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a) != EOF)<br>        num.<span class="hljs-built_in">push_back</span>(a);<br>    <span class="hljs-type">int</span> n = num.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">mergesort</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>相关问题及解决方法</title>
    <link href="/2023/08/11/%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2023/08/11/%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0rainbowrainbowrainbow">遇到的一些问题和解决方法（持续更新！）🌈🌈🌈</a><ul><li><a href="#%E7%AC%AC1%E5%91%A8rainbow">第1周🌈</a></li><li><a href="#%E7%AC%AC2%E5%91%A8rainbow">第2周🌈</a></li><li><a href="#%E7%AC%AC3%E5%91%A8rainbow">第3周🌈</a></li><li><a href="#%E7%AC%AC4%E5%91%A8rainbow">第4周🌈</a></li><li><a href="#%E7%AC%AC5%E5%91%A8rainbow">第5周🌈</a></li></ul></li></ul><!-- /TOC --><h2 id="遇到的一些问题和解决方法持续更新"><a class="markdownIt-Anchor" href="#遇到的一些问题和解决方法持续更新"></a> 遇到的一些问题和解决方法（持续更新！）🌈🌈🌈</h2><h3 id="第1周"><a class="markdownIt-Anchor" href="#第1周"></a> 第1周🌈</h3><ol><li>windows环境下安装pycocotools报错：ERROR: Could not build wheels for pycocotools, which is required to install pyproject.toml-based projects，解决方法：<a href="https://blog.csdn.net/weixin_45775136/article/details/130248372?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=ERROR:%20Could%20not%20build%20wheels%20&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-130248372.nonecase&amp;spm=1018.2226.3001.4187">1</a></li><li>windows环境下安装mmcv库报错：ERROR:Could not build wheels for mmcv, which is required to install pyproject.toml-based projects，解决方法：先pip install openmim，然后mim install mmcv</li><li>训练时出现OSError: [WinError 1455] 页面文件太小,无法完成操作，原因是dataloader的num_worker设置的太大，CPU线程不支持，解决方法：num_worker设置小一些即可</li><li>TarDAL代码中，检测部分yolov5s网络输出的结果shape不一致，解决办法：调试之后发现yolov5源码中会根据当前模式(train or eval)选择输出</li><li>MetaFusion论文并未提供详细代码，只提供了测试代码，因此无法得知网络具体的训练策略以及损失计算的详细过程。</li><li>训练TarDAL时，自己训练的子模型无法加载到下一个子模型中，而论文提供的预训练模型却可以。解决方法：该篇论文提供的源码存在诸多问题，经过多番调试发现，自己训练的模型无法加载的原因是因为判别器模型linear层参数的size与当前判别器模型对应层参数size不匹配，而提供的预训练权重可以正常加载的原因是预训练权重只包含了生成器的权重，因此代码在加载预训练权重时没有加载判别器权重。进一步调试后发现，linear层参数size不匹配的原因是不同子模型训练时输入图片的大小不一致，导致后续子模型无法加载权重。</li><li>训练时梯度回传时出现nan。解决方法：先检查数据有没有问题，没有问题则尝试将对应的学习率调低。</li></ol><h3 id="第2周"><a class="markdownIt-Anchor" href="#第2周"></a> 第2周🌈</h3><ol><li>执行sh脚本文件时出现找不到目录。解决方法：windows默认换行符是\r\n，linux下是\n，我在windows环境下使用vscode连接远程服务器时，使用的换行符依旧是\r\n，所以在执行cd时找不到目录，这时可以使用dos2unix命令来转换脚本文件。</li><li>OSError: cannot write mode F as PNG。解决方法：这里的 mode F 意思是图像中浮点类型的像素值，原因是代码中的 img 数组是 float 类型的，而图像中每个像素的值应该是 0-255(uint8 类型)。使用astype(np.uint8)转换数据类型即可。</li><li>使用wandb时出错，wandb: ERROR Internal wandb error: file data was not synced。解决方法：该错误与protobuf库有关，卸载后重新安装即可解决。</li><li>detfusion在使用bash compile.sh编译mmdet时报错。解决方法：原因是因为python. cuda. pytorch版本过高导致的，安装python3.7. 切换cuda版本安装pytorch低版本1.3.1后解决。</li><li>尝试运行detfusion时出现ModuleNotFoundError: No module named ‘DOTA_devkit’。解决方法：安装swig，然后git下DOTA_devkit远程仓库，然后编译c++扩展。具体参考：(<a href="https://zhuanlan.zhihu.com/p/355862906">https://zhuanlan.zhihu.com/p/355862906</a>)</li><li>运行时报错ImportError: urllib3 v2.0 only supports OpenSSL 1.1.1+, currently the ‘ssl’ module is compiled with 'OpenSSL 1.0.2u。解决方法：urllib版本过高导致，安装对应版本的urllib即可。</li><li>使用faster rcnn对detfusion的融合结果进行检测时，边界框回归损失出现nan。解决方法：起初认为是学习率过高导致，后来降低学习率无果后，怀疑是作者给的annotations存在问题，编写简单脚本进行检查后发现，有5张图片的gt存在问题，具体问题是xmin==xmax导致边界框回归计算出错，将出错的gt删除即可。</li><li>部署模型时出现timm.layers未找到，timm更新后路径改变导致。解决方法：改为timm.models.layers</li><li>使用lyngor编译模型时出现AttributeError: module ‘torch’ has no attribute ‘get_autocast_gpu_dtype’。解决方法：这是因为pytorch版本过低导致，可以升级pytorch或者手动更改代码中的dtype，我通过本地高版本pytorch打印出该函数返回值，然后手动改为torch.half和torch.bfloat16</li><li>AttributeError: ‘str’ object has no attribute ‘fromat’，解决方法：改成f-string形式。</li><li>ValueError: only one element tensors can be converted to Python scalars，解决方法：<a href="https://blog.csdn.net/Vertira/article/details/127814093?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169372428616800225573433%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169372428616800225573433&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-2-127814093-null-null.142%5Ev93%5Econtrol&amp;utm_term=ValueError%3A%20only%20one%20element%20tensors%20can%20be%20converted%20to%20Python%20scalars&amp;spm=1018.2226.3001.4187">1</a></li></ol><h3 id="第3周"><a class="markdownIt-Anchor" href="#第3周"></a> 第3周🌈</h3><ol><li>python导入另一个文件夹下的包时提示找不到模块，如/a/aa.py的aa.py文件需要导入/b/bb.py文件，aa.py文件提示找不到bb模块。解决方法：需要在/b/文件夹下创建__init__.py，然后再aa.py中加入import sys,sys.path.append(‘…’)，将上级目录添加到工作路径中。</li><li>ImportError: attempted relative import with no known parent package。解决方法：这个错误通常是由于相对导入的模块没有正确的父级包导致的，使用绝对导入即可解决。</li><li>使用thop计算模型参数量时出现RuntimeError: module must have its parameters and buffers on device cuda:0 (device_ids[0]) but found one of them on device: cpu。解决方法：原因是nn.DataParallel()导致部分模型没有在同一张GPU上，使用单卡计算参数量和计算量即可。</li><li>在改动CDDFuse代码时，使用params_group为不同参数设置学习率后，出现梯度为0，loss不变的情况。解决方法：经过排查是学习率太大导致，降低学习率即可。</li><li>在使用FFT计算频谱的时候，使用torch.fft.ifftn将频谱逆变换回来，然后保存为图像时报错。解决办法：图像的数据需要转换为np.uint8类型，所以逆变换后需要将数据转换成np.uint8才能正常保存。</li><li>将频域信息输入到卷积层时报错。解决方法：nn.Linear，nn.Conv2d等默认输入数据类型是torch.float32，频域数据是复数，所以需要将dtype改成torch.complex64即可解决。</li><li>使用切片操作得到预测的滤波器时报错：RuntimeError: “div_floor_cuda” not implemented for ‘ComplexFloat’。解决方法：该错误和数据类型有关，需要使用torch.abs将数据类型为torch.complex的数据转换一下。</li></ol><h3 id="第4周"><a class="markdownIt-Anchor" href="#第4周"></a> 第4周🌈</h3><ol><li>自己搭建的融合网络进行推理测试时报错：IndexError: invalid index of a 0-dim tensor. Use <code>tensor.item()</code> in Python or <code>tensor.item&lt;T&gt;()</code> in C++ to convert a 0-dim tensor to a number。解决方法：因为在推理时，batchsize为1，所以计算时出现了维度错误，将相应的和batch有关的计算进行更改即可。</li><li>将ycbcr进行拼接转为rgb图像时，图像显示时色彩异常。解决方法：出现此情况的原因时读取ycbcr图像时，先分别读取出y，cbcr，然后在分别进行归一化，因为rgb2ycbcr的过程中涉及其他计算，所以应当先对整张图像归一化，再分别读取出y，cbcr。</li><li>推理时报错TypeError: conv2d() received an invalid combination of arguments - got (tuple, Parameter, NoneType, tuple, tuple, tuple, int), but expected one of: * (Tensor input, Tensor weight, Tensor bias, tuple of ints stride, tuple of ints padding, tuple of ints dilation, int groups)didn’t match because some of the arguments have invalid types: (tuple of (Tensor, Tensor), Parameter, NoneType, tuple of (int, int), tuple of (int, int), tuple of (int, int), int)。解决方法：原因是输入模型的数据有误，误把某个tuple类型的数据输入到一个本该为tensor的数据中。</li></ol><h3 id="第5周"><a class="markdownIt-Anchor" href="#第5周"></a> 第5周🌈</h3><ol><li>使用git push出现<br />error: 对象文件 .git/objects/f2/22d3b7ccb69f6a75af88129fa8ebc652a6d349 为空<br />error: 对象文件 .git/objects/f2/22d3b7ccb69f6a75af88129fa8ebc652a6d349 为空<br />fatal: 松散对象 f222d3b7ccb69f6a75af88129fa8ebc652a6d349（保存在 .git/objects/f2/22d3b7ccb69f6a75af88129fa8ebc652a6d349）已损坏<br />解决方法：是因为虚拟机强制退出引起的，按照网上的方法要find .git/objects/ -size 0 -exec rm -f {} ;<br />git fetch origin，但没有解决，应该将备份分支的.git文件夹复制到主目录，部署分支的.git放在.deploy_git</li><li>error: 源引用规格 main 没有匹配，解决方法，本地分支与远程分支名称不匹配，指定推送的远程分支名称即可。</li><li>vscode终端运行c++文件输出中文乱码，解决方法：原因是vscode文件编码为utf8而终端编码为gbk，因此需要把终端编码改为utf8，对于powershell，需要按ctrl+,然后在命令行后面加powershell.exe -NoExit chcp 65001，对于cmd，需要在注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor新建字符串值，然后输入chcp 65001。或者在代码中，包含#include &lt;windows.h&gt;，然后在输出前加一行SetConsoleOutputCP(CP_UTF8);这样就可以正常输出中文了。</li></ol>]]></content>
    
    
    <categories>
      
      <category>资料</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>参考资料合集</title>
    <link href="/2023/08/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E5%90%88%E9%9B%86/"/>
    <url>/2023/08/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B8%80%E4%BA%9B%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0rainbowrainbowrainbow">一些有价值的参考资料（持续更新!）🌈🌈🌈</a><ul><li><a href="#%E7%AC%AC1%E5%91%A8rainbow">第1周🌈</a></li><li><a href="#%E7%AC%AC2%E5%91%A8rainbow">第2周🌈</a></li><li><a href="#%E7%AC%AC3%E5%91%A8rainbow">第3周🌈</a></li><li><a href="#%E7%AC%AC4%E5%91%A8rainbow">第4周🌈</a></li><li><a href="#%E7%AC%AC5%E5%91%A8rainbow">第5周🌈</a></li><li><a href="#%E7%AC%AC6%E5%91%A8rainbow">第6周🌈</a></li><li><a href="#%E7%AC%AC7%E5%91%A8rainbow">第7周🌈</a></li></ul></li></ul><!-- /TOC --><h2 id="一些有价值的参考资料持续更新"><a class="markdownIt-Anchor" href="#一些有价值的参考资料持续更新"></a> 一些有价值的参考资料（持续更新!）🌈🌈🌈</h2><h3 id="第1周"><a class="markdownIt-Anchor" href="#第1周"></a> 第1周🌈</h3><ol><li>了解了在线深度学习可视化辅助工具wandb</li><li>关于结构性相似度（SSIM）的论文，《Image quality assessment: from error visibility to structural similarity》</li><li>在TarDAL中使用显著性检测从红外图像中生成mask的网络，《R3Net: Recurrent Residual Refinement Network for Saliency Detection》</li><li>GAN网络中为什么判别器训练的越好，生成器梯度消失越严重，参考<a href="https://blog.csdn.net/qq_42693593/article/details/127365516?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169372361316800182792093%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169372361316800182792093&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127365516-null-null.142%5Ev93%5Econtrol&amp;utm_term=%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%A4%E5%88%AB%E5%99%A8%E8%AE%AD%E7%BB%83%E7%9A%84%E8%B6%8A%E5%A5%BD%EF%BC%8C%E7%94%9F%E6%88%90%E5%99%A8%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E8%B6%8A%E4%B8%A5%E9%87%8D&amp;spm=1018.2226.3001.4187">1</a></li><li>在TarDAL论文中，判别器损失函数使用了WGAN-div损失函数，即引入了Wasserstein散度，具体参考(<a href="https://zhuanlan.zhihu.com/p/25071913">https://zhuanlan.zhihu.com/p/25071913</a>)，<a href="https://blog.csdn.net/qq_39237205/article/details/123718856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169372388816800182120614%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169372388816800182120614&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-123718856-null-null.142%5Ev93%5Econtrol&amp;utm_term=wgan-div&amp;spm=1018.2226.3001.4187">1</a>，总的来说WGAN可以帮助GAN网络的训练变的更加稳定。</li><li>关于图像融合评价指标的计算：<a href="https://blog.csdn.net/fovever_/article/details/129332278?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169372348316800188584429%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169372348316800188584429&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129332278-null-null.142%5Ev93%5Econtrol&amp;utm_term=%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87python&amp;spm=1018.2226.3001.4187">1</a></li></ol><h3 id="第2周"><a class="markdownIt-Anchor" href="#第2周"></a> 第2周🌈</h3><ol><li>linux下通过软连接切换cuda版本，首先 ls /usr/local | grep cuda查看已安装的cuda版本，然后sudo ln -snf /usr/local/cuda-10.0 /usr/local/cuda建立软连接即可，-s表示创建软连接，-n表示软连接已存在则删除，-f表示强制覆盖，具体可参考<a href="https://blog.csdn.net/fxmtb/article/details/130573696?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169371218816800213030057%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169371218816800213030057&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130573696-null-null.142%5Ev93%5Econtrol&amp;utm_term=linux%E4%B8%8B%E5%88%87%E6%8D%A2cuda%E7%89%88%E6%9C%AC%E8%BD%AF%E8%BF%9E%E6%8E%A5&amp;spm=1018.2226.3001.4187">1</a>，如果没有root权限，可通过修改~/.bashrc文件的方法切换，具体参考<a href="https://blog.csdn.net/Marquis_Z/article/details/129683777?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169371196516800211516194%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169371196516800211516194&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-129683777-null-null.142%5Ev93%5Econtrol&amp;utm_term=linux%E4%B8%8B%E5%88%87%E6%8D%A2cuda%E7%89%88%E6%9C%AC&amp;spm=1018.2226.3001.4187">2</a>,<a href="https://blog.csdn.net/deersonglzx/article/details/132103228?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169371204116800188517144%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169371204116800188517144&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-1-132103228-null-null.142%5Ev93%5Econtrol&amp;utm_term=linux%E4%B8%8B%E5%88%87%E6%8D%A2cuda%E7%89%88%E6%9C%AC&amp;spm=1018.2226.3001.4187">3</a></li><li>vscode远程调试中文件路径无法找到时，可以将launch.json中pargram设置为运行文件，cwd设置为运行目录，这样即可正常调试。</li><li>调试过程查看梯度：在vscode调试时，尝试在调试控制台查看模型的梯度，但是只能在变量中看到nn.module.parameters()函数，要具体查看参数需要通过代码将梯度打印出来，如for name, param in self.detect.net.named_parameters(): print(name, param.grad)，经过调试得出，在优化器更新参数时，只有模型的loss经过backward()回传才会计算梯度，比如gloss=a * floss+b * dloss，如果a=0，那么gloss.backward()后，会计算模型d梯度而不会计算模型f的梯度。</li><li>pytorch中permute函数和view()/reshape()函数的区别，前者是在维度上互换或者重新排列，后者相当于将所有元素重新取出再排列。详细参考<a href="https://blog.csdn.net/Dust_Evc/article/details/128565263?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=permute%E5%92%8Cview/reshape%E5%8C%BA%E5%88%AB&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128565263.142%5Ev93%5Econtrol&amp;spm=1018.2226.3001.4187">1</a>,<a href="https://blog.csdn.net/ODIMAYA/article/details/123898732?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169371133116800226577302%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169371133116800226577302&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-11-123898732-null-null.142%5Ev93%5Econtrol&amp;utm_term=permute%E5%92%8Cview%2Freshape%E5%8C%BA%E5%88%AB&amp;spm=1018.2226.3001.4187">2</a>，同时torch.nn.Flatten与torch.flatten也有点小区别，即前者默认从维度1开始，后者默认从维度0开始。</li><li>einops库中的矩阵操作与einsum矩阵乘法，参考：<a href="https://blog.csdn.net/a486259/article/details/126966772?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169370823316800182774809%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169370823316800182774809&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-126966772-null-null.142%5Ev93%5Econtrol&amp;utm_term=einops%E4%B8%8Eeinsum&amp;spm=1018.2226.3001.4187">1</a></li><li>关于dataloader中的collate_fn函数，他的作用是手动调整1个batch中的数据的组织方式，其传入参数为batch(1个大小为batchsize的list)，具体参考<a href="https://blog.csdn.net/dong_liuqi/article/details/114521240">1</a>，如果__getitem__函数中出现标签为空的情况，可以通过collate_fn进行改动，参考<a href="https://blog.csdn.net/guyuealian/article/details/91129367###">2</a></li><li>pytorch中torchvision.transform.Resize()和torch.nn.functions.interpolate的区别：前者是基于插值实现的，用于调整图像的大小，后者常用于对特征图进行上采样等操作。更多关于图像预处理的方法，参考torchvision官方文档(<a href="https://pytorch.org/vision/0.15/transforms.html#transforms-scriptability">https://pytorch.org/vision/0.15/transforms.html#transforms-scriptability</a>)</li><li>IEEE Conference latex模板使用注意事项，参考<a href="https://blog.csdn.net/Hsin96/article/details/121133441">1</a>，latex列表的使用，参考<a href="https://blog.csdn.net/xovee/article/details/106365532?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169372332716800188537784%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169372332716800188537784&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-106365532-null-null.142%5Ev93%5Econtrol&amp;utm_term=latex%E5%88%97%E8%A1%A8&amp;spm=1018.2226.3001.4187">2</a></li><li>ppt绘图后使用vba宏1键导出为pdf并裁剪，参考<a href="https://blog.csdn.net/leida_wt/article/details/114326133?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169372340516800180676210%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169372340516800180676210&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-114326133-null-null.142%5Ev93%5Econtrol&amp;utm_term=ppt%E4%BD%BF%E7%94%A8vba%E5%AF%BC%E5%87%BApdf&amp;spm=1018.2226.3001.4187">1</a>，这里vba代码中使用pdfcrop在我的电脑中失效，可以shell代码改为Shell &quot;pdfcrop &quot; &amp; strNotes &amp; sExt &amp; &quot; &quot; &amp; strNotes &amp; sExt，然后在前面加上ChDir sPath更改工作路径，或者手动使用pdfcrop进行pdf裁剪</li><li>科研作图和表格参考：(<a href="https://zhuanlan.zhihu.com/p/603088040">https://zhuanlan.zhihu.com/p/603088040</a>)</li><li>统计模型参数量和计算量，参考<a href="https://blog.csdn.net/qq_43426908/article/details/130338449?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169370415016800182723428%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169370415016800182723428&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-4-130338449-null-null.142%5Ev93%5Econtrol&amp;utm_term=torchstat&amp;spm=1018.2226.3001.4187">1</a></li><li>etc.，et al.，i.e.，e.g.的区别，参考(<a href="https://zhuanlan.zhihu.com/p/85630819">https://zhuanlan.zhihu.com/p/85630819</a>)</li><li>图像的相关系数计算，参考<a href="https://blog.csdn.net/weixin_30394333/article/details/95754064?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%9B%BE%E5%83%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0%E8%AE%A1%E7%AE%97&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-95754064.142%5Ev93%5Econtrol&amp;spm=1018.2226.3001.4187">1</a></li><li>关于范数，0范数表示非零元素个数，1范数表示所有元素绝对值之和，2范数表示所有元素间平方和，无穷范数表示所有元素最大值，对于两个向量，L1范数又叫曼哈顿距离，是元素间的绝对误差和(差的绝对值求和)，而L2范数是欧氏距离，是元素间的平方差和。</li><li>梯度裁剪nn.utils.clip_grad_norm_的使用，参考<a href="https://blog.csdn.net/Mikeyboi/article/details/119522689">1</a>，<a href="https://blog.csdn.net/zhaohongfei_358/article/details/122820992?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169365178316800213092562%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169365178316800213092562&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-122820992-null-null.142%5Ev93%5Econtrol&amp;utm_term=nn.utils.clip_grad_norm_&amp;spm=1018.2226.3001.4187">2</a></li><li>本地文件传输到远程服务器，远程服务器文件互相传输，参考：(<a href="https://cloud.tencent.com/developer/article/2092491">https://cloud.tencent.com/developer/article/2092491</a>)</li><li>服务器防火墙设置，参考<a href="https://blog.csdn.net/lu962820662/article/details/129340504?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169365169716800211535651%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169365169716800211535651&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-3-129340504-null-null.142%5Ev93%5Econtrol&amp;utm_term=linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%B2%E7%81%AB%E5%A2%99%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8&amp;spm=1018.2226.3001.4187">1</a></li><li>关于自注意力的意义的详细解析，参考(<a href="https://zhuanlan.zhihu.com/p/410776234">https://zhuanlan.zhihu.com/p/410776234</a>)</li><li>BatchNorm，LayerNorm，GroupNorm的区别，参考：<a href="https://blog.csdn.net/qq_43426908/article/details/123119919?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169365115016800225577832%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169365115016800225577832&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-123119919-null-null.142%5Ev93%5Econtrol&amp;utm_term=batchnorm%20layernorm%20%20groupnorm&amp;spm=1018.2226.3001.4187">1</a></li><li>python广播机制的用法，参考：(<a href="https://zhuanlan.zhihu.com/p/86997775">https://zhuanlan.zhihu.com/p/86997775</a>)</li><li>h5py库的用法，参考<a href="https://blog.csdn.net/csdn15698845876/article/details/73278120?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%2273278120%22%2C%22source%22%3A%22qq_45909764%22%7D&amp;fromshare=blogdetail">1</a></li></ol><h3 id="第3周"><a class="markdownIt-Anchor" href="#第3周"></a> 第3周🌈</h3><ol><li>两台服务器之间传输文件的方法，参考<a href="https://blog.csdn.net/Black_8/article/details/122925549?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22122925549%22%2C%22source%22%3A%22qq_45909764%22%7D&amp;fromshare=blogdetail">1</a></li><li>关于python中文件路径的介绍，参考<a href="https://blog.csdn.net/The_Time_Runner/article/details/84147220?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%2284147220%22%2C%22source%22%3A%22qq_45909764%22%7D&amp;fromshare=blogdetail">1</a></li><li>关于python中super()函数，有时候看到在super函数中传递当前类的实例如super(AttentionBase, self).<strong>init</strong>()，又是则不传递，如super().<strong>init</strong>()，在Python 3中，如果super()不传递任何参数，则函数将自动使用当前类和实例作为参数。因此直接super().<strong>init</strong>()与前者是等效的。</li><li>list，numpy，tensor互相转换及常用操作，参考：<a href="https://blog.csdn.net/onion_rain/article/details/107460601?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22107460601%22%2C%22source%22%3A%22qq_45909764%22%7D&amp;fromshare=blogdetail">1</a></li><li>对list进行[:None]和[None:]的作用，参考：(<a href="https://zhuanlan.zhihu.com/p/598562546">https://zhuanlan.zhihu.com/p/598562546</a>)</li><li>关于使用np.percentile计算百分位数的用法，参考<a href="https://blog.csdn.net/yxf771hotmail/article/details/131849484?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22131849484%22%2C%22source%22%3A%22qq_45909764%22%7D&amp;fromshare=blogdetail">1</a></li><li>python导入上级目录. 同级目录. 下级目录的包，参考<a href="https://blog.csdn.net/gaifuxi9518/article/details/81038818?ops_request_misc=%7B%22request%5Fid%22%3A%22169382667516800197050835%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169382667516800197050835&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-81038818-null-null.142%5Ev93%5Econtrol&amp;utm_term=python%E5%AF%BC%E5%85%A5%E5%8C%85%E7%9A%84%E5%8E%9F%E7%90%86&amp;spm=1018.2226.3001.4187">1</a>，<a href="https://blog.csdn.net/anshiquanshu/article/details/116174774?ops_request_misc=%7B%22request%5Fid%22%3A%22169381126916800225545986%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169381126916800225545986&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-116174774-null-null.142%5Ev93%5Econtrol&amp;utm_term=python%E6%89%BE%E4%B8%8D%E5%88%B0%E4%B8%8A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9&amp;spm=1018.2226.3001.4187">2</a>，为了减少导入包时候的错误，导入同一包(目录)中的模块应使用相对导入(.)，导入其他包中模块应使用绝对导入。</li><li>关于python中的解包和打包，<em>通常用于解包，如<code>a=[[1,2],[3,4]]</code>，则使用</em>a返回两个List，<code>[1,2]</code>和<code>[3,4]</code>，使用zip进行打包，它会将两个可迭代对象相同位置的元素打包成一个元组，然后返回一个迭代器，例如<code>a=[1,2]</code>，<code>b=[3,4]</code>，zip(a,b)会得到两个元组<code>(1,3)，(2,4)</code>，可以用for来进行迭代。通常在__collate_fn__中，使用zip(*batch)重新组织一批数据，例如get_item函数返回了两个列表a,b，假设batchsize为8，传入到__collate_fn__中的batch是一个包含8个元素的list，其中每个元素都为元组(a,b)，*batch会将list解包，然后zip会将8个元组中的a打包成一个新的元组，然后将8个元组中的b打包成一个新的元组，也就是说得到了两个新元组x(由8个a组成)和y(由8个b组成)，然后分别返回x，y即可。</li><li>关于params_group，以及如何为不同层设置不同学习率，参考<a href="https://blog.csdn.net/weixin_45464524/article/details/130456843?ops_request_misc=%7B%22request%5Fid%22%3A%22169390449016800192272047%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169390449016800192272047&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-2-130456843-null-null.142%5Ev93%5Econtrol&amp;utm_term=pytorch%E7%9A%84params_group&amp;spm=1018.2226.3001.4187">1</a>，<a href="https://zhuanlan.zhihu.com/p/347929433">2</a>，<a href="https://blog.csdn.net/weixin_45464524/article/details/130477798?ops_request_misc=%7B%22request%5Fid%22%3A%22169407405916800184146887%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169407405916800184146887&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130477798-null-null.142%5Ev93%5Econtrol&amp;utm_term=%E4%BD%BF%E7%94%A8params_group%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E5%AD%A6%E4%B9%A0%E7%8E%87&amp;spm=1018.2226.3001.4187">3</a>。</li><li>关于python中矩阵乘法multiply(). dot().  matmul(). ’ * '. '@'的区别，参考:<a href="https://blog.csdn.net/u011851421/article/details/83783826?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=@,dot,multiply%E7%9A%84%E5%8C%BA%E5%88%AB&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-83783826.142%5Ev93%5Econtrol&amp;spm=1018.2226.3001.4187">1</a></li><li>optimizer.zero_grad和model.zero_grad的区别，参考<a href="https://blog.csdn.net/qq_32614873/article/details/128626028?ops_request_misc=%7B%22request%5Fid%22%3A%22169400319916777224491083%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169400319916777224491083&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-128626028-null-null.142%5Ev93%5Econtrol&amp;utm_term=model.zero_grad()%E5%92%8Coptimizer.zero_grad()&amp;spm=1018.2226.3001.4187">1</a>。</li><li>pytorch的显存分配机制，参考(<a href="https://zhuanlan.zhihu.com/p/424512257">https://zhuanlan.zhihu.com/p/424512257</a>)</li><li>哪些部分需要to(device)? 损失函数需不需要to(device)? 参考<a href="https://blog.csdn.net/virus111222/article/details/129773728?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=pytorch%E5%93%AA%E4%BA%9B%E9%9C%80%E8%A6%81to(device)&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-129773728.142%5Ev93%5Econtrol&amp;spm=1018.2226.3001.4187">1</a></li><li>关于分组卷积，即conv2d中groups参数，每个卷积核的通道数为in_channel / groups，然后共有out_channels个卷积核，每个组内有out_channels / groups个卷积核，深度可分离卷积的输入输出通道数以及groups都相同，具体例子参考<a href="https://blog.csdn.net/u012633319/article/details/109171775?ops_request_misc=%7B%22request%5Fid%22%3A%22169443420016800180671495%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169443420016800180671495&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109171775-null-null.142%5Ev93%5Econtrol&amp;utm_term=conv2d%E7%9A%84groups%E5%8F%82%E6%95%B0&amp;spm=1018.2226.3001.4187">1</a></li><li>关于全局平均池化(GAP)的原理以及实现。参考<a href="https://blog.csdn.net/qq_41990294/article/details/128930017?ops_request_misc=%7B%22request%5Fid%22%3A%22169466072616800185863464%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169466072616800185863464&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-128930017-null-null.142%5Ev94%5Econtrol&amp;utm_term=globalaveragepooling&amp;spm=1018.2226.3001.4187">1</a>，pytorch中主要通过自适应池化实现，参考<a href="https://blog.csdn.net/weixin_45928096/article/details/122506640?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169926028516777224462932%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169926028516777224462932&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-122506640-null-null.142%5Ev96%5Epc_search_result_base5&amp;utm_term=adaptive%20avg%20pool&amp;spm=1018.2226.3001.4187">2</a></li></ol><h3 id="第4周"><a class="markdownIt-Anchor" href="#第4周"></a> 第4周🌈</h3><ol><li>关于模型断点继续训练，参考(<a href="https://zhuanlan.zhihu.com/p/611485709">https://zhuanlan.zhihu.com/p/611485709</a>),                           (<a href="https://zhuanlan.zhihu.com/p/647349640">https://zhuanlan.zhihu.com/p/647349640</a>)</li><li>关于进度条tqdm的使用，参考(<a href="https://blog.csdn.net/wxd1233/article/details/118371404">https://blog.csdn.net/wxd1233/article/details/118371404</a>)</li><li>关于词嵌入向量torch.nn.Embedding，参考<a href="https://blog.csdn.net/athrunsunny/article/details/123068113?spm=1001.2014.3001.5501">1</a></li><li>匈牙利算法常用来解决最优指派问题，在DETR里它的作用是为每一个gt匹配到唯一的query，从而使代价矩阵的匹配成功的query和gt的代价和最小，关于匈牙利算法的简单理解，参考<a href="https://blog.csdn.net/athrunsunny/article/details/123504015?spm=1001.2014.3001.5502">1</a></li><li>各种IOU的介绍，参考<a href="https://blog.csdn.net/weixin_43694096/article/details/126455488?ops_request_misc=%7B%22request%5Fid%22%3A%22169544548316800180675276%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169544548316800180675276&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-17-126455488-null-null.142%5Ev94%5Econtrol&amp;utm_term=ciou,diou,giou&amp;spm=1018.2226.3001.4187">1</a></li><li>latex配置c和python代码块风格，参考<a href="https://blog.csdn.net/Aldielshala/article/details/89840206">1</a>，<a href="https://zhuanlan.zhihu.com/p/464141424">2</a></li><li>latex写伪代码，参考(<a href="https://zhuanlan.zhihu.com/p/599142563">https://zhuanlan.zhihu.com/p/599142563</a>)，(<a href="https://zhuanlan.zhihu.com/p/572285214">https://zhuanlan.zhihu.com/p/572285214</a>)</li><li>plt.subplots的使用,参考<a href="https://blog.csdn.net/weixin_39258979/article/details/126039763">1</a></li></ol><h3 id="第5周"><a class="markdownIt-Anchor" href="#第5周"></a> 第5周🌈</h3><ol><li>使用algorithmic宏包编写伪代码时的分页问题，参考(<a href="https://blog.csdn.net/Yiigel/article/details/53840888">https://blog.csdn.net/Yiigel/article/details/53840888</a>)</li><li>cv中的绝对位置编码和相对位置编码，绝对位置编码：一般是可学习的，实现非常简洁，初始化一个形状和经过patch_embedding后的输出x相同的参数，然后直接加到x上，在训练阶段一起训练，有点像加了一个可学习的bias，VIT中使用的就是这种方式。对于相对位置编码：绝对位置编码是在patch_embedding之后，计算自注意力(Q,K,V)之前，而相对位置编码是在计算自注意力的时候加入的，在swin transformer中，将二维位置信息转换为一维位置信息，然后去根据相对位置偏移表查询具体的值，位置偏移表的值是训练出来的，在文章中，相对位置编码效果好于绝对位置编码。具体参考<a href="https://blog.csdn.net/qq_43733107/article/details/127077056">这里</a>。</li><li>dense block，每一层将之前所有层的输入进行拼接，之后将输出的特征图传递给之后的所有层，可以可以减轻梯度消失现象，加强特征的融合。参考(<a href="https://www.jianshu.com/p/0b8fc900abef">https://www.jianshu.com/p/0b8fc900abef</a>)</li><li>关于变异系数CV(coefficient of variation)，需要比较两组数据离散程度大小的时候，如果两组数据的测量尺度相差太大，或者数据量纲的不同，直接使用标准差来进行比较不合适，此时就应当消除测量尺度和量纲的影响，而变异系数可以做到这一点，它是原始数据标准差与原始数据平均数的比。CV没有量纲，这样就可以进行客观比较了。事实上，可以认为变异系数和极差. 标准差和方差一样，都是反映数据离散程度的绝对值。其数据大小不仅受变量值离散程度的影响，而且还受变量值平均水平大小的影响。参考<a href="https://blog.csdn.net/m0_64799907/article/details/130041485?ops_request_misc=%7B%22request%5Fid%22%3A%22169745656316800225536260%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169745656316800225536260&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-130041485-null-null.142%5Ev96%5Econtrol&amp;utm_term=coefficientofvariation&amp;spm=1018.2226.3001.4187">1</a></li><li>git fetch 和git pull的区别，git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</li><li>转置卷积的计算详解，参考<a href="https://blog.csdn.net/ZhaoDongyu_AK47/article/details/130602195">1</a></li></ol><h3 id="第6周"><a class="markdownIt-Anchor" href="#第6周"></a> 第6周🌈</h3><ol><li>新设备配置git时，验证是否成功ssh -T <a href="mailto:git@github.com">git@github.com</a>，启智平台同理，参考<a href="https://blog.csdn.net/m0_72983118/article/details/130546429">1</a></li><li>vbox的虚拟环境的复制，只需要复制.vbox, .vdi, vbox-prev文件到相同路径，然后在vbox中注册即可</li><li>vscode终端支持conda命令，参考<a href="https://blog.csdn.net/takedachia/article/details/124694616">1</a></li><li>list的extend和append的区别：append（）用于在列表末尾添加新的对象，输入参数为对象；extend（）用于在列表末尾追加另一个序列中的多个值，输入对象为元素队列；</li><li>numpy的ravel和flatten函数的区别：参考<a href="https://blog.csdn.net/liuweiyuxiang/article/details/78220080?ops_request_misc=%7B%22request%5Fid%22%3A%22169830186016800186578235%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169830186016800186578235&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-78220080-null-null.142%5Ev96%5Epc_search_result_base5&amp;utm_term=ravel%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">1</a></li><li>delctype和auto的区别，二者都用于自动推导类型，但delctype更为灵活，auto所修饰的变量必须被初始化，编译器需要通过初始化来确定auto所代表的类型，即必须要定义变量。若仅希望得到类型，则可以用delctype，如一些排序规则需要使用仿函数，可以用lambda表达式定义比较函数，然后用decltype自动推导。参考(<a href="https://zhuanlan.zhihu.com/p/152154499">https://zhuanlan.zhihu.com/p/152154499</a>)</li></ol><h3 id="第7周"><a class="markdownIt-Anchor" href="#第7周"></a> 第7周🌈</h3><ol><li>python中函数命名时下划线的作用，单前置下划线作为类名或者函数名时，表示会阻止其他python脚本通过【from module import *】语句导入该名字，即该名字不会被星号匹配；前后均带有双下划线的名字，一般用于特殊方法的命名，用来实现对象的一些行为或者功能，如__new__()方法用来创建实例，<strong>init</strong>()方法用来初始化对象，x + y操作被映射为方法x.<strong>add</strong>(y)，序列或者字典的索引操作x[k]映射为x.<strong>getitem</strong>(k), <strong>len</strong>(), <strong>str</strong>()分别被内置函数len(). str()调用等等；仅开头带双下划线的命名，表示，以此命名的属性或者方法为类的私有属性或者私有方法。</li><li>linux终端命令中&amp;&amp;和&amp;的区别，&amp;&amp; 用于顺序执行两个命令，并且第二个命令仅在第一个成功时才执行，而 &amp; 用于将命令置于后台运行，允许你同时执行其他任务。</li><li>余弦退火调整学习率，一般训练时梯度下降算法可能陷入局部最小值，此时可以通过突然提高学习率，来“跳出”局部最小值并找到通向全局最小值的路径。这种方式称为带重启的随机梯度下降方法。参考(<a href="https://blog.csdn.net/weixin_35848967/article/details/108493217">https://blog.csdn.net/weixin_35848967/article/details/108493217</a>)</li><li>关于torch.backends.cudnn.benchmark，该选项设置为true时，会自动选择最优卷积算子，但是这个过程是随机的，也就是说即使固定了随机种子，如果这一项为true，训练的结果依然会不同。</li><li>windows终端查看编码格式，chcp，切换编码chcp 65001(utf-8) chcp 936(简体中文gbk) chcp 437(英语)</li></ol>]]></content>
    
    
    <categories>
      
      <category>资料</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最近公共祖先LCA</title>
    <link href="/2023/06/13/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88LCA/"/>
    <url>/2023/06/13/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88LCA/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%A5%96%E5%85%88">树节点的第K个祖先</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="树节点的第k个祖先"><a class="markdownIt-Anchor" href="#树节点的第k个祖先"></a> 树节点的第K个祖先</h2><p><a href="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。</p><p>树节点的第 k 个祖先节点是从该节点到根节点路径上的第 k 个节点。</p><p>实现 TreeAncestor 类：</p><p>TreeAncestor（int n， int[] parent） 对树和父数组中的节点数初始化对象。<br />getKthAncestor(int node, int k) 返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;TreeAncestor&quot;</span>,<span class="hljs-string">&quot;getKthAncestor&quot;</span>,<span class="hljs-string">&quot;getKthAncestor&quot;</span>,<span class="hljs-string">&quot;getKthAncestor&quot;</span>]<br>[[<span class="hljs-number">7</span>,[<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]],[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">3</span>]]<br><br>输出：<br>[null,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>]<br><br>解释：<br><span class="hljs-symbol">TreeAncestor</span> treeAncestor = new <span class="hljs-symbol">TreeAncestor</span>(<span class="hljs-number">7</span>, [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]);<br>treeAncestor.getKthAncestor(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);  // 返回 <span class="hljs-number">1</span> ，它是 <span class="hljs-number">3</span> 的父节点<br>treeAncestor.getKthAncestor(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>);  // 返回 <span class="hljs-number">0</span> ，它是 <span class="hljs-number">5</span> 的祖父节点<br>treeAncestor.getKthAncestor(<span class="hljs-number">6</span>, <span class="hljs-number">3</span>);  // 返回 <span class="hljs-number">-1</span> 因为不存在满足要求的祖先节点<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要用到树上倍增算法，需要用二维数组<code>pa[x][i]</code>表示节点<code>x</code>的第<code>2^i</code>祖先节点，则满足<code>pa[x][i+1]=pa[pa[x][i]][i]</code>，然后获取第k个祖先节点时，将k转换成二进制然后按位计算即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">TreeAncestor</span> &#123;<br>    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; pa;<br><span class="hljs-keyword">public</span>:<br>    TreeAncestor(<span class="hljs-built_in">int</span> n, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; parent) &#123;<br>        <span class="hljs-built_in">int</span> m=<span class="hljs-number">32</span>-__builtin_clz(n);<br>        pa.resize(n,vector&lt;<span class="hljs-built_in">int</span>&gt;(m,<span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>            pa[i][<span class="hljs-number">0</span>]=parent[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;m<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> x=<span class="hljs-number">0</span>;x&lt;n;++x)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span> p=pa[x][i];p!=<span class="hljs-number">-1</span>)<br>                    pa[x][i+<span class="hljs-number">1</span>]=pa[p][i];<br>            &#125;<br>        &#125;<br>    &#125;  <br>    <span class="hljs-built_in">int</span> getKthAncestor(<span class="hljs-built_in">int</span> node, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> l=<span class="hljs-number">32</span>-__builtin_clz(k);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;l;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((k&gt;&gt;i)&amp;<span class="hljs-number">1</span>)<br>            &#123;<br>                node=pa[node][i];<br>                <span class="hljs-keyword">if</span>(node&lt;<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;    <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最近公共祖先lca"><a class="markdownIt-Anchor" href="#最近公共祖先lca"></a> 最近公共祖先LCA</h2><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>关于两个点x和y的lca，可以先预处理出每个节点的深度数组<code>depth[i]</code>，由于x和y的深度可能不同，所以需要现将深度较深的一个如<code>y</code>转换成它和x同一深度的祖先<code>y'</code>，然后x和y同时往上跳，在x到根节点的这条路径上猜一个点z当作lca，且x与z相距<code>2^i</code>步。把x和y同时向上跳<code>2^i</code>步，如果<code>x≠y</code>，就说明lca在z的上面，否则lca要么是z，要么在z的下面。</p><p>下面是模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeAncestor</span> &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; depth;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; pa;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TreeAncestor</span>(vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; &amp;edges) &#123;<br>        <span class="hljs-type">int</span> n = edges.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">32</span> - __builtin_clz(n); <span class="hljs-comment">// n 的二进制长度</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y]: edges) &#123; <span class="hljs-comment">// 节点编号从 0 开始</span><br>            g[x].<span class="hljs-built_in">push_back</span>(y);<br>            g[y].<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br><br>        depth.<span class="hljs-built_in">resize</span>(n);<br>        pa.<span class="hljs-built_in">resize</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">-1</span>));<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) &#123;<br>            pa[x][<span class="hljs-number">0</span>] = fa;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y: g[x]) &#123;<br>                <span class="hljs-keyword">if</span> (y != fa) &#123;<br>                    depth[y] = depth[x] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">dfs</span>(y, x);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; n; x++)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-type">int</span> p = pa[x][i]; p != <span class="hljs-number">-1</span>)<br>                    pa[x][i + <span class="hljs-number">1</span>] = pa[p][i];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_kth_ancestor</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (; k; k &amp;= k - <span class="hljs-number">1</span>)<br>            node = pa[node][__builtin_ctz(k)];<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回 x 和 y 的最近公共祖先（节点编号从 0 开始）</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (depth[x] &gt; depth[y])<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        <span class="hljs-comment">// 使 y 和 x 在同一深度</span><br>        y = <span class="hljs-built_in">get_kth_ancestor</span>(y, depth[y] - depth[x]);<br>        <span class="hljs-keyword">if</span> (y == x)<br>            <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pa[x].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> px = pa[x][i], py = pa[y][i];<br>            <span class="hljs-keyword">if</span> (px != py) &#123;<br>                x = px;<br>                y = py;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pa[x][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>活字印刷</title>
    <link href="/2023/05/19/%E6%B4%BB%E5%AD%97%E5%8D%B0%E5%88%B7/"/>
    <url>/2023/05/19/%E6%B4%BB%E5%AD%97%E5%8D%B0%E5%88%B7/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%B4%BB%E5%AD%97%E5%8D%B0%E5%88%B7">活字印刷</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="活字印刷"><a class="markdownIt-Anchor" href="#活字印刷"></a> 活字印刷</h2><p><a href="https://leetcode.cn/problems/letter-tile-possibilities/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。</p><p>注意：本题中，每个活字字模只能使用一次。</p><p>e.g.</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;AAB&quot;</span><br>输出：<span class="hljs-number">8</span><br>解释：可能的序列为 <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-string">&quot;AB&quot;</span>, <span class="hljs-string">&quot;BA&quot;</span>, <span class="hljs-string">&quot;AAB&quot;</span>, <span class="hljs-string">&quot;ABA&quot;</span>, <span class="hljs-string">&quot;BAA&quot;</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>计数dp，用<code>dp[i][j]</code>表示前i种字符生成长度为j的字符串时，能得到的方案数，用二位数组v预处理组合数，用哈系表统计字符出现频率，当不选第i种字符时，<code>dp[i][j]=dp[i-1][j]</code>，当选中k个i字符时，需要从j中选出k个位置放置这些字符，其余位置就是用前<code>i-1</code>种字符构造长为<code>j-k</code>的字符串，即<code>dp[i][j]=dp[i-1][j-k]*v[j][k]</code>，最后把所有不同长度的方案数加起来即最终答案。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTilePossibilities</span><span class="hljs-params">(string tiles)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> &amp;c:tiles)<br>            ++mp[c];<br>        <span class="hljs-type">int</span> n=tiles.<span class="hljs-built_in">size</span>(),m=mp.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">v</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)<br>        &#123;<br>            v[i][<span class="hljs-number">0</span>]=v[i][i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j)<br>                v[i][j]=v[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+v[i<span class="hljs-number">-1</span>][j];<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; it:mp)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;++j)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=j&amp;&amp;k&lt;=it.second;++k)<br>                    dp[i][j]+=dp[i<span class="hljs-number">-1</span>][j-k]*v[j][k];<br>            &#125;<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(dp[m].<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,dp[m].<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>按列翻转得到最大值等行数</title>
    <link href="/2023/05/15/%E6%8C%89%E5%88%97%E7%BF%BB%E8%BD%AC%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%AD%89%E8%A1%8C%E6%95%B0/"/>
    <url>/2023/05/15/%E6%8C%89%E5%88%97%E7%BF%BB%E8%BD%AC%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%AD%89%E8%A1%8C%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8C%89%E5%88%97%E7%BF%BB%E8%BD%AC%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%AD%89%E8%A1%8C%E6%95%B0">按列翻转得到最大值等行数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="按列翻转得到最大值等行数"><a class="markdownIt-Anchor" href="#按列翻转得到最大值等行数"></a> 按列翻转得到最大值等行数</h2><p><a href="https://leetcode.cn/problems/flip-columns-for-maximum-number-of-equal-rows/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定 m x n 矩阵 matrix 。</p><p>你可以从中选出任意数量的列并翻转其上的 每个 单元格。（即翻转后，单元格的值从 0 变成 1，或者从 1 变为 0 。）</p><p>返回 经过一些翻转后，行与行之间所有值都相等的最大行数 。</p><p>e.g.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[0,1],[1,1]]</span><br>输出：<span class="hljs-number">1</span><br>解释：不进行翻转，有 <span class="hljs-number">1</span> 行所有值都相等。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>因为最终统计的行都是全0或者全1，所以这道题的最终目的是找到互补的行数，所以对各行中首个元素为1的行取反，然后将每行转换成字符串，用哈系表统计相同行的最大数量即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> maxEqualRowsAfterFlips(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-keyword">matrix</span>) &#123;<br>        <span class="hljs-keyword">int</span> n=<span class="hljs-keyword">matrix</span>[<span class="hljs-number">0</span>].<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-keyword">string</span>,<span class="hljs-keyword">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; t:<span class="hljs-keyword">matrix</span>)<br>        &#123;<br>            <span class="hljs-keyword">string</span> s(n,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>                s[i]=t[i]^t[<span class="hljs-number">0</span>];<br>            ++mp[s];<br>            ans=<span class="hljs-keyword">max</span>(ans,mp[s]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>推箱子</title>
    <link href="/2023/05/08/%E6%8E%A8%E7%AE%B1%E5%AD%90/"/>
    <url>/2023/05/08/%E6%8E%A8%E7%AE%B1%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8E%A8%E7%AE%B1%E5%AD%90">推箱子</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="推箱子"><a class="markdownIt-Anchor" href="#推箱子"></a> 推箱子</h2><p><a href="https://leetcode.cn/problems/minimum-moves-to-move-a-box-to-their-target-location/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。</p><p>游戏地图用大小为 m x n 的网格 grid 表示，其中每个元素可以是墙、地板或者是箱子。</p><p>现在你将作为玩家参与游戏，按规则将箱子 ‘B’ 移动到目标位置 ‘T’ ：</p><p>玩家用字符 ‘S’ 表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。<br />地板用字符 ‘.’ 表示，意味着可以自由行走。<br />墙用字符 ‘#’ 表示，意味着障碍物，不能通行。<br />箱子仅有一个，用字符 ‘B’ 表示。相应地，网格上有一个目标位置 ‘T’。<br />玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。<br />玩家无法越过箱子。<br />返回将箱子推到目标位置的最小 推动 次数，如果无法做到，请返回 -1。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [[<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>],<br>             [<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>],<br>             [<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>],<br>             [<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>],<br>             [<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>],<br>             [<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>]]<br>输出：<span class="hljs-number">3</span><br>解释：我们只需要返回推箱子的次数。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>深度优先搜索(BFS)，通过<code>vis[px][py][bx][by]</code>记录当前箱子和人的位置是否被访问过，然后定义一个双端队列<code>deque&lt;tuple&lt;int,int,int,int&gt;&gt;</code>，每个元素记录人的位置、箱子的位置和当前推动距离，然后进行bfs，每次取出队首元素，如果箱子到达目的地则返回推动距离，否则先让人移动，当人移动到箱子位置时推动箱子(更新箱子位置)，如果推动后人和箱子当前位置未被访问，则将该状态加入队尾，如果人未移动到箱子位置并且当前二者位置未被访问，则将当前状态加入队首，重复上述步骤知道队列为空为止。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs prolog">class <span class="hljs-symbol">Solution</span> &#123;<br>int dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br>bool vis[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>][<span class="hljs-number">20</span>][<span class="hljs-number">20</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>public:<br>    int minPushBox(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;<br>        int m=grid.size(),n=grid[<span class="hljs-number">0</span>].size();<br>        auto isvalid=[&amp;](int x,int y)-&gt;bool&#123;<br>            return x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="hljs-number">0</span>&amp;&amp;y&lt;n&amp;&amp;grid[x][y]!=<span class="hljs-string">&#x27;#&#x27;</span>;<br>        &#125;;<br>        int startx,starty,boxx,boxy,endx,endy;<br>        for(int i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            for(int j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                if(grid[i][j]==<span class="hljs-string">&#x27;S&#x27;</span>)<br>                &#123;<br>                    startx=i;starty=j;<br>                &#125;<br>                else if(grid[i][j]==<span class="hljs-string">&#x27;B&#x27;</span>)<br>                &#123;<br>                    boxx=i;boxy=j;<br>                &#125;<br>                else if(grid[i][j]==<span class="hljs-string">&#x27;T&#x27;</span>)<br>                &#123;<br>                    endx=i;endy=j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        deque&lt;tuple&lt;int,int,int,int,int&gt;&gt; q;<br>        q.emplace_front(startx,starty,boxx,boxy,<span class="hljs-number">0</span>);<br>        vis[startx][starty][boxx][boxy]=true;<br>        while(!q.empty())<br>        &#123;<br>            auto [px,py,bx,by,d]=q.front();<br>            q.pop_front();<br>            if(bx==endx&amp;&amp;by==endy)<br>                return d;<br>            for(auto [dx,dy]:dir)<br>            &#123;<br>                int npx=px+dx,npy=py+dy;<br>                if(!isvalid(npx,npy))<br>                    continue;<br>                if(npx==bx&amp;&amp;npy==by)<br>                &#123;<br>                    int nbx=bx+dx,nby=by+dy;<br>                    if(!isvalid(nbx,nby)||vis[npx][npy][nbx][nby])<br>                        continue;<br>                    q.emplace_back(npx,npy,nbx,nby,d+<span class="hljs-number">1</span>);<br>                    vis[npx][npy][nbx][nby]=true;<br>                &#125;<br>                else if(!vis[npx][npy][bx][by])<br>                &#123;<br>                    q.emplace_front(npx,npy,bx,by,d);<br>                    vis[npx][npy][bx][by]=true;<br>                &#125;  <br>            &#125;<br>        &#125;<br>        return <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>摘水果</title>
    <link href="/2023/05/04/%E6%91%98%E6%B0%B4%E6%9E%9C/"/>
    <url>/2023/05/04/%E6%91%98%E6%B0%B4%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%91%98%E6%B0%B4%E6%9E%9C">摘水果</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="摘水果"><a class="markdownIt-Anchor" href="#摘水果"></a> 摘水果</h2><p><a href="https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 fruits ，其中 fruits[i] = [positioni, amounti] 表示共有 amounti 个水果放置在 positioni 上。fruits 已经按 positioni 升序排列 ，每个 positioni 互不相同 。</p><p>另给你两个整数 startPos 和 k 。最初，你位于 startPos 。从任何位置，你可以选择 向左或者向右 走。在 x 轴上每移动 一个单位 ，就记作 一步 。你总共可以走 最多 k 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。</p><p>返回你可以摘到水果的 最大总数 。<br />e.g.</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4<br>输出：9<br>解释：<br>最佳路线为：<br>- 向右移动到位置<span class="hljs-number"> 6 </span>，摘到<span class="hljs-number"> 3 </span>个水果<br>- 向右移动到位置<span class="hljs-number"> 8 </span>，摘到<span class="hljs-number"> 6 </span>个水果<br>移动<span class="hljs-number"> 3 </span>步，共摘到<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 9 </span>个水果<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>枚举移动的区间<code>[left,right]</code>，用二分查找来确定移动区间，实际移动时，要么先向左移动<code>x</code>步，再向右移动<code>k-x</code>，要么先向右移动<code>x</code>步，再向左移动<code>k-x</code>步，通过前缀和来快速计算区间的水果数量，通过二分查找枚举移动区间的时候，要注意边界，最后更新最大值即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    <span class="hljs-built_in">int</span> maxTotalFruits(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; fruits, <span class="hljs-built_in">int</span> startPos, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>=fruits.size();<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>);<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; idx(<span class="hljs-built_in">n</span>);<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">n</span>;++i)<br>        &#123;<br>            <span class="hljs-built_in">sum</span>[i+<span class="hljs-number">1</span>]=<span class="hljs-built_in">sum</span>[i]+fruits[i][<span class="hljs-number">1</span>];<br>            idx[i]=fruits[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>=k/<span class="hljs-number">2</span>;<br>        for(<span class="hljs-built_in">int</span> x=<span class="hljs-number">0</span>;x&lt;=<span class="hljs-built_in">t</span>;++x)<br>        &#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">offset</span>=k-<span class="hljs-number">2</span>*x;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=startPos-x;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>=startPos+<span class="hljs-built_in">offset</span>;<br>            <span class="hljs-built_in">int</span> l=lower_bound(idx.begin(),idx.end(),<span class="hljs-built_in">left</span>)-idx.begin();<br>            <span class="hljs-built_in">int</span> r=upper_bound(idx.begin(),idx.end(),<span class="hljs-built_in">right</span>)-idx.begin();<br>            res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">sum</span>[r]-<span class="hljs-built_in">sum</span>[l]);<br>            <span class="hljs-built_in">right</span>=startPos+x;<br>            <span class="hljs-built_in">left</span>=startPos-<span class="hljs-built_in">offset</span>;<br>            l=lower_bound(idx.begin(),idx.end(),<span class="hljs-built_in">left</span>)-idx.begin();<br>            r=upper_bound(idx.begin(),idx.end(),<span class="hljs-built_in">right</span>)-idx.begin();<br>            res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">sum</span>[r]-<span class="hljs-built_in">sum</span>[l]);<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>检查替换后的词是否有效</title>
    <link href="/2023/05/03/%E6%A3%80%E6%9F%A5%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E8%AF%8D%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88/"/>
    <url>/2023/05/03/%E6%A3%80%E6%9F%A5%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E8%AF%8D%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%A3%80%E6%9F%A5%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E8%AF%8D%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88">检查替换后的词是否有效</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="检查替换后的词是否有效"><a class="markdownIt-Anchor" href="#检查替换后的词是否有效"></a> 检查替换后的词是否有效</h2><p><a href="https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个字符串 s ，请你判断它是否 有效 。<br />字符串 s 有效 需要满足：假设开始有一个空字符串 t = “” ，你可以执行 任意次 下述操作将 t 转换为 s ：</p><p>将字符串 “abc” 插入到 t 中的任意位置。形式上，t 变为 tleft + “abc” + tright，其中 t == tleft + tright 。注意，tleft 和 tright 可能为 空 。<br />如果字符串 s 有效，则返回 true；否则，返回 false。</p><p>e.g.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 输入：s">输出：true<br>解释：<br>&quot;&quot; -&gt; &quot;abc&quot; -&gt; &quot;aabcbc&quot;<br>因此，&quot;aabcbc&quot; 有效。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>创建一个栈,然后遍历字符串s，如果遇到a，就加入栈，遇到b，检查一下栈顶是否为a，是的话把b入栈，否则返回false，遇到c，依次检查栈顶是否是ba，是则弹出栈顶两个元素，否则返回false。最后如果栈非空，返回false。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">bool</span> isValid(<span class="hljs-keyword">string</span> s) &#123;<br>        stack&lt;<span class="hljs-keyword">char</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:s)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;a&#x27;</span>)<br>                st.push(c);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;b&#x27;</span>&amp;&amp;!st.<span class="hljs-keyword">empty</span>()&amp;&amp;st.top()==<span class="hljs-string">&#x27;a&#x27;</span>)<br>                st.push(c);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;c&#x27;</span>&amp;&amp;!st.<span class="hljs-keyword">empty</span>()&amp;&amp;st.top()==<span class="hljs-string">&#x27;b&#x27;</span>)<br>            &#123;<br>                st.pop();<br>                <span class="hljs-keyword">if</span>(!st.<span class="hljs-keyword">empty</span>()&amp;&amp;st.top()==<span class="hljs-string">&#x27;a&#x27;</span>)<br>                    st.pop();<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!st.<span class="hljs-keyword">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最长等差数列</title>
    <link href="/2023/04/22/%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/"/>
    <url>/2023/04/22/%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97">最长等差数列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最长等差数列"><a class="markdownIt-Anchor" href="#最长等差数列"></a> 最长等差数列</h2><p><a href="https://leetcode.cn/problems/longest-arithmetic-subsequence/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。</p><p>回想一下，nums 的子序列是一个列表 nums[i1], nums[i2], …, nums[ik] ，且 0 &lt;= i1 &lt; i2 &lt; … &lt; ik &lt;= nums.length - 1。并且如果 seq[i+1] - seq[i]( 0 &lt;= i &lt; seq.length - 1) 的值都相同，那么序列 seq 是等差的。</p><p>e.g.</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">3,6,9,12</span>]<br>输出：<span class="hljs-number">4</span><br>解释： <br>整个数组是公差为 <span class="hljs-number">3</span> 的等差数列。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题其实是<a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">最长递增子序列</a>的升级版，只不过加了公差的限制，用<code>dp[i][d]</code>表示i位置处公差为d的最长子序列长度，然后遍历<code>j(j&lt;i)</code>位置，当<code>dp[j][d]+1&gt;dp[i][d]</code>时更新<code>dp[i][d]</code>，返回整个过程最大长度即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestArithSeqLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1001</span>,<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j)<br>            &#123;<br>                <span class="hljs-type">int</span> d=nums[i]-nums[j]+<span class="hljs-number">500</span>;<br>                dp[i][d]=<span class="hljs-built_in">max</span>(dp[i][d],dp[j][d]+<span class="hljs-number">1</span>);<br>                ans=<span class="hljs-built_in">max</span>(ans,dp[i][d]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使数组严格递增</title>
    <link href="/2023/04/20/%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/"/>
    <url>/2023/04/20/%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E">使数组严格递增</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="使数组严格递增"><a class="markdownIt-Anchor" href="#使数组严格递增"></a> 使数组严格递增</h2><p><a href="https://leetcode.cn/problems/make-array-strictly-increasing/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你两个整数数组 arr1 和 arr2，返回使 arr1 严格递增所需要的最小「操作」数（可能为 0）。</p><p>每一步「操作」中，你可以分别从 arr1 和 arr2 中各选出一个索引，分别为 i 和 j，0 &lt;= i &lt; arr1.length 和 0 &lt;= j &lt; arr2.length，然后进行赋值运算 arr1[i] = arr2[j]。</p><p>如果无法让 arr1 严格递增，请返回 -1。</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr1 = <span class="hljs-comment">[1,5,3,6,7]</span>, arr2 = <span class="hljs-comment">[4,3,1]</span><br>输出：2<br>解释：用 3 来替换 5，然后用 4 来替换 3，得到 arr1 = <span class="hljs-comment">[1, 3, 4, 6, 7]</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用<code>dfs（i,r）</code>表示<code>0~i</code>区间严格递增，且<code>a[i]&lt;r</code>的最小操作次数，对于<code>i</code>位置的数，记它右边的数是<code>r</code>，那么<code>i</code>位置分替换和不替换两种情况</p><ul><li>不替换：<code>a[i]&lt;r</code>，<code>dfs(i,r)=dfs(i-1,a[i])</code></li><li>替换：<code>a[i]&gt;=r</code>，通过二分查找在b中找到小于r的最大数<code>b[k]</code>，然后替换，dfs(i,pre)=dfs(i-1,b[k])+1;</li></ul><p>为了减少时间，还可以用一个哈系表记录每个位置的值，如果i已经访问过则直接返回结果即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">makeArrayIncreasing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n=a.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m[n];<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; dfs=[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> r)-&gt;<span class="hljs-type">int</span>&#123;<br>            <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">auto</span> it=m[i].<span class="hljs-built_in">find</span>(r);<br>            <span class="hljs-comment">// 计算过直接用之前的结果</span><br>            <span class="hljs-keyword">if</span>(it!=m[i].<span class="hljs-built_in">end</span>())<br>                <span class="hljs-keyword">return</span> it-&gt;second;<br>            <span class="hljs-type">int</span> res=a[i]&lt;r ? <span class="hljs-built_in">dfs</span>(i<span class="hljs-number">-1</span>,a[i]):INT_MAX/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 二分查找b中第一个大于等于r的位置</span><br>            <span class="hljs-keyword">auto</span> k=<span class="hljs-built_in">lower_bound</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>(),r);<br>            <span class="hljs-keyword">if</span>(k!=b.<span class="hljs-built_in">begin</span>())<br>                res=<span class="hljs-built_in">min</span>(res,<span class="hljs-built_in">dfs</span>(i<span class="hljs-number">-1</span>,*(--k))+<span class="hljs-number">1</span>);<br>            m[i][r]=res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-built_in">dfs</span>(n<span class="hljs-number">-1</span>,INT_MAX);<br>        <span class="hljs-keyword">return</span> ans&gt;n ? <span class="hljs-number">-1</span>:ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票的最佳时机</title>
    <link href="/2023/04/14/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <url>/2023/04/14/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">买卖股票的最佳时机</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#买卖股票的最佳时机"></a> 买卖股票的最佳时机</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>e.g.</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：k = 2, prices = [3,2,6,5,0,3]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天 (股票价格 = 2) 的时候买入，在第<span class="hljs-number"> 3 </span>天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 =<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 5 </span>天 (股票价格 = 0) 的时候买入，在第<span class="hljs-number"> 6 </span>天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>动态规划,用<code>buy[i][j]</code>表示第<code>i</code>天时发生<code>j</code>笔交易时的最大利润，且此时持有股票，同理<code>sell[i][j]</code>表示此时不持有股票，然后分类讨论。</p><p>对于<code>buy[i][j]</code>:</p><ul><li>若前一天本就持有股票，那么等于<code>buy[i-1][j]</code></li><li>若前一天不持有股票，那今天需买入股票，那么等于<code>sell[i-1][j]-prices[i]</code></li></ul><p>对于<code>sell[i][j]</code>:</p><ul><li>若前一天不持有股票，那么等于<code>sell[i-1][j]</code></li><li>若前一天持有股票，那今天需卖出股票，那么等于<code>buy[i-1][j-1]+prices[i]</code></li></ul><p>最后的答案应该是卖出所有股票后的最大值，所以返回sell[n-1]的最大值</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;<br>        int n=prices.size();<br>        k=min(k,n/2);<br>        if(n==0)<br>            return 0;<br>        vector&lt;vector&lt;int&gt;&gt; buy(n,vector&lt;int&gt;(k+1));<br>        vector&lt;vector&lt;int&gt;&gt; sell(n,vector&lt;int&gt;(k+1));<br>        buy<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>=-prices<span class="hljs-comment">[0]</span>;<br>        sell<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>=0;<br>        for(int i=1;i&lt;=k;++i)<br>            buy<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span>=sell<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span>=-1e6;<br>        for(int i=1;i&lt;n;++i)<br>        &#123;<br>            buy<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>=max(buy<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>,sell<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>-prices<span class="hljs-comment">[i]</span>);<br>            for(int j=1;j&lt;=k;++j)<br>            &#123;<br>                buy<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(buy<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>,sell<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>-prices<span class="hljs-comment">[i]</span>);<br>                sell<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(sell<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>,buy<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>+prices<span class="hljs-comment">[i]</span>);<br>            &#125;<br>        &#125;<br>        return *max_element(sell<span class="hljs-comment">[n-1]</span>.begin(),sell<span class="hljs-comment">[n-1]</span>.end());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>段式回文</title>
    <link href="/2023/04/12/%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87/"/>
    <url>/2023/04/12/%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87">段式回文</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="段式回文"><a class="markdownIt-Anchor" href="#段式回文"></a> 段式回文</h2><p><a href="https://leetcode.cn/problems/longest-chunked-palindrome-decomposition/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你会得到一个字符串 text 。你应该把它分成 k 个子字符串 (subtext1, subtext2，…， subtextk) ，要求满足:</p><ul><li>subtexti 是 非空 字符串</li><li>所有子字符串的连接等于 text ( 即subtext1 + subtext2 + … + subtextk == text )</li><li>对于所有 i 的有效值( 即 1 &lt;= i &lt;= k ) ，subtexti == subtextk - i + 1 均成立<br />返回k可能最大值。</li></ul><p>e.g.</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：text <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ghiabcdefhelloadamhelloabcdefghi&quot;</span><br>输出：<span class="hljs-number">7</span><br>解释：我们可以把字符串拆分成 <span class="hljs-string">&quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>枚举子串的长度<code>i</code>，分别截取前后长度为<code>i</code>的子串，如果相等，答案加2，否则继续枚举，当<code>i&gt;text.length/2</code>时，说明已经不可再分，答案加1</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestDecomposition</span><span class="hljs-params">(string text)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!text.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,n=text.<span class="hljs-built_in">length</span>();<br>            <span class="hljs-keyword">while</span>(i&lt;=n/<span class="hljs-number">2</span>&amp;&amp;text.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,i)!=text.<span class="hljs-built_in">substr</span>(n-i))<br>                ++i;<br>            <span class="hljs-keyword">if</span>(i&gt;n/<span class="hljs-number">2</span>)<br>            &#123;<br>                ++ans;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ans+=<span class="hljs-number">2</span>;<br>            text=text.<span class="hljs-built_in">substr</span>(i,n-i*<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>合并石头的最低成本</title>
    <link href="/2023/04/04/%E5%90%88%E5%B9%B6%E7%9F%B3%E5%A4%B4%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/"/>
    <url>/2023/04/04/%E5%90%88%E5%B9%B6%E7%9F%B3%E5%A4%B4%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%90%88%E5%B9%B6%E7%9F%B3%E5%A4%B4%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC">合并石头的最低成本</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="合并石头的最低成本"><a class="markdownIt-Anchor" href="#合并石头的最低成本"></a> 合并石头的最低成本</h2><p><a href="https://leetcode.cn/problems/minimum-cost-to-merge-stones/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。</p><p>每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。</p><p>找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。<br />e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：stones = <span class="hljs-comment">[3,2,4,1]</span>, K = 2<br>输出：20<br>解释：<br>从 <span class="hljs-comment">[3, 2, 4, 1]</span> 开始。<br>合并 <span class="hljs-comment">[3, 2]</span>，成本为 5，剩下 <span class="hljs-comment">[5, 4, 1]</span>。<br>合并 <span class="hljs-comment">[4, 1]</span>，成本为 5，剩下 <span class="hljs-comment">[5, 5]</span>。<br>合并 <span class="hljs-comment">[5, 5]</span>，成本为 10，剩下 <span class="hljs-comment">[10]</span>。<br>总成本 20，这是可能的最小值。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用<code>dfs(i,j,p)</code>表示把第i堆到第j堆合并成p堆需要的最小成本，然后将原问题划分成子问题。比如有7堆石子，k=3，实际上要求的就是<code>dfs(0,6,1)</code>，而它又可以划分为<code>dfs(0,6,3)+0到6所有堆之和</code>，对于<code>dfs(0,6,3)</code>，按第一堆的合并方式也分为几种情况，比如<code>dfs(0,0,1)+dfs(1,6,2)</code>，<code>dfs(0,2,1)+dfs(3,6,2)</code>，<code>dfs(0,4,1)+dfs(5,6,2)</code>，取这些情况中最小的即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    <span class="hljs-built_in">int</span> mergeStones(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; stones, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>=stones.size();<br>        <span class="hljs-built_in">if</span>((<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>)%(k-<span class="hljs-number">1</span>))<br>            return -<span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>);<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">n</span>;++i)<br>            <span class="hljs-built_in">sum</span>[i+<span class="hljs-number">1</span>]=<span class="hljs-built_in">sum</span>[i]+stones[i];<br>        <span class="hljs-built_in">int</span> m[<span class="hljs-built_in">n</span>][<span class="hljs-built_in">n</span>][k+<span class="hljs-number">1</span>];<br>        memset(m,-<span class="hljs-number">1</span>,sizeof(m));<br>        function&lt;<span class="hljs-built_in">int</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>)&gt; dfs=[&amp;](<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> j,<span class="hljs-built_in">int</span> p)-&gt;<span class="hljs-built_in">int</span><br>        &#123;<br>            <span class="hljs-built_in">if</span>(m[i][j][p]!=-<span class="hljs-number">1</span>)<br>                return m[i][j][p];<br>            <span class="hljs-built_in">if</span>(p==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">if</span>(i==j)<br>                    return <span class="hljs-number">0</span>;<br>                else<br>                    return dfs(i,j,k)+<span class="hljs-built_in">sum</span>[j+<span class="hljs-number">1</span>]-<span class="hljs-built_in">sum</span>[i];<br>            &#125;<br>            <span class="hljs-built_in">int</span> res=INT_MAX;<br>            for(<span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>=i;<span class="hljs-built_in">t</span>&lt;j;<span class="hljs-built_in">t</span>+=k-<span class="hljs-number">1</span>)<br>            &#123;<br>                res=<span class="hljs-built_in">min</span>(res,dfs(i,<span class="hljs-built_in">t</span>,<span class="hljs-number">1</span>)+dfs(<span class="hljs-built_in">t</span>+<span class="hljs-number">1</span>,j,p-<span class="hljs-number">1</span>));<br>            &#125;<br>            m[i][j][p]=res;<br>            return res;<br>        &#125;;<br>        return dfs(<span class="hljs-number">0</span>,<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>交换一次的先前排列</title>
    <link href="/2023/04/03/%E4%BA%A4%E6%8D%A2%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%88%E5%89%8D%E6%8E%92%E5%88%97/"/>
    <url>/2023/04/03/%E4%BA%A4%E6%8D%A2%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%88%E5%89%8D%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BA%A4%E6%8D%A2%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%88%E5%89%8D%E6%8E%92%E5%88%97">交换一次的先前排列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="交换一次的先前排列"><a class="markdownIt-Anchor" href="#交换一次的先前排列"></a> 交换一次的先前排列</h2><p><a href="https://leetcode.cn/problems/previous-permutation-with-one-swap/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个正整数数组 arr（可能存在重复的元素），请你返回可在 一次交换（交换两数字 arr[i] 和 arr[j] 的位置）后得到的、按字典序排列小于 arr 的最大排列。</p><p>如果无法这么操作，就请返回原数组。</p><p>e.g.</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[1,9,4,6,7]</span><br>输出：<span class="hljs-string">[1,7,4,6,9]</span><br>解释：交换 <span class="hljs-number">9</span> 和 <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>先从后往前，找到第一个降序排列的数<code>a[i]</code>，并可知他后面的数都是非递减排列的，再次从后往前遍历，找到第一个小于<code>a[i]</code>且下标尽可能小的数(重复数字取下标更小的)与<code>a[i]</code>交换即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prevPermOpt1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>,j=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(arr[i]&gt;arr[i+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-keyword">while</span>(arr[j]&gt;=arr[i]||arr[j]==arr[j<span class="hljs-number">-1</span>])<br>                    --j;<br>                <span class="hljs-built_in">swap</span>(arr[i],arr[j]);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多边形三角剖分的最低得分</title>
    <link href="/2023/04/02/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/"/>
    <url>/2023/04/02/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86">多边形三角剖分的最低得分</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="多边形三角剖分的最低得分"><a class="markdownIt-Anchor" href="#多边形三角剖分的最低得分"></a> 多边形三角剖分的最低得分</h2><p><a href="https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你有一个凸的 n 边形，其每个顶点都有一个整数值。给定一个整数数组 values ，其中 values[i] 是第 i 个顶点的值（即 顺时针顺序 ）。</p><p>假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和。</p><p>返回 多边形进行三角剖分后可以得到的最低分 。<br />e.g.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：values = [3,7,4,5]<br>输出：144<br>解释：有两种三角剖分，可能得分分别为：3<span class="hljs-number">*7</span><span class="hljs-number">*5</span> + 4<span class="hljs-number">*5</span><span class="hljs-number">*7</span> = 245，或 3<span class="hljs-number">*4</span><span class="hljs-number">*5</span> + 3<span class="hljs-number">*4</span><span class="hljs-number">*7</span> = 144。最低分数为 144。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>对于顶点<code>i~j</code>，可以选取中间的顶点<code>k(i&lt;k&lt;j)</code>,这3个点会将多边形分为3部分，其中i,j,k组成的是三角形，其余两部分形状不确定，因此可以用递归的方式对其余两部分再进行划分，这样就可以得出顶点<code>i~j</code>之间剖分成三角形的最低分数，在递归的过程中，可以用记忆化搜索来跳过已经计算过的区间。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minScoreTriangulation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; values)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=values.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">m</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; dfs=[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)-&gt;<span class="hljs-type">int</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(m[i][j]||i+<span class="hljs-number">1</span>==j)<br>                <span class="hljs-keyword">return</span> m[i][j];<br>            <span class="hljs-type">int</span> res=INT_MAX;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i+<span class="hljs-number">1</span>;k&lt;j;++k)<br>                res=<span class="hljs-built_in">min</span>(res,<span class="hljs-built_in">dfs</span>(i,k)+<span class="hljs-built_in">dfs</span>(k,j)+values[i]*values[k]*values[j]);<br>            m[i][j]=res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>统计字典序元音字符串的数目</title>
    <link href="/2023/03/29/%E7%BB%9F%E8%AE%A1%E5%AD%97%E5%85%B8%E5%BA%8F%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <url>/2023/03/29/%E7%BB%9F%E8%AE%A1%E5%AD%97%E5%85%B8%E5%BA%8F%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BB%9F%E8%AE%A1%E5%AD%97%E5%85%B8%E5%BA%8F%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE">统计字典序元音字符串的数目</a></li><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul><!-- /TOC --><h2 id="统计字典序元音字符串的数目"><a class="markdownIt-Anchor" href="#统计字典序元音字符串的数目"></a> 统计字典序元音字符串的数目</h2><p><a href="https://leetcode.cn/problems/count-sorted-vowel-strings/description/">原题</a></p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。</p><p>字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">15</span><br>解释：仅由元音组成的 <span class="hljs-number">15</span> 个字典序字符串为<br>[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;ai&quot;</span>,<span class="hljs-string">&quot;ao&quot;</span>,<span class="hljs-string">&quot;au&quot;</span>,<span class="hljs-string">&quot;ee&quot;</span>,<span class="hljs-string">&quot;ei&quot;</span>,<span class="hljs-string">&quot;eo&quot;</span>,<span class="hljs-string">&quot;eu&quot;</span>,<span class="hljs-string">&quot;ii&quot;</span>,<span class="hljs-string">&quot;io&quot;</span>,<span class="hljs-string">&quot;iu&quot;</span>,<span class="hljs-string">&quot;oo&quot;</span>,<span class="hljs-string">&quot;ou&quot;</span>,<span class="hljs-string">&quot;uu&quot;</span>]<br>注意，<span class="hljs-string">&quot;ea&quot;</span> 不是符合题意的字符串，因为 <span class="hljs-string">&#x27;e&#x27;</span> 在字母表中的位置比 <span class="hljs-string">&#x27;a&#x27;</span> 靠后<br></code></pre></td></tr></table></figure><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>看到了一个很简洁的思路，😢，主要需要考虑分别以5个字母结尾的个数，对于长度为n的字符串，如果要满足按字典序排列，以a结尾的个数只有1个，而以e结尾的个数等于前一位以a结尾的数目加上以e结尾的数目，即<code>e=a+e</code>，以此类推。。。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    int countVowelStrings(int n) &#123;<br>        int <span class="hljs-attribute">a</span>=1,e=1,i=1,o=1,u=1;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">k</span>=1;k&lt;n;++k)<br>        &#123;<br>            <span class="hljs-attribute">e</span>=a+e;<br>            <span class="hljs-attribute">i</span>=e+i;<br>            <span class="hljs-attribute">o</span>=i+o;<br>            <span class="hljs-attribute">u</span>=o+u;<br>        &#125;<br>        return a+e+i+o+u;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最短公共超序列</title>
    <link href="/2023/03/28/%E6%9C%80%E7%9F%AD%E5%85%AC%E5%85%B1%E8%B6%85%E5%BA%8F%E5%88%97/"/>
    <url>/2023/03/28/%E6%9C%80%E7%9F%AD%E5%85%AC%E5%85%B1%E8%B6%85%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E7%9F%AD%E5%85%AC%E5%85%B1%E8%B6%85%E5%BA%8F%E5%88%97">最短公共超序列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最短公共超序列"><a class="markdownIt-Anchor" href="#最短公共超序列"></a> 最短公共超序列</h2><p><a href="https://leetcode.cn/problems/shortest-common-supersequence/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给出两个字符串 str1 和 str2，返回同时以 str1 和 str2 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。</p><p>（如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 任意位置），可以得到字符串 S，那么 S 就是 T 的子序列）</p><p>e.g.</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">输入：str1 = <span class="hljs-string">&quot;abac&quot;</span>, str2 = <span class="hljs-string">&quot;cab&quot;</span><br>输出：<span class="hljs-string">&quot;cabac&quot;</span><br>解释：<br>str1 = <span class="hljs-string">&quot;abac&quot;</span> 是 <span class="hljs-string">&quot;cabac&quot;</span> 的一个子串，因为我们可以删去 <span class="hljs-string">&quot;cabac&quot;</span> 的第一个 <span class="hljs-string">&quot;c&quot;</span>得到 <span class="hljs-string">&quot;abac&quot;</span>。 <br>str2 = <span class="hljs-string">&quot;cab&quot;</span> 是 <span class="hljs-string">&quot;cabac&quot;</span> 的一个子串，因为我们可以删去 <span class="hljs-string">&quot;cabac&quot;</span> 末尾的 <span class="hljs-string">&quot;ac&quot;</span> 得到 <span class="hljs-string">&quot;cab&quot;</span>。<br>最终我们给出的答案是满足上述属性的最短字符串<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>如果想要构成的超序列最短，那么公共的子串部分就要尽可能长，因此先求两个字符串最长公共子串的dp数组。得到之后需要构造最短公共超序列，若要满足最短条件，那么公共部分就要尽可能长，因此从右至左选择字符时，当<code>str[i]==str[j]</code>，同时<code>--i;--j</code>，如果不相等，则优先选择不会损失dp数组的字符，例如如果<code>dp[i-1][j]&gt;dp[i][j-1]</code>，说明选择str1[i]不会损失dp数组，也就是不会影响当当前位置的最长公共子串，因此选择str1[i]。当有一个字符串先到达左端点时退出循环，然后构造剩余部分即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    string shortestCommonSupersequence(string str1, string str2) &#123;<br>        int m=str1.size(),n=str2.size();<br>        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1));<br>        for(int i=1;i&lt;=m;++i)<br>        &#123;<br>            for(int j=1;j&lt;=n;++j)<br>            &#123;<br>                if(str1<span class="hljs-comment">[i-1]</span>==str2<span class="hljs-comment">[j-1]</span>)<br>                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>+1;<br>                else<br>                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>);<br>            &#125;<br>        &#125;<br>        string res;<br>        int i=m,j=n;<br>        while(i&gt;0&amp;&amp;j&gt;0)<br>        &#123;<br>            if(str1<span class="hljs-comment">[i-1]</span>==str2<span class="hljs-comment">[j-1]</span>)<br>            &#123;<br>                res+=str1<span class="hljs-comment">[i-1]</span>;<br>                --i;<br>                --j;<br>            &#125;<br>            else if(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>&gt;dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>)<br>            &#123;<br>                res+=str1<span class="hljs-comment">[i-1]</span>;<br>                --i;<br>            &#125;<br>            else<br>            &#123;<br>                res+=str2<span class="hljs-comment">[j-1]</span>;<br>                --j;<br>            &#125;<br>        &#125;<br>        while(i&gt;0)<br>        &#123;<br>            res+=str1<span class="hljs-comment">[i-1]</span>;<br>            --i;<br>        &#125;<br>        while(j&gt;0)<br>        &#123;<br>            res+=str2<span class="hljs-comment">[j-1]</span>;<br>            --j;<br>        &#125;<br>        reverse(res.begin(),res.end());<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>无矛盾的最佳球队</title>
    <link href="/2023/03/22/%E6%97%A0%E7%9F%9B%E7%9B%BE%E7%9A%84%E6%9C%80%E4%BD%B3%E7%90%83%E9%98%9F/"/>
    <url>/2023/03/22/%E6%97%A0%E7%9F%9B%E7%9B%BE%E7%9A%84%E6%9C%80%E4%BD%B3%E7%90%83%E9%98%9F/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%97%A0%E7%9F%9B%E7%9B%BE%E7%9A%84%E6%9C%80%E4%BD%B3%E7%90%83%E9%98%9F">无矛盾的最佳球队</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="无矛盾的最佳球队"><a class="markdownIt-Anchor" href="#无矛盾的最佳球队"></a> 无矛盾的最佳球队</h2><p><a href="https://leetcode.cn/problems/best-team-with-no-conflicts/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 总和 。</p><p>然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 没有矛盾 的球队。如果一名年龄较小球员的分数 严格大于 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。</p><p>给你两个列表 scores 和 ages，其中每组 scores[i] 和 ages[i] 表示第 i 名球员的分数和年龄。请你返回 所有可能的无矛盾球队中得分最高那支的分数 。</p><p>e.g.</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：scores = <span class="hljs-string">[1,3,5,10,15]</span>, ages = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-number">34</span><br>解释：你可以选中所有球员。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>首先对所有人按照分数升序排序，<code>dp[i]</code>表示选择到第<code>i</code>名球员时的最大分数，对于球员<code>i</code>,需要找到<code>j</code>满足<code>j</code>的年龄小于<code>i</code>且<code>j&lt;i</code>，并且<code>dp[j]</code>是所有<code>i</code>之前且年龄小于<code>i</code>的球员的最大分数，因此<code>dp[i]=dp[j]+score[i]</code>，然后更新答案即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bestTeamScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; scores, vector&lt;<span class="hljs-type">int</span>&gt;&amp; ages)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=scores.<span class="hljs-built_in">size</span>();<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; v;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>            v.<span class="hljs-built_in">push_back</span>(&#123;scores[i],ages[i]&#125;);<br>        <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;--j)<br>                <span class="hljs-keyword">if</span>(v[j].second&lt;=v[i].second)<br>                dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[j]);<br>            <br>            dp[i]+=v[i].first;<br>            ans=<span class="hljs-built_in">max</span>(ans,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分割得到字符串</title>
    <link href="/2023/03/18/%E5%88%86%E5%89%B2%E5%BE%97%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/03/18/%E5%88%86%E5%89%B2%E5%BE%97%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%88%86%E5%89%B2%E5%BE%97%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2">分割得到字符串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="分割得到字符串"><a class="markdownIt-Anchor" href="#分割得到字符串"></a> 分割得到字符串</h2><p><a href="https://leetcode.cn/problems/split-two-strings-to-make-palindrome/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a = aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b = bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。</p><p>当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s = “abc” 那么 “” + “abc” ， “a” + “bc” ， “ab” + “c” 和 “abc” + “” 都是合法分割。</p><p>如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。</p><p>注意， x + y 表示连接字符串 x 和 y 。</p><p>e.g.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：<span class="hljs-keyword">a</span> = <span class="hljs-string">&quot;abdef&quot;</span>, b = <span class="hljs-string">&quot;fecab&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>使用双指针的思想，分取a的前缀和取b前缀两种情况，但是处理方式相同。以取a前缀为例，首先分别从a左端和b右端开始比较，如果<code>a[l]==b[r]</code>,那么<code>++l,--r</code>，直到不相等或者<code>l&gt;=r</code>为止，如果<code>l&gt;=r</code>说明在中间位置分割可满足要求，直接返回<code>true</code>;如果是不相等的情况，则需要判断是以l还是r为分割点，并判断l~r之间的子串是否回文，如果满足要求即可返回<code>true</code>。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">checksub</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> a,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;a[l]==a[r])<br>        &#123;<br>            ++l;--r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l&gt;=r;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">check</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> a,<span class="hljs-built_in">string</span> b,<span class="hljs-built_in">int</span> n</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;a[l]==b[r])<br>        &#123;<br>            ++l;--r;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l&gt;=r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> checksub(a,l,r)||checksub(b,l,r);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">checkPalindromeFormation</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n=a.size();<br>        <span class="hljs-keyword">return</span> check(a,b,n)||check(b,a,n);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>统计中位数为K的子数组</title>
    <link href="/2023/03/16/%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2023/03/16/%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">统计中位数为 K 的子数组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="统计中位数为-k-的子数组"><a class="markdownIt-Anchor" href="#统计中位数为-k-的子数组"></a> 统计中位数为 K 的子数组</h2><p><a href="https://leetcode.cn/problems/count-subarrays-with-median-k/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 不同 整数组成。另给你一个正整数 k 。</p><p>统计并返回 nums 中的 中位数 等于 k 的非空子数组的数目。</p><p>注意：</p><p>数组的中位数是按 递增 顺序排列后位于 中间 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 左 的那个元素。<br />例如，[2,3,1,4] 的中位数是 2 ，[8,4,3,5,1] 的中位数是 4 。<br />子数组是数组中的一个连续部分。</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1,4,5]</span>, k = 4<br>输出：3<br>解释：中位数等于 4 的子数组有：<span class="hljs-comment">[4]</span>、<span class="hljs-comment">[4,5]</span> 和 <span class="hljs-comment">[1,4,5]</span> 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>首先找出<code>k</code>在数组中的位置<code>idx</code>，对于每个数，大于<code>k</code>记为1,否则为-1，统计每个位置前缀和。如果下标<code>l</code>处与<code>r</code>处的前缀和之差为0或1,那么说明<code>[l+1,r]</code>范围内的子数组元素和为0或1,那么<code>k</code>就是该子数组的中位数。在统计相同前缀和个数时，用哈系表记录前缀和出现的次数，然后对符合要求的位置累加即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> judge(<span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a&gt;b)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a&lt;b)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">int</span> countSubarrays(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> n=nums.size();<br>        <span class="hljs-built_in">int</span> idx=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==k)<br>            &#123;<br>                idx=i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt; mp;<br>        mp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            sum+=judge(nums[i],k);<br>            <span class="hljs-keyword">if</span>(i&lt;idx)<br>                ++mp[sum];<br>            <span class="hljs-keyword">else</span><br>                ans+=mp[sum]+mp[sum<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>给定行和列的和求可行矩阵</title>
    <link href="/2023/03/14/%E7%BB%99%E5%AE%9A%E8%A1%8C%E5%92%8C%E5%88%97%E7%9A%84%E5%92%8C%E6%B1%82%E5%8F%AF%E8%A1%8C%E7%9F%A9%E9%98%B5/"/>
    <url>/2023/03/14/%E7%BB%99%E5%AE%9A%E8%A1%8C%E5%92%8C%E5%88%97%E7%9A%84%E5%92%8C%E6%B1%82%E5%8F%AF%E8%A1%8C%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BB%99%E5%AE%9A%E8%A1%8C%E5%92%8C%E5%88%97%E7%9A%84%E5%92%8C%E6%B1%82%E5%8F%AF%E8%A1%8C%E7%9F%A9%E9%98%B5">给定行和列的和求可行矩阵</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="给定行和列的和求可行矩阵"><a class="markdownIt-Anchor" href="#给定行和列的和求可行矩阵"></a> 给定行和列的和求可行矩阵</h2><p><a href="https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你两个非负整数数组 rowSum 和 colSum ，其中 rowSum[i] 是二维矩阵中第 i 行元素的和， colSum[j] 是第 j 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。</p><p>请找到大小为 rowSum.length x colSum.length 的任意 非负整数 矩阵，且该矩阵满足 rowSum 和 colSum 的要求。</p><p>请你返回任意一个满足题目要求的二维矩阵，题目保证存在 至少一个 可行矩阵。<br />e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：rowSum = <span class="hljs-comment">[3,8]</span>, colSum = <span class="hljs-comment">[4,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3,0]</span>,</span><br><span class="hljs-comment">      <span class="hljs-comment">[1,7]</span>]</span><br>解释：<br>第 0 行：3 + 0 = 3 == rowSum<span class="hljs-comment">[0]</span><br>第 1 行：1 + 7 = 8 == rowSum<span class="hljs-comment">[1]</span><br>第 0 列：3 + 1 = 4 == colSum<span class="hljs-comment">[0]</span><br>第 1 列：0 + 7 = 7 == colSum<span class="hljs-comment">[1]</span><br>行和列的和都满足题目要求，且所有矩阵元素都是非负的。<br>另一个可行的矩阵为：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">                  <span class="hljs-comment">[3,5]</span>]</span><br><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>矩阵每行和每列的最大值已知，那么每次填的时候选择<code>min(rowsum[i],colsum[j])</code>，这样被选择的某行/列后续的值都为0,每填一个位置后，还要更新rowsum或者colsum，这样一共需填<code>m+n-1个值</code>，其余位置都为0。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">restoreMatrix</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; rowSum, vector&lt;<span class="hljs-type">int</span>&gt;&amp; colSum) &#123;<br>        <span class="hljs-type">int</span> m=rowSum.<span class="hljs-built_in">size</span>(),n=colSum.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;m&amp;&amp;j&lt;n)<br>        &#123;<br>            <span class="hljs-type">int</span> r=rowSum[i],c=colSum[j];<br>            <span class="hljs-keyword">if</span>(r&lt;=c)<br>            &#123;<br>                colSum[j]-=r;<br>                ans[i++][j]=r;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                rowSum[i]-=c;<br>                ans[i][j++]=c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字母与数字</title>
    <link href="/2023/03/11/%E5%AD%97%E6%AF%8D%E4%B8%8E%E6%95%B0%E5%AD%97/"/>
    <url>/2023/03/11/%E5%AD%97%E6%AF%8D%E4%B8%8E%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%AD%97%E6%AF%8D%E4%B8%8E%E6%95%B0%E5%AD%97">字母与数字</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="字母与数字"><a class="markdownIt-Anchor" href="#字母与数字"></a> 字母与数字</h2><p><a href="https://leetcode.cn/problems/find-longest-subarray-lcci/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。</p><p>返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。</p><p>e.g.</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less">输入: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>,<span class="hljs-string">&quot;M&quot;</span>]</span><br><br>输出: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用到前缀和的思想，当元素为字母时加1，为数字时减1，当<code>i</code>和<code>j</code>位置处的前缀和相等，说明他们之间的子数组满足要求。用哈系表保存每一个前缀和的值第一次出现时对应的数组下标，并遍历数组，如果前缀和的值已经出现过，那么记录子数组的起始位置，更新最大长度，否则在哈系表中记录该下标。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">vector</span>&lt;string&gt; findLongestSubarray(<span class="hljs-type">vector</span>&lt;string&gt;&amp; <span class="hljs-type">array</span>) &#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        mp[<span class="hljs-number">0</span>]=-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span>,maxlen=<span class="hljs-number">0</span>,start=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n=<span class="hljs-type">array</span>.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(isalpha(<span class="hljs-type">array</span>[i][<span class="hljs-number">0</span>]))<br>                ++<span class="hljs-built_in">sum</span>;<br>            <span class="hljs-keyword">else</span><br>                --<span class="hljs-built_in">sum</span>;<br>            <span class="hljs-keyword">if</span>(mp.count(<span class="hljs-built_in">sum</span>))<br>            &#123;<br>                <span class="hljs-type">int</span> preidx=mp[<span class="hljs-built_in">sum</span>];<br>                <span class="hljs-keyword">if</span>(i-preidx&gt;maxlen)<br>                &#123;<br>                    maxlen=i-preidx;<br>                    start=preidx+<span class="hljs-number">1</span>;<br>                &#125;    <br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                mp[<span class="hljs-built_in">sum</span>]=i;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(maxlen==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-type">vector</span>&lt;string&gt;(<span class="hljs-type">array</span>.begin()+start,<span class="hljs-type">array</span>.begin()+start+maxlen);<br>    &#125;   <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使数组和能被P整除</title>
    <link href="/2023/03/10/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%ABP%E6%95%B4%E9%99%A4/"/>
    <url>/2023/03/10/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%ABP%E6%95%B4%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%AB-p-%E6%95%B4%E9%99%A4">使数组和能被 P 整除</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="使数组和能被-p-整除"><a class="markdownIt-Anchor" href="#使数组和能被-p-整除"></a> 使数组和能被 P 整除</h2><p><a href="https://leetcode.cn/problems/make-sum-divisible-by-p/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。</p><p>请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。</p><p>子数组 定义为原数组中连续的一组元素。</p><p>e.g.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[3,1,4,2]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">6</span><br>输出：<span class="hljs-number">1</span><br>解释：nums 中元素和为 <span class="hljs-number">10</span>，不能被 <span class="hljs-selector-tag">p</span> 整除。我们可以移除子数组 <span class="hljs-selector-attr">[4]</span> ，剩余元素的和为 <span class="hljs-number">6</span> <br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>设整个数组的和对p取模的值为<code>x</code>，前缀和(经过取模处理)数组为<code>sum</code>，若要满足去掉<code>nums[i]~nums[j]</code>之间的数后，剩下的数之和能被p整除，则满足<code>(sum[j]-x+p)%p==sum[i]</code>,为了计算最短长度，还需要用哈系表记录当前位置<code>sum[j]</code>的下标j，在代码实现时，<code>sum</code>数组可以通过维护一个整型值代替。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> minSubarray(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> p) &#123;<br>        <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a:nums)<br>            x=(x+a)%p;<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; idx;<br>        <span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>,res=nums.<span class="hljs-keyword">size</span>(),n=nums.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            idx[y]=i;<br>            y=(y+nums[i])%p;<br>            <span class="hljs-keyword">if</span>(idx.count((y-x+p)%p)&gt;<span class="hljs-number">0</span>)<br>                res=<span class="hljs-keyword">min</span>(res,i-idx[(y-x+p)%p]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res==n?<span class="hljs-number">-1</span>:res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>花括号展开</title>
    <link href="/2023/03/07/%E8%8A%B1%E6%8B%AC%E5%8F%B7%E5%B1%95%E5%BC%80/"/>
    <url>/2023/03/07/%E8%8A%B1%E6%8B%AC%E5%8F%B7%E5%B1%95%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<h2 id="花括号展开"><a class="markdownIt-Anchor" href="#花括号展开"></a> 花括号展开</h2><p><a href="https://leetcode.cn/problems/brace-expansion-ii/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。<br />花括号展开的表达式可以看作一个由 花括号、逗号 和 小写英文字母 组成的字符串，定义下面几条语法规则：<br />如果只给出单一的元素 x，那么表达式表示的字符串就只有 <code>&quot;x&quot;</code>。<code>R(x) = &#123;x&#125;</code><br />例如，表达式 <code>&quot;a&quot;</code> 表示字符串 <code>&quot;a&quot;</code>。<br />而表达式 <code>&quot;w&quot;</code> 就表示字符串 <code>&quot;w&quot;</code>。<br />当两个或多个表达式并列，以逗号分隔，我们取这些表达式中元素的并集。<code>R(&#123;e_1,e_2,...&#125;) = R(e_1) ∪ R(e_2) ∪ ...</code><br />例如，表达式 <code>&quot;&#123;a,b,c&#125;&quot;</code> 表示字符串 <code>&quot;a&quot;,``&quot;b&quot;</code>,<code>&quot;c&quot;</code>。<br />而表达式 <code>&quot;&#123;&#123;a,b&#125;,&#123;b,c&#125;&#125;&quot;</code> 也可以表示字符串 <code>&quot;a&quot;</code>,<code>&quot;b&quot;</code>,<code>&quot;c&quot;</code>。<br />要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。<code>R(e_1 + e_2) = &#123;a + b for (a, b) in R(e_1) × R(e_2)&#125;</code><br />例如，表达式 <code>&quot;&#123;a,b&#125;&#123;c,d&#125;&quot;</code> 表示字符串 <code>&quot;ac&quot;,&quot;ad&quot;,&quot;bc&quot;,&quot;bd&quot;</code>。<br />表达式之间允许嵌套，单一元素与表达式的连接也是允许的。<br />例如，表达式 <code>&quot;a&#123;b,c,d&#125;&quot;</code> 表示字符串 <code>&quot;ab&quot;,&quot;ac&quot;,&quot;ad&quot;​​​​​​</code>。<br />例如，表达式 <code>&quot;a&#123;b,c&#125;&#123;d,e&#125;f&#123;g,h&#125;&quot;</code> 可以表示字符串 <code>&quot;abdfg&quot;, &quot;abdfh&quot;, &quot;abefg&quot;, &quot;abefh&quot;, &quot;acdfg&quot;, &quot;acdfh&quot;, &quot;acefg&quot;, &quot;acefh&quot;</code>。<br />给出表示基于给定语法规则的表达式 expression，返回它所表示的所有字符串组成的有序列表。</p><p>e.g.</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">输入：<span class="hljs-keyword">expression</span> = <span class="hljs-string">&quot;&#123;a,b&#125;&#123;c,&#123;d,e&#125;&#125;&quot;</span><br>输出：[<span class="hljs-string">&quot;ac&quot;</span>,<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;bc&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题可以用类似中缀表达式求值的做法，把并列操作看作<code>+</code>，把组合操作看作<code>*</code>，需要建立两个栈，一个用来保存运算符，一个用来保存已有集合，然后分情况讨论：</p><ul><li>如果当前字符为<code>&#123;</code>，如果上一个字符为<code>&#125;</code>或者字母，则运算符栈先加入<code>*</code>再加入<code>&#123;</code></li><li>如果当前字符为<code>,</code>，如果运算符栈顶为<code>*</code>，那么不断弹出元素并计算，直到栈顶不是<code>*</code>，然后加入<code>+</code></li><li>如果为<code>&#125;</code>，则不断弹出元素并计算，直到遇到<code>&#123;</code>为止，并将左括号也弹出</li><li>如果为字母，如果上一个字符为<code>&#125;</code>或者字母，则运算符栈先加入<code>*</code>，再将字母单独构造成一个集合，加入集合栈</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">vector</span>&lt;char&gt; op;<br>    <span class="hljs-keyword">vector</span>&lt;set&lt;<span class="hljs-keyword">string</span>&gt;&gt; e;<br>    <span class="hljs-comment">//弹出栈顶两个元素并计算</span><br>    void compute()<br>    &#123;<br>        <span class="hljs-keyword">int</span> r=e.<span class="hljs-keyword">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> l=r<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(op.back()==<span class="hljs-string">&#x27;+&#x27;</span>)<br>            e[l].merge(e[r]);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            set&lt;<span class="hljs-keyword">string</span>&gt; tmp;<br>            <span class="hljs-keyword">for</span>(auto&amp; a:e[l])<br>            &#123;<br>                <span class="hljs-keyword">for</span>(auto&amp; b:e[r])<br>                    tmp.insert(a+b);<br>            &#125;<br>            e[l]=<span class="hljs-keyword">move</span>(tmp);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">string</span>&gt; braceExpansionII(<span class="hljs-keyword">string</span> <span class="hljs-keyword">expression</span>) &#123;<br>        <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <br>        <span class="hljs-keyword">int</span> n=<span class="hljs-keyword">expression</span>.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">expression</span>[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;(<span class="hljs-keyword">expression</span>[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;&#125;&#x27;</span>||isalpha(<span class="hljs-keyword">expression</span>[i<span class="hljs-number">-1</span>])))<br>                    op.push_back(<span class="hljs-string">&#x27;*&#x27;</span>);<br>                op.push_back(<span class="hljs-string">&#x27;&#123;&#x27;</span>);   <br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">expression</span>[i]==<span class="hljs-string">&#x27;,&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">while</span>(op.<span class="hljs-keyword">size</span>()&amp;&amp;op.back()==<span class="hljs-string">&#x27;*&#x27;</span>)<br>                &#123;<br>                    compute();<br>                    op.pop_back();<br>                    e.pop_back();<br>                &#125;<br>                op.push_back(<span class="hljs-string">&#x27;+&#x27;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">expression</span>[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">while</span>(op.<span class="hljs-keyword">size</span>()&amp;&amp;op.back()!=<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>                &#123;<br>                    compute();<br>                    op.pop_back();<br>                    e.pop_back();<br>                &#125;<br>                op.pop_back();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                set&lt;<span class="hljs-keyword">string</span>&gt; tmp;<br>                <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;(<span class="hljs-keyword">expression</span>[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;&#125;&#x27;</span>||isalpha(<span class="hljs-keyword">expression</span>[i<span class="hljs-number">-1</span>])))<br>                    op.push_back(<span class="hljs-string">&#x27;*&#x27;</span>);<br>                <span class="hljs-keyword">string</span> s;<br>                s+=<span class="hljs-keyword">expression</span>[i];<br>                tmp.insert(s);<br>                e.push_back(tmp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(op.<span class="hljs-keyword">size</span>())<br>        &#123;<br>            compute();<br>            op.pop_back();<br>            e.pop_back();<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;e.back().begin(),e.back().end()&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使字符串平衡的最少删除次数</title>
    <link href="/2023/03/06/%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0/"/>
    <url>/2023/03/06/%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0">使字符串平衡的最少删除次数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="使字符串平衡的最少删除次数"><a class="markdownIt-Anchor" href="#使字符串平衡的最少删除次数"></a> 使字符串平衡的最少删除次数</h2><p><a href="https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个字符串 s ，它仅包含字符 ‘a’ 和 'b’​​​​ 。</p><p>你可以删除 s 中任意数目的字符，使得 s 平衡 。当不存在下标对 (i,j) 满足 i &lt; j ，且 s[i] = ‘b’ 的同时 s[j]= ‘a’ ，此时认为 s 是 平衡 的。</p><p>请你返回使 s 平衡 的 最少 删除次数。</p><p>e.g.</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;aababbab&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：你可以选择以下任意一种方案：<br>下标从 <span class="hljs-number">0</span> 开始，删除第 <span class="hljs-number">2</span> 和第 <span class="hljs-number">6</span> 个字符（<span class="hljs-string">&quot;aababbab&quot;</span> -&gt; <span class="hljs-string">&quot;aaabbb&quot;</span>），<br>下标从 <span class="hljs-number">0</span> 开始，删除第 <span class="hljs-number">3</span> 和第 <span class="hljs-number">6</span> 个字符（<span class="hljs-string">&quot;aababbab&quot;</span> -&gt; <span class="hljs-string">&quot;aabbbb&quot;</span>）。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>参考了灵神的思路，tql😆<br />首先要遍历一遍记录字符<code>a</code>的个数cnt，然后遍历分割点，如果是<code>a</code>则cnt-1，否则cnt+1，这个过程中cnt最小值即为最小的删除次数，这个过程，其实相当于统计分割点左边<code>b</code>的个数和右边<code>a</code>的个数，也就是满足题意的最少删除次数。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">minimumDeletions</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">char</span> c:s)<br>            cnt+=<span class="hljs-string">&#x27;b&#x27;</span>-c;<br>        ans=cnt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">char</span> c:s)<br>        &#123;<br>            cnt+=(c-<span class="hljs-string">&#x27;a&#x27;</span>)*<span class="hljs-number">2</span><span class="hljs-number">-1</span>;<br>            ans=min(ans,cnt);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运营摩天轮</title>
    <link href="/2023/03/05/%E8%BF%90%E8%90%A5%E6%91%A9%E5%A4%A9%E8%BD%AE/"/>
    <url>/2023/03/05/%E8%BF%90%E8%90%A5%E6%91%A9%E5%A4%A9%E8%BD%AE/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%BF%90%E8%90%A5%E6%91%A9%E5%A4%A9%E8%BD%AE">运营摩天轮</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="运营摩天轮"><a class="markdownIt-Anchor" href="#运营摩天轮"></a> 运营摩天轮</h2><p><a href="https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 runningCost 。摩天轮每次轮转都恰好转动 1 / 4 周。</p><p>给你一个长度为 n 的数组 customers ， customers[i] 是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 boardingCost ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。</p><p>你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，将免费进行所有后续轮转 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。</p><p>返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。</p><p>e.g.</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：customers = [8,3], boardingCost = 5, runningCost = 6<br>输出：3<br>解释：座舱上标注的数字是该座舱的当前游客数。<br>1.<span class="hljs-number"> 8 </span>位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为<span class="hljs-number"> 4 </span>* $5 -<span class="hljs-number"> 1 </span>* $6 = $14 。<br>2.<span class="hljs-number"> 3 </span>位游客抵达，4 位在等待的游客登舱，其他<span class="hljs-number"> 3 </span>位等待，摩天轮轮转。当前利润为<span class="hljs-number"> 8 </span>* $5 -<span class="hljs-number"> 2 </span>* $6 = $28 。<br>3. 最后<span class="hljs-number"> 3 </span>位游客登舱，摩天轮轮转。当前利润为<span class="hljs-number"> 11 </span>* $5 -<span class="hljs-number"> 3 </span>* $6 = $37 。<br>轮转<span class="hljs-number"> 3 </span>次得到最大利润，最大利润为 $37 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>模拟摩天轮的运营过程，首先记录每次到来的人数<code>come</code>和排队人数<code>wait</code>，当二者之和大于4,统计收入，然后更新排队人数，当二者之和小于，统计收入，排队人数清零，每一轮过后减去运营成本，并更新最大利润即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> minOperationsMaxProfit(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; customers, <span class="hljs-built_in">int</span> boardingCost, <span class="hljs-built_in">int</span> runningCost) &#123;<br>        <span class="hljs-built_in">int</span> n=customers.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">int</span> ans=-<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> come=<span class="hljs-number">0</span>,<span class="hljs-keyword">wait</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span>,<span class="hljs-built_in">max</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;n||<span class="hljs-keyword">wait</span>&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;=n)<br>                come=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                come=customers[i];<br>            <br>            <span class="hljs-keyword">if</span>(come+<span class="hljs-keyword">wait</span>&gt;<span class="hljs-number">4</span>)<br>            &#123;<br>                <span class="hljs-built_in">sum</span>+=boardingCost*<span class="hljs-number">4</span>;<br>                <span class="hljs-keyword">wait</span>=come+<span class="hljs-keyword">wait</span>-<span class="hljs-number">4</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">sum</span>+=(come+<span class="hljs-keyword">wait</span>)*boardingCost;<br>                <span class="hljs-keyword">wait</span>=<span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-built_in">sum</span>-=runningCost;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span>&gt;<span class="hljs-built_in">max</span>)<br>            &#123;<br>                ans=i+<span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">max</span>=<span class="hljs-built_in">sum</span>;<br>            &#125;<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>按位与为0的三元组</title>
    <link href="/2023/03/04/%E6%8C%89%E4%BD%8D%E4%B8%8E%E4%B8%BA0%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84/"/>
    <url>/2023/03/04/%E6%8C%89%E4%BD%8D%E4%B8%8E%E4%B8%BA0%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8C%89%E4%BD%8D%E4%B8%8E%E4%B8%BA0%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84">按位与为0的三元组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="按位与为0的三元组"><a class="markdownIt-Anchor" href="#按位与为0的三元组"></a> 按位与为0的三元组</h2><p><a href="https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums ，返回其中 按位与三元组 的数目。</p><p>按位与三元组 是由下标 (i, j, k) 组成的三元组，并满足下述全部条件：</p><p>0 &lt;= i &lt; nums.length<br />0 &lt;= j &lt; nums.length<br />0 &lt;= k &lt; nums.length<br />nums[i] &amp; nums[j] &amp; nums[k] == 0 ，其中 &amp; 表示按位与运算符。</p><p>e.g.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：nums = [2,1,3]<br>输出：12<br>解释：可以选出如下 i, j, k 三元组：<br>(<span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">j</span>=0, <span class="hljs-attribute">k</span>=1) : 2 &amp; 2 &amp; 1<br>(<span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">j</span>=1, <span class="hljs-attribute">k</span>=0) : 2 &amp; 1 &amp; 2<br>(<span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">j</span>=1, <span class="hljs-attribute">k</span>=1) : 2 &amp; 1 &amp; 1<br>(<span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">j</span>=1, <span class="hljs-attribute">k</span>=2) : 2 &amp; 1 &amp; 3<br>(<span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">j</span>=2, <span class="hljs-attribute">k</span>=1) : 2 &amp; 3 &amp; 1<br>(<span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">j</span>=0, <span class="hljs-attribute">k</span>=0) : 1 &amp; 2 &amp; 2<br>(<span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">j</span>=0, <span class="hljs-attribute">k</span>=1) : 1 &amp; 2 &amp; 1<br>(<span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">j</span>=0, <span class="hljs-attribute">k</span>=2) : 1 &amp; 2 &amp; 3<br>(<span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">j</span>=1, <span class="hljs-attribute">k</span>=0) : 1 &amp; 1 &amp; 2<br>(<span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">j</span>=2, <span class="hljs-attribute">k</span>=0) : 1 &amp; 3 &amp; 2<br>(<span class="hljs-attribute">i</span>=2, <span class="hljs-attribute">j</span>=0, <span class="hljs-attribute">k</span>=1) : 3 &amp; 2 &amp; 1<br>(<span class="hljs-attribute">i</span>=2, <span class="hljs-attribute">j</span>=1, <span class="hljs-attribute">k</span>=0) : 3 &amp; 1 &amp; 2<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题直接枚举的话时间复杂度太高，会超时，因此可以用一个数组记录两个数字相与结果出现的频率，然后遍历第三个数与其相与，如果结果为<code>0</code>，则统计到结果中，具体代码如下。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countTriplets</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a:nums)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b:nums)<br>                ++v[a&amp;b];<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:nums)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(v[k]&amp;&amp;(x&amp;k)==<span class="hljs-number">0</span>)<br>                    ans+=v[k];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>得分最高单词集合</title>
    <link href="/2023/02/26/%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E5%8D%95%E8%AF%8D%E9%9B%86%E5%90%88/"/>
    <url>/2023/02/26/%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E5%8D%95%E8%AF%8D%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E5%8D%95%E8%AF%8D%E9%9B%86%E5%90%88">得分最高单词集合</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="得分最高单词集合"><a class="markdownIt-Anchor" href="#得分最高单词集合"></a> 得分最高单词集合</h2><p><a href="https://leetcode.cn/problems/maximum-score-words-formed-by-letters/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你将会得到一份单词表 words，一个字母表 letters （可能会有重复字母），以及每个字母对应的得分情况表 score。</p><p>请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 letters 里的字母拼写出的 任意 属于 words 单词子集中，分数最高的单词集合的得分。</p><p>单词拼写游戏的规则概述如下：</p><p>玩家需要用字母表 letters 里的字母来拼写单词表 words 中的单词。<br />可以只使用字母表 letters 中的部分字母，但是每个字母最多被使用一次。<br />单词表 words 中每个单词只能计分（使用）一次。<br />根据字母得分情况表score，字母 ‘a’, ‘b’, ‘c’, … , ‘z’ 对应的得分分别为 score[0], score[1], …, score[25]。<br />本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。</p><p>e.g.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：words = [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;dad&quot;</span>,<span class="hljs-string">&quot;good&quot;</span>], letters = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]<br>输出：23<br>解释：<br>字母得分为  <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">c</span>=9, <span class="hljs-attribute">d</span>=5, <span class="hljs-attribute">g</span>=3, <span class="hljs-attribute">o</span>=2<br>使用给定的字母表 letters，我们可以拼写单词 <span class="hljs-string">&quot;dad&quot;</span> (5+1+5)和 <span class="hljs-string">&quot;good&quot;</span> (3+2+2+5)，得分为 23 。<br>而单词 <span class="hljs-string">&quot;dad&quot;</span> 和 <span class="hljs-string">&quot;dog&quot;</span> 只能得到 21 分。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题主要用到状态压缩的思想，对于words中的每个单词，都可以用<code>0/1</code>来表示他是否被使用，比如’<code>110</code>可以表示使用了第二个和第三个单词，假设words中共有<code>n</code>个单词，那么一共有<code>1&lt;&lt;n</code>种状态，需要遍历所有状态。每次遍历时，以此遍历words中的单词，判断是否在当前状态里，如果在的话，统计各个字母出现的次数，每遍历完一个状态，计算一次得分，并更新最高分数即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxScoreWords</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, vector&lt;<span class="hljs-type">char</span>&gt;&amp; letters, vector&lt;<span class="hljs-type">int</span>&gt;&amp; score)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=words.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> &amp; c:letters)<br>            ++cnt[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">1</span>&lt;&lt;n;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;num;++i)<br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>&lt;&lt;j)&amp;i)<br>                &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span>&amp;c:words[j])<br>                        ++t[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">26</span>;++k)<br>            &#123;<br>                sum+=score[k]*t[k];<br>                <span class="hljs-keyword">if</span>(t[k]&gt;cnt[k])<br>                &#123;<br>                    flag=<span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>                ans=<span class="hljs-built_in">max</span>(ans,sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>交换字符使字符串相同</title>
    <link href="/2023/02/25/%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%90%8C/"/>
    <url>/2023/02/25/%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%90%8C">交换字符使字符串相同</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="交换字符使字符串相同"><a class="markdownIt-Anchor" href="#交换字符使字符串相同"></a> 交换字符使字符串相同</h2><p><a href="https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 “x” 和 “y”，你需要通过「交换字符」的方式使这两个字符串相同。</p><p>每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。</p><p>交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。</p><p>最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1</p><p>示例</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;xx&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;yy&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：<br>交换 <span class="hljs-built_in">s1</span>[<span class="hljs-number">0</span>] 和 <span class="hljs-built_in">s2</span>[<span class="hljs-number">1</span>]，得到 <span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;yx&quot;</span>，<span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;yx&quot;</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用xy表示<code>s1[i]=x,s2[i]=y</code>出现的次数，yx同理，这时有两种交换情况</p><ul><li><p>交换一次,使xy或者yx的值减少2,如<code>xx,yy-&gt;yx,yx</code></p></li><li><p>交换两次，使xy和yx各减少1,如<code>xy,yx-&gt;yy,xx-&gt;xy,xy</code></p></li></ul><p>为了尽可能减少交换次数，应当尽量使用第一种方式，同时如果<code>xy+yx</code>为奇数，那么怎么交换也不能相等，因为此时s1和s2两边有奇数个x或y，无法交换使得两个字符串的x和y数量相等。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">minimumSwap</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s1, <span class="hljs-built_in">string</span> s2</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n=s1.size();<br>        <span class="hljs-built_in">int</span> xy=<span class="hljs-number">0</span>,yx=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s1[i]==<span class="hljs-string">&#x27;x&#x27;</span>&amp;&amp;s2[i]==<span class="hljs-string">&#x27;y&#x27;</span>)<br>                ++xy;<br>            <span class="hljs-keyword">if</span>(s1[i]==<span class="hljs-string">&#x27;y&#x27;</span>&amp;&amp;s2[i]==<span class="hljs-string">&#x27;x&#x27;</span>)<br>                ++yx;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((xy+yx)&amp;<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> xy/<span class="hljs-number">2</span>+yx/<span class="hljs-number">2</span>+(xy%<span class="hljs-number">2</span>)*<span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>循环码</title>
    <link href="/2023/02/23/%E5%BE%AA%E7%8E%AF%E7%A0%81/"/>
    <url>/2023/02/23/%E5%BE%AA%E7%8E%AF%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%BE%AA%E7%8E%AF%E7%A0%81">循环码</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="循环码"><a class="markdownIt-Anchor" href="#循环码"></a> 循环码</h2><p><a href="https://leetcode.cn/problems/circular-permutation-in-binary-representation/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你两个整数 n 和 start。你的任务是返回任意 (0,1,2,…,2^n-1) 的排列 p，并且满足：</p><ul><li>p[0] = start</li><li>[i] 和 p[i+1] 的二进制表示形式只有一位不同</li><li>[0] 和 p[2^n -1] 的二进制表示形式也只有一位不同</li></ul><p>示例</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：n = <span class="hljs-number">2</span>, start = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">3,2,0,1</span>]<br>解释：这个排列的二进制表示是 (<span class="hljs-number">11,10,00,01</span>)<br>     所有的相邻元素都有一位是不同的，另一个有效的排列是 [<span class="hljs-number">3,1,0,2</span>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题需要用到规律：<br />对于n位数，可生成<code>1&lt;&lt;n</code>个循环码，每个循环码的表达式为: <code>res[i]=i^(i&gt;&gt;1)</code>,如果要生成从<code>start</code>开始的循环码，则表达式为<code>res[i]=i^(i&gt;&gt;1)^start</code>。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">circularPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;res.<span class="hljs-built_in">size</span>();++i)<br>            res[i]=i^(i&gt;&gt;<span class="hljs-number">1</span>)^start;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>灌溉花园</title>
    <link href="/2023/02/21/%E7%81%8C%E6%BA%89%E8%8A%B1%E5%9B%AD/"/>
    <url>/2023/02/21/%E7%81%8C%E6%BA%89%E8%8A%B1%E5%9B%AD/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%81%8C%E6%BA%89%E8%8A%B1%E5%9B%AD">灌溉花园</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="灌溉花园"><a class="markdownIt-Anchor" href="#灌溉花园"></a> 灌溉花园</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。</p><p>花园里总共有 n + 1 个水龙头，分别位于 [0, 1, …, n] 。</p><p>给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i -  ranges[i], i + ranges[i]] 。</p><p>请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。</p><p>示例</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 5, ranges = <span class="hljs-comment">[3,4,1,1,0,0]</span><br>输出：1<br>解释：<br>点 0 处的水龙头可以灌溉区间 <span class="hljs-comment">[-3,3]</span><br>点 1 处的水龙头可以灌溉区间 <span class="hljs-comment">[-3,5]</span><br>点 2 处的水龙头可以灌溉区间 <span class="hljs-comment">[1,3]</span><br>点 3 处的水龙头可以灌溉区间 <span class="hljs-comment">[2,4]</span><br>点 4 处的水龙头可以灌溉区间 <span class="hljs-comment">[4,4]</span><br>点 5 处的水龙头可以灌溉区间 <span class="hljs-comment">[5,5]</span><br>只需要打开点 1 处的水龙头即可灌溉整个花园 <span class="hljs-comment">[0,5]</span> 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>动态规划，用<code>dp[i]</code>表示<code>0～i</code>之间最少的水龙头数量，首先计算每个水龙头对应的覆盖范围<code>(l,r)</code>，并按照左区间升序排序。初始化dp数组的值为INT_MAX，接下来对每个水龙头的范围进行遍历，更新dp。在遍历时，对于位置<code>i(l&lt;=i&lt;=r)</code>，<code>l~r</code>位置的已经被覆盖，所以需要关注<code>0~l</code>位置，所以状态方程为<code>dp[i]=min(dp[i],1+dp[l])</code>，如果某个范围的<code>dp[l]=INT_MAX</code>，说明<code>l</code>位置永远无法被覆盖，直接返回-1即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minTaps</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; ranges)</span> </span>&#123;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; v;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> l=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,i-ranges[i]);<br>            <span class="hljs-type">int</span> r=<span class="hljs-built_in">min</span>(n,i+ranges[i]);<br>            v.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; t:v)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(dp[t.first]==INT_MAX)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=t.first;i&lt;=t.second;++i)<br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i],<span class="hljs-number">1</span>+dp[t.first]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大平均通过率</title>
    <link href="/2023/02/19/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E9%80%9A%E8%BF%87%E7%8E%87/"/>
    <url>/2023/02/19/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E9%80%9A%E8%BF%87%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E9%80%9A%E8%BF%87%E7%8E%87">最大平均通过率</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最大平均通过率"><a class="markdownIt-Anchor" href="#最大平均通过率"></a> 最大平均通过率</h2><p><a href="https://leetcode.cn/problems/maximum-average-pass-ratio/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passi, totali] ，表示你提前知道了第 i 个班级总共有 totali 个学生，其中只有 passi 个学生可以通过考试。</p><p>给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。</p><p>一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率 是所有班级的通过率之和除以班级数目。</p><p>请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-5 以内的结果都会视为正确结果。</p><p>示例</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：classes = <span class="hljs-string">[[1,2],[3,5],[2,2]]</span>, extraStudents = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">0.78333</span><br>解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (<span class="hljs-number">3</span>/<span class="hljs-number">4</span> + <span class="hljs-number">3</span>/<span class="hljs-number">5</span> + <span class="hljs-number">2</span>/<span class="hljs-number">2</span>) / <span class="hljs-number">3</span> = <span class="hljs-number">0.78333</span> 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题的核心思想是贪心，就是需要保证每次安排的班级通过率增加的最多。</p><p>假设一个班级当前的通过率为<code>a/b</code>，如果将一个聪明的学生安排到此班级，那么班级的通过率就会变为<code>a+1/b+1</code>,可以发现，通过率的增量为<code>a+1/b+1-a/b</code>。</p><p>所以可以维护一个大顶堆，存储的是每个班级的通过率增量。</p><p>进行 <code>extraStudents</code> 次操作，每次从堆顶取出一个班级，将这个班级的人数和通过人数都加 1，然后将这个班级的通过率增量重新计算并放回堆中。重复这个过程，直到将所有的学生都分配完毕。</p><p>最后，将所有班级的通过率求和，然后除以班级数目，即为答案。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> node<br>    &#123;<br>        <span class="hljs-built_in">double</span> <span class="hljs-keyword">add</span>;<br>        <span class="hljs-built_in">int</span> pass,total;<br>        node(<span class="hljs-built_in">double</span> a,<span class="hljs-built_in">int</span> b,<span class="hljs-built_in">int</span> c):<span class="hljs-keyword">add</span>(a),pass(b),total(c)&#123;&#125;<br>        <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node&amp; t) <span class="hljs-keyword">const</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">add</span>&lt;t.<span class="hljs-keyword">add</span>;<br>        &#125;<br>    &#125;;<br>    priority_queue&lt;node&gt; q;<br>    <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">maxAverageRatio</span>(<span class="hljs-params">vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; classes, <span class="hljs-built_in">int</span> extraStudents</span>)</span> &#123;<br>        <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; v:classes)<br>        &#123;<br>            <span class="hljs-built_in">int</span> a=v[<span class="hljs-number">0</span>],b=v[<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">double</span> <span class="hljs-keyword">add</span>=(<span class="hljs-built_in">double</span>)(a+<span class="hljs-number">1</span>)/(b+<span class="hljs-number">1</span>)-(<span class="hljs-built_in">double</span>)a/b;<br>            q.push(node(<span class="hljs-keyword">add</span>,a,b));<br>        &#125;<br>        <span class="hljs-keyword">while</span>(extraStudents--)<br>        &#123;<br>            node t=q.top();<br>            q.pop();<br>            ++t.pass;<br>            ++t.total;<br>            t.<span class="hljs-keyword">add</span>=(<span class="hljs-built_in">double</span>)(t.pass+<span class="hljs-number">1</span>)/(t.total+<span class="hljs-number">1</span>)-(<span class="hljs-built_in">double</span>)t.pass/t.total;<br>            q.push(t);<br>        &#125;<br>        <span class="hljs-built_in">double</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.empty())<br>        &#123;<br>            node t=q.top();<br>            q.pop();<br>            ans+=(<span class="hljs-built_in">double</span>) t.pass/t.total;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans/classes.size();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大正方形</title>
    <link href="/2023/02/17/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2023/02/17/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2">最大正方形</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最大正方形"><a class="markdownIt-Anchor" href="#最大正方形"></a> 最大正方形</h2><p><a href="https://leetcode.cn/problems/largest-1-bordered-square/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。</p><p>示例</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,1,1],[1,0,1],[1,1,1]]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用到前缀和的思路，把每行每列的前缀和数组保存下来，用来快速计算边界，然后依次遍历边界长度(从大到小)和左上角坐标，当满足条件时返回正方形面积即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">int</span> largest1BorderedSquare(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid) &#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(),n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">row</span>(m,<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>)),<span class="hljs-built_in">col</span>(n,<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-built_in">row</span>[i][j+<span class="hljs-number">1</span>]=<span class="hljs-built_in">row</span>[i][j]+grid[i][j];<br>                <span class="hljs-built_in">col</span>[j][i+<span class="hljs-number">1</span>]=<span class="hljs-built_in">col</span>[j][i]+grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> d=<span class="hljs-built_in">min</span>(m,n);<br>        <span class="hljs-keyword">for</span>(;d&gt;<span class="hljs-number">0</span>;--d)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m-d;++i)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n-d;++j)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">row</span>[i][j+d]-<span class="hljs-built_in">row</span>[i][j]==d&amp;&amp;<br>                    <span class="hljs-built_in">row</span>[i+d-<span class="hljs-number">1</span>][j+d]-<span class="hljs-built_in">row</span>[i+d-<span class="hljs-number">1</span>][j]==d&amp;&amp;<br>                    <span class="hljs-built_in">col</span>[j][i+d]-<span class="hljs-built_in">col</span>[j][i]==d&amp;&amp;<br>                    <span class="hljs-built_in">col</span>[j+d-<span class="hljs-number">1</span>][i+d]-<span class="hljs-built_in">col</span>[j+d-<span class="hljs-number">1</span>][i]==d)<br>                        <span class="hljs-keyword">return</span> d*d;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>检查好数组</title>
    <link href="/2023/02/16/%E6%A3%80%E6%9F%A5%E5%A5%BD%E6%95%B0%E7%BB%84/"/>
    <url>/2023/02/16/%E6%A3%80%E6%9F%A5%E5%A5%BD%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%A3%80%E6%9F%A5%E5%A5%BD%E6%95%B0%E7%BB%84">检查好数组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="检查好数组"><a class="markdownIt-Anchor" href="#检查好数组"></a> 检查好数组</h2><p><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个正整数数组 nums，你需要从中任选一些子集，然后将子集中每一个数乘以一个 任意整数，并求出他们的和。</p><p>假如该和结果为 1，那么原数组就是一个「好数组」，则返回 True；否则请返回 False。</p><p>示例</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：nums = [12,5,7,23]<br>输出：<span class="hljs-literal">true</span><br>解释：挑选数字 5 和 7。<br>5<span class="hljs-number">*3</span> + 7*(-2) = 1<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题实际上是个数学题😅，用到裴蜀定理：<br />对于不全为零的任意整数 <code>a</code> 和 <code>b</code>，记 <code>g=gcd⁡(a,b)</code>，则对于任意整数 <code>x</code> 和 <code>y</code> 都满足 <code>a×x+b×y</code> 是 <code>g</code> 的倍数，特别地，存在整数 <code>x</code> 和 <code>y</code> 满足 <code>a×x+b×y=g</code>，对于多个整数同样适用。</p><p>因此本体只需要考虑最大公约数是否为1即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isGoodArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> divisor = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            divisor = <span class="hljs-built_in">gcd</span>(divisor, num);<br>            <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> divisor == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>替换子串</title>
    <link href="/2023/02/13/%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2/"/>
    <url>/2023/02/13/%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2%E5%BE%97%E5%88%B0%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2">替换子串得到平衡字符串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="替换子串得到平衡字符串"><a class="markdownIt-Anchor" href="#替换子串得到平衡字符串"></a> 替换子串得到平衡字符串</h2><p><a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。</p><p>假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。</p><p>给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p><p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p><p>请返回待替换子串的最小可能长度。</p><p>如果原字符串自身就是一个平衡字符串，则返回 0。</p><p>示例</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;QQWE&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：我们需要把一个 &#x27;Q&#x27; 替换成 &#x27;R&#x27;，这样得到的 <span class="hljs-string">&quot;RQWE&quot;</span> (或 <span class="hljs-string">&quot;QRWE&quot;</span>) 是平衡的。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要用到双指针，根据题目的描述可以得知，当替换部分以外的其他字母都小于等于<code>n/4</code>时，替换后才能符合要求。因此右指针向右移动，当符合要求时，更新答案，左指针缩小子串长度。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs hsp">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> balancedString(string s) &#123;<br>        <span class="hljs-keyword">int</span> n=s.size()<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">int</span> m=n/<span class="hljs-number">4</span><span class="hljs-comment">;</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">cnt</span>(<span class="hljs-number">26</span>)<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">for</span>(char c:s)<br>        &#123;<br>            ++<span class="hljs-keyword">cnt</span>[c-<span class="hljs-string">&#x27;A&#x27;</span>]<span class="hljs-comment">;</span><br>        &#125;<br>        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span><span class="hljs-comment">;</span><br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>e9<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;Q&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]==m&amp;&amp;<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;W&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]==m&amp;&amp;<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;E&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]==m&amp;&amp;<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;R&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]==m)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>        <span class="hljs-keyword">for</span>(r=<span class="hljs-number">0</span><span class="hljs-comment">;r&lt;n;++r)</span><br>        &#123;<br>            --<span class="hljs-keyword">cnt</span>[s[r]-<span class="hljs-string">&#x27;A&#x27;</span>]<span class="hljs-comment">;</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;Q&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]&lt;=m&amp;&amp;<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;W&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]&lt;=m&amp;&amp;<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;E&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]&lt;=m&amp;&amp;<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;R&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]&lt;=m)<br>            &#123;<br>                ans=min(ans,r-l+<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>                ++<span class="hljs-keyword">cnt</span>[s[l]-<span class="hljs-string">&#x27;A&#x27;</span>]<span class="hljs-comment">;</span><br>                ++l<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>掷骰子</title>
    <link href="/2023/02/10/%E6%8E%B7%E9%AA%B0%E5%AD%90/"/>
    <url>/2023/02/10/%E6%8E%B7%E9%AA%B0%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="掷骰子模拟"><a class="markdownIt-Anchor" href="#掷骰子模拟"></a> 掷骰子模拟</h2><p><a href="https://leetcode.cn/problems/dice-roll-simulation/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。</p><p>不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。</p><p>现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。</p><p>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。</p><p>示例：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2, rollMax = [1,1,2,2,2,3]<br>输出：34<br>解释：我们掷<span class="hljs-number"> 2 </span>次骰子，如果没有约束的话，共有<span class="hljs-number"> 6 </span>*<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 36 </span>种可能的组合。但是根据 rollMax 数组，数字<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题自己完全没啥头绪，强烈推荐大佬的思路：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs prolog">// -------------------------------------------------说明-----------------------------------------------------------------<br><br>// 首先，我们创建一个二维dp数组。<br>//  dp[i][j]表示第i次掷出骰子时，数字j出现的可能的序列总数。<br>// （也就是说，第i次掷出的骰子数字是 j 所有可能的序列数) <br>// 其中 <span class="hljs-number">1</span> &lt;= i &lt;= n    <span class="hljs-number">1</span> &lt;= j &lt;= <span class="hljs-number">6</span><br><br>// 明显，dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]... dp[<span class="hljs-number">1</span>][<span class="hljs-number">6</span>]均为 <span class="hljs-number">1</span><br>// 所以，最后结果有效序列总数就是 sum (dp[n][<span class="hljs-number">1</span>] + dp[n][<span class="hljs-number">2</span>] + ... + dp[n][<span class="hljs-number">6</span>])  | sum为求和函数<br><br>// 那么，如何计算第i次骰子掷出时，掷出数字为j的序列总数为多少呢?<br>// 仔细思考一下dp[i][j]和什么有关?<br><br>// 第一: dp[i][j] 和dp[i<span class="hljs-number">-1</span>][j]有关，不仅如此，dp[i][j] 和 dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>],...dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">6</span>]都有关<br>// 第二: 由于连续数字限制，dp[i][j]还和 dp[i-rollMax[j<span class="hljs-number">-1</span>]][<span class="hljs-number">1</span>],...,dp[i-rollMax[j<span class="hljs-number">-1</span>]][<span class="hljs-number">6</span>]均有关<br>// 即， 第i次掷出骰子的序列总数只和第i<span class="hljs-number">-1</span>次掷出骰子的序列总数，以及第i-rollMax[j<span class="hljs-number">-1</span>]次掷出骰子的序列总数有关。<br><br>// --------------------------------------------------举例----------------------------------------------------------------<br><br>// 这么说 可能还是不够清楚， 举个例子<br><br>// 假如现在是第 <span class="hljs-number">5</span> 次掷出骰子， 且掷出的数字是 <span class="hljs-number">6</span>, 而最多能连续出现 <span class="hljs-number">3</span> 次 <span class="hljs-number">6</span>， dp[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>]如何计算?<br><br>// 序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>   <span class="hljs-symbol">___</span>   <span class="hljs-number">6</span> <br>// 次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>     <span class="hljs-number">4</span>    <span class="hljs-number">5</span><br><br>① 如果第 <span class="hljs-number">4</span> 次掷出的数字是 <span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span> 中的一种， 会不会对第 <span class="hljs-number">5</span> 次掷出的 <span class="hljs-number">6</span> 产生影响? <br>  答案是 不会，因为如果第 <span class="hljs-number">4</span> 次不是 <span class="hljs-number">6</span>，那么第 <span class="hljs-number">5</span> 次掷出的 <span class="hljs-number">6</span> 肯定是第一个 <span class="hljs-number">6</span>， 肯定不会连续。<br>  所以不用考虑限制数组rollMax。<br>  也就是说，可以直接将 dp[<span class="hljs-number">4</span>][<span class="hljs-number">1</span>]，dp[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]，dp[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>]，dp[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]，dp[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>]加入到 dp[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>] 中。<br>  <br>  // <span class="hljs-number">5</span>种可能<br>  // 序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>    <span class="hljs-number">1</span>   <span class="hljs-number">6</span>       序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>    <span class="hljs-number">2</span>   <span class="hljs-number">6</span>  ...  序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>    <span class="hljs-number">5</span>   <span class="hljs-number">6</span><br>  // 次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>     <span class="hljs-number">4</span>   <span class="hljs-number">5</span>       次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>     <span class="hljs-number">4</span>   <span class="hljs-number">5</span>  ...  次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>     <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br><br>② 如果第 <span class="hljs-number">4</span> 次掷出的数字是 <span class="hljs-number">6</span> ，会不会对第 <span class="hljs-number">5</span> 次掷出的 <span class="hljs-number">6</span> 产生影响? <br>  答案是 不一定。为什么是不一定? 因为第 <span class="hljs-number">4</span> 次掷出的 <span class="hljs-number">6</span> 加上第五次掷出的 <span class="hljs-number">6</span> 可能都还没达到rollMax中所设置的上限。<br>  那么，可以先将dp[<span class="hljs-number">4</span>][<span class="hljs-number">6</span>] 加入到dp[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>]中去。只是后面需要去除不合法的序列罢了。（注意）<br>   <br>   // 类似这种<br>   // 序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>    <span class="hljs-number">6</span>   <span class="hljs-number">6</span>      // 序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>   <span class="hljs-number">6</span>    <span class="hljs-number">6</span>   <span class="hljs-number">6</span><br>   // 次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>     <span class="hljs-number">4</span>   <span class="hljs-number">5</span>      // 次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br><br>③ 好的，第②步中我们多加了一些不合法的序列数目，那么，我们要将其减掉。那么到底需要减去多少呢?<br>  <br>  我们先思考一个问题， 第 <span class="hljs-number">5</span> 次掷出数字 <span class="hljs-number">6</span> 时，掷出之前连续 <span class="hljs-number">6</span> 的数量最大有多少?<br>  答案是 rollMax[<span class="hljs-number">5</span>]（数字 <span class="hljs-number">6</span> 的上限），不可能超过该数字 ，<br>  因为如果超过了rollMax[<span class="hljs-number">5</span>]（<span class="hljs-number">6</span>的上限），在第 <span class="hljs-number">4</span> 次肯定就已经被处理了。<br><br>  那么，现在又存在两种情况：<br>  a. 第 <span class="hljs-number">5</span> 次掷出数字 <span class="hljs-number">6</span> 之前连续 <span class="hljs-number">6</span> 的数量 &lt; rollMax[<span class="hljs-number">5</span>] （<span class="hljs-number">6</span>的上限）<br>  b. 第 <span class="hljs-number">5</span> 次掷出数字 <span class="hljs-number">6</span> 之前连续 <span class="hljs-number">6</span> 的数量 == rollMax[<span class="hljs-number">5</span>] （<span class="hljs-number">6</span>的上限）<br>  情况a. 我们不需要过多考虑，因为还没有达到上限，直接将dp[<span class="hljs-number">4</span>][<span class="hljs-number">6</span>]加入dp[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>] 即可（前面已经加入）<br>  情况b. 在第 <span class="hljs-number">5</span> 次掷出之前连续 <span class="hljs-number">6</span> 的数量就已经到达了上限，那么第 <span class="hljs-number">5</span> 次掷出 <span class="hljs-number">6</span> 是非法的，<br>  这种情况下的序列数目就是我们步骤②中需要减去的数量<br>  <br>  // 情况a. （合法的）                            // 情况b. （不合法的）<br>  // 序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>   <span class="hljs-symbol">___</span>   <span class="hljs-number">6</span>   <span class="hljs-number">6</span>                // 序列  <span class="hljs-symbol">___</span>   <span class="hljs-number">6</span>    <span class="hljs-number">6</span>    <span class="hljs-number">6</span>   <span class="hljs-number">6</span><br>  // 次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>     <span class="hljs-number">3</span>    <span class="hljs-number">4</span>   <span class="hljs-number">5</span>                // 次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br><br>  仔细分析一下情况 b.<br>  在第 <span class="hljs-number">5</span> 次掷出之前连续 <span class="hljs-number">6</span> 的数量就已经到达了上限，说明第 <span class="hljs-number">2</span> 次，第 <span class="hljs-number">3</span> 次，第 <span class="hljs-number">4</span> 次掷出的数字一定都是<span class="hljs-number">6</span>，<br>  而且，第<span class="hljs-number">1</span>次掷出的数字一定不是<span class="hljs-number">6</span>。<br>  结果也就很明显了吧，第 <span class="hljs-number">1</span> 次不是 <span class="hljs-number">6</span> ，那就是 <span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span> 中的一种呗!!!<br>  需要减去的序列数量为: sum (dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">4</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">5</span>])<br><br>// ------------------------------------------------------------------------------------------------------------------<br>  <br>  其他的数字<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span>可依次类推...<br><br>// ------------------------------------------------------------------------------------------------------------------<br><br>作者：yex➰<br>链接：https://leetcode.cn/problems/dice-roll-simulation/solutions/<span class="hljs-number">492200</span>/ni-bi-dong-chao-jian-dan-dong-tai-gui-hua-fu-za-du/<br>来源：力扣（<span class="hljs-symbol">LeetCode</span>）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>tql呜呜呜</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br><br>    typedef long long ll;<br><br>    <span class="hljs-built_in">int</span> dieSimulator(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; rollMax) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mod</span>=<span class="hljs-number">1</span>e9+<span class="hljs-number">7</span>;<br>        vector&lt;vector&lt;ll&gt;&gt; dp(<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>,vector&lt;ll&gt;(<span class="hljs-number">7</span>));<br>        for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">6</span>;++j)<br>            dp[<span class="hljs-number">1</span>][j]=<span class="hljs-number">1</span>;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-built_in">n</span>;++i)<br>        &#123;<br>            for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">6</span>;++j)<br>            &#123;<br>                ll <span class="hljs-built_in">t</span>=accumulate(dp[i-<span class="hljs-number">1</span>].begin(),dp[i-<span class="hljs-number">1</span>].end(),<span class="hljs-number">0</span>ll);<br>                <span class="hljs-built_in">int</span> idx=i-<span class="hljs-number">1</span>-rollMax[j-<span class="hljs-number">1</span>];<br>                <span class="hljs-built_in">if</span>(idx&gt;=<span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-built_in">t</span>=accumulate(dp[idx].begin(),dp[idx].end(),<span class="hljs-built_in">t</span>,[&amp;](ll a,ll b)&#123;<br>                        return a+<span class="hljs-built_in">mod</span>-b;<br>                    &#125;);<br>                    <span class="hljs-built_in">t</span>+=dp[idx][j];<br>                &#125;<br>                else <span class="hljs-built_in">if</span>(idx==<span class="hljs-number">0</span>)<br>                    <span class="hljs-built_in">t</span>-=<span class="hljs-number">1</span>;<br>                dp[i][j]=<span class="hljs-built_in">t</span>%<span class="hljs-built_in">mod</span>;<br>            &#125;<br>        &#125;<br>        return accumulate(dp[<span class="hljs-built_in">n</span>].begin(),dp[<span class="hljs-built_in">n</span>].end(),<span class="hljs-number">0</span>ll)%<span class="hljs-built_in">mod</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>构造连续值</title>
    <link href="/2023/02/04/%E6%9E%84%E9%80%A0%E8%BF%9E%E7%BB%AD%E5%80%BC/"/>
    <url>/2023/02/04/%E6%9E%84%E9%80%A0%E8%BF%9E%E7%BB%AD%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9E%84%E9%80%A0%E8%BF%9E%E7%BB%AD%E5%80%BC">构造连续值</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="构造连续值"><a class="markdownIt-Anchor" href="#构造连续值"></a> 构造连续值</h2><p><a href="https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个长度为 n 的整数数组 coins ，它代表你拥有的 n 个硬币。第 i 个硬币的值为 coins[i] 。如果你从这些硬币中选出一部分硬币，它们的和为 x ，那么称，你可以 构造 出 x 。</p><p>请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。</p><p>你可能有多个相同值的硬币。</p><p>示例:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：coins = <span class="hljs-comment">[1,1,1,4]</span><br>输出：8<br>解释：你可以得到以下这些值：<br>- 0：什么都不取 <span class="hljs-comment">[]</span><br>- 1：取 <span class="hljs-comment">[1]</span><br>- 2：取 <span class="hljs-comment">[1,1]</span><br>- 3：取 <span class="hljs-comment">[1,1,1]</span><br>- 4：取 <span class="hljs-comment">[4]</span><br>- 5：取 <span class="hljs-comment">[4,1]</span><br>- 6：取 <span class="hljs-comment">[4,1,1]</span><br>- 7：取 <span class="hljs-comment">[4,1,1,1]</span><br>从 0 开始，你可以构造出 8 个连续整数。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题就是构造从0开始的连续整数的个数，代码及其简单，但思路很好，第一眼看下去我想不到😢😢😢，tcl.</p><p>首先思考，如果数组中的若干元素能构造<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">0 \sim x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，那么当加入了一个元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>,能构造的范围就变成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>x</mi><mo>∪</mo><mi>k</mi><mo>∼</mo><mi>k</mi><mo>+</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">0 \sim x \cup k \sim k+x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k \le x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，两个范围就合并为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>k</mi><mo>+</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">0 \sim k+x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>。因此，这道题中，用res表示下一个要构造的数，先对数组排序，然后依次取数组中的元素<code>i</code>，如果<code>i&lt;=res</code>，说明可构造的范围需要扩大，下一个要构造的数变为<code>res+i</code>，直到<code>i&gt;res</code>，说明此时已经无法继续构造连续的整数。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaximumConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(coins.<span class="hljs-built_in">begin</span>(),coins.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i:coins)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&lt;=res)<br>                res+=i;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>颜色交替最短路</title>
    <link href="/2023/02/02/%E9%A2%9C%E8%89%B2%E4%BA%A4%E6%9B%BF%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2023/02/02/%E9%A2%9C%E8%89%B2%E4%BA%A4%E6%9B%BF%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%A2%9C%E8%89%B2%E4%BA%A4%E6%9B%BF%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF">颜色交替的最短路</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="颜色交替的最短路"><a class="markdownIt-Anchor" href="#颜色交替的最短路"></a> 颜色交替的最短路</h2><p><a href="https://leetcode.cn/problems/shortest-path-with-alternating-colors/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在一个有向图中，节点分别标记为 0, 1, …, n-1。图中每条边为红色或者蓝色，且存在自环或平行边。</p><p>red_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的红色有向边。类似地，blue_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的蓝色有向边。</p><p>返回长度为 n 的数组 answer，其中 answer[X] 是从节点 0 到节点 X 的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么 answer[x] = -1。</p><p>示例</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span>, red_edges = <span class="hljs-string">[[0,1]]</span>, blue_edges = <span class="hljs-string">[[2,1]]</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要是bfs的思想，一开始我想的是吧红色边和蓝色边放在一个图处理，但是这样做的问题就是后面我不会处理环路的情况了，自己也晕了，参考大佬的思路后，才解决，其实红色边和蓝色边分为两个图，每个边处理后，颜色取反，然后去对应颜色的图里找下一条边即可。</p><p>首先将起点 0 和起点边的颜色 0 或 1 入队，表示从起点出发，且当前是红色或蓝色边。接下来，进行 BFS 。每次从队列中取出一个节点<code>(u,clr)</code>，如果当前节点的答案还未更新，则将当前节点的答案更新为当前层数<code>d</code>，即 <code>ans[i]=d</code>。然后，我们将当前边的颜色 <code>clr</code> 取反，即如果当前边为红色，则将其变为蓝色，之后取出颜色对应的所有边，如果边的另一端节点未被搜索过，则将其入队。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">shortestAlternatingPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; redEdges, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; blueEdges)</span> </span>&#123;<br>        vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">edges</span>(<span class="hljs-number">2</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n));<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; e : redEdges) <br>            edges[<span class="hljs-number">0</span>][e[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; e : blueEdges)<br>            edges[<span class="hljs-number">1</span>][e[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">1</span>]);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n,<span class="hljs-number">-1</span>)</span></span>;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> d=<span class="hljs-number">0</span>;<br>        q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> sz=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(sz--)<br>            &#123;<br>                <span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>().first;<br>                <span class="hljs-type">int</span> clr=q.<span class="hljs-built_in">front</span>().second;<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(ans[u]==<span class="hljs-number">-1</span>)<br>                    ans[u]=d;<br>                vis[u][clr]=<span class="hljs-literal">true</span>;<br>                clr^=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; v:edges[clr][u])<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(!vis[v][clr])<br>                        q.<span class="hljs-built_in">emplace</span>(v,clr);<br>                &#125;<br>            &#125;<br>            ++d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>平衡数组方案数</title>
    <link href="/2023/01/28/%E5%B9%B3%E8%A1%A1%E6%95%B0%E7%BB%84%E6%96%B9%E6%A1%88%E6%95%B0/"/>
    <url>/2023/01/28/%E5%B9%B3%E8%A1%A1%E6%95%B0%E7%BB%84%E6%96%B9%E6%A1%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%B9%B3%E8%A1%A1%E6%95%B0%E7%BB%84%E6%96%B9%E6%A1%88%E6%95%B0">平衡数组方案数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="平衡数组方案数"><a class="markdownIt-Anchor" href="#平衡数组方案数"></a> 平衡数组方案数</h2><p><a href="https://leetcode.cn/problems/ways-to-make-a-fair-array/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums 。你需要选择 恰好 一个下标（下标从 0 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。</p><p>比方说，如果 nums = [6,1,7,4,1] ，那么：</p><p>选择删除下标 1 ，剩下的数组为 nums = [6,7,4,1] 。<br />选择删除下标 2 ，剩下的数组为 nums = [6,1,4,1] 。<br />选择删除下标 4 ，剩下的数组为 nums = [6,1,7,4] 。<br />如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 平衡数组 。</p><p>请你返回删除操作后，剩下的数组 nums 是 平衡数组 的 方案数 。</p><p>示例</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,1,6,4]<br>输出：1<br>解释：<br>删除下标<span class="hljs-number"> 0 </span>：[1,6,4] -&gt; 偶数元素下标为：1 +<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 5 </span>。奇数元素下标为：6 。不平衡。<br>删除下标<span class="hljs-number"> 1 </span>：[2,6,4] -&gt; 偶数元素下标为：2 +<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 6 </span>。奇数元素下标为：6 。平衡。<br>删除下标<span class="hljs-number"> 2 </span>：[2,1,4] -&gt; 偶数元素下标为：2 +<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 6 </span>。奇数元素下标为：1 。不平衡。<br>删除下标<span class="hljs-number"> 3 </span>：[2,1,6] -&gt; 偶数元素下标为：2 +<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 8 </span>。奇数元素下标为：1 。不平衡。<br>只有一种让剩余数组成为平衡数组的方案。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>对于位置<code>i</code>来说，需要维护4个变量 <code>prej,preo,sufj,sufo</code>,分别表示位置<code>i</code>之前奇数下标的数之和，偶数下标的数之和，以及位置<code>i</code>之后奇数下标的数之和与偶数下标的数之和。当位置<code>i</code>处的数字被去掉后，只需判断<code>prej+sufo==preo+sufj</code>是否相等，若相等则符合要求。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    int waysToMakeFair(vector&lt;int&gt;&amp; nums) &#123;<br>        int <span class="hljs-attribute">n</span>=nums.size();<br>        int <span class="hljs-attribute">prej</span>=0,preo=0,sufj=0,sufo=0;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&amp;1)<br>                sufj+=nums[i];<br>            <span class="hljs-keyword">else</span><br>                sufo+=nums[i];<br>        &#125;<br>        int <span class="hljs-attribute">res</span>=0;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&amp;1)<br>                <span class="hljs-attribute">sufj-</span>=nums[i];<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-attribute">sufo-</span>=nums[i];<br>            <span class="hljs-keyword">if</span>(prej+<span class="hljs-attribute">sufo</span>==preo+sufj)<br>                ++res;<br>            <span class="hljs-keyword">if</span>(i&amp;1)<br>                prej+=nums[i];<br>            <span class="hljs-keyword">else</span><br>                preo+=nums[i];<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>矩阵转换后的秩</title>
    <link href="/2023/01/25/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%A7%A9/"/>
    <url>/2023/01/25/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%A7%A9/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%A7%A9">矩阵转换后的秩</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="矩阵转换后的秩"><a class="markdownIt-Anchor" href="#矩阵转换后的秩"></a> 矩阵转换后的秩</h2><p><a href="https://leetcode.cn/problems/rank-transform-of-a-matrix/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个 m x n 的矩阵 matrix ，请你返回一个新的矩阵 answer ，其中 answer[row][col] 是 matrix[row][col] 的秩。</p><p>每个元素的 秩 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：</p><p>秩是从 1 开始的一个整数。<br />如果两个元素 p 和 q 在 同一行 或者 同一列 ，那么：<br />如果 p &lt; q ，那么 rank(p) &lt; rank(q)<br />如果 p == q ，那么 rank(p) == rank(q)<br />如果 p &gt; q ，那么 rank(p) &gt; rank(q)<br />秩 需要越 小 越好。<br />题目保证按照上面规则 answer 数组是唯一的。</p><p>示例：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,4]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>]</span><br>解释：<br>matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 的秩为 1 ，因为它是所在行和列的最小整数。<br>matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> 的秩为 2 ，因为 matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> &gt; matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 且 matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 的秩为 1 。<br>matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span> 的秩为 2 ，因为 matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span> &gt; matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 且 matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 的秩为 1 。<br>matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> 的秩为 3 ，因为 matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> &gt; matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span>， matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> &gt; matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span> 且 matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> 和 matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span> 的秩都为 2 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题还是很麻烦的，要用到并查集+拓扑排序，看了题解也很勉强的写下来😢</p><p>主要的思路就是，用哈希表把每行相同元素的下标记录下来，然后用并查集把相同元素的下标连接起来，下面就是建图，我们希望构建这样的图，一条边<code>u-&gt;v</code>中，<code>u</code>是较小的元素的集合的<code>root</code>，<code>v</code>是较大的元素的集合的<code>root</code>，也就是说，建立的是不同集合间的拓扑图，然后通过拓扑排序，为每个集合的根节点设置它的 “秩”，然后把同一集合的元素的值设置为集合内根节点的值即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> unionset</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class">    vector&lt;int&gt; vset,sz;</span><br><span class="hljs-class">public:</span><br><span class="hljs-class">    unionset(<span class="hljs-title">int</span> <span class="hljs-title">n</span>)</span><br><span class="hljs-class">    &#123;</span><br><span class="hljs-class">        vset=vector&lt;int&gt; (<span class="hljs-title">n</span>);</span><br><span class="hljs-class">        sz=vector&lt;int&gt; (<span class="hljs-title">n</span>,1);</span><br><span class="hljs-class">        iota(<span class="hljs-title">vset</span>.<span class="hljs-title">begin</span>(),vset.end(),0);</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">    int find(<span class="hljs-title">int</span> <span class="hljs-title">a</span>)</span><br><span class="hljs-class">    &#123;</span><br><span class="hljs-class">        if(<span class="hljs-title">vset</span>[<span class="hljs-title">a</span>]==<span class="hljs-title">a</span>)</span><br><span class="hljs-class">            return a;</span><br><span class="hljs-class">        return vset[a]=find(<span class="hljs-title">vset</span>[<span class="hljs-title">a</span>]);</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">    void con(<span class="hljs-title">int</span> <span class="hljs-title">a</span>,<span class="hljs-title">int</span> <span class="hljs-title">b</span>)</span><br><span class="hljs-class">    &#123;</span><br><span class="hljs-class">        int x=find(<span class="hljs-title">a</span>);</span><br><span class="hljs-class">        int y=find(<span class="hljs-title">b</span>);</span><br><span class="hljs-class">        if(<span class="hljs-title">x</span>!=<span class="hljs-title">y</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            if(<span class="hljs-title">sz</span>[<span class="hljs-title">x</span>]&gt;<span class="hljs-title">sz</span>[<span class="hljs-title">y</span>])</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                vset[y]=x;</span><br><span class="hljs-class">                sz[x]+=sz[y];</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">            else</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                vset[x]=y;</span><br><span class="hljs-class">                sz[y]+=sz[x];</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">&#125;;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;</span><br><span class="hljs-class">public:</span><br><span class="hljs-class">    vector&lt;vector&lt;int&gt;&gt; matrixRankTransform(<span class="hljs-title">vector</span>&lt;<span class="hljs-title">vector</span>&lt;<span class="hljs-title">int</span>&gt;&gt;&amp; <span class="hljs-title">matrix</span>) &#123;</span><br><span class="hljs-class">        int n=matrix.size(),m=matrix[0].size();</span><br><span class="hljs-class">        unionset uset(<span class="hljs-title">n</span>*<span class="hljs-title">m</span>);</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            map&lt;int,vector&lt;int&gt;&gt; mp;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">                mp[matrix[i][j]].emplace_back(<span class="hljs-title">i</span>*<span class="hljs-title">m</span>+<span class="hljs-title">j</span>);</span><br><span class="hljs-class">            for(<span class="hljs-title">auto</span> &amp;[<span class="hljs-title">num</span>,<span class="hljs-title">vec</span>]:<span class="hljs-title">mp</span>)//将每行相同元素connect</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                for(<span class="hljs-title">int</span> <span class="hljs-title">k</span>=0;<span class="hljs-title">k</span>+1&lt;<span class="hljs-title">vec</span>.<span class="hljs-title">size</span>();++k)</span><br><span class="hljs-class">                    uset.con(<span class="hljs-title">vec</span>[<span class="hljs-title">k</span>],<span class="hljs-title">vec</span>[<span class="hljs-title">k</span>+1]);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            map&lt;int,vector&lt;int&gt;&gt; mp;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">                mp[matrix[i][j]].emplace_back(<span class="hljs-title">i</span>*<span class="hljs-title">m</span>+<span class="hljs-title">j</span>);</span><br><span class="hljs-class">            for(<span class="hljs-title">auto</span> &amp;[<span class="hljs-title">num</span>,<span class="hljs-title">vec</span>]:<span class="hljs-title">mp</span>)//将每列相同元素connect</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                for(<span class="hljs-title">int</span> <span class="hljs-title">k</span>=0;<span class="hljs-title">k</span>+1&lt;<span class="hljs-title">vec</span>.<span class="hljs-title">size</span>();++k)</span><br><span class="hljs-class">                    uset.con(<span class="hljs-title">vec</span>[<span class="hljs-title">k</span>],<span class="hljs-title">vec</span>[<span class="hljs-title">k</span>+1]);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        vector&lt;vector&lt;int&gt;&gt; adj(<span class="hljs-title">n</span>*<span class="hljs-title">m</span>);</span><br><span class="hljs-class">        vector&lt;int&gt; in(<span class="hljs-title">n</span>*<span class="hljs-title">m</span>);</span><br><span class="hljs-class">        //建图</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            vector&lt;pair&lt;int,int&gt;&gt; v(<span class="hljs-title">m</span>);</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">                v[j]=&#123;matrix[i][j],j&#125;;</span><br><span class="hljs-class">            sort(<span class="hljs-title">v</span>.<span class="hljs-title">begin</span>(),v.end());</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>+1&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                if(<span class="hljs-title">v</span>[<span class="hljs-title">j</span>].<span class="hljs-title">first</span>!=<span class="hljs-title">v</span>[<span class="hljs-title">j</span>+1].<span class="hljs-title">first</span>)</span><br><span class="hljs-class">                &#123;</span><br><span class="hljs-class">                    int uu=uset.find(<span class="hljs-title">i</span>*<span class="hljs-title">m</span>+<span class="hljs-title">v</span>[<span class="hljs-title">j</span>].<span class="hljs-title">second</span>);</span><br><span class="hljs-class">                    int vv=uset.find(<span class="hljs-title">i</span>*<span class="hljs-title">m</span>+<span class="hljs-title">v</span>[<span class="hljs-title">j</span>+1].<span class="hljs-title">second</span>);</span><br><span class="hljs-class">                    adj[uu].emplace_back(<span class="hljs-title">vv</span>);</span><br><span class="hljs-class">                    ++in[vv];</span><br><span class="hljs-class">                &#125;</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            vector&lt;pair&lt;int,int&gt;&gt; v(<span class="hljs-title">n</span>);</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">                v[i]=&#123;matrix[i][j],i&#125;;</span><br><span class="hljs-class">            sort(<span class="hljs-title">v</span>.<span class="hljs-title">begin</span>(),v.end());</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>+1&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                if(<span class="hljs-title">v</span>[<span class="hljs-title">i</span>].<span class="hljs-title">first</span>!=<span class="hljs-title">v</span>[<span class="hljs-title">i</span>+1].<span class="hljs-title">first</span>)</span><br><span class="hljs-class">                &#123;</span><br><span class="hljs-class">                    int uu=uset.find(<span class="hljs-title">v</span>[<span class="hljs-title">i</span>].<span class="hljs-title">second</span>*<span class="hljs-title">m</span>+<span class="hljs-title">j</span>);</span><br><span class="hljs-class">                    int vv=uset.find(<span class="hljs-title">v</span>[<span class="hljs-title">i</span>+1].<span class="hljs-title">second</span>*<span class="hljs-title">m</span>+<span class="hljs-title">j</span>);</span><br><span class="hljs-class">                    adj[uu].emplace_back(<span class="hljs-title">vv</span>);</span><br><span class="hljs-class">                    ++in[vv];</span><br><span class="hljs-class">                &#125;</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        vector&lt;int&gt; ans(<span class="hljs-title">n</span>*<span class="hljs-title">m</span>,1);</span><br><span class="hljs-class">        queue&lt;int&gt; q;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>*<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            if(<span class="hljs-title">uset</span>.<span class="hljs-title">find</span>(<span class="hljs-title">i</span>)==i&amp;&amp;in[i]==0)</span><br><span class="hljs-class">                q.emplace(<span class="hljs-title">i</span>);</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        while(!<span class="hljs-title">q</span>.<span class="hljs-title">empty</span>())</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            int u=q.front();</span><br><span class="hljs-class">            q.pop();</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> &amp;<span class="hljs-title">v</span>:<span class="hljs-title">adj</span>[<span class="hljs-title">u</span>])</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                ans[v]=ans[u]+1;</span><br><span class="hljs-class">                <span class="hljs-comment">--in[v];</span></span><br><span class="hljs-class">                if(<span class="hljs-title">in</span>[<span class="hljs-title">v</span>]==0)</span><br><span class="hljs-class">                    q.emplace(<span class="hljs-title">v</span>);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        vector&lt;vector&lt;int&gt;&gt; res(<span class="hljs-title">n</span>,<span class="hljs-title">vector</span>&lt;<span class="hljs-title">int</span>&gt; (<span class="hljs-title">m</span>));</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                res[i][j]=ans[uset.find(<span class="hljs-title">i</span>*<span class="hljs-title">m</span>+<span class="hljs-title">j</span>)];</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        return res;</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">&#125;;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最小侧跳次数</title>
    <link href="/2023/01/21/%E6%9C%80%E5%B0%8F%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0/"/>
    <url>/2023/01/21/%E6%9C%80%E5%B0%8F%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E5%B0%8F%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0">最小侧跳次数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最小侧跳次数"><a class="markdownIt-Anchor" href="#最小侧跳次数"></a> 最小侧跳次数</h2><p><a href="https://leetcode.cn/problems/minimum-sideway-jumps/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。</p><p>给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。</p><p>比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。<br />这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。</p><p>比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。<br />这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>动态规划，用数组<code>d[j]</code>表示当前位置在j跑道上最短侧跳次数，对于每一个位置i，先找出<code>i-1</code>位置3个跑道中最小<code>d[j]</code>，记为cnt,然后用<code>d[j]=min(d[j],cnt+1)</code>进行更新即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    int minSideJumps(vector&lt;int&gt;&amp; obstacles) &#123;<br>        int <span class="hljs-attribute">inf</span>=0x3f3f3f3f;<br>        int <span class="hljs-attribute">n</span>=obstacles.size()-1;<br>        int d[3]=&#123;1,0,1&#125;;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=n;++i)<br>        &#123;<br>            int <span class="hljs-attribute">cnt</span>=inf;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=0;j&lt;3;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-attribute">j</span>==obstacles[i]-1)<br>                    d[j]=inf;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-attribute">cnt</span>=min(cnt,d[j]);<br>            &#125;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=0;j&lt;3;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j!=obstacles[i]-1)<br>                    d[j]=min(cnt+1,d[j]);<br>            &#125;<br>        &#125;<br>        return *min_element(d,d+3);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大公约数的个数</title>
    <link href="/2023/01/14/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2023/01/14/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="最大公约数的个数"><a class="markdownIt-Anchor" href="#最大公约数的个数"></a> 最大公约数的个数</h2><p><a href="">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个由正整数组成的数组 nums 。</p><p>数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。</p><p>例如，序列 [4,6,16] 的最大公约数是 2 。<br />数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。</p><p>例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。<br />计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [6,10,3]<br>输出：5<br>解释：不同的最大公约数为<span class="hljs-number"> 6 </span>、10 、3 、2 和<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>参考了大佬的思路，枚举<code>1~maxval</code>之间的数作为最大公约数的倍数，例如[1,2,3,…]，[2,4,6,…]，当某个数在nums中时，更新该子序列的最大公约数，如果循环结束最大公约数等于开始时的值，则<code>++ans</code>，可以通过代码帮助理解。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countDifferentSubsequenceGCDs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxv=*<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(maxv+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;t:nums)<br>            vis[t]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxv;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=maxv&amp;&amp;t!=i;j+=i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(vis[j]==<span class="hljs-literal">true</span>)<br>                    t=<span class="hljs-built_in">gcd</span>(t,j);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(t==i)<br>                ++ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>破解保险箱</title>
    <link href="/2023/01/10/%E7%A0%B4%E8%A7%A3%E4%BF%9D%E9%99%A9%E7%AE%B1/"/>
    <url>/2023/01/10/%E7%A0%B4%E8%A7%A3%E4%BF%9D%E9%99%A9%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%A0%B4%E8%A7%A3%E4%BF%9D%E9%99%A9%E7%AE%B1">破解保险箱</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="破解保险箱"><a class="markdownIt-Anchor" href="#破解保险箱"></a> 破解保险箱</h2><p><a href="https://leetcode.cn/problems/cracking-the-safe/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>There is a safe protected by a password. The password is a sequence of n digits where each digit can be in the range [0, k - 1].</p><p>The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the most recent n digits that were entered each time you type a digit.</p><p>For example, the correct password is “345” and you enter in “012345”:<br />After typing 0, the most recent 3 digits is “0”, which is incorrect.<br />After typing 1, the most recent 3 digits is “01”, which is incorrect.<br />After typing 2, the most recent 3 digits is “012”, which is incorrect.<br />After typing 3, the most recent 3 digits is “123”, which is incorrect.<br />After typing 4, the most recent 3 digits is “234”, which is incorrect.<br />After typing 5, the most recent 3 digits is “345”, which is correct and the safe unlocks.<br />Return any string of minimum length that will unlock the safe at some point of entering it.</p><p>example：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Input:</span> n = <span class="hljs-number">2</span>, k = <span class="hljs-number">2</span><br><span class="hljs-symbol">Output:</span> <span class="hljs-string">&quot;01100&quot;</span><br><span class="hljs-symbol">Explanation:</span> <span class="hljs-keyword">For</span> <span class="hljs-keyword">each</span> possible password:<br>- <span class="hljs-string">&quot;00&quot;</span> <span class="hljs-built_in">is</span> typed <span class="hljs-keyword">in</span> starting <span class="hljs-keyword">from</span> the <span class="hljs-number">4</span>th digit.<br>- <span class="hljs-string">&quot;01&quot;</span> <span class="hljs-built_in">is</span> typed <span class="hljs-keyword">in</span> starting <span class="hljs-keyword">from</span> the <span class="hljs-number">1s</span>t digit.<br>- <span class="hljs-string">&quot;10&quot;</span> <span class="hljs-built_in">is</span> typed <span class="hljs-keyword">in</span> starting <span class="hljs-keyword">from</span> the <span class="hljs-number">3</span>rd digit.<br>- <span class="hljs-string">&quot;11&quot;</span> <span class="hljs-built_in">is</span> typed <span class="hljs-keyword">in</span> starting <span class="hljs-keyword">from</span> the <span class="hljs-number">2</span>nd digit.<br>Thus <span class="hljs-string">&quot;01100&quot;</span> will unlock the safe. <span class="hljs-string">&quot;01100&quot;</span>, <span class="hljs-string">&quot;10011&quot;</span>, <span class="hljs-built_in">and</span> <span class="hljs-string">&quot;11001&quot;</span> would also unlock the safe.<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这题很大一部分难度在于读题，中文题目描述实在是太偷懒了，差评!!!😠<br />所以这里题目描述给英文的🐱</p><p>题意是说，给一个k值，然后有一个n位的密码，密码的每一位来自<code>0~k-1</code>之间，需要返回一个字符串，该字符串的后n位是可能的密码。</p><p>那么密码到底是怎么规定的呢？ 密码其实是n位数字的任意排列，比如<code>k=5,n=3</code>，如果3位取的是<code>012</code>，那么密码可能就是<code>000,001,002,010,011,012,021,022...,222</code>;如果3位取的是<code>123</code>,那么密码可能是<code>111,112,113,121,122,123....</code>，对于<code>k=5,n=3</code>的情况,n每一位都可以取<code>0,1,2,3,4</code>,所以满足条件的密码一共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>k</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">k^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>个</p><p>要返回的是一个字符串，包含了所有可能的密码，所以可以通过构造密码组成答案<br />通过代码可以更好的理解思路 <s>(其实是不想打字了🐶)</s></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_set&lt;<span class="hljs-built_in">string</span>&gt; st;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">crackSafe</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> k</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> cnt=pow(k,n);<br>        <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ans</span>(<span class="hljs-params">n,<span class="hljs-string">&#x27;0&#x27;</span></span>)</span>;<br>        st.insert(ans);<br>        <span class="hljs-built_in">string</span> t=ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            t.erase(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=k<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;--j)<br>            &#123;<br>                t+=j+<span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(!st.count(t))<br>                &#123;<br>                    st.insert(t);<br>                    ans+=j+<span class="hljs-string">&#x27;0&#x27;</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    t.pop_back();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>减为0的最小操作数</title>
    <link href="/2023/01/07/%E5%87%8F%E4%B8%BA0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/"/>
    <url>/2023/01/07/%E5%87%8F%E4%B8%BA0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%87%8F%E4%B8%BA0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0">减为0的最小操作数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="减为0的最小操作数"><a class="markdownIt-Anchor" href="#减为0的最小操作数"></a> 减为0的最小操作数</h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。</p><p>如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。</p><p>示例</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span>]<span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>输出：<span class="hljs-number">2</span><br>解释：最佳解决方案是移除后两个元素，将 <span class="hljs-keyword">x</span> 减到 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>双指针，首先计算小于<code>x</code>的最长后缀长度，然后依次从左向右加入左边元素，每加入一个元素，就尝试减少后缀长度，当前缀后缀的元素和等于<code>x</code>时更新<code>ans</code></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> minOperations(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> x) &#123;<br>        <span class="hljs-built_in">int</span> n=nums.size();<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>,r=n;<br>        <span class="hljs-keyword">while</span>(r&gt;<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-keyword">sum</span>+nums[r<span class="hljs-number">-1</span>]&lt;=x)<br>            <span class="hljs-keyword">sum</span>+=nums[--r];<br>        <span class="hljs-keyword">if</span>(r==<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-keyword">sum</span>&lt;x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-keyword">sum</span>==x?n-r:INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> l=<span class="hljs-number">0</span>;l&lt;n;++l)<br>        &#123;<br>            <span class="hljs-keyword">sum</span>+=nums[l];<br>            <span class="hljs-keyword">while</span>(r&lt;n&amp;&amp;<span class="hljs-keyword">sum</span>&gt;x)<span class="hljs-comment">//减少后缀</span><br>                <span class="hljs-keyword">sum</span>-=nums[r++];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&gt;x)<span class="hljs-comment">//前缀过大</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>==x)<br>                ans=min(ans,l+<span class="hljs-number">1</span>+n-r);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans&gt;n ? <span class="hljs-number">-1</span>:ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>考场就座</title>
    <link href="/2022/12/30/%E8%80%83%E5%9C%BA%E5%B0%B1%E5%BA%A7/"/>
    <url>/2022/12/30/%E8%80%83%E5%9C%BA%E5%B0%B1%E5%BA%A7/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%80%83%E5%9C%BA%E5%B0%B1%E5%BA%A7">考场就座</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="考场就座"><a class="markdownIt-Anchor" href="#考场就座"></a> 考场就座</h2><p><a href="https://leetcode.cn/problems/exam-room/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在考场里，一排有 N 个座位，分别编号为 0, 1, 2, …, N-1 。</p><p>当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)</p><p>返回 ExamRoom(int N) 类，它有两个公开的函数：其中，函数 ExamRoom.seat() 会返回一个 int （整型数据），代表学生坐的位置；函数 ExamRoom.leave(int p) 代表坐在座位 p 上的学生现在离开了考场。每次调用 ExamRoom.leave(p) 时都保证有学生坐在座位 p 上。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题主要解决坐在哪里的问题，设置一个<code>set</code>，每次安排座位，遍历一遍<code>set</code>，找出最大位置处，在此过程中，需要一个<code>pre</code>记录上一个座位的位置，然后<code>maxd</code>记录当前最大距离，如果当前位置距离大于<code>maxd</code>,那就更新插入位置和<code>maxd</code>即可</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExamRoom</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m;<br>    set&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-built_in">ExamRoom</span>(<span class="hljs-type">int</span> n) &#123;<br>        m=n;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">seat</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> pre=<span class="hljs-number">-1</span>,maxd=<span class="hljs-number">0</span>,p=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; t:st)<br>        &#123;<br>            <span class="hljs-type">int</span> d=(t-pre)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(d&gt;maxd)<br>            &#123;<br>                maxd=d;<br>                p= pre==<span class="hljs-number">-1</span>?<span class="hljs-number">0</span>:pre+d;<br>            &#125;<br>            pre=t;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(m<span class="hljs-number">-1</span>-pre&gt;maxd)<br>            p=m<span class="hljs-number">-1</span>;<br>        st.<span class="hljs-built_in">insert</span>(p);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leave</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>        st.<span class="hljs-built_in">erase</span>(p);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>统计特殊整数</title>
    <link href="/2022/12/22/%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E6%95%B4%E6%95%B0/"/>
    <url>/2022/12/22/%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E6%95%B4%E6%95%B0">统计特殊整数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="统计特殊整数"><a class="markdownIt-Anchor" href="#统计特殊整数"></a> 统计特殊整数</h2><p><a href="https://leetcode.cn/problems/count-special-integers/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。</p><p>给你一个 正 整数 n ，请你返回区间 [1, n] 之间特殊整数的数目。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>数位dp模板题，需要按位进行分情况讨论.</p><ul><li><p>用<code>dp[i][mask]</code>记录第i位状态为mask时的数目</p></li><li><p>定义了函数<code>f(int i,int mask,bool limit,bool isnum)</code></p></li><li><p><code>i</code>表示当前计算第<code>i</code>位，<code>mask</code>存储之前使用过得数字，<code>limit</code>表示当前位可以取的值是否受限制，<code>isnum</code>表示当前位前面是否有数字</p></li></ul><p>具体实现看代码即可</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSpecialNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        string s=<span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>,<span class="hljs-number">-1</span>));<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">bool</span>,<span class="hljs-type">bool</span>)&gt; f=[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> mask,<span class="hljs-type">bool</span> limit,<span class="hljs-type">bool</span> isnum)-&gt;<span class="hljs-type">int</span>&#123;<br>            <span class="hljs-keyword">if</span>(i==len)<br>                <span class="hljs-keyword">return</span> isnum;<br>            <span class="hljs-comment">//剪枝，如果当前位无limit且前面有数字，则可以利用之前计算过的结果</span><br>            <span class="hljs-keyword">if</span>(!limit&amp;&amp;isnum&amp;&amp;dp[i][mask]&gt;=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> dp[i][mask];<br>            <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//如果当前位之前没有填数字，跳过当前位</span><br>            <span class="hljs-keyword">if</span>(!isnum)<br>                res=<span class="hljs-built_in">f</span>(i+<span class="hljs-number">1</span>,mask,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>            <span class="hljs-type">int</span> up,down;<br>            <span class="hljs-comment">//如果有limit上界为s[i]，没有则上界为9</span><br>            up= limit ? s[i]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">9</span>;<br>            <span class="hljs-comment">//如果前面的位有数字，下界为0，否则下界为1</span><br>            down= isnum ? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=down;t&lt;=up;++t)<br>            &#123;<br>                <span class="hljs-comment">//如果当前数字没用过,则继续</span><br>                <span class="hljs-keyword">if</span>((mask&gt;&gt;t&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)<br>                &#123;<br>                    res+=<span class="hljs-built_in">f</span>(i+<span class="hljs-number">1</span>,mask|<span class="hljs-number">1</span>&lt;&lt;t,limit&amp;&amp;t==up,<span class="hljs-literal">true</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!limit&amp;&amp;isnum)<br>                 dp[i][mask]=res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分袋子里的球</title>
    <link href="/2022/12/20/%E5%88%86%E8%A2%8B%E5%AD%90%E9%87%8C%E7%9A%84%E7%90%83/"/>
    <url>/2022/12/20/%E5%88%86%E8%A2%8B%E5%AD%90%E9%87%8C%E7%9A%84%E7%90%83/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%88%86%E8%A2%8B%E5%AD%90%E9%87%8C%E7%9A%84%E7%90%83">分袋子里的球</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="分袋子里的球"><a class="markdownIt-Anchor" href="#分袋子里的球"></a> 分袋子里的球</h2><p><a href="">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。</p><p>你可以进行如下操作至多 maxOperations 次：</p><p>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。<br />比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。<br />你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。</p><p>请你返回进行上述操作后的最小开销。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用到二分的思想(<s>为什么我就想不到😢</s>)，对于二分的中间量mid，表示把当前所有数字全部分成小于等于mid的数字，统计操作次数，如果操作次数小于规定次数，r=mid-1，继续寻找更小的符合要求的mid，否则，l=mid+1,调大mid的值。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumSize</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> maxOperations)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=*<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,mid;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)<br>        &#123;<br>            mid=(l+r)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> cnt=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:nums)<br>                cnt+=(x<span class="hljs-number">-1</span>) / mid;<br>            <span class="hljs-keyword">if</span>(cnt&lt;=maxOperations)<br>            &#123;<br>                ans=mid;<br>                r=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>边长度限制的路径</title>
    <link href="/2022/12/14/%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/12/14/%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84">边长度限制的路径</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="边长度限制的路径"><a class="markdownIt-Anchor" href="#边长度限制的路径"></a> 边长度限制的路径</h2><p><a href="https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个 n 个点组成的无向图边集 edgeList ，其中 edgeList[i] = [ui, vi, disi] 表示点 ui 和点 vi 之间有一条长度为 disi 的边。请注意，两个点之间可能有 超过一条边 。</p><p>给你一个查询数组queries ，其中 queries[j] = [pj, qj, limitj] ，你的任务是对于每个查询 queries[j] ，判断是否存在从 pj 到 qj 的路径，且这条路径上的每一条边都 严格小于 limitj 。</p><p>请你返回一个 布尔数组 answer ，其中 answer.length == queries.length ，当 queries[j] 的查询结果为 true 时， answer 第 j 个值为 true ，否则为 false 。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><blockquote><p>主要用到并查集的思想，先将edgelist和queries中的边按长度升序排序，对于queries的每条边，先将edgelist中长度小于limit的边加入并查集，然后再判断queries的p,q是否连通，如果是，说明存在p到q的路径，而且因为当前并查集中的边都小于此query的limit，所以p到q路径上的所有边也小于limit，该query的结果为true，否则为false。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><p>我在实现并查集时习惯初始化为-1，但这道题不知道为什么不能初始化为-1，后面后机会再看吧😢</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vset,<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(vset[a]==a)<br>            <span class="hljs-keyword">return</span> a;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> vset[a]=<span class="hljs-built_in">find</span>(vset,vset[a]);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">distanceLimitedPathsExist</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edgeList, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(edgeList.<span class="hljs-built_in">begin</span>(),edgeList.<span class="hljs-built_in">end</span>(),[](vector&lt;<span class="hljs-type">int</span>&gt;&amp; a,vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>]&lt;b[<span class="hljs-number">2</span>];<br>        &#125;);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vset</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-built_in">iota</span>(vset.<span class="hljs-built_in">begin</span>(),vset.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">idx</span><span class="hljs-params">(queries.size())</span></span>;<br>        <span class="hljs-built_in">iota</span>(idx.<span class="hljs-built_in">begin</span>(),idx.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">sort</span>(idx.<span class="hljs-built_in">begin</span>(),idx.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;<br>            <span class="hljs-keyword">return</span> queries[a][<span class="hljs-number">2</span>]&lt;queries[b][<span class="hljs-number">2</span>];<br>        &#125;);<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(queries.size())</span></span>;<br>        <span class="hljs-type">int</span> sz=edgeList.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:idx)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(k&lt;sz&amp;&amp;edgeList[k][<span class="hljs-number">2</span>]&lt;queries[i][<span class="hljs-number">2</span>])<br>            &#123;<br>                <span class="hljs-type">int</span> x=<span class="hljs-built_in">find</span>(vset,edgeList[k][<span class="hljs-number">0</span>]);<br>                <span class="hljs-type">int</span> y=<span class="hljs-built_in">find</span>(vset,edgeList[k][<span class="hljs-number">1</span>]);<br>                vset[x]=y;<br>                ++k;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(vset,queries[i][<span class="hljs-number">0</span>])==<span class="hljs-built_in">find</span>(vset,queries[i][<span class="hljs-number">1</span>]))<br>                ans[i]=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆长方体</title>
    <link href="/2022/12/10/%E5%A0%86%E9%95%BF%E6%96%B9%E4%BD%93/"/>
    <url>/2022/12/10/%E5%A0%86%E9%95%BF%E6%96%B9%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%A0%86%E9%95%BF%E6%96%B9%E4%BD%93">堆长方体</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="堆长方体"><a class="markdownIt-Anchor" href="#堆长方体"></a> 堆长方体</h2><p><a href="https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你 n 个长方体 cuboids ，其中第 i 个长方体的长宽高表示为 cuboids[i] = [widthi, lengthi, heighti]（下标从 0 开始）。请你从 cuboids 选出一个 子集 ，并将它们堆叠起来。</p><p>如果 widthi &lt;= widthj 且 lengthi &lt;= lengthj 且 heighti &lt;= heightj ，你就可以将长方体 i 堆叠在长方体 j 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。</p><p>返回 堆叠长方体 cuboids 可以得到的 最大高度 。</p><p>示例:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cuboids = [[50,45,20],[95,37,53],[45,23,12]]<br>输出：190<br>解释：<br>第<span class="hljs-number"> 1 </span>个长方体放在底部，53x37 的一面朝下，高度为<span class="hljs-number"> 95 </span>。<br>第<span class="hljs-number"> 0 </span>个长方体放在中间，45x20 的一面朝下，高度为<span class="hljs-number"> 50 </span>。<br>第<span class="hljs-number"> 2 </span>个长方体放在上面，23x12 的一面朝下，高度为<span class="hljs-number"> 45 </span>。<br>总高度是<span class="hljs-number"> 95 </span>+<span class="hljs-number"> 50 </span>+<span class="hljs-number"> 45 </span>=<span class="hljs-number"> 190 </span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用到动态规划的思路，<code>dp[i]</code>表示到第i个长方体的最大高度，状态方程为<code>dp[i]=max(dp[i],dp[j]+cu[i][2])</code></p><p>动态规划之前，先对每个长方体内部排序，然后按<code>w,h,l</code>之和排序</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int maxHeight(vector&lt;vector&lt;int&gt;&gt;&amp; cuboids) &#123;<br>        int n=cuboids.size();<br>        for(auto&amp; t:cuboids)<br>        &#123;<br>            sort(t.begin(),t.end());<br>        &#125;<br>        sort(cuboids.begin(),cuboids.end(),<span class="hljs-comment">[&amp;]</span>(vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;<br>            return a<span class="hljs-comment">[0]</span>+a<span class="hljs-comment">[1]</span>+a<span class="hljs-comment">[2]</span>&lt;b<span class="hljs-comment">[0]</span>+b<span class="hljs-comment">[1]</span>+b<span class="hljs-comment">[2]</span>;<br>        &#125;);<br>        vector&lt;int&gt; dp(n);<br>        int ans=0;<br>        for(int i=0;i&lt;n;++i)<br>        &#123;<br>            dp<span class="hljs-comment">[i]</span>=cuboids<span class="hljs-comment">[i]</span><span class="hljs-comment">[2]</span>;<br>            for(int j=0;j&lt;i;++j)<br>            &#123;<br>                if(cuboids<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>&gt;=cuboids<span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span>&amp;&amp;cuboids<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span>&gt;=cuboids<span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span>&amp;&amp;cuboids<span class="hljs-comment">[i]</span><span class="hljs-comment">[2]</span>&gt;=cuboids<span class="hljs-comment">[j]</span><span class="hljs-comment">[2]</span>)<br>                &#123;<br>                    dp<span class="hljs-comment">[i]</span>=max(dp<span class="hljs-comment">[i]</span>,dp<span class="hljs-comment">[j]</span>+cuboids<span class="hljs-comment">[i]</span><span class="hljs-comment">[2]</span>);<br>                &#125;<br>            &#125;<br>            ans=max(ans,dp<span class="hljs-comment">[i]</span>);<br>        &#125;<br>        return ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>甜点成本</title>
    <link href="/2022/12/04/%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC/"/>
    <url>/2022/12/04/%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="甜点成本"><a class="markdownIt-Anchor" href="#甜点成本"></a> 甜点成本</h2><p><a href="https://leetcode.cn/problems/closest-dessert-cost/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则：</p><p>必须选择 一种 冰激凌基料。<br />可以添加 一种或多种 配料，也可以不添加任何配料。<br />每种类型的配料 最多两份 。<br />给你以下三个输入：</p><p>baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。<br />toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。<br />target ，一个整数，表示你制作甜点的目标价格。<br />你希望自己做的甜点总成本尽可能接近目标价格 target 。</p><p>返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。</p><p>示例</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：baseCosts = [2,3], toppingCosts = [4,5,100], target = 18<br>输出：17<br>解释：考虑下面的方案组合（所有下标均从<span class="hljs-number"> 0 </span>开始）：<br>- 选择<span class="hljs-number"> 1 </span>号基料：成本 3<br>- 选择<span class="hljs-number"> 1 </span>份<span class="hljs-number"> 0 </span>号配料：成本<span class="hljs-number"> 1 </span>x<span class="hljs-number"> 4 </span>= 4<br>- 选择<span class="hljs-number"> 2 </span>份<span class="hljs-number"> 1 </span>号配料：成本<span class="hljs-number"> 2 </span>x<span class="hljs-number"> 5 </span>= 10<br>- 选择<span class="hljs-number"> 0 </span>份<span class="hljs-number"> 2 </span>号配料：成本<span class="hljs-number"> 0 </span>x<span class="hljs-number"> 100 </span>= 0<br>总成本：3 +<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 10 </span>+<span class="hljs-number"> 0 </span>=<span class="hljs-number"> 17 </span>。不存在总成本为<span class="hljs-number"> 18 </span>的甜点制作方案。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这是一道背包问题的变种，可以把所有的方案分成两大类，总成本大于target的和总成本小于target的，我们要做的就是用一个变量res记录大于target的最小成本，然后对小于target的方案进行动态规划。</p><p>首先维护一个数组<code>can[]</code>,表示每个小于target的方案是否合法（即可以通过base或者配料组合得到的数值），先遍历basecosts，如果有x小于target的，则<code>can[x]=true</code>，大于target则更新res。然后开始动态规划，每个配料遍历两次，如果加上当前配料后成本大于target，则更新res，如果当前成本不合法，那么有可能减去当前配料后就合法了，所以据此更新当前的<code>can</code></p><p>最后，只需要考虑在<code>res-target</code>的距离内，小于target的方案有没有合法的，因为如果大于这个距离，那么最接近target的方案就是res了。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> closestCost(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; baseCosts, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; toppingCosts, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-built_in">int</span> b=*min_element(baseCosts.begin(),baseCosts.<span class="hljs-keyword">end</span>());<br>        <span class="hljs-keyword">if</span>(b&gt;=<span class="hljs-keyword">target</span>)<br>            <span class="hljs-keyword">return</span> b;<br>        vector&lt;bool&gt; can(<span class="hljs-keyword">target</span>+<span class="hljs-number">1</span>,false);<br>        <span class="hljs-built_in">int</span> res=<span class="hljs-number">2</span>*<span class="hljs-keyword">target</span>-b;<br>        for(<span class="hljs-built_in">int</span> &amp;t:baseCosts)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(t&lt;=<span class="hljs-keyword">target</span>)<br>                can[t]=true;<br>            <span class="hljs-keyword">else</span><br>                res=<span class="hljs-built_in">min</span>(res,t);<br>        &#125;<br>        for(<span class="hljs-built_in">int</span>&amp; t:toppingCosts)<br>        &#123;<br>            for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i)<br>            &#123;<br>                for(<span class="hljs-built_in">int</span> j=<span class="hljs-keyword">target</span>;j&gt;=<span class="hljs-number">0</span>;--j)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(can[j]&amp;&amp;j+t&gt;<span class="hljs-keyword">target</span>)<br>                        res=<span class="hljs-built_in">min</span>(res,j+t);<br>                    <span class="hljs-keyword">if</span>(j-t&gt;=<span class="hljs-number">0</span>)<br>                        can[j]=can[j]|can[j-t];<br>                &#125;<br>            &#125;<br>        &#125;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;=res-<span class="hljs-keyword">target</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(can[<span class="hljs-keyword">target</span>-i])<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">target</span>-i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动球的最小次数</title>
    <link href="/2022/12/02/%E7%A7%BB%E5%8A%A8%E7%90%83%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/12/02/%E7%A7%BB%E5%8A%A8%E7%90%83%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%A7%BB%E5%8A%A8%E6%89%80%E6%9C%89%E7%90%83%E5%88%B0%E6%AF%8F%E4%B8%AA%E7%9B%92%E5%AD%90%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0">移动所有球到每个盒子所需的最小操作数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="移动所有球到每个盒子所需的最小操作数"><a class="markdownIt-Anchor" href="#移动所有球到每个盒子所需的最小操作数"></a> 移动所有球到每个盒子所需的最小操作数</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有 n 个盒子。给你一个长度为 n 的二进制字符串 boxes ，其中 boxes[i] 的值为 ‘0’ 表示第 i 个盒子是 空 的，而 boxes[i] 的值为 ‘1’ 表示盒子里有 一个 小球。</p><p>在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。第 i 个盒子和第 j 个盒子相邻需满足 abs(i - j) == 1 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p><p>返回一个长度为 n 的数组 answer ，其中 answer[i] 是将所有小球移动到第 i 个盒子所需的 最小 操作数。</p><p>每个 answer[i] 都需要根据盒子的 初始状态 进行计算。</p><p>示例</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：boxes = &quot;110&quot;<br>输出：[1,1,3]<br>解释：每个盒子对应的最小操作数如下：<br>1) 第<span class="hljs-number"> 1 </span>个盒子：将一个小球从第<span class="hljs-number"> 2 </span>个盒子移动到第<span class="hljs-number"> 1 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。<br>2) 第<span class="hljs-number"> 2 </span>个盒子：将一个小球从第<span class="hljs-number"> 1 </span>个盒子移动到第<span class="hljs-number"> 2 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。<br>3) 第<span class="hljs-number"> 3 </span>个盒子：将一个小球从第<span class="hljs-number"> 1 </span>个盒子移动到第<span class="hljs-number"> 3 </span>个盒子，需要<span class="hljs-number"> 2 </span>步操作。将一个小球从第<span class="hljs-number"> 2 </span>个盒子移动到第<span class="hljs-number"> 3 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。共计<span class="hljs-number"> 3 </span>步操作。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题因为样例少，所以暴力也能过，这里用前缀和与后缀和进行优化。</p><p><code>pre[i]</code>表示把i位置之前所有的1移到i位置所需要的次数，状态方程<code>pre[i]=pre[i-1]+presum</code>,可以看做先把前面的所有球移动到i-1位置，需要<code>pre[i-1]</code>次，然后i-1位置一共有presum个小球，把他们依次移动到i位置即可</p><p>后缀同理，那么每个位置所需的移动次数就是<code>pre[i]+aft[i]</code></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minOperations</span><span class="hljs-params">(string boxes)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = boxes.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">aft</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-type">int</span> prsum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)<br>                pre[i] = pre[i - <span class="hljs-number">1</span>] + prsum;<br>            <span class="hljs-keyword">if</span>(boxes[i] == <span class="hljs-string">&#x27;1&#x27;</span>) <br>                ++prsum;<br>        &#125;<br><br>        <span class="hljs-type">int</span> afsum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&lt;n<span class="hljs-number">-1</span>)<br>                aft[i] = aft[i + <span class="hljs-number">1</span>] + afsum;<br>            <span class="hljs-keyword">if</span>(boxes[i] == <span class="hljs-string">&#x27;1&#x27;</span>) <br>                ++afsum;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i++)<br>            res[i] = pre[i] + aft[i];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大频率栈</title>
    <link href="/2022/11/30/%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/"/>
    <url>/2022/11/30/%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="最大频率栈"><a class="markdownIt-Anchor" href="#最大频率栈"></a> 最大频率栈</h2><p><a href="https://leetcode.cn/problems/maximum-frequency-stack/description/">题目</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。</p><p>实现 FreqStack 类:</p><p>FreqStack() 构造一个空的堆栈。<br />void push(int val) 将一个整数 val 压入栈顶。<br />int pop() 删除并返回堆栈中出现频率最高的元素。<br />如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</p><p>示例</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<br>[<span class="hljs-string">&quot;FreqStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>],<br>[[],[<span class="hljs-number">5</span>],[<span class="hljs-number">7</span>],[<span class="hljs-number">5</span>],[<span class="hljs-number">7</span>],[<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>],[],[],[],[]]<br>输出：[<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>]<br>解释：<br>FreqStack = <span class="hljs-keyword">new</span> FreqStack();<br>freqStack.<span class="hljs-built_in">push</span> (<span class="hljs-number">5</span>);<span class="hljs-comment">//堆栈为 [5]</span><br>freqStack.<span class="hljs-built_in">push</span> (<span class="hljs-number">7</span>);<span class="hljs-comment">//堆栈是 [5,7]</span><br>freqStack.<span class="hljs-built_in">push</span> (<span class="hljs-number">5</span>);<span class="hljs-comment">//堆栈是 [5,7,5]</span><br>freqStack.<span class="hljs-built_in">push</span> (<span class="hljs-number">7</span>);<span class="hljs-comment">//堆栈是 [5,7,5,7]</span><br>freqStack.<span class="hljs-built_in">push</span> (<span class="hljs-number">4</span>);<span class="hljs-comment">//堆栈是 [5,7,5,7,4]</span><br>freqStack.<span class="hljs-built_in">push</span> (<span class="hljs-number">5</span>);<span class="hljs-comment">//堆栈是 [5,7,5,7,4,5]</span><br>freqStack.<span class="hljs-built_in">pop</span> ();<span class="hljs-comment">//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。</span><br>freqStack.<span class="hljs-built_in">pop</span> ();<span class="hljs-comment">//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。</span><br>freqStack.<span class="hljs-built_in">pop</span> ();<span class="hljs-comment">//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。</span><br>freqStack.<span class="hljs-built_in">pop</span> ();<span class="hljs-comment">//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用一个map记录数字和对应频率，然后每一个频率对应一个栈，每当加入一个元素，就把这个元素加入到对应频率的栈中，取出时从最大频率对应的栈弹出元素即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FreqStack</span> &#123;<br><span class="hljs-keyword">public</span>: <br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>    unordered_map&lt;<span class="hljs-type">int</span>,stack&lt;<span class="hljs-type">int</span>&gt;&gt; st;<br>    <span class="hljs-type">int</span> maxfreq;<br>    <span class="hljs-built_in">FreqStack</span>() &#123;<br>        maxfreq=<span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ++mp[val];<br>        st[mp[val]].<span class="hljs-built_in">push</span>(val);<br>        maxfreq=<span class="hljs-built_in">max</span>(maxfreq,mp[val]);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=st[maxfreq].<span class="hljs-built_in">top</span>();<br>        st[maxfreq].<span class="hljs-built_in">pop</span>();<br>        --mp[res];<br>        <span class="hljs-keyword">if</span>(st[maxfreq].<span class="hljs-built_in">empty</span>())<br>            --maxfreq;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大平均值和的分组</title>
    <link href="/2022/11/28/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/"/>
    <url>/2022/11/28/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84">最大平均值和的分组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最大平均值和的分组"><a class="markdownIt-Anchor" href="#最大平均值和的分组"></a> 最大平均值和的分组</h2><p><a href="https://leetcode.cn/problems/largest-sum-of-averages/description/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个相邻的非空子数组 。 分数 由每个子数组内的平均值的总和构成。</p><p>注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。</p><p>返回我们所能得到的最大 分数 是多少。答案误差在 10-6 内被视为是正确的。</p><p>示例</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: nums = [<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>], k = <span class="hljs-number">3</span><br>输出: <span class="hljs-number">20.00000</span><br>解释: <br>nums 的最优分组是[<span class="hljs-number">9</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">9</span>]. 得到的分数是 <span class="hljs-number">9</span> + (<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>) / <span class="hljs-number">3</span> + <span class="hljs-number">9</span> = <span class="hljs-number">20.</span> <br>我们也可以把 nums 分成[<span class="hljs-number">9</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>]. <br>这样的分组得到的分数为 <span class="hljs-number">5</span> + <span class="hljs-number">2</span> + <span class="hljs-number">6</span> = <span class="hljs-number">13</span>, 但不是最大值.<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>动态规划，用<code>dp[i][j]</code>表示前i个数分j组时的最大平均值和，然后写出状态方程:<br /><code>dp[i][j]=max(dp[i][j],dp[x][j-1]+(sum[i]-sum[x])/(i-x))</code></p><ul><li>j:<code>2~k</code></li><li>i:<code>j~n</code></li><li>x:<code>j-1~i</code></li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">largestSumOfAverages</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            sum[i+<span class="hljs-number">1</span>]=sum[i]+nums[i];<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(k+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            dp[i][<span class="hljs-number">1</span>]=sum[i]/i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=k;++j)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=j;i&lt;=n;++i)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=j<span class="hljs-number">-1</span>;x&lt;i;++x)<br>                &#123;<br>                    dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j],dp[x][j<span class="hljs-number">-1</span>]+(sum[i]-sum[x])/(i-x));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最长公共子串</title>
    <link href="/2022/11/27/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/11/27/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2">最长公共子串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最长公共子串"><a class="markdownIt-Anchor" href="#最长公共子串"></a> 最长公共子串</h2><h3 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h3><p>给定两个字符串str1和str2,输出两个字符串的最长公共子串，如果最长公共子串为空，输出-1。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>一道模板题，这里要输出最长的公共子串而不是其长度，代码如下</p><p>注意，<code>starti</code>从第一个字符串末尾开始，<code>startj</code>从第二个字符串开头开始</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>string maxsubstr(string s1,string s2)<br>&#123;<br>int <span class="hljs-attribute">l1</span>=s1.size();<br>int <span class="hljs-attribute">l2</span>=s2.size();<br>int <span class="hljs-attribute">maxlen</span>=0,curlen=0;<br>int <span class="hljs-attribute">starti</span>=l1-1,startj=0;<br>int <span class="hljs-attribute">endi</span>=-1;<br><span class="hljs-keyword">while</span>(startj&lt;l2)<br>&#123;<br><span class="hljs-attribute">curlen</span>=0;<br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=starti,j=startj;i&lt;l1&amp;&amp;j&lt;l2;++i,++j)<br>&#123;<br><span class="hljs-keyword">if</span>(s1[i]==s2[j])<br>&#123;<br>++curlen;<br><span class="hljs-keyword">if</span>(curlen&gt;maxlen)<br>&#123;<br><span class="hljs-attribute">maxlen</span>=curlen;<br><span class="hljs-attribute">endi</span>=i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-attribute">curlen</span>=0;<br>&#125;<br><span class="hljs-keyword">if</span>(starti&gt;0)<br>--starti;<br><span class="hljs-keyword">else</span><br>++startj;<br>&#125;<br>return <span class="hljs-attribute">maxlen</span>==0 ? <span class="hljs-string">&quot;-1&quot;</span>:s1.substr(endi-maxlen+1,maxlen);<br>&#125;<br><br>int main()<br>&#123;<br>string s1,s2;<br>cin&gt;&gt;s1&gt;&gt;s2;<br>cout&lt;&lt;maxsubstr(s1,s2)&lt;&lt;endl;<br>return 0;<br><br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>细分图的可到达节点</title>
    <link href="/2022/11/26/%E7%BB%86%E5%88%86%E5%9B%BE%E7%9A%84%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9/"/>
    <url>/2022/11/26/%E7%BB%86%E5%88%86%E5%9B%BE%E7%9A%84%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BB%86%E5%88%86%E5%9B%BE%E7%9A%84%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9">细分图的可到达节点</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="细分图的可到达节点"><a class="markdownIt-Anchor" href="#细分图的可到达节点"></a> 细分图的可到达节点</h2><p><a href="https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个无向图（原始图），图中有 n 个节点，编号从 0 到 n - 1 。你决定将图中的每条边 细分 为一条节点链，每条边之间的新节点数各不相同。</p><p>图用由边组成的二维数组 edges 表示，其中 edges[i] = [ui, vi, cnti] 表示原始图中节点 ui 和 vi 之间存在一条边，cnti 是将边 细分 后的新节点总数。注意，cnti == 0 表示边不可细分。</p><p>要 细分 边 [ui, vi] ，需要将其替换为 (cnti + 1) 条新边，和 cnti 个新节点。新节点为 x1, x2, …, xcnti ，新边为 [ui, x1], [x1, x2], [x2, x3], …, [xcnti+1, xcnti], [xcnti, vi] 。</p><p>现在得到一个 新的细分图 ，请你计算从节点 0 出发，可以到达多少个节点？如果节点间距离是 maxMoves 或更少，则视为 可以到达 。</p><p>给你原始图和 maxMoves ，返回 新的细分图中从节点 0 出发 可到达的节点数 。</p><p>示例</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：edges = <span class="hljs-comment">[<span class="hljs-comment">[0,1,4]</span>,<span class="hljs-comment">[1,2,6]</span>,<span class="hljs-comment">[0,2,8]</span>,<span class="hljs-comment">[1,3,1]</span>]</span>, maxMoves = 10, n = 4<br>输出：23<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题看了一遍题没太看懂，本来想直接cv了😢，看了眼题解发现是最短路，就参考大佬灵茶山的题解写了，顺便复习一下堆优化的dijkstra和链式前向星存图</p><p><a href="https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/solutions/1991509/tu-jie-zhuan-huan-cheng-dan-yuan-zui-dua-6l8o/">链接</a></p><ul><li>首先需要进行一边dijkstra，求出0到其他点的最短路</li><li>遍历所有顶点，小于maxmoves则<code>++ans</code></li><li>遍历所有边，设一条边的起点和终点为u和v，分别用maxmoves减去<code>dis[u]</code>和<code>dis[v]</code>得到a和b,这条边上符合要求的点个数即为<code>min(a+b,cnt)</code>,加入到ans中即可</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> dis[<span class="hljs-number">3005</span>];<br>    <span class="hljs-built_in">bool</span> vis[<span class="hljs-number">3005</span>];<br>    static <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">int</span> head[N];<br>    <span class="hljs-built_in">int</span> cnt;<br>    struct edges<br>    &#123;<br>        <span class="hljs-built_in">int</span> to,next,w;<br>    &#125;e[<span class="hljs-number">2</span>*N];<br><br>    struct node<br>    &#123;<br>        <span class="hljs-built_in">int</span> n,w;<br>        node(<span class="hljs-built_in">int</span> nn,<span class="hljs-built_in">int</span> ww):n(nn),w(ww)&#123;&#125;<br>        <span class="hljs-built_in">bool</span> operator &lt; (<span class="hljs-keyword">const</span> node &amp; t) <span class="hljs-keyword">const</span>&#123;<br>            <span class="hljs-keyword">return</span> w&gt;t.w;<br>        &#125;<br>    &#125;;<br>    priority_queue&lt;node&gt; q;<br>    <span class="hljs-built_in">void</span> add(<span class="hljs-built_in">int</span> u,<span class="hljs-built_in">int</span> v,<span class="hljs-built_in">int</span> w)<br>    &#123;<br>        ++cnt;<br>        e[cnt].to=v;<br>        e[cnt].w=w;<br>        e[cnt].next=head[u];<br>        head[u]=cnt;<br>    &#125;<br>    <span class="hljs-built_in">int</span> reachableNodes(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; edges, <span class="hljs-built_in">int</span> maxMoves, <span class="hljs-built_in">int</span> n) <br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">auto</span> &amp;e: edges) <br>        &#123;<br>            <span class="hljs-built_in">int</span> u = e[<span class="hljs-number">0</span>], v = e[<span class="hljs-number">1</span>], cnt = e[<span class="hljs-number">2</span>];<br>            add(u,v,cnt+<span class="hljs-number">1</span>);<br>            add(v,u,cnt+<span class="hljs-number">1</span>);<br>        &#125;<br>        memset(dis,<span class="hljs-number">0x3f</span>,sizeof(dis));<br>        <span class="hljs-built_in">int</span> u,v,w;<br>        dis[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        q.push(node(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">while</span>(!q.empty())<br>        &#123;<br>            node t=q.top();<br>            q.pop();<br>            u=t.n;<br>            <span class="hljs-keyword">if</span>(!vis[u])<br>            &#123;<br>                vis[u]=<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=head[u];i;i=e[i].next)<br>                &#123;<br>                    v=e[i].to;<br>                    w=e[i].w;<br>                    <span class="hljs-keyword">if</span>(dis[u]+w&lt;dis[v])<br>                    &#123;<br>                        dis[v]=dis[u]+w;<br>                        <span class="hljs-keyword">if</span>(!vis[v])<br>                            q.push(node(v,dis[v]));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// return dis[2];</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(dis[i]&lt;=maxMoves)<br>                ++ans;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">auto</span> &amp;e: edges) <br>        &#123;<br>            <span class="hljs-built_in">int</span> u = e[<span class="hljs-number">0</span>], v = e[<span class="hljs-number">1</span>], cnt = e[<span class="hljs-number">2</span>];<br>            <span class="hljs-built_in">int</span> a=max(maxMoves-dis[u],<span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">int</span> b=max(maxMoves-dis[v],<span class="hljs-number">0</span>);<br>            ans+=min(a+b,cnt);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>情感丰富的文字</title>
    <link href="/2022/11/25/%E6%83%85%E6%84%9F%E4%B8%B0%E5%AF%8C%E7%9A%84%E6%96%87%E5%AD%97/"/>
    <url>/2022/11/25/%E6%83%85%E6%84%9F%E4%B8%B0%E5%AF%8C%E7%9A%84%E6%96%87%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="情感丰富的文字"><a class="markdownIt-Anchor" href="#情感丰富的文字"></a> 情感丰富的文字</h2><p><a href="https://leetcode.cn/problems/expressive-words/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有时候人们会用重复写一些字母来表示额外的感受，比如 “hello” -&gt; “heeellooo”, “hi” -&gt; “hiii”。我们将相邻字母都相同的一串字符定义为相同字母组，例如：“h”, “eee”, “ll”, “ooo”。</p><p>对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 c ），然后往其中添加相同的字母 c 使其长度达到 3 或以上。</p><p>例如，以 “hello” 为例，我们可以对字母组 “o” 扩张得到 “hellooo”，但是无法以同样的方法得到 “helloo” 因为字母组 “oo” 长度小于 3。此外，我们可以进行另一种扩张 “ll” -&gt; “lllll” 以获得 “helllllooo”。如果 S = “helllllooo”，那么查询词 “hello” 是可扩张的，因为可以对它执行这两种扩张操作使得 query = “hello” -&gt; “hellooo” -&gt; “helllllooo” = S。</p><p>输入一组查询单词，输出其中可扩张的单词数量。</p><p>示例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">输入： <br>S = <span class="hljs-string">&quot;heeellooo&quot;</span><br>words = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;helo&quot;</span>]<br>输出：1<br>解释：<br>我们能通过扩张 <span class="hljs-string">&quot;hello&quot;</span> 的 <span class="hljs-string">&quot;e&quot;</span> 和 <span class="hljs-string">&quot;o&quot;</span> 来得到 <span class="hljs-string">&quot;heeellooo&quot;</span>。<br>我们不能通过扩张 <span class="hljs-string">&quot;helo&quot;</span> 来得到 <span class="hljs-string">&quot;heeellooo&quot;</span> 因为 <span class="hljs-string">&quot;ll&quot;</span> 的长度小于 3 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>定义两个指针分别从左到右遍历字符串，统计连续字符的出现频率，分以下情况：</p><ul><li>当两个指针对应的字符不同，不匹配</li><li>当s的指针统计的字符c出现次数小于于t中该字符次数，不匹配</li><li>如果字符c在两个串中出现的次数不相等，且在s中出现次数小于3,不匹配</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">judge</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>&amp; s,<span class="hljs-built_in">string</span>&amp; t</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> len1=s.size();<br>        <span class="hljs-built_in">int</span> len2=t.size();<br>        <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">char</span> c;<br>        <span class="hljs-keyword">while</span>(i&lt;len1&amp;&amp;j&lt;len2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]!=t[j])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            c=s[i];<br>            <span class="hljs-built_in">int</span> c1=<span class="hljs-number">0</span>,c2=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(i&lt;len1&amp;&amp;s[i]==c)<br>            &#123;<br>                ++i;<br>                ++c1;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(j&lt;len2&amp;&amp;t[j]==c)<br>            &#123;<br>                ++j;<br>                ++c2;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(c1&lt;c2)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c1&gt;c2&amp;&amp;c1&lt;<span class="hljs-number">3</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i==len1&amp;&amp;j==len2;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">expressiveWords</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s, vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; words</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">string</span>&amp; ss:words)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(judge(s,ss))<br>                ++ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>到达首都的最小油耗</title>
    <link href="/2022/11/21/%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B2%B9%E8%80%97/"/>
    <url>/2022/11/21/%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B2%B9%E8%80%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B2%B9%E8%80%97">到达首都的最小油耗</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="到达首都的最小油耗"><a class="markdownIt-Anchor" href="#到达首都的最小油耗"></a> 到达首都的最小油耗</h2><p><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一棵 n 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 0 到 n - 1 ，且恰好有 n - 1 条路。0 是首都。给你一个二维整数数组 roads ，其中 roads[i] = [ai, bi] ，表示城市 ai 和 bi 之间有一条 双向路 。</p><p>每个城市里有一个代表，他们都要去首都参加一个会议。</p><p>每座城市里有一辆车。给你一个整数 seats 表示每辆车里面座位的数目。</p><p>城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。</p><p>请你返回到达首都最少需要多少升汽油。</p><p>示例</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2<br>输出：7<br>解释：<br>- 代表<span class="hljs-number"> 2 </span>到达城市<span class="hljs-number"> 3 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 2 </span>和代表<span class="hljs-number"> 3 </span>一起到达城市<span class="hljs-number"> 1 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 2 </span>和代表<span class="hljs-number"> 3 </span>一起到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 1 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 5 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 6 </span>到达城市<span class="hljs-number"> 4 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 4 </span>和代表<span class="hljs-number"> 6 </span>一起到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>最少消耗<span class="hljs-number"> 7 </span>升汽油。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题实际上是在算车的数量，以0为根节点，用dfs来计算所有树对0的贡献值</p><p>例如，某个子树如下图:</p><p><img src="https://pic.leetcode.cn/1668950622-FRRlaR-4.png" alt="fig1" /></p><p>最下面两个节点的贡献各自为1,然后第二层的节点有3个人，而座位数为2，那么贡献值就是2（3/2向上取整）,所以该子树的总贡献是1+1+2=4</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">minimumFuelCost</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; roads, <span class="hljs-type">int</span> seats)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=roads.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; t:roads)<br>        &#123;<br>            g[t[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(t[<span class="hljs-number">1</span>]);<br>            g[t[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(t[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">0</span>;<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; dfs=[&amp;](<span class="hljs-type">int</span> t,<span class="hljs-type">int</span> par)-&gt;<span class="hljs-type">int</span>&#123;<br>            <span class="hljs-type">int</span> num=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; c:g[t])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(c!=par)<br>                    num+=<span class="hljs-built_in">dfs</span>(c,t);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(t!=<span class="hljs-number">0</span>)<br>                ans+=(num<span class="hljs-number">-1</span>)/seats+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> num;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>香槟塔</title>
    <link href="/2022/11/20/%E9%A6%99%E6%A7%9F%E5%A1%94/"/>
    <url>/2022/11/20/%E9%A6%99%E6%A7%9F%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%A6%99%E6%A7%9F%E5%A1%94">香槟塔</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="香槟塔"><a class="markdownIt-Anchor" href="#香槟塔"></a> 香槟塔</h2><p><a href="https://leetcode.cn/problems/champagne-tower/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>示例</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: poured = <span class="hljs-number">100000009</span>, query_row = <span class="hljs-number">33</span>, query_glass = <span class="hljs-number">17</span><br>输出: <span class="hljs-number">1.00000</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>一开始以为是个数学规律题，结果没想到还是个动态规划😂</p><p><code>dp[i][j]</code>表示第i行第j个杯子的盛水量，可以得出状态方程为：</p><p><code>dp[i][j]=max(dp[i-1][j]-1,0.0)/2+max(dp[i-1][j-1]-1,0.0)/2;</code></p><p>为了防止下标越界，dp数组下标从1开始</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">champagneTower</span><span class="hljs-params">(<span class="hljs-type">int</span> poured, <span class="hljs-type">int</span> query_row, <span class="hljs-type">int</span> query_glass)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">101</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">101</span>));<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=poured;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=query_row+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;++j)<br>            &#123;<br>                dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j]<span class="hljs-number">-1</span>,<span class="hljs-number">0.0</span>)/<span class="hljs-number">2</span>+<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>,<span class="hljs-number">0.0</span>)/<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[query_row+<span class="hljs-number">1</span>][query_glass+<span class="hljs-number">1</span>],<span class="hljs-number">1.0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子序列宽度之和</title>
    <link href="/2022/11/18/%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/11/18/%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C">子序列宽度之和</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="子序列宽度之和"><a class="markdownIt-Anchor" href="#子序列宽度之和"></a> 子序列宽度之和</h2><p><a href="https://leetcode.cn/problems/sum-of-subsequence-widths/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>一个序列的 宽度 定义为该序列中最大元素和最小元素的差值。</p><p>给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 109 + 7 取余 后的结果。</p><p>子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。</p><p>示例</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,1,3]</span><br>输出：6<br>解释：子序列为 <span class="hljs-comment">[1]</span>, <span class="hljs-comment">[2]</span>, <span class="hljs-comment">[3]</span>, <span class="hljs-comment">[2,1]</span>, <span class="hljs-comment">[2,3]</span>, <span class="hljs-comment">[1,3]</span>, <span class="hljs-comment">[2,1,3]</span> 。<br>相应的宽度是 0, 0, 0, 1, 1, 2, 2 。<br>宽度之和是 6 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题没什么好的思路，参考了大佬的：<a href="https://leetcode.cn/problems/sum-of-subsequence-widths/solutions/1977443/tan-xin-by-heren1229-bo9s/">链接</a></p><p>我们知道，一个数组有<code>2^n-1个</code>非空子序列，枚举显然是不可行的。 换一个角度思考这个问题，事实上，对于每一个子序列，元素的顺序不影响结果，因为我们只要知道它的最大值和最小值就可以了。所以我们想知道，对每一个元素来说，有几个子序列以它为最大值，又有几个子序列以它为最小值？ 考虑以某个元素为最小值的序列个数。如果是整个序列的最小值，显然，所有包含它的子序列都以它为最小值，数目为<code>2^(n-1)</code>。那次小值呢？就是包含它，但不包含最小值的序列个数，就是2<sup>(n-2)，这样，我们就看出规律来了：如果某个数是数组中第k小的元素，那么以它为最小值的子序列就有2</sup>(n-k)个。其实也很好理解，我们从选与不选的角度考虑子序列个数，当确定以第k小的元素为最小值时，前面k-1个都不能选，第k个必须选，剩下可选可不选的还有n-k个，子序列自然就是<code>2^(n-k)</code>个了。 同理，以第k大元素为最大值的子序列也有<code>2^(n-k)</code>个。 接下来考虑如何用代码计算。直接写是不可能的，因为不可能算<code>2^100000</code>，所以我们维护一个系数，从1到<code>2^(n-1)</code>，每次乘二，根据上述的描述，可以推知，以第k小元素为最大值的序列数=以第k大元素为最小值的序列数<code>2^k</code>，(k从0开始)，所以我们从小到大遍历，每次加上<code>(2^k)</code>乘以第k小值，减去<code>(2^k)</code>乘以第k大值。 排序时间复杂度O(nlogn)，计算时间复杂度O(n)</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">mod</span>=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>; <br>    <span class="hljs-built_in">int</span> sumSubseqWidths(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">int</span> n=nums.size();<br>        sort(nums.begin(),nums.end());<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> k=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            ans=(ans+nums[i]*k-nums[n<span class="hljs-number">-1</span>-i]*k)%<span class="hljs-keyword">mod</span>;<br>            k=(k*<span class="hljs-number">2</span>)%<span class="hljs-keyword">mod</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>匹配子序列的单词数</title>
    <link href="/2022/11/17/%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
    <url>/2022/11/17/%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0">匹配子序列的单词数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="匹配子序列的单词数"><a class="markdownIt-Anchor" href="#匹配子序列的单词数"></a> 匹配子序列的单词数</h2><p><a href="https://leetcode.cn/problems/number-of-matching-subsequences/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定字符串 s 和字符串数组 words, 返回  words[i] 中是s的子序列的单词个数 。</p><p>字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。</p><p>例如， “ace” 是 “abcde” 的子序列。</p><p>示例：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入: s = <span class="hljs-string">&quot;dsahjpjauf&quot;</span>, <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;ahjpjau&quot;</span>,<span class="hljs-string">&quot;ja&quot;</span>,<span class="hljs-string">&quot;ahbwzgqnuk&quot;</span>,<span class="hljs-string">&quot;tnmlanowax&quot;</span>]<br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用<code>pair(i,j)</code>表示words中，第<code>i</code>个字符串的查询到了第<code>j</code>个字符，开始先将words中所有字符串的第一个字符放入对应queue中，然后遍历所有s中的字符，取出字符对应的queue，然后依次出队列，将对应words中的字符串的下标<code>j</code>增加1，如果<code>j</code>等于所在字符串的长度，说明该字符串符合要求。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numMatchingSubseq</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=words.<span class="hljs-built_in">size</span>();<br>        vector&lt;queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">v</span>(<span class="hljs-number">26</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>            v[words[i][<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">push</span>(&#123;i,<span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span>&amp; c:s)<br>        &#123;<br>            <span class="hljs-keyword">auto</span>&amp; q=v[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-type">int</span> n=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(n--)<br>            &#123;<br>                <span class="hljs-type">int</span> i=q.<span class="hljs-built_in">front</span>().first;<br>                <span class="hljs-type">int</span> j=q.<span class="hljs-built_in">front</span>().second;<br>                q.<span class="hljs-built_in">pop</span>();<br>                ++j;<br>                <span class="hljs-keyword">if</span>(j==words[i].<span class="hljs-built_in">size</span>())<br>                    ++ans;<br>                <span class="hljs-keyword">else</span><br>                    v[words[i][j]-<span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">push</span>(&#123;i,j&#125;);                <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回文串个数</title>
    <link href="/2022/11/13/%E5%9B%9E%E6%96%87%E4%B8%B2%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/11/13/%E5%9B%9E%E6%96%87%E4%B8%B2%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">回文子串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE">不重叠回文子字符串的最大数目</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="回文子串"><a class="markdownIt-Anchor" href="#回文子串"></a> 回文子串</h2><p><a href="https://leetcode.cn/problems/palindromic-substrings/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aaa&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<span class="hljs-number">6</span>个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>关于回文串数量问题一般用中心扩展法，即：</p><blockquote><p>枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。</p></blockquote><p>关于回文中心的数量，有以下规律：</p><ul><li>长度为<code>n</code>的字符串可以得到<code>2*n-1</code>组回文中心<code>[l,r]</code></li><li>第<code>i</code>组回文中心的<code>l=i/2,r=i/2+i%2</code>;</li></ul><p>从所有回文中心开始扩展，可以得到所有回文子串的数量</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> countSubstrings(<span class="hljs-built_in">string</span> s) &#123;<br>        <span class="hljs-built_in">int</span> n=s.size();<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-built_in">int</span> l=i/<span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">int</span> r=l+i%<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span>(l&gt;=<span class="hljs-number">0</span>&amp;&amp;r&lt;n&amp;&amp;s[l]==s[r])<br>            &#123;<br>                --l;<br>                ++r;<br>                ++ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="不重叠回文子字符串的最大数目"><a class="markdownIt-Anchor" href="#不重叠回文子字符串的最大数目"></a> 不重叠回文子字符串的最大数目</h2><p><a href="https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/description/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>给你一个字符串 s 和一个 正 整数 k 。</p><p>从字符串 s 中选出一组满足下述条件且 不重叠 的子字符串：</p><p>每个子字符串的长度 至少 为 k 。<br />每个子字符串是一个 回文串 。<br />返回最优方案中能选择的子字符串的 最大 数目。</p><p>子字符串 是字符串中一个连续的字符序列。</p><p>示例</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abaccdbbd&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：可以选择 <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abaccdbbd&quot;</span> 中斜体加粗的子字符串。<span class="hljs-string">&quot;aba&quot;</span> 和 <span class="hljs-string">&quot;dbbd&quot;</span> 都是回文，且长度至少为 <span class="hljs-attr">k</span> = <span class="hljs-number">3</span> 。<br>可以证明，无法选出两个以上的有效子字符串。<br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>主要思路是中心扩展法+dp</p><p>中心扩展法可参考上面的题，此题中用<code>dp[i]</code>表示<code>0～i-1</code>的子串中符合要求的子串个数，通过中心扩展法可得到若干回文中心，对于每一个回文中心，要更新l、r对应的dp值，即<code>dp[l+1]</code>和<code>dp[r+1]</code>。</p><ul><li>对于<code>dp[l+1]</code>，要考虑是否加入<code>l</code>位置的字符，所以<code>dp[l+1]=max(dp[l+1],dp[l])</code></li><li>对于<code>dp[r+1]</code>，因为<code>l~r</code>是个回文串，所以比较的是<code>0~l-1</code>和<code>0~r</code>这两段，<code>dp[r+1]=max(dp[r+1],dp[l]+1)</code></li></ul><p>最后<code>dp[n]</code>即最终答案</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> maxPalindromes(<span class="hljs-keyword">string</span> s, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">int</span> n=s.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">int</span> l=i/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> r=l+i%2;<br>            dp[l+<span class="hljs-number">1</span>]=<span class="hljs-keyword">max</span>(dp[l+<span class="hljs-number">1</span>],dp[l]);<br>            <span class="hljs-keyword">while</span>(l&gt;=<span class="hljs-number">0</span>&amp;&amp;r&lt;n&amp;&amp;s[l]==s[r])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(r-l+<span class="hljs-number">1</span>&gt;=k)<br>                &#123;<br>                    dp[r+<span class="hljs-number">1</span>]=<span class="hljs-keyword">max</span>(dp[r+<span class="hljs-number">1</span>],dp[l]+<span class="hljs-number">1</span>);<br>                &#125;<br>                --l;<br>                ++r;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多米诺和托米诺平铺</title>
    <link href="/2022/11/12/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/"/>
    <url>/2022/11/12/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA">多米诺和托米诺平铺</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="多米诺和托米诺平铺"><a class="markdownIt-Anchor" href="#多米诺和托米诺平铺"></a> 多米诺和托米诺平铺</h2><p><a href="https://leetcode.cn/problems/domino-and-tromino-tiling/description/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。<br /><img src="https://assets.leetcode.com/uploads/2021/07/15/lc-domino.jpg" alt="" /><br />给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 109 + 7 取模 的值。</p><p>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 3</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>动态规划题目，<code>dp[i][4]</code>表示第i列在4种情况下的类数。</p><ul><li>dp[i][0]:当第i列一个瓷砖也没有，说明上一列填满了,<code>dp[i][0]=dp[i-1][3]</code></li><li>dp[i][1]:第i列只有上边有瓷砖，说明i-1列可能只有下边有，或者一个也没有，<code>dp[i][1]=dp[i-1][0]+dp[i-1][2]</code></li><li>dp[i][2]:第i列只有下边有瓷砖，说明i-1列可能只有上边有，或者一个也没有，<code>dp[i][2]=dp[i-1][0]+dp[i-1][1]</code></li><li>dp[i][3]:第i列上下都有，可能i-1列上下都有，也可能i-1列上或者下有，要加L型的，也可能i-1列上下都没有，加了两个多米诺的。<code>dp[i][3]=dp[i-1][0]+dp[i-1][1]+dp[i-1][2]+dp[i-1][3]</code></li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><br>class <span class="hljs-symbol">Solution</span> &#123;<br>public:<br>    static const int mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>    long long dp[<span class="hljs-number">1001</span>][<span class="hljs-number">4</span>];<br>    int numTilings(int n) &#123;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;<br>        for(int i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            dp[i][<span class="hljs-number">0</span>]=dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>]<span class="hljs-comment">%mod;</span><br>            dp[i][<span class="hljs-number">1</span>]=(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>])<span class="hljs-comment">%mod;</span><br>            dp[i][<span class="hljs-number">2</span>]=(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])<span class="hljs-comment">%mod;</span><br>            dp[i][<span class="hljs-number">3</span>]=(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>])<span class="hljs-comment">%mod;</span><br>        &#125;<br>        return dp[n][<span class="hljs-number">3</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2022/11/11/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/11/11/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%95%BF%E5%BA%A6%E4%B8%BA-k-%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">长度为 K 子数组中的最大和</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0">区间子数组个数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li></ul><!-- /TOC --><blockquote><p>滑动窗口也是很典型的一类题，这里举个简单的例子回顾一下主要思想。<s>(水篇博客😂)</s></p></blockquote><h2 id="长度为-k-子数组中的最大和"><a class="markdownIt-Anchor" href="#长度为-k-子数组中的最大和"></a> 长度为 K 子数组中的最大和</h2><p><a href="https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和：</p><p>子数组的长度是 k，且<br />子数组中的所有元素 各不相同 。<br />返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。</p><p>子数组 是数组中一段连续非空的元素序列。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>设置一个<code>hashset</code>，用<code>l</code>记录滑动窗口左端下标，然后遍历数组中的所有元素，分以下三种情况：</p><ul><li>判断set中有没有该元素，有的话不断删除最左边的数直到没有该元素</li><li>窗口大小如果大于等于k，从左边删除一个元素，然后加入当前元素，更新最大和</li><li>窗口大小如果小于k，则加入当前元素，如果加入后窗口大小为k，更新最大和</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_set&lt;<span class="hljs-built_in">int</span>&gt; st;<br>    <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> maximumSubarraySum(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> len=nums.size();<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> l=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-keyword">count</span>(nums[i]))<br>            &#123;<br>                <span class="hljs-keyword">sum</span>-=nums[l];<br>                st.erase(nums[l]);<br>                ++l;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i-l&gt;=k)<br>            &#123;<br>                <span class="hljs-keyword">sum</span>-=nums[l];<br>                st.erase(nums[l]);<br>                ++l;<br>                <span class="hljs-keyword">sum</span>+=nums[i];<br>                st.insert(nums[i]);<br>                ans=max(ans,<span class="hljs-keyword">sum</span>);   <br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                st.insert(nums[i]);<br>                <span class="hljs-keyword">sum</span>+=nums[i];<br>                <span class="hljs-keyword">if</span>(i-l==k<span class="hljs-number">-1</span>)<br>                    ans=max(ans,<span class="hljs-keyword">sum</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="区间子数组个数"><a class="markdownIt-Anchor" href="#区间子数组个数"></a> 区间子数组个数</h2><p><a href="https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/description/">题目链接</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。</p><p>生成的测试用例保证结果符合 32-bit 整数范围。</p><p>示例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[2,1,4,3]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：满足条件的三个子数组：<span class="hljs-selector-attr">[2]</span>, <span class="hljs-selector-attr">[2, 1]</span>, <span class="hljs-selector-attr">[3]</span><br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>用l和r记录滑动窗口的左右端，然后从左到右遍历数组，如果当前元素符合要求，<code>r=i</code>，如果当前元素大于right，<code>r=i+1</code>,然后加上每次的结果<code>r-l+1</code></p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    <span class="hljs-built_in">int</span> numSubarrayBoundedMax(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span>=nums.size();<br>        <span class="hljs-built_in">int</span> l=<span class="hljs-number">0</span>,r=-<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>;++i)<br>        &#123;<br>            <span class="hljs-built_in">if</span>(nums[i]&gt;=<span class="hljs-built_in">left</span>&amp;&amp;nums[i]&lt;=<span class="hljs-built_in">right</span>)<br>                r=i;<br>            else <span class="hljs-built_in">if</span>(nums[i]&gt;<span class="hljs-built_in">right</span>)<br>                l=i+<span class="hljs-number">1</span>;<br>            ans+=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,r-l+<span class="hljs-number">1</span>);<br>        &#125;<br>        return ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>获取所有钥匙的最短路径</title>
    <link href="/2022/11/10/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/11/10/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">获取所有钥匙的最短路径</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="获取所有钥匙的最短路径"><a class="markdownIt-Anchor" href="#获取所有钥匙的最短路径"></a> 获取所有钥匙的最短路径</h2><p><a href="https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个二维网格 grid ，其中：</p><p>‘.’ 代表一个空房间<br />‘#’ 代表一堵<br />‘@’ 是起点<br />小写字母代表钥匙<br />大写字母代表锁<br />我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p><p>假设 k 为 钥匙/锁 的个数，且满足 1 &lt;= k &lt;= 6，字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p><p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。</p><p>示例：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@.a.#&quot;</span>,<span class="hljs-string">&quot;###.#&quot;</span>,<span class="hljs-string">&quot;b.A.B&quot;</span>]<br>输出：<span class="hljs-number">8</span><br>解释：目标是获得所有钥匙，而不是打开所有锁<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用一个三元组<code>(x,y,status)</code> 表示当前的状态，其中 <code>(x,y)</code> 表示当前所处的位置，<code>status</code> 是一个二进制数，长度恰好等于网格中钥匙的数目，<code>status</code> 的第 i 个二进制位为 1，当且仅当我们已经获得了网格中的第 i 把钥匙。</p><p>这样一来，我们就可以使用上述的状态进行广度优先搜索。初始时，我们把 <code>(srcx,srcy,0)</code>加入队列，其中 <code>srcx,srcy)</code> 为起点。在搜索的过程中，我们可以向上下左右四个方向进行扩展：</p><p>如果对应方向是空房间，那么 <code>status</code> 的值不变；</p><p>如果对应方向是第 i 把钥匙，那么将 <code>status</code> 的第 i 位置为 111；</p><p>如果对应方向是第 i 把锁，那么只有在 <code>status</code> 的第 i 位为 1 时，才可以通过。</p><p>当 <code>status</code> 每一位都为1时，说明获取了所有钥匙，此时就可以返回最短路作为答案。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs prolog">int dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>class <span class="hljs-symbol">Solution</span> &#123;<br>public:<br>    unordered_map&lt;char,int&gt; mp;<br>    queue&lt;tuple&lt;int,int,int&gt;&gt; q;<br>    int shortestPathAllKeys(vector&lt;string&gt;&amp; grid) &#123;<br>        int m=grid.size(),n=grid[<span class="hljs-number">0</span>].size();<br>        int srcx,srcy,dx,dy;<br>        for(int i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            for(int j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                if(grid[i][j]==<span class="hljs-string">&#x27;@&#x27;</span>)<br>                &#123;<br>                    srcx=i;<br>                    srcy=j;<br>                &#125;<br>                else if(grid[i][j]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;grid[i][j]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)<br>                &#123;<br>                    if(!mp.count(grid[i][j]))<br>                        mp[grid[i][j]]=mp.size();<br>                &#125;<br>            &#125;<br>        &#125;<br>        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dis(m,vector&lt;vector&lt;int&gt;&gt;(n,vector&lt;int&gt;(<span class="hljs-number">1</span>&lt;&lt;mp.size(),<span class="hljs-number">-1</span>)));<br>        q.push(&#123;srcx,srcy,<span class="hljs-number">0</span>&#125;);<br>        dis[srcx][srcy][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        while(!q.empty())<br>        &#123;   <br>            auto[x,y,status]=q.front();<br>            q.pop();<br>            for(int i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)<br>            &#123;<br>                dx=x+dir[i][<span class="hljs-number">0</span>];<br>                dy=y+dir[i][<span class="hljs-number">1</span>];<br>                if(dx&gt;=<span class="hljs-number">0</span>&amp;&amp;dx&lt;m&amp;&amp;dy&gt;=<span class="hljs-number">0</span>&amp;&amp;dy&lt;n&amp;&amp;grid[dx][dy]!=<span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123;<br>                    if(grid[dx][dy]==<span class="hljs-string">&#x27;.&#x27;</span>||grid[dx][dy]==<span class="hljs-string">&#x27;@&#x27;</span>)<br>                    &#123;<br>                        if(dis[dx][dy][status]==<span class="hljs-number">-1</span>)<br>                        &#123;<br>                            dis[dx][dy][status]=dis[x][y][status]+<span class="hljs-number">1</span>;<br>                            q.push(&#123;dx,dy,status&#125;);<br>                        &#125;<br>                    &#125;<br>                    else if(grid[dx][dy]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;grid[dx][dy]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)<br>                    &#123;<br>                        int idx=mp[grid[dx][dy]];<br>                        if(dis[dx][dy][status|(<span class="hljs-number">1</span>&lt;&lt;idx)]==<span class="hljs-number">-1</span>)<br>                        &#123;<br>                            dis[dx][dy][status|(<span class="hljs-number">1</span>&lt;&lt;idx)]=dis[x][y][status]+<span class="hljs-number">1</span>;<br>                            if((status|(<span class="hljs-number">1</span>&lt;&lt;idx))==(<span class="hljs-number">1</span>&lt;&lt;mp.size())<span class="hljs-number">-1</span>)<br>                                return dis[dx][dy][status|(<span class="hljs-number">1</span>&lt;&lt;idx)];<br>                            q.push(&#123;dx,dy,status|(<span class="hljs-number">1</span>&lt;&lt;idx)&#125;);<br>                        &#125;<br>                    &#125;<br>                    else<br>                    &#123;<br>                        int idx=mp[grid[dx][dy]+<span class="hljs-number">32</span>];<br>                        if((status &amp; (<span class="hljs-number">1</span>&lt;&lt;idx)) &amp;&amp; dis[dx][dy][status]==<span class="hljs-number">-1</span>)<br>                        &#123;<br>                            dis[dx][dy][status]=dis[x][y][status]+<span class="hljs-number">1</span>;<br>                            q.push(&#123;dx,dy,status&#125;);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return <span class="hljs-number">-1</span>;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大加号标志</title>
    <link href="/2022/11/09/%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97/"/>
    <url>/2022/11/09/%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97">最大加号标志</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最大加号标志"><a class="markdownIt-Anchor" href="#最大加号标志"></a> 最大加号标志</h2><p><a href="https://leetcode.cn/problems/largest-plus-sign/description/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在一个 n x n 的矩阵 grid 中，除了在数组 mines 中给出的元素为 0，其他每个元素都为 1。mines[i] = [xi, yi]表示 grid[xi][yi] == 0</p><p>返回  grid 中包含 1 的最大的 轴对齐 加号标志的阶数 。如果未找到加号标志，则返回 0 。</p><p>一个 k 阶由 1 组成的 “轴对称”加号标志 具有中心网格 grid[r][c] == 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 0 也可能为 1 。</p><p>示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: n = <span class="hljs-number">5</span>, mines = <span class="hljs-string">[[4, 2]]</span><br>输出: <span class="hljs-number">2</span><br>解释: 在上面的网格中，最大加号标志的阶只能是<span class="hljs-number">2</span>。一个标志已在图中标出。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><blockquote><p>这道题属于动态规划，用<code>dp[i][j]</code>表示在<code>(i,j)</code>位置四个方向阶数的最小值，然后找到dp数组中的最大值即可。<br />注意：遍历时要先处理水平方向，再处理垂直方向，不然无法正确更新dp数组</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    bool vis[250001];<br>    int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) &#123;<br>        vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(n,n));<br>        <span class="hljs-keyword">for</span>(auto &amp; t:mines)<br>            vis[t[0]*n+t[1]]=<span class="hljs-literal">true</span>;<br>        int <span class="hljs-attribute">count</span>=0;<br>        int <span class="hljs-attribute">ans</span>=0;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=0;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(vis[i*n+j])<br>                    <span class="hljs-attribute">count</span>=0;<br>                <span class="hljs-keyword">else</span><br>                    ++count;<br>                dp[i][j]=min(dp[i][j],count);<br>            &#125;<br>            <span class="hljs-attribute">count</span>=0;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=n-1;j&gt;=0;--j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(vis[i*n+j])<br>                    <span class="hljs-attribute">count</span>=0;<br>                <span class="hljs-keyword">else</span><br>                    ++count;<br>                dp[i][j]=min(dp[i][j],count);<br>            &#125;<br>            <span class="hljs-attribute">count</span>=0;<br>            <br>        &#125;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=0;j&lt;n;++j)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n;++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(vis[i*n+j])<br>                    <span class="hljs-attribute">count</span>=0;<br>                <span class="hljs-keyword">else</span><br>                    ++count;<br>                dp[i][j]=min(dp[i][j],count);<br>            &#125;<br>            <span class="hljs-attribute">count</span>=0;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=n-1;i&gt;=0;--i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(vis[i*n+j])<br>                    <span class="hljs-attribute">count</span>=0;<br>                <span class="hljs-keyword">else</span><br>                    ++count;<br>                dp[i][j]=min(dp[i][j],count);<br>                <span class="hljs-attribute">ans</span>=max(dp[i][j],ans);<br>            &#125;<br>            <span class="hljs-attribute">count</span>=0;<br>        &#125;<br>        return ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>美丽整数最小增量</title>
    <link href="/2022/11/08/%E7%BE%8E%E4%B8%BD%E6%95%B4%E6%95%B0%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/"/>
    <url>/2022/11/08/%E7%BE%8E%E4%B8%BD%E6%95%B4%E6%95%B0%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BE%8E%E4%B8%BD%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F">美丽整数的最小增量</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="美丽整数的最小增量"><a class="markdownIt-Anchor" href="#美丽整数的最小增量"></a> 美丽整数的最小增量</h2><p><a href="https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/description/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你两个正整数 n 和 target 。</p><p>如果某个整数每一位上的数字相加小于或等于 target ，则认为这个整数是一个 美丽整数 。</p><p>找出并返回满足 n + x 是 美丽整数 的最小非负整数 x 。生成的输入保证总可以使 n 变成一个美丽整数。</p><p>示例：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 16, target = 6<br>输出：4<br>解释：最初，n 是<span class="hljs-number"> 16 </span>，且其每一位数字的和是<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 7 </span>。<br>在加<span class="hljs-number"> 4 </span>之后，n 变为<span class="hljs-number"> 20 </span>且每一位数字的和变成<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 0 </span>=<span class="hljs-number"> 2 </span>。可以证明无法加上一个小于<span class="hljs-number"> 4 </span>的非负整数使 n 变成一个美丽整数。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>从右到左遍历，依次进行高位加1,低位置0,直到满足条件为止</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> makeIntegerBeautiful(<span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> n, <span class="hljs-built_in">int</span> target) &#123;<br>        string s=to_string(n);<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> len=s.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">char</span> c:s)<br>            <span class="hljs-keyword">sum</span>+=c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&lt;=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=len<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;9&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;++j)<br>                <span class="hljs-keyword">sum</span>+=s[j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            ++<span class="hljs-keyword">sum</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&lt;=target)<br>            &#123;<br>                string ans=s;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=i+<span class="hljs-number">1</span>;j&lt;len;++j)<br>                    ans[j]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>                ++ans[i];<br>                <span class="hljs-keyword">return</span> stoll(ans)-n;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> stoll(<span class="hljs-string">&#x27;1&#x27;</span>+string(len,<span class="hljs-string">&#x27;0&#x27;</span>))-n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>transformer笔记</title>
    <link href="/2022/11/03/transformer%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/03/transformer%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#transformer%E7%AC%94%E8%AE%B0">Transformer笔记</a><ul><li><a href="#transformer%E7%9A%84%E6%8F%90%E5%87%BA">transformer的提出</a></li><li><a href="#%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6">自注意力机制</a></li><li><a href="#%E5%A4%9A%E5%A4%B4%E6%B3%A8%E6%84%8F%E5%8A%9B">多头注意力</a></li><li><a href="#%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81">位置编码</a><ul><li><a href="#token-embedding">Token Embedding</a></li><li><a href="#positional-embedding">Positional Embedding</a></li></ul></li><li><a href="#transformer%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84">Transformer网络结构</a><ul><li><a href="#encoder">Encoder</a></li><li><a href="#decoder">Decoder</a></li><li><a href="#%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%8E%A9%E7%A0%81%E6%9C%BA%E5%88%B6">注意力掩码机制</a></li></ul></li><li><a href="#%E5%9F%BA%E4%BA%8Etransformer%E7%9A%84%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B">基于transformer的分类模型</a></li></ul></li></ul><!-- /TOC --><h1 id="transformer笔记"><a class="markdownIt-Anchor" href="#transformer笔记"></a> Transformer笔记</h1><p>在写本篇博客时，主要参考了这篇博客（<a href="https://zhuanlan.zhihu.com/p/420820453">博客链接</a>），博主介绍的非常细致，强烈推荐。</p><h2 id="transformer的提出"><a class="markdownIt-Anchor" href="#transformer的提出"></a> transformer的提出</h2><p>该模型的提出，来源于2017年的一篇论文：Attention is all you need</p><p>在论文中作者提到，当前主流的序列模型都是基于复杂的RNN或者CNN构造的Encoder-Decoder模型,这种模型使得下一个时刻的计算过程依赖于上一个时刻的输出，因此RNN在计算效率上受到很大限制。于是作者提出了transformer架构，他抛弃了RNN结构，引入了注意力机制来计算模型输入输出间的隐含表示。</p><h2 id="自注意力机制"><a class="markdownIt-Anchor" href="#自注意力机制"></a> 自注意力机制</h2><p>注意力机制可以描述为将query和一系列的key-value对映射到某个输出的过程，而这个输出的向量就是根据query和key计算得到的权重作用于value上的权重和。</p><p><img src="https://pic2.zhimg.com/80/v2-21ebe709cd12dda0a9c9da7559d3e045_720w.webp" alt="" /><br />可以看出，自注意力的计算过程就是通过Query和Key计算出权重，然后与Value相乘得到输出。</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mo fence="true">(</mo><mfrac><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac><mo fence="true">)</mo></mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">Attention\left(Q,K,V\right)=softmax\left(\frac{QK^T}{\sqrt{d_k}}\right)V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.468361em;vertical-align:-0.95003em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p><p>其中Q,K,V分别是三个矩阵，而除以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.18278000000000005em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span></span>就是上图中的scale过程。作者发现某些情况下<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">QK^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>会得到很大的值，这会导致softmax后产生很小的梯度，不利于训练，所以加入scale的过程。</p><p>下面举例说明Q,K,V是怎么来的。</p><p><img src="https://pic4.zhimg.com/80/v2-28903ee6a9c01d4895af7836b1e5997f_720w.webp" alt="" /></p><p>从上图可以看出，Q，K，V其实就是输入X乘以三个不同的矩阵计算而来，即：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>X</mi><msup><mi>W</mi><mi>q</mi></msup><mspace linebreak="newline"></mspace><mi>K</mi><mo>=</mo><mi>X</mi><msup><mi>W</mi><mi>k</mi></msup><mspace linebreak="newline"></mspace><mi>V</mi><mo>=</mo><mi>X</mi><msup><mi>W</mi><mi>v</mi></msup></mrow><annotation encoding="application/x-tex">Q=XW^q\\K=XW^k\\V=XW^v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.714392em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8991079999999999em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span></span></span></span></span></span></span></span></p><p>得到Q,K,V之后，就可以进一步计算得到权重向量。</p><p><img src="https://pic4.zhimg.com/80/v2-3173490f0b8fb89b22a22b65d2851c7f_720w.webp" alt="" /><br />假如Q和K的计算结果如上图，对于权重矩阵的第1行来说，0.7表示的就是“我”与“我”的注意力值；0.2表示的就是“我”与”是”的注意力值；0.1表示的就是“我”与“谁”的注意力值。换句话说，在对序列中的“我“进行编码时，应该将0.7的注意力放在“我”上，0.2的注意力放在“是”上，将0.1的注意力放在谁上。</p><p>不过，上面的规律也反映了一个小问题：<strong>模型在对当前位置的信息进行编码时，会过度的将注意力集中于自身的位置而可能忽略了其它位置。</strong></p><p>得到权重矩阵之后，与V相乘：</p><p><img src="https://pic3.zhimg.com/80/v2-a574d12396e1e2006716eb58f9fa5806_720w.webp" alt="" /></p><p>对于“是”而言，它的编码向量其实就是“我，是，谁”三个字的加权和，如下图所示：</p><p><img src="https://pic2.zhimg.com/80/v2-3de3645627bd94e4258a89c4376227c1_720w.webp" alt="" /></p><p>这种自注意力机制,确实解决了作者在论文中所提出的“传统序列模型在编码过程中都需顺序进行的弊端”的问题，有了自注意力机制后，仅仅只需要对原始输入进行几次矩阵变换便能够得到最终包含有不同位置注意力信息的编码向量。</p><h2 id="多头注意力"><a class="markdownIt-Anchor" href="#多头注意力"></a> 多头注意力</h2><p>之前提到，自注意力在对当前位置的信息进行编码时，会过度的将注意力集中于自身的位置，所以提出了Multi-head Attention来进行改进。</p><p><img src="https://pic4.zhimg.com/80/v2-849a1a08e54a4ab3b2bfadfaceddfeab_720w.webp" alt="" /></p><p>多头注意力机制其实就是将原始的输入序列进行多组的自注意力处理过程；然后再将每一组自注意力的结果拼接起来进行一次线性变换得到最终的输出结果。具体的，其计算公式为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>H</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>a</mi><mi>t</mi><mo stretchy="false">(</mo><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>h</mi></msub><mo stretchy="false">)</mo><msup><mi>W</mi><mi>O</mi></msup><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mi>W</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>Q</mi><msubsup><mi>W</mi><mi>i</mi><mi>Q</mi></msubsup><mo separator="true">,</mo><mi>K</mi><msubsup><mi>W</mi><mi>i</mi><mi>K</mi></msubsup><mo separator="true">,</mo><mi>V</mi><msubsup><mi>W</mi><mi>i</mi><mi>V</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">MultiHead(Q,K,V)=Concat(head_1,...,head_h)W^O\\\\Where head_i=Attention(QW_i^Q,KW^K_i,VW_i^V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.236103em;vertical-align:-0.276864em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9592389999999998em;"><span style="top:-2.4231360000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.180908em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>作者使用了个并行的自注意力模块（8个头）来构建一个注意力层，论文中所使用的多头注意力机制其实就是将一个大的高维单头拆分成了h个多头。</p><p><img src="https://pic4.zhimg.com/80/v2-382a68f2a5543f00b7a4a1fd84e29b83_720w.webp" alt="" /></p><p>当进行进行注意力权重矩阵计算时，h越大那么Q,K,V就会被切分得越小，进而得到的注意力权重分配方式越多，如图所示。</p><p><img src="https://pic1.zhimg.com/80/v2-8837a813f9028886bb8529a59c6cd9c8_720w.webp" alt="" /></p><p>因而多头这一做法也恰好用于克服模型在对当前位置的信息进行编码时，会过度的将注意力集中于自身的位置的问题，使得权重分配更合理。</p><h2 id="位置编码"><a class="markdownIt-Anchor" href="#位置编码"></a> 位置编码</h2><h3 id="token-embedding"><a class="markdownIt-Anchor" href="#token-embedding"></a> Token Embedding</h3><p>在对文本相关的数据进行建模时首先要做的便是对其进行向量化(Embedding),在深度学习中，更常见的做法便是将各个词（或者字）通过一个Embedding层映射到低维稠密的向量空间。因此，在Transformer模型中，首先第一步要做的同样是将文本以这样的方式进行向量化表示，并且将其称之为Token Embedding，也就是深度学习中常说的词嵌入（Word Embedding）</p><p><img src="https://pic4.zhimg.com/80/v2-9e4cb60bd2ed3e1aca137928bf34a537_720w.webp" alt="" /></p><p>如果是换做之前的网络模型，例如CNN或者RNN，那么对于文本向量化的步骤就到此结束了，因为这些网络结构本身已经具备了捕捉时序特征的能力,但是这对仅仅只有自注意力机制的网络结构来说却不行。自注意力机制在实际运算过程中不过就是几个矩阵来回相乘进行<strong>线性变换</strong>而已。因此，这就导致即使是打乱各个词的顺序，那么最终计算得到的结果本质上却没有发生任何变换，换句话说仅仅只使用自注意力机制会丢失文本原有的序列信息（<s>换个顺序学习不到新的东西</s>）。</p><p>下面举例说明原因：</p><p><img src="https://pic4.zhimg.com/80/v2-a61fbde8b2b7958eef3dd134f722c69b_720w.webp" alt="" /></p><p>经过词嵌入表示后，序列“我 在 看 书”经过了一次线性变换。现在，我们将序列变成“书 在 看 我”，然后同样以中间这个权重矩阵来进行线性变换。</p><p><img src="https://pic4.zhimg.com/80/v2-9aede5435fe5c6f010457c5818ec3ce3_720w.webp" alt="" /></p><p>所以，序列在交换位置前和交换位置后计算得到的结果在本质上并没有任何区别，仅仅只是交换了对应的位置。因此，基于这样的原因，Transformer在原始输入文本进行Embedding后，又额外的加入了一个Positional Embedding来刻画数据在时序上的特征。</p><h3 id="positional-embedding"><a class="markdownIt-Anchor" href="#positional-embedding"></a> Positional Embedding</h3><p>先来通过一幅图直观看看经过Positional Embedding处理后到底产生了什么样的变化。</p><p><img src="https://pic3.zhimg.com/80/v2-8110b24565ffbfb028866a19050940fa_720w.webp" alt="" /></p><blockquote><p>如图所示，横坐标表示输入序列中的每一个Token，每一条曲线或者直线表示对应Token在每个维度上对应的位置信息。在左图中，每个维度所对应的位置信息都是一个不变的常数；而在右图中，每个维度所对应的位置信息都是基于某种公式变换所得到。换句话说就是，左图中任意两个Token上的向量都可以进行位置交换而模型却不能捕捉到这一差异，但是加入右图这样的位置信息模型却能够感知到。例如位置20这一处的向量，在左图中无论你将它换到哪个位置，都和原来一模一样；但在右图中，你却再也找不到与位置20处位置信息相同的位置。</p></blockquote><p>下面再看一个例子</p><p><img src="https://pic1.zhimg.com/80/v2-9a4be9596e49f523e90c2c9eb7b37864_720w.webp" alt="" /></p><p>原始输入在经过Token Embedding后，又加入了一个常数位置信息的的Positional Embedding。在经过一次线性变换后便得到了图2-5左右边所示的结果。接下来，我们再交换序列的位置，并同时进行Positional Embedding观察其结果。</p><p><img src="https://pic3.zhimg.com/80/v2-d98e246f487827ee1ad6411cc00928e6_720w.webp" alt="" /></p><p>可以看到，交换位置后得到的权重矩阵只是发生了普通的线性变换，说明上述类型的PE是无效的。</p><p>在Transformer中，作者采用了以下公式所示的规则来生成各个维度的位置信息。</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><msub><mi>E</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi></mrow></msub><mo>=</mo><mi>s</mi><mi>i</mi><mi>n</mi><mrow><mo fence="true">(</mo><mfrac><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><mrow><mn>1000</mn><msup><mn>0</mn><mfrac><mrow><mn>2</mn><mi>i</mi></mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub></mfrac></msup></mrow></mfrac><mo fence="true">)</mo></mrow><mspace linebreak="newline"></mspace><mi>P</mi><msub><mi>E</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>c</mi><mi>o</mi><mi>s</mi><mrow><mo fence="true">(</mo><mfrac><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><mrow><mn>1000</mn><msup><mn>0</mn><mfrac><mrow><mn>2</mn><mi>i</mi></mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub></mfrac></msup></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">PE_{pos,2i}=sin\left(\frac{pos}{10000^{\frac{2i}{d_{model}}}}\right)\\PE_{pos,2i+1}=cos\left(\frac{pos}{10000^{\frac{2i}{d_{model}}}}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4619299999999997em;vertical-align:-1.01193em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.12193em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1219299999999999em;"><span style="top:-3.5233700000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8550857142857142em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.69444em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34963999999999995em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5937428571428571em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.35193em;"><span class="pstrut" style="height:3.12193em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.79893em;"><span class="pstrut" style="height:3.12193em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.01193em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4619299999999997em;vertical-align:-1.01193em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.12193em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1219299999999999em;"><span style="top:-3.5233700000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8550857142857142em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.69444em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34963999999999995em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5937428571428571em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.35193em;"><span class="pstrut" style="height:3.12193em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.79893em;"><span class="pstrut" style="height:3.12193em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.01193em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>上式中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">PE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>就是embedding的矩阵，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span></span></span></span>代表某一个位置,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>代表某一个维度，在融入这种非常数的Positional Embedding位置信息后，便可以得到下图结果。</p><p><img src="https://pic3.zhimg.com/80/v2-0c62651daf9f5c0c1de77e9137b058b6_720w.webp" alt="" /></p><p>这就说明通过Positional Embedding可以弥补自注意力机制不能捕捉序列时序信息的缺陷(<s>感觉类似于激活层的作用</s>)。</p><h2 id="transformer网络结构"><a class="markdownIt-Anchor" href="#transformer网络结构"></a> Transformer网络结构</h2><p>整体结构如下：</p><p><img src="https://pic1.zhimg.com/80/v2-6da4c9720ec88860295bd63e19344820_720w.webp" alt="" /></p><h3 id="encoder"><a class="markdownIt-Anchor" href="#encoder"></a> Encoder</h3><p><img src="https://pic3.zhimg.com/80/v2-5da93887d468045677e9983f14b35db6_720w.webp" alt="" /></p><p>主要由多头注意力机制和两层前馈神经网络构成，并且都加入了残差连接，并进行了层归一化。其中前馈神经网络主要用于变换维度，增强模型表达能力。</p><h3 id="decoder"><a class="markdownIt-Anchor" href="#decoder"></a> Decoder</h3><p><img src="https://pic1.zhimg.com/80/v2-8ab2c37e224137c05332419d525c88cc_720w.webp" alt="" /></p><p>不同于Encoder部分，在Decoder中一共包含有3个部分的网络结构。最上面的和最下面的部分（暂时忽略Mask）与Encoder相同，只是多了中间这个与Encoder输出（Memory）进行交互的部分，作者称之为“Encoder-Decoder attention”。<strong>对于这部分的输入，Q来自于下面多头注意力机制的输出，K和V均是Encoder部分的输出（Memory）经过线性变换后得到。</strong></p><p>具体解码过程如下：</p><p>首先，待解码向量和Memory分别各自乘上一个矩阵后得到Q、K、V。</p><p><img src="https://pic2.zhimg.com/80/v2-22669eedb0931017b8ed1d56dcd28089_720w.webp" alt="" /></p><p><img src="https://pic4.zhimg.com/80/v2-56ab4338fc9da4ca495fe070904846cf_720w.webp" alt="" /></p><p>在解码第1个时刻时，首先Q通过与K进行交互得到权重向量，此时可以看做是<strong>Q（待解码向量）在K（本质上也就是Memory）中查询Memory中各个位置与Q有关的信息</strong>；然后将权重向量与V进行运算得到解码向量，此时这个解码向量可以看作是<strong>考虑了Memory中各个位置编码信息的输出向量</strong>，也就是说它包含了在解码当前时刻时应该将注意力放在Memory中哪些位置上的信息。</p><p>在得到这个解码向量并经过图2-10中最上面的两层全连接层后，便将其输入到分类层中进行分类得到当前时刻的解码输出值。</p><h3 id="注意力掩码机制"><a class="markdownIt-Anchor" href="#注意力掩码机制"></a> 注意力掩码机制</h3><p>模型在实际的预测过程中只是将当前时刻之前（包括当前时刻）的所有时刻作为输入来预测下一个时刻，也就是说模型在预测时是看不到当前时刻之后的信息。因此，Transformer中的Decoder通过加入注意力掩码机制（Masked Multi-Head Attention）来解决了这一问题。</p><p><img src="https://pic4.zhimg.com/80/v2-ef714b246dfc08c912db18aaec0542cb_720w.webp" alt="" /></p><p>如图所示，左边依旧是通过Q和K计算得到了注意力权重矩阵（此时还未进行softmax操作），而中间的就是所谓的注意力掩码矩阵，两者在相加之后再乘上矩阵V便得到了整个自注意力机制的输出。（因为attention mask的加入，使得softmax之后，后面时刻的权重变为0，正好屏蔽了当前时刻之后的输入。）</p><h2 id="基于transformer的分类模型"><a class="markdownIt-Anchor" href="#基于transformer的分类模型"></a> 基于transformer的分类模型</h2><p><img src="https://moonhotel.oss-cn-shanghai.aliyuncs.com/images/2107052058585050890.jpg" alt="" /></p><p>上图便是一个基于Transformer结构的文本分类模型。不过准确的说应该只是一个基于Transformer中Encoder的文本分类模型。这是因为在文本分类任务中并没有解码这一过程，所以我们只需要将Encoder编码得到的向量输入到分类器中进行分类即可。</p>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调双端队列</title>
    <link href="/2022/10/26/%E5%8D%95%E8%B0%83%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    <url>/2022/10/26/%E5%8D%95%E8%B0%83%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-k-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84">和至少为 K 的最短子数组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="和至少为-k-的最短子数组"><a class="markdownIt-Anchor" href="#和至少为-k-的最短子数组"></a> 和至少为 K 的最短子数组</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/">题目链接</a></p><p>给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。</p><p>子数组 是数组中 连续 的一部分。</p><p>示例</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [2,-1,2], k = 3</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题自己想的就是前缀和然后暴力，但TLE了，看了题解发现需要用单调双端队列对前缀和数组进行优化</p><p>主要做两处优化：</p><ol><li><p>弹出队首并更新答案</p></li><li><p>弹出队尾，保证队列单调递增</p></li></ol><p><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/solution/liang-zhang-tu-miao-dong-dan-diao-dui-li-9fvh/">参考链接</a></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(len+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i)<br>            a[i]=nums[i<span class="hljs-number">-1</span>]+a[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-type">int</span> ans=INT_MAX;<br>        deque&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=len;++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]-a[q.<span class="hljs-built_in">front</span>()]&gt;=k)<br>            &#123;<br>                ans=<span class="hljs-built_in">min</span>(ans,i-q.<span class="hljs-built_in">front</span>());<br>                q.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]&lt;=a[q.<span class="hljs-built_in">back</span>()])<br>               q.<span class="hljs-built_in">pop_back</span>();<br>            q.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans==INT_MAX ? <span class="hljs-number">-1</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大人工岛</title>
    <link href="/2022/10/25/%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B/"/>
    <url>/2022/10/25/%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B">最大人工岛</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5">最短的桥</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最大人工岛"><a class="markdownIt-Anchor" href="#最大人工岛"></a> 最大人工岛</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p><a href="https://leetcode.cn/problems/making-a-large-island/">原题链接</a></p><p>给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。</p><p>返回执行此操作后，grid 中最大的岛屿面积是多少？</p><p>岛屿 由一组上、下、左、右四个方向相连的 1 形成。</p><p>示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: grid = <span class="hljs-string">[[1, 1], [1, 0]]</span><br>输出: <span class="hljs-number">4</span><br>解释: 将一格<span class="hljs-number">0</span>变成<span class="hljs-number">1</span>，岛屿的面积扩大为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要思路是dfs，用dfs给不同的岛编号，用哈系表记录每个编号的岛的面积，然后遍历所有非岛屿部分，更新最大面积即可</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;</span><br><span class="hljs-class">public:</span><br><span class="hljs-class">    void dfs(<span class="hljs-title">int</span> <span class="hljs-title">x</span>,<span class="hljs-title">int</span> <span class="hljs-title">y</span>,<span class="hljs-title">int</span> <span class="hljs-title">bh</span>,<span class="hljs-title">vector</span>&lt;<span class="hljs-title">vector</span>&lt;<span class="hljs-title">int</span>&gt;&gt;&amp; <span class="hljs-title">grid</span>,<span class="hljs-title">int</span> <span class="hljs-title">m</span>,<span class="hljs-title">int</span> <span class="hljs-title">n</span>)</span><br><span class="hljs-class">    &#123;</span><br><span class="hljs-class">        if(<span class="hljs-title">grid</span>[<span class="hljs-title">x</span>][<span class="hljs-title">y</span>]!=1)</span><br><span class="hljs-class">            return;</span><br><span class="hljs-class">        grid[x][y]=bh;</span><br><span class="hljs-class">        if(<span class="hljs-title">x</span>+1&lt;<span class="hljs-title">m</span>)</span><br><span class="hljs-class">            dfs(<span class="hljs-title">x</span>+1,<span class="hljs-title">y</span>,<span class="hljs-title">bh</span>,<span class="hljs-title">grid</span>,<span class="hljs-title">m</span>,<span class="hljs-title">n</span>);</span><br><span class="hljs-class">        if(<span class="hljs-title">y</span>+1&lt;<span class="hljs-title">n</span>)</span><br><span class="hljs-class">            dfs(<span class="hljs-title">x</span>,<span class="hljs-title">y</span>+1,<span class="hljs-title">bh</span>,<span class="hljs-title">grid</span>,<span class="hljs-title">m</span>,<span class="hljs-title">n</span>);</span><br><span class="hljs-class">        if(<span class="hljs-title">x</span>-1&gt;=0)</span><br><span class="hljs-class">            dfs(<span class="hljs-title">x</span>-1,<span class="hljs-title">y</span>,<span class="hljs-title">bh</span>,<span class="hljs-title">grid</span>,<span class="hljs-title">m</span>,<span class="hljs-title">n</span>);</span><br><span class="hljs-class">        if(<span class="hljs-title">y</span>-1&gt;=0)</span><br><span class="hljs-class">            dfs(<span class="hljs-title">x</span>,<span class="hljs-title">y</span>-1,<span class="hljs-title">bh</span>,<span class="hljs-title">grid</span>,<span class="hljs-title">m</span>,<span class="hljs-title">n</span>);</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">    int largestIsland(<span class="hljs-title">vector</span>&lt;<span class="hljs-title">vector</span>&lt;<span class="hljs-title">int</span>&gt;&gt;&amp; <span class="hljs-title">grid</span>) &#123;</span><br><span class="hljs-class">        int m=grid.size();</span><br><span class="hljs-class">        int n=grid[0].size();</span><br><span class="hljs-class">        unordered_map&lt;int,int&gt; mp;</span><br><span class="hljs-class">        mp[0]=0;</span><br><span class="hljs-class">        int ans=0;</span><br><span class="hljs-class">        int bh=2;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                if(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>]==1)</span><br><span class="hljs-class">                &#123;</span><br><span class="hljs-class">                    dfs(<span class="hljs-title">i</span>,<span class="hljs-title">j</span>,<span class="hljs-title">bh</span>,<span class="hljs-title">grid</span>,<span class="hljs-title">m</span>,<span class="hljs-title">n</span>);</span><br><span class="hljs-class">                    ++bh;</span><br><span class="hljs-class">                &#125;</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                if(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>]!=0)</span><br><span class="hljs-class">                    ++mp[grid[i][j]];</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        int flag=0;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                if(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>]==0)</span><br><span class="hljs-class">                &#123;</span><br><span class="hljs-class">                    flag=1;</span><br><span class="hljs-class">                    int t=0;</span><br><span class="hljs-class">                    unordered_set&lt;int&gt; s;</span><br><span class="hljs-class">                    if(<span class="hljs-title">i</span>-1&gt;=0)</span><br><span class="hljs-class">                        s.insert(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>-1][<span class="hljs-title">j</span>]);</span><br><span class="hljs-class">                    if(<span class="hljs-title">j</span>-1&gt;=0)</span><br><span class="hljs-class">                        s.insert(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>-1]);</span><br><span class="hljs-class">                    if(<span class="hljs-title">i</span>+1&lt;<span class="hljs-title">m</span>)</span><br><span class="hljs-class">                        s.insert(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>+1][<span class="hljs-title">j</span>]);</span><br><span class="hljs-class">                    if(<span class="hljs-title">j</span>+1&lt;<span class="hljs-title">n</span>)</span><br><span class="hljs-class">                        s.insert(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>+1]);</span><br><span class="hljs-class">                    for(<span class="hljs-title">auto</span> <span class="hljs-title">it</span>=<span class="hljs-title">s</span>.<span class="hljs-title">begin</span>();it!=s.end();++it)</span><br><span class="hljs-class">                        t+=mp[*it];</span><br><span class="hljs-class">                    ans=max(<span class="hljs-title">ans</span>,<span class="hljs-title">t</span>+1);</span><br><span class="hljs-class">                &#125;</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        if(<span class="hljs-title">flag</span>)</span><br><span class="hljs-class">            return ans;</span><br><span class="hljs-class">        else</span><br><span class="hljs-class">            return m*n;</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">&#125;;</span><br></code></pre></td></tr></table></figure><h2 id="最短的桥"><a class="markdownIt-Anchor" href="#最短的桥"></a> 最短的桥</h2><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p><a href="https://leetcode.cn/problems/shortest-bridge/">原题链接</a></p><p>给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。</p><p>岛 是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 。</p><p>你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。</p><p>返回必须翻转的 0 的最小数目。</p><p>示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[0,1,0],[0,0,0],[0,0,1]]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>这道题实际上是求两个岛之间的最短距离，主要思路是dfs标记其中一个岛，然后用bfs进行岛屿之间最短距离的求解</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        grid[x][y]=<span class="hljs-number">2</span>;<br>        q.<span class="hljs-built_in">emplace</span>(x,y);<br>        <span class="hljs-keyword">if</span>(x<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;grid[x<span class="hljs-number">-1</span>][y]==<span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">dfs</span>(x<span class="hljs-number">-1</span>,y,grid);<br>        <span class="hljs-keyword">if</span>(x+<span class="hljs-number">1</span>&lt;n&amp;&amp;grid[x+<span class="hljs-number">1</span>][y]==<span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">dfs</span>(x+<span class="hljs-number">1</span>,y,grid);<br>        <span class="hljs-keyword">if</span>(y<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;grid[x][y<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">dfs</span>(x,y<span class="hljs-number">-1</span>,grid);<br>        <span class="hljs-keyword">if</span>(y+<span class="hljs-number">1</span>&lt;n&amp;&amp;grid[x][y+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">dfs</span>(x,y+<span class="hljs-number">1</span>,grid);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span>&amp; step)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> len=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(len--)<br>            &#123;<br>                <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>().first;<br>                <span class="hljs-type">int</span> y=q.<span class="hljs-built_in">front</span>().second;<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(x<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;grid[x<span class="hljs-number">-1</span>][y]!=<span class="hljs-number">2</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(grid[x<span class="hljs-number">-1</span>][y]==<span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(x<span class="hljs-number">-1</span>,y);<br>                    grid[x<span class="hljs-number">-1</span>][y]=<span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(y<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;grid[x][y<span class="hljs-number">-1</span>]!=<span class="hljs-number">2</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(grid[x][y<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(x,y<span class="hljs-number">-1</span>);<br>                    grid[x][y<span class="hljs-number">-1</span>]=<span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(x+<span class="hljs-number">1</span>&lt;n&amp;&amp;grid[x+<span class="hljs-number">1</span>][y]!=<span class="hljs-number">2</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(grid[x+<span class="hljs-number">1</span>][y]==<span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(x+<span class="hljs-number">1</span>,y);<br>                    grid[x+<span class="hljs-number">1</span>][y]=<span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(y+<span class="hljs-number">1</span>&lt;n&amp;&amp;grid[x][y+<span class="hljs-number">1</span>]!=<span class="hljs-number">2</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(grid[x][y+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(x,y+<span class="hljs-number">1</span>);<br>                    grid[x][y+<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>            ++step;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestBridge</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        n=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> step=<span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(i,j,grid);<br>                    <span class="hljs-built_in">bfs</span>(grid,step);<br>                    <span class="hljs-keyword">return</span> step;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数位dp</title>
    <link href="/2022/10/23/%E6%95%B0%E4%BD%8Ddp/"/>
    <url>/2022/10/23/%E6%95%B0%E4%BD%8Ddp/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%95%B0%E4%BD%8Ddp">数位DP</a><ul><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#ac%E4%BB%A3%E7%A0%81">AC代码</a></li></ul></li></ul><!-- /TOC --><h2 id="数位dp"><a class="markdownIt-Anchor" href="#数位dp"></a> 数位DP</h2><blockquote><p>一般指在限定条件下，关于每位数字出现次数的相关题目，先从入门开始吧(😢自己tcl)</p></blockquote><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p><a href="https://www.luogu.com.cn/problem/P2602">P2602 [ZJOI2010] 数字计数</a></p><p><strong>题目描述</strong></p><p>给定两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，求在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> 中的所有整数中，每个数码(digit)各出现了多少次。</p><p><strong>输入格式</strong></p><p>仅包含一行两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span></span></span></span>，含义如上所述。</p><p><strong>输出格式</strong></p><p>包含一行十个整数，分别表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">0\sim 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> 中出现了多少次。</p><p>样例输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">99</span><br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">9 </span><span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><strong>数据规模与约定</strong></p><ul><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，保证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">a\le b\le10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，保证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>a</mi><mo>≤</mo><mi>b</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">1\le a\le b\le 10^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>。</li></ul><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题主要就是找到各种规律</p><p>首先找到递推公式，如果有<code>i</code>位数字，那么对于<code>0～9</code>的每一个数字，出现的次数是一样的，所以不考虑前导0时有<br /><code>dp[i]=10*dp[i-1]+10^(i-1)</code><br />dp[i]表示i位的数每个数字出现的次数</p><p>对于ABCD</p><p>看A000，把这个A000看成0000～1000～2000…A000对于不考虑首位每一个式子的数字的出现个数为 <code>A*dp[3]</code>。加上首位出现也就是小于A每一个数都出现了<code>10^3</code>次，再加上，我们就把A000处理完了。</p><p>另外，首位A还出现了BCD+1次呢，也就是从A000~ABCD，这个A还出现了BCD+1次，最后减去前导0的个数，就是<code>10^(i-1)</code></p><h3 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a,b;<br>ll cnta[<span class="hljs-number">10</span>],cntb[<span class="hljs-number">10</span>];<br>ll dp[<span class="hljs-number">13</span>],ten[<span class="hljs-number">13</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dig</span><span class="hljs-params">(ll x,ll* cnt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">13</span>,<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">while</span>(x)<br>&#123;<br>v[++len]=x%<span class="hljs-number">10</span>;<br>x/=<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len;i&gt;=<span class="hljs-number">1</span>;--i)<br>&#123;<br><span class="hljs-comment">//不算首位，每个数字出现了x*dp[i-1]次,x是当前最高位 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10</span>;++j)<br>cnt[j]+=v[i]*dp[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">//算首位，即小于x的数增加10^(i-1)个 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;v[i];++j)<br>cnt[j]+=ten[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">//首位还多出现了低位+1次</span><br>ll tmp=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">1</span>;--j)<br>&#123;<br>tmp=tmp*<span class="hljs-number">10</span>+v[j];<br>&#125;<br>cnt[v[i]]+=tmp+<span class="hljs-number">1</span>;<br><span class="hljs-comment">//减去前导0</span><br>cnt[<span class="hljs-number">0</span>]-=ten[i<span class="hljs-number">-1</span>]; <br>&#125;<br>&#125;<br><span class="hljs-comment">//dp[i]=10*dp[i-1]+10^(i-1)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ll a,b;<br>cin&gt;&gt;a&gt;&gt;b;<br>ten[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//初始化dp </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">13</span>;++i)<br>&#123;<br>dp[i]=<span class="hljs-number">10</span>*dp[i<span class="hljs-number">-1</span>]+ten[i<span class="hljs-number">-1</span>];<br>ten[i]=<span class="hljs-number">10</span>*ten[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-built_in">dig</span>(a<span class="hljs-number">-1</span>,cnta);<br><span class="hljs-built_in">dig</span>(b,cntb);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i)<br>&#123;<br>cout&lt;&lt;cntb[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>规划兼职工作</title>
    <link href="/2022/10/22/%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C/"/>
    <url>/2022/10/22/%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C">规划兼职工作</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="规划兼职工作"><a class="markdownIt-Anchor" href="#规划兼职工作"></a> 规划兼职工作</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你打算利用空闲时间兼职来赚些零花钱</p><p>现在有若<code>n</code>条兼职信息，一条兼职信息包含<code>a,b,c</code>3个数据</p><p><code>a</code>表示该兼职的开始时间<br /><code>b</code>表示该兼职的终止时间<br /><code>c</code>表示该兼职的收入</p><p>你在一个时间段内只能有1份兼职，也就是说上一份兼职的终止时间要满足小于等于下一份兼职的开始时间</p><p>请你算出你能获得的最大收入</p><p>输入第一行<code>n</code>，表示兼职个数<br />下面<code>n</code>行，每行3个数，表示<code>a,b,c</code></p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">10</span> <span class="hljs-number">100</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">70</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">9</span> <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">150<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题可以用动态规划解决，先将所有兼职按照终止时间升序排序，<code>dp[i]</code>表示到第<code>i</code>份能获得的最大收益</p><ul><li>当不选择第<code>i</code>份兼职，<code>dp[i]=dp[i-1]</code></li><li>当选择第<code>i</code>份兼职，<code>dp[i]=dp[k]+profit[i]</code>，<code>k</code>是满足终止时间小于等于第<code>i</code>份兼职开始时间的第<code>k</code>份兼职</li></ul><p>状态方程：<code>dp[i]=max(dp[i-1],dp[k]+profit[i])</code>;</p><p>关于<code>k</code>的确定，很多人是通过二分查找来确定<code>k</code>的，但我自己写的二分查找总是没法ac，所以就没用(tcl😢😢😢)</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">e</span><br>&#123;<br>    <span class="hljs-type">int</span> a,b,c;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> e&amp; t) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> b&lt;t.b;<br>    &#125; <br>&#125;e[N];<br><span class="hljs-type">int</span> dp[N]; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-type">int</span> k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>cin&gt;&gt;e[i].a&gt;&gt;e[i].b&gt;&gt;e[i].c;<br>&#125;<br><span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>k=i;<br><span class="hljs-keyword">while</span>(e[k].b&gt;e[i].a)<br>--k;<br>dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],dp[k]+e[i].c);<br>&#125;<br>cout&lt;&lt;dp[n]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第k个语法符号</title>
    <link href="/2022/10/20/%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/10/20/%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7">第k个语法符号</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%89%A9%E5%B1%95">位操作扩展</a></li></ul></li><li><a href="#%E6%89%A9%E5%B1%95%E6%B1%82%E6%9F%90%E4%B8%AA%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0">扩展：求某个数二进制表示中1的个数</a><ul><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="第k个语法符号"><a class="markdownIt-Anchor" href="#第k个语法符号"></a> 第k个语法符号</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p><a href="https://leetcode.cn/problems/k-th-symbol-in-grammar/">原题链接</a><br />我们构建了一个包含 n 行( 索引从 1  开始 )的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。</p><p>例如，对于 n = 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。<br />给定行数 n 和序数 k，返回第 n 行中第 k 个字符。（ k 从索引 1 开始）</p><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 2, k = 1</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: </span><br><span class="hljs-section">第一行: 0 </span><br><span class="hljs-section">第二行: 01</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题大致看上去不是很难，自己的思路就是中规中矩的算，没什么亮点(😢tcl)</p><p>看了评论区的一位大佬，瞬间的折服了，时间复杂度直接<code>O(1)</code></p><p>大佬解这道题就是一句话：<strong>对K-1做奇偶校验</strong></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><p>下面放上大佬的代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">class</span> <span class="hljs-variable">Solution</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-variable">public</span><span class="hljs-operator">:</span><br>    <span class="hljs-variable">int</span> <span class="hljs-variable">kthGrammar</span><span class="hljs-punctuation">(</span><span class="hljs-variable">int</span> <span class="hljs-built_in">N</span><span class="hljs-operator">,</span> <span class="hljs-variable">unsigned</span> <span class="hljs-variable">int</span> <span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span> <br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-built_in">K</span> <span class="hljs-operator">-=</span> <span class="hljs-number">1</span><span class="hljs-operator">;</span><br>        <span class="hljs-built_in">K</span> <span class="hljs-operator">^=</span> <span class="hljs-built_in">K</span> <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">1</span><span class="hljs-operator">;</span><br>        <span class="hljs-built_in">K</span> <span class="hljs-operator">^=</span> <span class="hljs-built_in">K</span> <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">2</span><span class="hljs-operator">;</span><br>        <span class="hljs-built_in">K</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">(</span><span class="hljs-built_in">K</span> <span class="hljs-operator">&amp;</span> <span class="hljs-number">0</span><span class="hljs-variable">x11111111</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">*</span> <span class="hljs-number">0</span><span class="hljs-variable">x11111111</span><span class="hljs-operator">;</span><br>        <span class="hljs-variable">return</span> <span class="hljs-punctuation">(</span><span class="hljs-built_in">K</span> <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">28</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">&amp;</span> <span class="hljs-number">1</span><span class="hljs-operator">;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">;</span><br></code></pre></td></tr></table></figure><p>第一眼看过去，我还是不会😢</p><p>于是仔细看了一番，下面我来解释一下</p><h3 id="位操作扩展"><a class="markdownIt-Anchor" href="#位操作扩展"></a> 位操作扩展</h3><p>大佬的话，翻译一下，就是求<code>K-1</code>对应的二进制数中，1的个数是奇数还是偶数，奇数返回1,偶数返回0</p><p>因为在奇偶校验中，常常需要需要判断一个数中1的个数，以确定奇偶校验位</p><p>也就是说，这道题的本质，就是判断<code>K-1</code>对应的二进制数中，1的个数是奇数还是偶数。(大佬太强了%%%)</p><p>关于代码呢，我主要参考了这篇博客  <a href="https://blog.csdn.net/u012028275/article/details/112596947"><em>博客链接</em></a>，说的非常详细，还带图示。</p><p><code>K ^= K &gt;&gt; 1;</code>，作用就是相邻两位异或，判断每两位1的个数，奇数个1则为，否则为0，结果存在相邻2位的低位</p><p><code>K ^= K &gt;&gt; 2;</code>，和上一步差不多，不过判断的是每4位的1的个数</p><p><code>K &amp; 0x11111111</code>，作用是每4位只取最低位，其他置0</p><p><code>K * 0x11111111;</code>，作用是将整个32位的1的个数奇偶性压缩到最高4位，也就是28～31位</p><p><code>(K &gt;&gt; 28) &amp; 1;</code>，移到最低4位，解出1的个数的奇偶性</p><h2 id="扩展求某个数二进制表示中1的个数"><a class="markdownIt-Anchor" href="#扩展求某个数二进制表示中1的个数"></a> 扩展：求某个数二进制表示中1的个数</h2><p>位操作还可以求某个数二进制表示中1的个数</p><p>比如现在需要求一个无符号整形数的二进制数中1的个数</p><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>其实和奇偶校验有点关系，求每2个数、每4个数、每8个数、每16个数的1的个数相加就好了</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-attr">std</span><span class="hljs-punctuation">;</span><br>int main()<br><span class="hljs-punctuation">&#123;</span><br>int n<span class="hljs-punctuation">;</span><br>cin&gt;&gt;n<span class="hljs-punctuation">;</span><br><span class="hljs-comment">//int n=0b0111100110011000000000000000001; </span><br>n=((n<span class="hljs-variable">&amp;0xaaaaaaaa</span>)&gt;&gt;<span class="hljs-number">1</span>)+(n<span class="hljs-variable">&amp;0x55555555</span>)<span class="hljs-punctuation">;</span> <br>n=((n<span class="hljs-variable">&amp;0xcccccccc</span>)&gt;&gt;<span class="hljs-number">2</span>)+(n<span class="hljs-variable">&amp;0x33333333</span>)<span class="hljs-punctuation">;</span><br>n=((n<span class="hljs-variable">&amp;0xf0f0f0f0</span>)&gt;&gt;<span class="hljs-number">4</span>)+(n<span class="hljs-variable">&amp;0x0f0f0f0f</span>)<span class="hljs-punctuation">;</span><br>n=((n<span class="hljs-variable">&amp;0xff00ff00</span>)&gt;&gt;<span class="hljs-number">8</span>)+(n<span class="hljs-variable">&amp;0x00ff00ff</span>)<span class="hljs-punctuation">;</span><br>n=((n<span class="hljs-variable">&amp;0xffff0000</span>)&gt;&gt;<span class="hljs-number">16</span>)+(n<span class="hljs-variable">&amp;0x0000ffff</span>)<span class="hljs-punctuation">;</span><br>cout<span class="hljs-params">&lt;&lt;n&lt;&lt;endl;</span><br><span class="hljs-params">return <span class="hljs-number">0</span>;</span><br><span class="hljs-params">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使序列递增的最小交换次数</title>
    <link href="/2022/10/18/%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/10/18/%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0">使序列递增的最小交换次数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="使序列递增的最小交换次数"><a class="markdownIt-Anchor" href="#使序列递增的最小交换次数"></a> 使序列递增的最小交换次数</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p><a href="https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/">原题</a></p><p>我们有两个长度相等且不为空的整型数组 nums1 和 nums2 。在一次操作中，我们可以交换 nums1[i] 和 nums2[i]的元素。</p><p>例如，如果 nums1 = [1,2,3,8] ， nums2 =[5,6,7,4] ，你可以交换 i = 3 处的元素，得到 nums1 =[1,2,3,4] 和 nums2 =[5,6,7,8] 。<br />返回 使 nums1 和 nums2 严格递增 所需操作的最小次数 。</p><p>数组 arr 严格递增 且  arr[0] &lt; arr[1] &lt; arr[2] &lt; … &lt; arr[arr.length - 1] 。<br />input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p><code>dp[i][0]</code>表示不交换 <code>i</code> 处元素时满足条件的最小操作次数，<code>dp[i][1]</code>表示交换 <code>i</code> 处元素时满足条件的最小操作次数</p><p>下面要分类讨论：</p><ul><li>当nums1和nums都递增，且在<code>i</code>处交换后也都递增，那么在<code>i</code>处可换可不换</li><li>当nums1和nums都递增，但在<code>i</code>处交换后不递增，那么如果在<code>i</code>处交换，在<code>i-1</code>处也要交换</li><li>当nums1或nums2不递增，如果在<code>i</code>处交换，那么<code>i-1</code>处不交换，如果<code>i-1</code>处交换，<code>i</code>处不交换</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int N=1e5;<br>int a<span class="hljs-comment">[N]</span>;<br>int b<span class="hljs-comment">[N]</span>;<br>int dp<span class="hljs-comment">[N]</span><span class="hljs-comment">[2]</span>;<br>int main()<br>&#123;<br>int n;<br>cin&gt;&gt;n;<br>for(int i=0;i&lt;n;++i)<br>cin&gt;&gt;a<span class="hljs-comment">[i]</span>;<br>for(int i=0;i&lt;n;++i)<br>cin&gt;&gt;b<span class="hljs-comment">[i]</span>;<br>dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span>=1;<br>for(int i=1;i&lt;n;++i)<br>&#123;<br>if((a<span class="hljs-comment">[i-1]</span>&lt;a<span class="hljs-comment">[i]</span>&amp;&amp;b<span class="hljs-comment">[i-1]</span>&lt;b<span class="hljs-comment">[i]</span>)&amp;&amp;(a<span class="hljs-comment">[i-1]</span>&lt;b<span class="hljs-comment">[i]</span>&amp;&amp;b<span class="hljs-comment">[i-1]</span>&lt;a<span class="hljs-comment">[i]</span>))<br>&#123;<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>=min(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>,dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>);<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span>=dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>+1;<br>&#125;<br>else if(a<span class="hljs-comment">[i-1]</span>&lt;a<span class="hljs-comment">[i]</span>&amp;&amp;b<span class="hljs-comment">[i-1]</span>&lt;b<span class="hljs-comment">[i]</span>)<br>&#123;<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>=dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>;<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span>=dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>+1;<br>&#125;<br>else<br>&#123;<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>=dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>;<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span>=dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>+1;<br>&#125;<br>&#125;<br>cout&lt;&lt;min(dp<span class="hljs-comment">[n-1]</span><span class="hljs-comment">[0]</span>,dp<span class="hljs-comment">[n-1]</span><span class="hljs-comment">[1]</span>);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>不同的子序列</title>
    <link href="/2022/10/14/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/10/14/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97">不同的子序列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="不同的子序列"><a class="markdownIt-Anchor" href="#不同的子序列"></a> 不同的子序列</h2><p><a href="https://leetcode.cn/problems/distinct-subsequences-ii/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。</p><p>字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。</p><p>例如，“ace” 是 “abcde” 的一个子序列，但 “aec” 不是。</p><p>示例：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aba&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<span class="hljs-number">6</span> 个不同的子序列分别是 <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-string">&quot;ba&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span> 以及 <span class="hljs-string">&quot;aba&quot;</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这是一道动态规划的题目，自己没想出来，看了题解才理解<br />核心的思想就是，<em>以当前字符结尾的不同子序列的个数=之前部分的个数+新增加的个数-重复序列个数</em><br />其中，需要一个数组<code>recount[]</code>来记录每个字符带来的增加量，当某字符多次出现时，它带来的重复量就等于<code>recount[i]</code></p><p>比如：对于序列 abcb</p><p>a : “”, a<br /><strong>newcnt=1</strong></p><p>ab : “”, a, b, ab<br /><strong>newcnt=2</strong></p><p>abc : “”,a, b, ab, c, ac, bc, cc<br /><strong>newcnt=4</strong></p><p>abcb: “”,a, b, ab, c, ac, bc, cc, <s>b</s>, <s>ab</s>, bb, abb, cb, acb, bcb, ccb<br /><strong>newcnt=8, recount[‘b’]=2</strong></p><p>根据以上例子，可得到下面的结论：</p><ul><li>newcnt=pre_cnt(上一个字符的个数)</li><li>recount[x]=newcnt_x(字符x上一次出现带来的新增个数)</li></ul><p>为了计算，在子集前面加了空串 <code>“”</code>，所以初始个数为1</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> distinctSubseqII(string s) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">mod</span>=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        <span class="hljs-built_in">int</span> len=s.size();<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; recount(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> newcnt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            newcnt=ans;<br>            ans=((ans+newcnt)%<span class="hljs-keyword">mod</span>-recount[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]+<span class="hljs-keyword">mod</span>)%<span class="hljs-keyword">mod</span>;<br>            recount[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]=newcnt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>优势洗牌</title>
    <link href="/2022/10/09/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/"/>
    <url>/2022/10/09/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C">优势洗牌</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="优势洗牌"><a class="markdownIt-Anchor" href="#优势洗牌"></a> 优势洗牌</h2><p><a href="https://leetcode.cn/problems/advantage-shuffle/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] &gt; nums2[i] 的索引 i 的数目来描述。</p><p>返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。</p><p>示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums1 = <span class="hljs-string">[12,24,8,32]</span>, nums2 = <span class="hljs-string">[13,25,32,11]</span><br>输出：<span class="hljs-string">[24,32,8,12]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><blockquote><p>题目有一个隐含条件是，当nums1中的某个数不大于于nums2的任意数时，该数对应nums2的较大的数。具体步骤如下，先将两个数组的下标根据数字的大小升序排序，然后当nums1中的数大于nums2的数，加入答案数组中，否则找到对应nums2中的较大数的对应位置，根据该位置加入答案数组中</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">advantageCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(len)</span>,<span class="hljs-title">a</span><span class="hljs-params">(len)</span>,<span class="hljs-title">b</span><span class="hljs-params">(len)</span></span>;<br>        <span class="hljs-built_in">iota</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">iota</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)&#123;<br>            <span class="hljs-keyword">return</span> nums1[i]&lt;nums1[j];<br>        &#125;);<br>        <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)&#123;<br>            <span class="hljs-keyword">return</span> nums2[i]&lt;nums2[j];<br>        &#125;);<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=len<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums1[a[i]]&gt;nums2[b[l]])<br>            &#123;<br>                ans[b[l]]=nums1[a[i]];<br>                ++l;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ans[b[r]]=nums1[a[i]];<br>                --r;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>括号问题</title>
    <link href="/2022/10/07/%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/"/>
    <url>/2022/10/07/%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D">括号匹配</a></li><li><a href="#%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%91%E6%B7%BB%E5%8A%A0">使括号有效的最少添加</a></li><li><a href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90">括号生成</a></li><li><a href="#%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%95%B0">括号的分数</a></li></ul><!-- /TOC --><blockquote><p>关于括号多多少少会用到栈，下面举几个简单例子</p></blockquote><h3 id="括号匹配"><a class="markdownIt-Anchor" href="#括号匹配"></a> 括号匹配</h3><p><a href="https://leetcode.cn/problems/valid-parentheses/">题目链接</a></p><p><strong>题目描述</strong></p><p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ul><p>example：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">bool</span> isValid(<span class="hljs-keyword">string</span> s) &#123;<br>        <span class="hljs-keyword">int</span> len=s.size();<br>        stack&lt;<span class="hljs-keyword">char</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-keyword">empty</span>()&amp;&amp;(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>||s[i]==<span class="hljs-string">&#x27;]&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st.<span class="hljs-keyword">empty</span>())<br>                st.push(s[i]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>||s[i]==<span class="hljs-string">&#x27;[&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>            &#123;<br>                <span class="hljs-comment">// if(s[i]&lt;=st.top())</span><br>                    st.push(s[i]);<br>                <span class="hljs-comment">// else</span><br>                <span class="hljs-comment">//     return false;</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>||s[i]==<span class="hljs-string">&#x27;]&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(st.top()==s[i]<span class="hljs-number">-1</span>||st.top()==s[i]<span class="hljs-number">-2</span>)<br>                    st.pop();<br>                <span class="hljs-keyword">else</span> <br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!st.<span class="hljs-keyword">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使括号有效的最少添加"><a class="markdownIt-Anchor" href="#使括号有效的最少添加"></a> 使括号有效的最少添加</h3><p><a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/">题目链接</a></p><p><strong>题目描述</strong></p><p>只有满足下面几点之一，括号字符串才是有效的：</p><p>它是一个空字符串，或者<br />它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者<br />它可以被写作 (A)，其中 A 是有效字符串。<br />给定一个括号字符串 s ，移动N次，你就可以在字符串的任何位置插入一个括号。</p><p>例如，如果 s = “()))” ，你可以插入一个开始括号为 “(()))” 或结束括号为 “())))” 。<br />返回 为使结果字符串 s 有效而必须添加的最少括号数。</p><p>example：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;())&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> minAddToMakeValid(string s) &#123;<br>        <span class="hljs-keyword">int</span> len=s.<span class="hljs-keyword">size</span>();<br>        stack&lt;<span class="hljs-keyword">char</span>&gt; st;<br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>&amp; c:s)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;(&#x27;</span>)<br>                st.<span class="hljs-keyword">push</span>(c);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;)&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(st.empty())<br>                    ++ans;<br>                <span class="hljs-keyword">else</span><br>                    st.<span class="hljs-keyword">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans+st.<span class="hljs-keyword">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="括号生成"><a class="markdownIt-Anchor" href="#括号生成"></a> 括号生成</h3><p><a href="https://leetcode.cn/problems/generate-parentheses/">题目链接</a></p><p><strong>题目描述</strong><br />数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。</p><p>example：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bk</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> &amp;tmp,vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; ans,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> n</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(tmp.size()==<span class="hljs-number">2</span>*n)<br>        &#123;<br>            ans.push_back(tmp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l&lt;n)<br>        &#123;<br>            tmp.push_back(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            bk(tmp,ans,l+<span class="hljs-number">1</span>,r,n);<br>            tmp.pop_back();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r&lt;l)<br>        &#123;<br>            tmp.push_back(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            bk(tmp,ans,l,r+<span class="hljs-number">1</span>,n);<br>            tmp.pop_back();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">generateParenthesis</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> &#123;<br>        <span class="hljs-built_in">string</span> tmp;<br>        vector&lt;<span class="hljs-built_in">string</span>&gt; ans;<br>        bk(tmp,ans,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="括号的分数"><a class="markdownIt-Anchor" href="#括号的分数"></a> 括号的分数</h3><p><a href="https://leetcode.cn/problems/score-of-parentheses/">题目链接</a></p><p><strong>题目描述</strong></p><p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：</p><ul><li>() 得 1 分。```A 是平衡括号字符串。</li></ul><p>样例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">输入： &quot;(()(()))&quot;<br>输出： <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p>因为(()(())) = (()) + ((()))，所以记录层数就好<br />出现 ‘(’ 代表层数+1 ， 出现 ‘)’ 代表层数-1<br />当<code>s[i]==')'&amp;&amp;s[i-1]=='('</code>,该部分得分为 2^(层数-1) ,更新一下总分数</p><p>代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">scoreOfParentheses</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> d=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> len=s.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>)<br>                ++d;<br>            <span class="hljs-keyword">else</span><br>                --d;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;(&#x27;</span>)<br>                ans+=<span class="hljs-number">1</span>&lt;&lt;d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LR字符串</title>
    <link href="/2022/10/02/LR%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/10/02/LR%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%9C%A8lr%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6">在LR字符串中交换相邻字符</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="在lr字符串中交换相邻字符"><a class="markdownIt-Anchor" href="#在lr字符串中交换相邻字符"></a> 在LR字符串中交换相邻字符</h2><p><a href="https://leetcode.cn/problems/swap-adjacent-in-lr-string/">原题链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如&quot;RXXLRXRXL&quot;）中进行移动操作。一次移动操作指用一个&quot;LX&quot;替换一个&quot;XL&quot;，或者用一个&quot;XR&quot;替换一个&quot;RX&quot;。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。</p><p>input:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">start</span> = <span class="hljs-string">&quot;RXXLRXRXL&quot;</span>, end = <span class="hljs-string">&quot;XRLXXRRLX&quot;</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用 i 和 j 分别表示 start 和 end 中的下标，跳过所有的<code>X</code>，当<code>start[i]!=start[j]</code>,直接返回false,当<code>start[i]==start[j]</code>，如果字符是<code>L</code>,应满足<code>j&lt;=i</code>,如果字符是<code>R</code>,应满足<code>i&lt;=j</code>，否则返回<code>false</code></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canTransform</span><span class="hljs-params">(string start, string end)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=start.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;n&amp;&amp;j&lt;n)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(i&lt;n&amp;&amp;start[i]==<span class="hljs-string">&#x27;X&#x27;</span>)<br>                ++i;<br>            <span class="hljs-keyword">while</span>(j&lt;n&amp;&amp;end[j]==<span class="hljs-string">&#x27;X&#x27;</span>)<br>                ++j;<br>            <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;j&lt;n)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(start[i]!=end[j])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(start[i]==<span class="hljs-string">&#x27;L&#x27;</span>&amp;&amp;i&lt;j)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span>(start[i]==<span class="hljs-string">&#x27;R&#x27;</span>&amp;&amp;i&gt;j)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                ++i;<br>                ++j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i&lt;n)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(start[i]!=<span class="hljs-string">&#x27;X&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j&lt;n)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(end[j]!=<span class="hljs-string">&#x27;X&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>非零段划分</title>
    <link href="/2022/09/29/%E9%9D%9E%E9%9B%B6%E6%AE%B5%E5%88%92%E5%88%86/"/>
    <url>/2022/09/29/%E9%9D%9E%E9%9B%B6%E6%AE%B5%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%9D%9E%E9%9B%B6%E6%AE%B5%E5%88%92%E5%88%86">非零段划分</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="非零段划分"><a class="markdownIt-Anchor" href="#非零段划分"></a> 非零段划分</h2><p>题目来自CCF 201909-2</p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>A1,A2,⋯,An 是一个由 n 个自然数组成的数组。我们称其中 Ai,⋯,Aj 是一个非零段，当且仅当以下条件同时满足：</p><ul><li>1≤i≤j≤n；</li><li>对于任意的整数 k，若 i≤k≤j，则 Ak&gt;0；</li><li>i=1 或 Ai−1=0；</li><li>j=n 或 Aj+1=0。</li></ul><p>下面展示了几个简单的例子：</p><p>A=[3,1,2,0,0,2,0,4,5,0,2] 中的 4 个非零段依次为 [3,1,2]、[2]、[4,5] 和 [2]；<br />A=[2,3,1,4,5] 仅有 1 个非零段；<br />A=[0,0,0] 则不含非零段（即非零段个数为 0）。</p><p>现在我们可以对数组 A 进行如下操作：任选一个正整数 p，然后将 A 中所有小于 p 的数都变为 0。试选取一个合适的 p，使得数组 A 中的非零段个数达到最大。若输入的 A 所含非零段数已达最大值，可取 p=1，即不对 A 做任何修改。</p><p>输入：<br />从标准输入读入数据。</p><p>输入的第一行包含一个正整数 n。</p><p>输入的第二行包含 n 个用空格分隔的自然数 A1,A2,⋯,An。</p><p>输出：</p><p>输出到标准输出。</p><p>仅输出一个整数，表示对数组 A 进行操作后，其非零段个数能达到的最大值。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>差分与前缀和<br />如果 <code>a[i]&gt;a[i−1]</code>，意味着当p取到 <code>a[i−1]+1 </code>到 <code>a[i]</code>之间的值时，非零段+1<br />数组<code>b[i]</code>表示<code>p</code>从<code>a[i-1]</code>到<code>a[i]</code>，非零段数量的变化<br />从正向前缀和中找出最大值就是所要的结果</p><p>差分前缀和之前练习过，但这道题真没想到还能这样，tcl😢，看了别人的思路，实在是太妙了啊😢😢😢😢</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M=<span class="hljs-number">1e4</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> b[M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>cin&gt;&gt;a[i];<br><span class="hljs-keyword">if</span>(a[i]&gt;a[i<span class="hljs-number">-1</span>])<br>&#123;<br><span class="hljs-comment">//a[i-1]~a[i]的非零段数加1 </span><br>++b[a[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>];<br>--b[a[i]+<span class="hljs-number">1</span>];<br>&#125; <br>&#125;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=M;++i)<br>&#123;<br>sum+=b[i];<br>ans=<span class="hljs-built_in">max</span>(ans,sum);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第k个数</title>
    <link href="/2022/09/29/%E7%AC%ACk%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/09/29/%E7%AC%ACk%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%AC%ACk%E4%B8%AA%E6%95%B0">第k个数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E7%AC%AC-n-%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97">第 N 个神奇数字</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="第k个数"><a class="markdownIt-Anchor" href="#第k个数"></a> 第k个数</h2><blockquote><p>此题不是特别难，但是第一眼看过去没有什么太好的想法，看了眼题解觉得思路很好，就记录下来<br /><s>顺便水一个博客😄</s></p></blockquote><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p><p>输入k，输出符合条件的第k个数</p><p>input:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">9<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>建立一个数组<code>dp[]</code>，<code>dp[i]</code>表示第<code>i</code>个数什么，然后三个变量a,b,c表示3、5、7的指针</p><p>状态方程：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int <span class="hljs-attribute">numa</span>=dp[a]<span class="hljs-number">*3</span>,<span class="hljs-attribute">numb</span>=dp[b]<span class="hljs-number">*5</span>,<span class="hljs-attribute">numc</span>=dp[c]<span class="hljs-number">*7</span>;<br>dp[i]=min(min(numa,numb),numc);<br></code></pre></td></tr></table></figure><p>然后如果<code>dp[i]</code>与任何一个num相等，对应的指针加1</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>const int <span class="hljs-attribute">N</span>=1e3;<br>int dp[N];<br>int main()<br>&#123;<br>int n;<br>cin&gt;&gt;n;<br>int <span class="hljs-attribute">a</span>=1,b=1,c=1;<br>dp[1]=1;<br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=2;i&lt;=n;++i)<br>&#123;<br>int <span class="hljs-attribute">numa</span>=dp[a]<span class="hljs-number">*3</span>,<span class="hljs-attribute">numb</span>=dp[b]<span class="hljs-number">*5</span>,<span class="hljs-attribute">numc</span>=dp[c]<span class="hljs-number">*7</span>;<br>dp[i]=min(min(numa,numb),numc);<br><span class="hljs-keyword">if</span>(dp[i]==numa)<br>++a;<br><span class="hljs-keyword">if</span>(dp[i]==numb)<br>++b;<br><span class="hljs-keyword">if</span>(dp[i]==numc)<br>++c;<br>&#125;<br>cout&lt;&lt;dp[n]&lt;&lt;endl;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第-n-个神奇数字"><a class="markdownIt-Anchor" href="#第-n-个神奇数字"></a> 第 N 个神奇数字</h2><p><a href="https://leetcode.cn/problems/nth-magical-number/description/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>一个正整数如果能被 a 或 b 整除，那么它是神奇的。</p><p>给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模 后的值。</p><p>示例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">4</span>, <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>用到了容斥原理，对于一个数x，他包含<code>x/a</code>个数能被a整除，包含<code>x/b</code>个数能被b整除,若a和b最小公倍数为c，那么x包含<code>x/c</code>个数能被a和b同时整除，因此，能被a或b整除的数的个数为：<code>x/a+x/b-x/c</code></p><p>根据以上规律，使用二分查找即可得出答案。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">mod</span>=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">mod</span>=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>    <span class="hljs-built_in">int</span> gcd(<span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b)<br>            <span class="hljs-keyword">return</span> gcd(b,a%b);<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-built_in">int</span> nthMagicalNumber(<span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) &#123;<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> l=min(a,b);<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> r=(<span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span>)n*l;<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> c=a*b/gcd(a,b);<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> mid,t;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)<br>        &#123;<br>            mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>            t=mid/a+mid/b-mid/c;<br>            <span class="hljs-keyword">if</span>(t&lt;n)<br>                l=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (r+<span class="hljs-number">1</span>)%<span class="hljs-keyword">mod</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>素数筛</title>
    <link href="/2022/09/25/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    <url>/2022/09/25/%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9A%B4%E5%8A%9B">暴力</a></li><li><a href="#%E5%9F%83%E6%B0%8F%E7%AD%9B">埃氏筛</a></li><li><a href="#%E6%AC%A7%E6%8B%89%E7%AD%9B">欧拉筛</a></li><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li></ul><!-- /TOC --><p><strong>素数筛</strong></p><blockquote><p>找到1到n区间里的所有素数,通常有以下几种方法</p></blockquote><h3 id="暴力"><a class="markdownIt-Anchor" href="#暴力"></a> 暴力</h3><p>最基本的方法，时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h3 id="埃氏筛"><a class="markdownIt-Anchor" href="#埃氏筛"></a> 埃氏筛</h3><p>主要思想是通过一个<code>bool</code>类型的数组记录某数是否为素数，思路不难，直接看代码就行</p><p><strong>代码</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>        isPrime[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//假设2-n都是素数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)   <span class="hljs-comment">//遍历2-n里面所有数</span><br>        <span class="hljs-keyword">if</span>(isPrime[i])      <span class="hljs-comment">//如果i是素数</span><br>            <span class="hljs-comment">//i是素数的话，那么i的倍数肯定就不是合适</span><br>            <span class="hljs-comment">//即 i*2，i*3 .....i*j肯定不是素数，注意边界i*j&lt;=n</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;i*j&lt;=n;++j)<br>                <span class="hljs-comment">//n以内，且是i的倍数的数肯定不是素数，设为false</span><br>                isPrime[i*j] = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h3 id="欧拉筛"><a class="markdownIt-Anchor" href="#欧拉筛"></a> 欧拉筛</h3><p>在埃尼筛的基础上加以改进，需要维护一个<code>vis[]</code>数组判断是否被标记过，然后<code>prime[]</code>数组记录第几个素数是什么，比较好理解，看一道例题就行</p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p><strong>题目描述</strong></p><p>Output the k-th prime number.</p><p>input:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">17<br></code></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>;<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-type">int</span> prime[<span class="hljs-number">10000</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    cin&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=N;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cnt==k)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-literal">false</span>)<br>            prime[++cnt]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=N;++j)<br>        &#123;<br>            vis[i*prime[j]]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;prime[k]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>相似度为k的字符串</title>
    <link href="/2022/09/23/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%BAk%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/09/23/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%BAk%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%BAk%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">相似度为k的字符串</a></li></ul><!-- /TOC --><h3 id="相似度为k的字符串"><a class="markdownIt-Anchor" href="#相似度为k的字符串"></a> 相似度为k的字符串</h3><p><a href="https://leetcode.cn/problems/k-similar-strings/">题目链接</a></p><p><strong>题目描述</strong></p><p>对于某些非负整数 <code>k</code> ，如果交换 <code>s1</code> 中两个字母的位置恰好 <code>k</code> 次，能够使结果字符串等于 <code>s2</code> ，则认为字符串 <code>s1</code> 和 <code>s2</code> 的 相似度为<code> k</code> 。</p><p>给你两个字母异位词 <code>s1 </code>和 <code>s2</code> ，返回 <code>s1 </code>和<code>s2</code>的相似度<code>k</code>的最小值。</p><p><strong>思路</strong></p><blockquote><p>主要是BFS+剪枝，当s1和s2在某个位置出现s1[i] != s2[i]时，将s1的指针后移，找到j使得s1[j] == s2[i],然后交换s1[i]和s1[j]，将字符串和位置加入队列中。同时要注意剪枝，当s1[j]==s2[j]时说明本来就能匹配，所以无需交换，当交换后的字符串在之前已经出现时，无需再次加入队列。</p></blockquote><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> queue&lt;pair&lt;string,<span class="hljs-type">int</span>&gt;&gt; qpi;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_set&lt;string&gt; vis;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kSimilarity</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        qpi q;<br>        <span class="hljs-type">int</span> len=s1.<span class="hljs-built_in">size</span>();<br>        q.<span class="hljs-built_in">push</span>(&#123;s1,<span class="hljs-number">0</span>&#125;);<br>        vis.<span class="hljs-built_in">insert</span>(s1);<br>        string ts;<br>        <span class="hljs-type">int</span> idx;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;;++ans)<br>        &#123;<br>            <span class="hljs-type">int</span> sz=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(sz--)<br>            &#123;<br>                pair&lt;string,<span class="hljs-type">int</span>&gt; t=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                ts=t.first;<br>                idx=t.second;<br>                <span class="hljs-keyword">if</span>(ts==s2)<br>                    <span class="hljs-keyword">return</span> ans;<br>                <span class="hljs-keyword">while</span>(idx&lt;len&amp;&amp;ts[idx]==s2[idx])<br>                    ++idx;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=idx+<span class="hljs-number">1</span>;i&lt;len;++i)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(ts[i]!=s2[i]&amp;&amp;ts[i]==s2[idx])<br>                    &#123;<br>                        <span class="hljs-built_in">swap</span>(ts[idx],ts[i]);<br>                        <span class="hljs-keyword">if</span>(!vis.<span class="hljs-built_in">count</span>(ts))<br>                        &#123;<br>                            q.<span class="hljs-built_in">push</span>(&#123;ts,idx+<span class="hljs-number">1</span>&#125;);<br>                            vis.<span class="hljs-built_in">insert</span>(ts);<br>                        &#125;<br>                        <span class="hljs-built_in">swap</span>(ts[idx],ts[i]);<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组中的逆序对</title>
    <link href="/2022/09/20/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <url>/2022/09/20/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9">数组中的逆序对</a></li></ul><!-- /TOC --><h3 id="数组中的逆序对"><a class="markdownIt-Anchor" href="#数组中的逆序对"></a> 数组中的逆序对</h3><p><strong>题目描述</strong></p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p>这道题可以用归并排序的思路来解决</p><p>假设我们有两个已排序的序列等待合并，分别是L={8,12,16,22,100} 和 R={9,26,55,64,91}。一开始我们用指针 lPtr = 0 指向 L 的首部，rPtr = 0 指向 R 的头部。记已经合并好的部分为 M。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">L = <span class="hljs-comment">[8, 12, 16, 22, 100]</span>   R = <span class="hljs-comment">[9, 26, 55, 64, 91]</span>  M = <span class="hljs-comment">[]</span><br>     |                          |<br>   lPtr                       rPtr<br></code></pre></td></tr></table></figure><p>发现 lPtr 指向的元素小于 rPtr 指向的元素，于是把 lPtr 指向的元素放入答案，并把 lPtr 后移一位。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">L = <span class="hljs-comment">[8, 12, 16, 22, 100]</span>   R = <span class="hljs-comment">[9, 26, 55, 64, 91]</span>  M = <span class="hljs-comment">[8]</span><br>        |                       |<br>      lPtr                     rPtr<br><br></code></pre></td></tr></table></figure><p>这个时候我们把左边的 8 加入了答案，我们发现右边没有数比 8 小，所以 8 对逆序对总数的「贡献」为 0。</p><p>接着我们继续合并，把 9 加入了答案，此时 lPtr 指向 12，rPtr 指向 26。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">L = <span class="hljs-comment">[8, 12, 16, 22, 100]</span>   R = <span class="hljs-comment">[9, 26, 55, 64, 91]</span>  M = <span class="hljs-comment">[8, 9]</span><br>        |                          |<br>       lPtr                       rPtr<br><br></code></pre></td></tr></table></figure><p>此时12对逆序数贡献为1，以此类推。</p><p><strong>代码</strong>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>int nums[100005];<br>int cnt;<br>int <span class="hljs-attribute">mod</span>=1e9+7;<br>void merge(int l,int m,int r)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-attribute">l</span>==r)<br>        return ;<br>    int i,j;<br>    int <span class="hljs-attribute">n1</span>=m-l+1;<br>    int <span class="hljs-attribute">n2</span>=r-m;<br>    vector&lt;int&gt; al(n1);<br>    vector&lt;int&gt; ar(n2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-attribute">i</span>=0;i&lt;n1;++i)<br>        al[i]=nums[l+i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-attribute">i</span>=0;i&lt;n2;++i)<br>        ar[i]=nums[m+1+i];<br>    <span class="hljs-attribute">i</span>=0;<br>    <span class="hljs-attribute">j</span>=0;<br>    int <span class="hljs-attribute">k</span>=l;<br>    <span class="hljs-keyword">while</span>(i&lt;n1&amp;&amp;j&lt;n2)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(al[i]&lt;=ar[j])<br>        &#123;<br>            nums[k]=al[i];<br>            ++k;<br>            ++i;<br>            cnt+=j;<br>            <span class="hljs-attribute">cnt</span>=cnt%mod;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            nums[k]=ar[j];<br>            ++k;<br>            ++j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;n1)<br>    &#123;<br>        nums[k++]=al[i];<br>        cnt+=j;<br>        <span class="hljs-attribute">cnt</span>=cnt%mod;<br>        ++i;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j&lt;n2)<br>    &#123;<br>        nums[k++]=ar[j];<br>        ++j;<br>    &#125;    <br>&#125;<br>void mergesort(int l,int r)<br>&#123;<br>    <span class="hljs-keyword">if</span>(l&lt;r)<br>    &#123;<br>        int <span class="hljs-attribute">m</span>=l+r&gt;&gt;1;<br>        mergesort(l,m);<br>        mergesort(m+1,r);<br>        merge(l,m,r);<br>    &#125;<br>&#125;<br>int main() <br>&#123;<br>int n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n;++i)<br>cin&gt;&gt;nums[i];<br>    mergesort(0,n-1);<br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最长达标子串</title>
    <link href="/2022/09/17/%E6%9C%80%E9%95%BF%E8%BE%BE%E6%A0%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/09/17/%E6%9C%80%E9%95%BF%E8%BE%BE%E6%A0%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E9%95%BF%E8%BE%BE%E6%A0%87%E5%AD%90%E4%B8%B2">最长达标子串</a></li><li><a href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%BB%83%E4%B9%A0">位操作练习</a></li></ul><!-- /TOC --><h3 id="最长达标子串"><a class="markdownIt-Anchor" href="#最长达标子串"></a> 最长达标子串</h3><p><strong>题目描述</strong></p><p>给定一个字符串<code>s</code>，其中都是英文小写字母，如果<code>s</code>的子串中含有的每种字符都是偶数个，那么这样的子串就是达标子串，输出达标子串的最大长度。</p><p>input:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">aababcdcdc</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用一个数组记录当前的状态，<code>1</code>表示当前字母出现了奇数次，<code>0</code>表示当前字母出现了偶数次</p><p>例如：如果<code>s</code>一共有四个字母<code>abcd</code>，子串<code>a</code>的状态可记为<code>1000</code>，子串<code>aab</code>记为<code>0100</code><br />,子串<code>abacd</code>记为<code>0111</code></p><p>可以得出这样的结论：如果<code>i</code>处的状态与<code>i+k</code>处的状态相同，则<code>i~i+k</code>之间的子串中的每个字母都出现了偶数次</p><p>原理就是出现偶数次，不会改变某个字母的状态</p><p>所以，只需要记录每个状态序列最早出现的位置，然后当他再次出现时，最晚出现的位置减去最早出现的位置就是最长的达标子串。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s;<br>cin&gt;&gt;s;<br><span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br><span class="hljs-type">int</span> status=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>mp[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<span class="hljs-comment">//初始化-1位置为0...00 32个0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>&#123;<br><span class="hljs-comment">//假设当前s[i]是&#x27;c&#x27;,那么将1左移2位，然后和status异或</span><br><span class="hljs-comment">//即可改变&#x27;c&#x27;处的状态 </span><br>status=status^<span class="hljs-number">1</span>&lt;&lt;s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(status))<br>ans=<span class="hljs-built_in">max</span>(ans,i-mp[status]);<br><span class="hljs-keyword">else</span><br>mp[status]=i; <br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="位操作练习"><a class="markdownIt-Anchor" href="#位操作练习"></a> 位操作练习</h3><p><strong>题目描述</strong></p><p>给出两个不大于65535的非负整数，判断其中一个的16位二进制表示形式，是否能由另一个的16位二进制表示形式经过循环左移若干位而得到。 循环左移和普通左移的区别在于：最左边的那一位经过循环左移一位后就会被移到最右边去。比如： 1011 0000 0000 0001 经过循环左移一位后，变成 0110 0000 0000 0011, 若是循环左移2位，则变成 1100 0000 0000 0110</p><p>输入两个不大于65535的非负整数</p><p>如果能通过循环左移相等，输出<code>YES</code>,否则输出<code>NO</code></p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">45057 </span><span class="hljs-number">49158</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">YES</span><br></code></pre></td></tr></table></figure><p>这个就不说了，直接看代码就行了</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> a,b;<br>cin&gt;&gt;a&gt;&gt;b;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">16</span>;++i)<br>&#123;<br><span class="hljs-keyword">if</span>(a==b)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(i==<span class="hljs-number">15</span>)<br>cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>a=a&lt;&lt;<span class="hljs-number">1</span> | a&gt;&gt;<span class="hljs-number">15</span>&amp;<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>龙与地下城游戏问题</title>
    <link href="/2022/09/16/%E9%BE%99%E4%B8%8E%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/16/%E9%BE%99%E4%B8%8E%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%BE%99%E4%B8%8E%E5%9C%B0%E4%B8%8B%E5%9F%8E%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98">龙与地下城迷宫问题</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li></ul><!-- /TOC --><h2 id="龙与地下城迷宫问题"><a class="markdownIt-Anchor" href="#龙与地下城迷宫问题"></a> 龙与地下城迷宫问题</h2><p><a href="https://www.nowcoder.com/practice/c0ca4c9e65144af69ada03febaa0e33a?tpId=230&amp;tqId=537494&amp;ru=/exam/oj&amp;qru=/ta/dynamic-programming/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D230">题目链接</a></p><p><strong>题目描述</strong></p><p>给定一个二维数组map，含义是一张地图</p><p>游戏的规则如下:<br />1）骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。<br />2）地图中每个位置的值代表骑士要遭遇的事情。如果是负数，说明此处有怪兽，要让骑士损失血量。如果是非负数，代表此处有血瓶，能让骑士回血。<br />3）骑士从左上角到右下角的过程中，走到任何一个位置时，血量都不能少于1。为了保证骑土能见到公主，初始血量至少是多少?</p><p>根据map,输出初始血量。</p><p>输入第一行<code>n,m</code>，表示矩阵大小<br />然后输入矩阵</p><p>输出初始血量</p><p>input:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">3 3<br><span class="hljs-string">-2</span> <span class="hljs-string">-3</span> 3<br><span class="hljs-string">-5</span> <span class="hljs-string">-10</span> 1<br>0 30 <span class="hljs-string">-5</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>这道题也属于dp，但是有意思的是，如果我们选择 <code>自顶向下</code> 的方式，即从左上角出发，在前进过程中，每一个位置的最小血量是由后面的路径决定的，因此<code>自顶向下</code> 方法是不行的，那么我们可以选择<code> 自底向上</code> 的方式，从右下角出发。</p><p><code>dp[i][j]</code>可理解为，走<code>a[i][j]</code>之前，至少要拥有的血量，且这个血量始终不能小于1</p><p>所以<code>dp[n][m]</code>初始化为<code>max(1-a[n][m],1)</code></p><p>然后从右下角到左上角更新dp数组即可</p><p><strong>代码</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include &lt;bits/stdc++.h&gt;<br>using namespace std;<br><br>const int N=1e3+5;<br>int a<span class="hljs-comment">[N]</span><span class="hljs-comment">[N]</span>,dp<span class="hljs-comment">[N]</span><span class="hljs-comment">[N]</span>;<br>int main()<br>&#123;<br>    int n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        for(int j=1;j&lt;=m;++j)<br>            cin&gt;&gt;a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>;<br>    &#125;<br>    dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[m]</span>=max(1-a<span class="hljs-comment">[n]</span><span class="hljs-comment">[m]</span>,1);<br>    for(int i=n-1;i&gt;=1;--i)<br>        dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[m]</span>=max(dp<span class="hljs-comment">[i+1]</span><span class="hljs-comment">[m]</span>-a<span class="hljs-comment">[i]</span><span class="hljs-comment">[m]</span>,1);<br>    for(int i=m-1;i&gt;=1;--i)<br>        dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[i]</span>=max(dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[i+1]</span>-a<span class="hljs-comment">[n]</span><span class="hljs-comment">[i]</span>,1);<br>    for(int i=n-1;i&gt;=1;--i)<br>    &#123;<br>        for(int j=m-1;j&gt;=1;--j)<br>        &#123;<br>            int t=min(dp<span class="hljs-comment">[i+1]</span><span class="hljs-comment">[j]</span>-a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j+1]</span>-a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>);<br>            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(t,1);<br>        &#125;<br>    &#125;<br>    <br>    cout&lt;&lt;dp<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span>&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dp练习</title>
    <link href="/2022/09/15/dp%E7%BB%83%E4%B9%A0/"/>
    <url>/2022/09/15/dp%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B8%8D%E5%90%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%B8%AA%E6%95%B0">不同二叉搜索树的个数</a></li><li><a href="#%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF">最小花费爬楼梯</a></li><li><a href="#%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9">最小花费</a></li><li><a href="#%E5%88%86%E9%85%8D%E5%AE%9D%E8%97%8F">分配宝藏</a></li></ul><!-- /TOC --><h2 id="不同二叉搜索树的个数"><a class="markdownIt-Anchor" href="#不同二叉搜索树的个数"></a> 不同二叉搜索树的个数</h2><p><strong>题目描述</strong></p><p>给定一个由节点值从 1 到 n 的 n 个节点。请问由多少种不同的方法用这 n 个节点构成互不相同的二叉搜索树。</p><p>仅一行输入一个正整数 n ，表示节点的数量。</p><p>输出组成不同二叉搜索树的方法数。</p><p>input:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p><code>dp[k]</code>表示<code>k</code>个节点时不同二叉搜索树的个数，当有<code>n</code>个节点时，以<code>i</code>为根节点的左子树有<code>i-1</code>个节点，而右子树有<code>i-j</code>个节点，所以以<code>i</code>为根节点的二叉搜索树一共有<code>dp[i-1]*d[i-j]</code>个</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">20</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>        &#123;<br>            dp[i]+=dp[j<span class="hljs-number">-1</span>]*dp[i-j];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最小花费爬楼梯"><a class="markdownIt-Anchor" href="#最小花费爬楼梯"></a> 最小花费爬楼梯</h2><p><strong>题目描述</strong></p><p>给定一个整数数组 <code>cost[]</code> ，其中 <code>cost[i]</code>是从楼梯第<code>i</code>个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">10</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">100</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">90</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">80</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p><code>dp[i]</code>表示第<code>i</code>个台阶之前的最小花费<br />因为一次能走一级或者两级台阶，所以<code>dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])</code></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> cost[N];<br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        cin&gt;&gt;cost[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n+<span class="hljs-number">1</span>;++i)<br>    &#123;<br>        dp[i]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>]+cost[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]+cost[i<span class="hljs-number">-2</span>]);<br>    &#125;<br>    cout&lt;&lt;dp[n+<span class="hljs-number">1</span>]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最小花费"><a class="markdownIt-Anchor" href="#最小花费"></a> 最小花费</h2><p><strong>题目描述</strong></p><p>在某条线路上有N个火车站，有三种距离的路程，L1，L2，L3,对应的价格为C1,C2,C3.<br />每两个站之间的距离不超过L3。 当乘客要移动的两个站的距离大于L3的时候，可以选择从中间一个站下车，然后买票再上车，所以乘客整个过程中至少会买两张票。 现在给你一个 L1，L2，L3，C1，C2，C3。然后是A，B的值，其分别为乘客旅程的起始站和终点站。 然后输入N，N为该线路上的总的火车站数目，然后输入N-1个整数，分别代表从该线路上的第一个站，到第2个站，第3个站，……，第N个站的距离。 根据输入，输出乘客从A到B站的最小花费。</p><p><strong>输入描述</strong></p><p>第一行输入l1,l2,l3,c1,c2,c3<br />第二行输入a,b<br />第三行输入n<br />第四行输入n-1个数，表示第一站到后面站的距离</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>output:</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>;<br><span class="hljs-type">int</span> l1,l2,l3,c1,c2,c3;<br><span class="hljs-type">int</span> a,b;<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getprice</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(dis[b]-dis[a]&lt;=l1)<br>        <span class="hljs-keyword">return</span> c1;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dis[b]-dis[a]&lt;=l2)<br>        <span class="hljs-keyword">return</span> c2;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> c3;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;l1&gt;&gt;l2&gt;&gt;l3&gt;&gt;c1&gt;&gt;c2&gt;&gt;c3)<br>    &#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        cin&gt;&gt;n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>            cin&gt;&gt;dis[i];<br>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>        dp[a]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a+<span class="hljs-number">1</span>;i&lt;=b;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=a;j&lt;i;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dis[i]-dis[j]&lt;=l3)<br>                    dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[j]+<span class="hljs-built_in">getprice</span>(j,i));<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;dp[b]&lt;&lt;endl;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分配宝藏"><a class="markdownIt-Anchor" href="#分配宝藏"></a> 分配宝藏</h2><p><strong>题目描述</strong></p><p>两个寻宝者找到一个宝藏，里面包含n件物品，每件物品的价值分别是W[0]，W[1]，…W[n-1]。<br />SumA代表寻宝者A所获物品价值总和，SumB代表寻宝者B所获物品价值总和，请问怎么分配才能使得两人所获物品价值总和差距最小，即两人所获物品价值总和之差的绝对值|SumA - SumB|最小。</p><p>输入说明<br />输入数据由两行构成：<br />第一行为一个正整数n，表示物品个数，其中<code>0&lt;n&lt;=200</code>。<br />第二行有n个正整数，分别代表每件物品的价值<code>W[i]</code>，其中<code>0&lt;W[i]&lt;=200</code>。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><p><strong>思路</strong><br />其实是一道<strong>01背包问题</strong>，只需要将背包容量设置为总价值的一半即可</p><p>代码</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs excel">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const <span class="hljs-built_in">int</span> <span class="hljs-built_in">N</span>=<span class="hljs-number">1</span>e6+<span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> a[<span class="hljs-built_in">N</span>];<br><span class="hljs-built_in">int</span> dp[<span class="hljs-built_in">N</span>]; <br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>;<br>cin&gt;&gt;<span class="hljs-built_in">n</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span>;<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">n</span>;++i)<br>&#123;<br>cin&gt;&gt;a[i];<br><span class="hljs-built_in">sum</span>+=a[i];<br>&#125;<br><span class="hljs-built_in">int</span> v=<span class="hljs-built_in">sum</span>/<span class="hljs-number">2</span>;<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">n</span>;++i)<br>&#123;<br>for(<span class="hljs-built_in">int</span> j=v;j&gt;=a[i];--j)<br>&#123;<br>dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-a[i]]+a[i]);<br>&#125;<br>&#125;<br>    cout&lt;&lt;<span class="hljs-built_in">abs</span>(<span class="hljs-number">2</span>*dp[v]-<span class="hljs-built_in">sum</span>)&lt;&lt;endl;<br>return <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2022/09/13/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2022/09/13/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BE%8B1">例1</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><strong>题目描述</strong></a></li><li><a href="#%E6%80%9D%E8%B7%AF"><strong>思路</strong></a></li><li><a href="#%E4%BB%A3%E7%A0%81"><strong>代码：</strong></a></li></ul></li><li><a href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2">柱状图中最大的矩形</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4">接雨水</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><strong>题目描述</strong></a></li><li><a href="#%E4%BB%A3%E7%A0%81"><strong>代码</strong></a></li></ul></li></ul><!-- /TOC --><h2 id="例1"><a class="markdownIt-Anchor" href="#例1"></a> 例1</h2><p>###<strong>题目描述</strong></p><p>给出项数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的整数数列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>…</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{1 \dots n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="minner mtight">…</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>定义函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> 代表数列中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个元素之后第一个大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的元素的<strong>下标</strong>，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>j</mi></msub><mo>&gt;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow></msub><mo stretchy="false">{</mo><mi>j</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f(i)=\min_{i&lt;j\leq n, a_j &gt; a_i} \{j\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0973199999999999em;vertical-align:-0.34731999999999996em;"></span><span class="mop"><span class="mop">min</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166400000000005em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">&lt;</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">n</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mrel mtight">&gt;</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">}</span></span></span></span>。若不存在，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(i)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><p>试求出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo>…</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(1\dots n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p><strong>输入格式</strong></p><p>第一行一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>第二行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>…</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{1\dots n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="minner mtight">…</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><strong>输出格式</strong></p><p>一行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo>…</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(1\dots n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的值。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>数据规模</strong></p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">n\leq 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>；</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>60</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">60\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n\leq 5 \times 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> ；</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1 \le n\leq 3\times 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1\leq a_i\leq 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> <strong>思路</strong></h3><p>找到a[i]右边第一个比他大的数的下标，也就是说对于栈中的元素来说，栈顶元素小于等于a[i]的数要不断出栈，直到遇到栈顶元素大于a[i]，此时栈顶的元素就是第一个比a[i]大的数。</p><ul><li>一般找a[i]右边比他大的数，要从右向左遍历</li><li>a[i]左边比他大的数，要从左向右遍历</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> <strong>代码：</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3</span>*<span class="hljs-number">1e6</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> a[N];<br>stack&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cin&gt;&gt;a[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;--i)<br>&#123;<br><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]&gt;a[st.<span class="hljs-built_in">top</span>()])<br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>())<br>f[i]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>f[i]=st.<span class="hljs-built_in">top</span>();<br>st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cout&lt;&lt;f[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="柱状图中最大的矩形"><a class="markdownIt-Anchor" href="#柱状图中最大的矩形"></a> 柱状图中最大的矩形</h2><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>e.g.</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：heights = <span class="hljs-string">[2,1,5,6,2,3]</span><br>输出：<span class="hljs-number">10</span><br>解释：最大的矩形为图中红色区域，面积为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>这道题实际上需要找出<code>heights[i]</code>左侧和右侧第一个小于他的数，因此要分别记录左右两侧第一个小于heights[i]的数的下标。然后以<code>heights[i]</code>为高的矩形面积就为<code>(right[i]-left[i]-1)*heights[i]</code><br /><code>left[i]和right[i]</code>与上一道例题类似，当栈顶元素大于heights[i]要不断出栈，直到栈顶元素小于heights[i]，分别向左向右遍历并更新两个单调栈即可。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> largestRectangleArea(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights) &#123;<br>        <span class="hljs-keyword">int</span> n=heights.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; left(n),right(n);<span class="hljs-comment">//记录左侧和右侧第一个比他小的数</span><br>        stack&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">ls</span>,rs;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">ls</span>.empty()&amp;&amp;heights[<span class="hljs-keyword">ls</span>.top()]&gt;=heights[i])<br>                <span class="hljs-keyword">ls</span>.pop();<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">ls</span>.empty())<br>                left[i]=<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left[i]=<span class="hljs-keyword">ls</span>.top();<br>            <span class="hljs-keyword">ls</span>.push(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!rs.empty()&amp;&amp;heights[rs.top()]&gt;=heights[i])<br>                rs.pop();<br>            <span class="hljs-keyword">if</span>(rs.empty())<br>                right[i]=n;<br>            <span class="hljs-keyword">else</span><br>                right[i]=rs.top();<br>            rs.push(i);<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            ans=<span class="hljs-keyword">max</span>(ans,(right[i]-left[i]<span class="hljs-number">-1</span>)*heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="接雨水"><a class="markdownIt-Anchor" href="#接雨水"></a> 接雨水</h2><p><a href="https://leetcode.cn/problems/trapping-rain-water/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> <strong>题目描述</strong></h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>输入输出</strong><br />第一行输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>表示柱子数量<br />第二行输入n个数<br />输出最多能接多少雨水</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">6</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">9<br></code></pre></td></tr></table></figure><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> <strong>代码</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> a[N];<br>stack&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cin&gt;&gt;a[i];<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]&gt;a[st.<span class="hljs-built_in">top</span>()])<br>        &#123;<br>            <span class="hljs-type">int</span> idx=st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>())<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">int</span> l=st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-type">int</span> h=<span class="hljs-built_in">min</span>(a[i],a[l])-a[idx];<br>            <span class="hljs-type">int</span> w=i-l<span class="hljs-number">-1</span>;<br>            ans+=w*h;<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归</title>
    <link href="/2022/09/11/%E9%80%92%E5%BD%92/"/>
    <url>/2022/09/11/%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98">汉诺塔问题</a></li><li><a href="#2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9">2的幂次方</a></li></ul><!-- /TOC --><h3 id="汉诺塔问题"><a class="markdownIt-Anchor" href="#汉诺塔问题"></a> 汉诺塔问题</h3><blockquote><p>汉诺塔问题的种类非常多，这里就写一下最最基础的那个吧</p></blockquote><p>问题描述</p><p>有<code>n</code>个大小不一的圆盘和 a,b,c 三根柱子，初始时n个盘子全在a上，现在要将他们移动到c上</p><ul><li>一次只能移动1个柱子</li><li>大盘子不能在小盘子上面</li></ul><p>input:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">to</span> c<br>move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">b</span><br>move <span class="hljs-selector-tag">from</span> c <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">b</span><br>move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">to</span> c<br>move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">a</span><br>move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">to</span> c<br>move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">to</span> c<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">char</span> a,<span class="hljs-type">char</span> b,<span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;move from &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; to &quot;</span>&lt;&lt;c&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">move</span>(x<span class="hljs-number">-1</span>,a,c,b);<br>cout&lt;&lt;<span class="hljs-string">&quot;move from &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; to &quot;</span>&lt;&lt;c&lt;&lt;endl;<br><span class="hljs-built_in">move</span>(x<span class="hljs-number">-1</span>,b,a,c);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-type">char</span> a=<span class="hljs-string">&#x27;a&#x27;</span>,b=<span class="hljs-string">&#x27;b&#x27;</span>,c=<span class="hljs-string">&#x27;c&#x27;</span>;<br><span class="hljs-built_in">move</span>(n,a,b,c);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2的幂次方"><a class="markdownIt-Anchor" href="#2的幂次方"></a> 2的幂次方</h3><p><strong>题目描述</strong></p><p>任何一个正整数都可以用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的幂次方表示。</p><p>例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>137</mn><mo>=</mo><msup><mn>2</mn><mn>7</mn></msup><mo>+</mo><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">137= 2^7 + 2^3 + 2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>。</p><p>同时约定方次用括号来表示，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">a^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span> 可表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>。</p><p>由此可知，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>137</mn></mrow><annotation encoding="application/x-tex">137</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">7</span></span></span></span> 可表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(7)+2(3)+2(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></p><p>进一步：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>=</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>2</mn><mo>+</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">7= 2^2+2+2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>  ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span> 用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 表示)，并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>=</mo><mn>2</mn><mo>+</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">3=2+2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>。</p><p>所以最后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>137</mn></mrow><annotation encoding="application/x-tex">137</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">7</span></span></span></span> 可表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(2(2)+2+2(0))+2(2+2(0))+2(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>。</p><p>又如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1315</mn><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mo>+</mo><msup><mn>2</mn><mn>8</mn></msup><mo>+</mo><msup><mn>2</mn><mn>5</mn></msup><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1315=2^{10} +2^8 +2^5 +2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1315</mn></mrow><annotation encoding="application/x-tex">1315</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span></span></span></span> 最后可表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>。</p><p><strong>输入格式</strong></p><p>一行一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>符合约定的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">0, 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span></span> 表示（在表示中不能有空格）。</p><p>input：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1315</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>(<span class="hljs-number">2</span>(<span class="hljs-number">2</span>+<span class="hljs-number">2</span>(<span class="hljs-number">0</span>))+<span class="hljs-number">2</span>)+<span class="hljs-number">2</span>(<span class="hljs-number">2</span>(<span class="hljs-number">2</span>+<span class="hljs-number">2</span>(<span class="hljs-number">0</span>)))+<span class="hljs-number">2</span>(<span class="hljs-number">2</span>(<span class="hljs-number">2</span>)+<span class="hljs-number">2</span>(<span class="hljs-number">0</span>))+<span class="hljs-number">2</span>+<span class="hljs-number">2</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>思路</p><blockquote><p>先找出当前数最大的次方，然后递归的对这个数分解，继续递归分解剩下的数</p></blockquote><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxm</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n)<br>&#123;<br>++k;<br>n/=<span class="hljs-number">2</span>;<br>&#125;<br>--k;<br><span class="hljs-keyword">return</span> k;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dg</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> mm=<span class="hljs-built_in">maxm</span>(n);<br><span class="hljs-keyword">if</span>(mm==<span class="hljs-number">1</span>)<br>cout&lt;&lt;<span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;2(&quot;</span>;<br><span class="hljs-keyword">if</span>(mm==<span class="hljs-number">0</span>)<br>cout&lt;&lt;<span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">dg</span>(mm);<br>cout&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br>n=n-<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,mm);<br><span class="hljs-keyword">if</span>(n) <br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&#x27;+&#x27;</span>;<br><span class="hljs-built_in">dg</span>(n);<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-built_in">dg</span>(n);<br>cout&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>贪心</title>
    <link href="/2022/09/08/%E8%B4%AA%E5%BF%83/"/>
    <url>/2022/09/08/%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BE%8B%E9%A2%98to-fill-or-not-to-fill">例题：To Fill or Not to Fill</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E9%A2%98%E8%A7%A3">题解</a></li></ul><!-- /TOC --><blockquote><p>贪心的基本思想是，每一步都求出局部最有解，从而来求得可能的全局最优解，但是这种方式求得的全局的解并不一定是全局最优的</p></blockquote><h3 id="例题to-fill-or-not-to-fill"><a class="markdownIt-Anchor" href="#例题to-fill-or-not-to-fill"></a> 例题：To Fill or Not to Fill</h3><p><strong>题目描述</strong></p><p>With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.</p><p><strong>输入描述</strong></p><p>For each case, the first line contains 4 positive numbers: Cmax (&lt;= 100), the maximum capacity of the tank; D (&lt;=30000), the distance between Hangzhou and the destination city; Davg (&lt;=20), the average distance per unit gas that the car can run; and N (&lt;= 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: Pi, the unit gas price, and Di (&lt;=D), the distance between this station and Hangzhou, for i=1,…N. All the numbers in a line are separated by a space.</p><p><strong>输出描述</strong></p><p>For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print “The maximum travel distance = X” where X is the maximum possible distance the car can run, accurate up to 2 decimal places.</p><p>input：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">50</span> <span class="hljs-number">1300</span> <span class="hljs-number">12</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">6</span>.<span class="hljs-number">00</span> <span class="hljs-number">1250</span><br><span class="hljs-attribute">7</span>.<span class="hljs-number">00</span> <span class="hljs-number">600</span><br><span class="hljs-attribute">7</span>.<span class="hljs-number">00</span> <span class="hljs-number">150</span><br><span class="hljs-attribute">7</span>.<span class="hljs-number">10</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">7</span>.<span class="hljs-number">20</span> <span class="hljs-number">200</span><br><span class="hljs-attribute">7</span>.<span class="hljs-number">50</span> <span class="hljs-number">400</span><br><span class="hljs-attribute">7</span>.<span class="hljs-number">30</span> <span class="hljs-number">1000</span><br><span class="hljs-attribute">6</span>.<span class="hljs-number">85</span> <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">749</span>.<span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>将所有加油站油价按升序排序，让油价最便宜的加油站尽可能加更多的油，维护一个数组<code>dis[]</code>来记录距离，同时需要注意低油价覆盖过的距离不可再次被覆盖</p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">st</span><br>&#123;<br>    <span class="hljs-type">double</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-built_in">st</span>():<span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">b</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>    <span class="hljs-built_in">st</span>(<span class="hljs-type">double</span> aa,<span class="hljs-type">int</span> bb):<span class="hljs-built_in">a</span>(aa),<span class="hljs-built_in">b</span>(bb)&#123;&#125;<br>&#125;sta[<span class="hljs-number">501</span>];<br><span class="hljs-type">int</span> dis[<span class="hljs-number">30001</span>];<br><span class="hljs-type">int</span> cmax,d,davg,n,di;<br><span class="hljs-type">double</span> pi;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> func=[](st&amp; a,st&amp; b)&#123;<br>        <span class="hljs-keyword">if</span>(a.a!=b.a)<br>            <span class="hljs-keyword">return</span> a.a&lt;b.a;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> a.b&lt;b.b;<br>    &#125;;<br>    cin&gt;&gt;cmax&gt;&gt;d&gt;&gt;davg&gt;&gt;n; <br><span class="hljs-built_in">memset</span>(sta,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(sta));<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>    &#123;<br>           cin&gt;&gt;pi&gt;&gt;di;<br>           sta[i]=<span class="hljs-built_in">st</span>(pi,di);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(sta,sta+n,func);<br>    <span class="hljs-type">int</span> maxlen=cmax*davg;<br>    <span class="hljs-type">double</span> cost=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>    &#123;<br>    <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(sta[i].b+maxlen&lt;d)<br>        len=maxlen;<br>        <span class="hljs-keyword">else</span><br>            len=d-sta[i].b;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=sta[i].b;j&lt;sta[i].b+len;++j)<br>&#123;<br>        <span class="hljs-keyword">if</span>(dis[j]==<span class="hljs-number">0</span>)<br>&#123;<br>                dis[j]=<span class="hljs-number">1</span>;<br>                ++cnt;<br>            &#125;<br>        &#125;<br>        cost+=(<span class="hljs-type">double</span>)cnt/davg*sta[i].a;<br>    &#125;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;d;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dis[i]==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The maximum travel distance = %d.00\n&quot;</span>,i);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i==d)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f\n&quot;</span>,cost);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大子矩阵</title>
    <link href="/2022/09/01/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/09/01/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul><!-- /TOC --><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>矩阵的大小定义为矩阵中所有元素的和，现在给定一个n维矩阵，输出他的最大子矩阵</p><p>输入：第一行输入n，表示矩阵的维数，随后输入n×n的矩阵</p><p>input:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">4<br>0 <span class="hljs-string">-2</span> <span class="hljs-string">-7</span> 0<br>9 2 <span class="hljs-string">-6</span> 2<br><span class="hljs-string">-4</span> 1 <span class="hljs-string">-4</span>  1<br><span class="hljs-string">-1</span> 8  0 <span class="hljs-string">-2</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">15<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题可以说是矩阵版的<em>最大连续子序列的和</em>，为了减少时间复杂度，将矩阵每个元素变成所在列的前缀和，如<code>s[i][j]</code>表示第<code>j</code>列前<code>i</code>个元素的和，然后按照一维的方式求最大和就好了</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>const int <span class="hljs-attribute">N</span>=105;<br>int <span class="hljs-attribute">inf</span>=-1e6;<br>int s[N][N];<br>int main()<br>&#123;<br>    int n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=1;j&lt;=n;++j)<br>        &#123;<br>            cin&gt;&gt;s[i][j];<br>            s[i][j]+=s[i-1][j];<br>        &#125;<br>    &#125;<br>    int <span class="hljs-attribute">ans</span>=inf;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=i;j&lt;=n;++j)<br>        &#123;<br>            int <span class="hljs-attribute">pre</span>=inf;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">col</span>=1;col&lt;=n;++col)<br>            &#123;<br>                int <span class="hljs-attribute">t</span>=s[j][col]-s[i-1][col];<br>                <span class="hljs-attribute">pre</span>=max(pre+t,t);<br>                <span class="hljs-attribute">ans</span>=max(ans,pre);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常见排序算法</title>
    <link href="/2022/08/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/08/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li><li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li><li><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8Fradix-sort">基数排序（Radix Sort)</a></li><li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li><li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fmerge-sort">归并排序（Merge Sort）</a></li><li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li><li><a href="#%E6%A1%B6%E6%8E%92%E5%BA%8Fbucket-sort">桶排序（Bucket Sort）</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li></ul><!-- /TOC --><blockquote><p>这篇博客主要总结一下常见排序算法及其时间复杂度</p></blockquote><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好</th><th style="text-align:center">最差</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">插入排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">不稳定</td></tr></tbody></table><h3 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h3><blockquote><p>每次选择一个元素，并且将这个元素和前面元素进行比较，然后插入到合适的位置</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">void <span class="hljs-keyword">insert_sort(int </span>arr[], int length)<br>&#123;<br>    int i,<span class="hljs-keyword">j;</span><br><span class="hljs-keyword"></span>    for (i = <span class="hljs-number">1</span><span class="hljs-comment">; i &lt; length; i++) &#123;</span><br>        int tmp = arr[i];<br>        for (<span class="hljs-keyword">j </span>= i<span class="hljs-comment">; j &gt; 0 &amp;&amp; arr[j - 1] &gt; tmp; j--) &#123;</span><br>            arr[<span class="hljs-keyword">j] </span>= arr[<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>];<br>        &#125;<br>        arr[<span class="hljs-keyword">j] </span>= tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h3><blockquote><p>插入排序的升级版，初始间隔<em>gap</em>为元素数目的一般，每次间隔<em>gap</em>个元素进行插入排序，直到gap为1</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> shellSort(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n) <br>&#123; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap = n/<span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) <br>    &#123; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; i += <span class="hljs-number">1</span>) <br>        &#123; <br>            <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = arr[i]; <br>            <span class="hljs-type">int</span> j;             <br>            <span class="hljs-keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; <span class="hljs-keyword">temp</span>; j -= gap) <br>                arr[j] = arr[j - gap]; <br>            arr[j] = <span class="hljs-keyword">temp</span>; <br>        &#125; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基数排序radix-sort"><a class="markdownIt-Anchor" href="#基数排序radix-sort"></a> 基数排序（Radix Sort)</h3><blockquote><p>将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程是将所有待比较数值统一为同样的数位长度，数位较短的数前面补零，然后从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p></blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> getMax(<span class="hljs-built_in">int</span> arr[], <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) <br>&#123; <br>    <span class="hljs-built_in">int</span> mx = arr[<span class="hljs-number">0</span>]; <br>    for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">n</span>; i++) <br>        <span class="hljs-built_in">if</span> (arr[i] &gt; mx) <br>            mx = arr[i]; <br>    return mx; <br>&#125; <br><br>void countSort(<span class="hljs-built_in">int</span> arr[], <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">exp</span>) <br>&#123; <br>    <span class="hljs-built_in">int</span> output[<span class="hljs-built_in">n</span>]; <br>    <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">count</span>[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;; <br>  <br>    for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i++) <br>        <span class="hljs-built_in">count</span>[ (arr[i]/<span class="hljs-built_in">exp</span>)%<span class="hljs-number">10</span> ]++; <br>  <br>    for (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) <br>        <span class="hljs-built_in">count</span>[i] += <span class="hljs-built_in">count</span>[i - <span class="hljs-number">1</span>]; //此时<span class="hljs-built_in">count</span>[i]每位数字存放的位置，实际下标还要-<span class="hljs-number">1</span><br>  <br>    for (i = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) //从后往前保证稳定性<br>    &#123; <br>        output[<span class="hljs-built_in">count</span>[ (arr[i]/<span class="hljs-built_in">exp</span>)%<span class="hljs-number">10</span> ] - <span class="hljs-number">1</span>] = arr[i]; <br>        <span class="hljs-built_in">count</span>[ (arr[i]/<span class="hljs-built_in">exp</span>)%<span class="hljs-number">10</span> ]--; <br>    &#125; <br>  <br>    for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i++) <br>        arr[i] = output[i]; <br>&#125; <br>  <br>void radixsort(<span class="hljs-built_in">int</span> arr[], <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) <br>&#123; <br>    <span class="hljs-built_in">int</span> m = getMax(arr, <span class="hljs-built_in">n</span>); <br>    for (<span class="hljs-built_in">int</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">1</span>; m/<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">0</span>; <span class="hljs-built_in">exp</span> *= <span class="hljs-number">10</span>) <br>        countSort(arr, <span class="hljs-built_in">n</span>, <span class="hljs-built_in">exp</span>); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3><blockquote><p>每次比较相邻两个元素大小，然后交换位置，每次将最大或最小的元素放到最后</p></blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs excel">void bubblesort(<span class="hljs-built_in">int</span> arr[],<span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span>)<br>&#123;<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>-<span class="hljs-number">1</span>;++i)<br>&#123;<br>for( <span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">len</span>-i-<span class="hljs-number">1</span>;++j)<br>&#123;<br><span class="hljs-built_in">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>=arr[j];<br>arr[j]=arr[j+<span class="hljs-number">1</span>];<br>arr[j+<span class="hljs-number">1</span>]=<span class="hljs-built_in">t</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序merge-sort"><a class="markdownIt-Anchor" href="#归并排序merge-sort"></a> 归并排序（Merge Sort）</h3><blockquote><p>主要思想是分治（Divide and Conquer），将数组不断分成两个部分，对分开的部分比较然后拼接</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> merge(<span class="hljs-built_in">int</span> arr[], <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> m, <span class="hljs-built_in">int</span> r) <br>&#123; <br>    <span class="hljs-built_in">int</span> i, j, k; <br>    <span class="hljs-built_in">int</span> n1 = m - l + <span class="hljs-number">1</span>; <br>    <span class="hljs-built_in">int</span> n2 =  r - m; <br><br>    <span class="hljs-built_in">int</span> L[n1], R[n2]; <br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n1; i++) <br>        L[i] = arr[l + i]; <br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n2; j++) <br>        R[j] = arr[m + <span class="hljs-number">1</span>+ j]; <br><br>    i = <span class="hljs-number">0</span>; <br>    j = <span class="hljs-number">0</span>; <br>    k = l; <br>    <span class="hljs-keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) <br>    &#123; <br>        <span class="hljs-keyword">if</span> (L[i] &lt;= R[j]) <br>        &#123; <br>            arr[k] = L[i]; <br>            i++; <br>        &#125; <br>        <span class="hljs-keyword">else</span><br>        &#123; <br>            arr[k] = R[j]; <br>            j++; <br>        &#125; <br>        k++; <br>    &#125; <br>  <br>    <span class="hljs-keyword">while</span> (i &lt; n1) <br>    &#123; <br>        arr[k] = L[i]; <br>        i++; <br>        k++; <br>    &#125; <br>  <br>    <span class="hljs-keyword">while</span> (j &lt; n2) <br>    &#123; <br>        arr[k] = R[j]; <br>        j++; <br>        k++; <br>    &#125; <br>&#125; <br>  <br><span class="hljs-built_in">void</span> mergeSort(<span class="hljs-built_in">int</span> arr[], <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r) <br>&#123; <br>    <span class="hljs-keyword">if</span> (l &lt; r) <br>    &#123; <br>        <span class="hljs-built_in">int</span> m = l+r&gt;&gt;<span class="hljs-number">1</span>; <br>        mergeSort(arr, l, m); <br>        mergeSort(arr, m+<span class="hljs-number">1</span>, r); <br>        merge(arr, l, m, r); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3><blockquote><p>主要是建立小顶堆或者大顶堆，排序的时候，每次取出堆顶元素，然后剩下元素重新建堆，<s>建堆可以直接用STL的make_heap()😄</s></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i)</span> <br>&#123; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxv</span> <span class="hljs-operator">=</span> i; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>*i + <span class="hljs-number">2</span>; <br>    <span class="hljs-keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[maxv]) <br>        maxv = l; <br>    <span class="hljs-keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[maxv]) <br>        maxv = r; <br>    <span class="hljs-keyword">if</span> (maxv != i) <br>    &#123; <br>        swap(arr[i], arr[maxv]); <br>        heapify(arr, n, maxv); <br>    &#125; <br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">heapsort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> len)</span><br>&#123;<br>    <span class="hljs-comment">//建堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        heapify(arr,len;i);<br>    <span class="hljs-comment">//排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>    &#123;<br>        swap(arr[i],a[<span class="hljs-number">0</span>]);<span class="hljs-comment">//堆顶放到最后</span><br>        heapify(arr,i,<span class="hljs-number">0</span>);<span class="hljs-comment">//重新调整</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="桶排序bucket-sort"><a class="markdownIt-Anchor" href="#桶排序bucket-sort"></a> 桶排序（Bucket Sort）</h3><blockquote><p>将数组分到有限数量的桶中，再对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。</p></blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs excel">\\该代码只适合正数数组的排序<br>void bucketSort(float arr[], <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) <br>&#123; <br>    vector&lt;float&gt; b[<span class="hljs-built_in">n</span>]; <br><br>    for (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">n</span>; i++) <br>    &#123; <br>       <span class="hljs-built_in">int</span> bi = <span class="hljs-built_in">n</span>*arr[i]; <br>       b[bi].push_back(arr[i]); <br>    &#125; <br>    for (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">n</span>; i++) <br>       sort(b[i].begin(), b[i].end()); <br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">index</span> = <span class="hljs-number">0</span>; <br>    for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i++) <br>        for (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; b[i].size(); j++) <br>          arr[<span class="hljs-built_in">index</span>++] = b[i][j]; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3><blockquote><p>核心思想也是分治，每次选择一个pivot(一般选第一个)，设置左右端点两个指针，每一趟调整将比pivot元素小的值放到左指针位置，比pivot元素大的值放到位置，这样左半部分就小于右半部分，然后递归，分别对左右两个部分进行快排</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> adjust(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)<br>&#123;<br><span class="hljs-type">int</span> t=arr[l];<br><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br><span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;arr[r]&gt;=t)<br><span class="hljs-comment">--r;</span><br>arr[l]=arr[r];<br><span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;arr[l]&lt;=t)<br>++l;<br>arr[r]=arr[l];<br>&#125;<br>arr[l]=t;<br><span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-type">void</span> quicksort(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)<br>&#123;<br><span class="hljs-keyword">if</span>(l&lt;r)<br>&#123;<br><span class="hljs-type">int</span> pos=adjust(arr,l,r);<br>quicksort(arr,l,pos);<br>quicksort(arr,pos+<span class="hljs-number">1</span>,r);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日期计算</title>
    <link href="/2022/08/29/%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97/"/>
    <url>/2022/08/29/%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>先来看一道题</p><p>输入一年中的一天，输出这一天是星期几</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">14 </span>October <span class="hljs-number">2001</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Sunday</span><br></code></pre></td></tr></table></figure><p>用以下公式计算天数：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi>X</mi><mo>−</mo><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>4</mn><mo>−</mo><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>100</mn><mo>+</mo><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>400</mn><mo>+</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">S=X-1+(X-1)/4-(X-1)/100+(X-1)/400+C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></p><p>其中，<code>X</code>是年份，<code>C</code>表示这一天是这一年的第<code>C</code>天</p><p>计算出<code>S</code>后用<code>S%7</code>判断星期几即可</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// S=X-1+(X-1)/4-(X-1)/100+(X-1)/400+C</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isrun</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;n%<span class="hljs-number">100</span>||n%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> d,y;<br>    string m;<br>    vector&lt;pair&lt;string,<span class="hljs-type">int</span>&gt;&gt; mon=&#123;&#123;<span class="hljs-string">&quot;January&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;February&quot;</span>,<span class="hljs-number">28</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;March&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;April&quot;</span>,<span class="hljs-number">30</span>&#125;,&#123;<span class="hljs-string">&quot;May&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;June&quot;</span>,<span class="hljs-number">30</span>&#125;,&#123;<span class="hljs-string">&quot;July&quot;</span>,<span class="hljs-number">31</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;August&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;September&quot;</span>,<span class="hljs-number">30</span>&#125;,&#123;<span class="hljs-string">&quot;October&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;November&quot;</span>,<span class="hljs-number">30</span>&#125;,<br>                                  &#123;<span class="hljs-string">&quot;December&quot;</span>,<span class="hljs-number">31</span>&#125;&#125;;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;d&gt;&gt;m&gt;&gt;y)<br>    &#123;<br>        <span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isrun</span>(y))<br>            flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=mon.<span class="hljs-built_in">begin</span>();it!=mon.<span class="hljs-built_in">end</span>();++it)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(it-&gt;first!=m)   <br>                sum+=it-&gt;second;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        sum=sum+d+flag;<br>        <span class="hljs-type">int</span> s=y<span class="hljs-number">-1</span>+(y<span class="hljs-number">-1</span>)/<span class="hljs-number">4</span>-(y<span class="hljs-number">-1</span>)/<span class="hljs-number">100</span>+(y<span class="hljs-number">-1</span>)/<span class="hljs-number">400</span>+sum;<br>        <span class="hljs-keyword">switch</span>(s%<span class="hljs-number">7</span>)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Sunday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Monday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Tuesday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Wednesday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Thursday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Friday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Saturday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="/2022/08/27/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/08/27/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BA%BF%E6%AE%B5%E6%A0%91">线段树</a><ul><li><a href="#%E9%80%92%E5%BD%92%E5%BB%BA%E6%A0%91">递归建树</a></li></ul></li><li><a href="#%E7%B1%BB%E5%9E%8B%E4%B8%80%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">类型一：单点修改，区间查询</a><ul><li><a href="#%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9">单点修改</a></li><li><a href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">区间查询</a></li><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li></ul></li><li><a href="#%E7%B1%BB%E5%9E%8B%E4%BA%8C%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2">类型二：区间修改，单点查询</a><ul><li><a href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9">区间修改</a></li><li><a href="#%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2">单点查询</a></li><li><a href="#%E4%BE%8B%E9%A2%98-1">例题</a></li></ul></li><li><a href="#%E7%B1%BB%E5%9E%8B%E4%B8%89-%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">类型三： 区间修改，区间查询</a><ul><li><a href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9-1">区间修改</a></li><li><a href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2-1">区间查询</a></li><li><a href="#%E4%BE%8B%E9%A2%98-2">例题</a></li></ul></li></ul><!-- /TOC --><h3 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h3><blockquote><p>能把对区间的修改、查询的时间复杂度由 O(n) 变为 O(logn)</p></blockquote><p>线段树实际上也是一种二叉树，每个节点用一个结构体<code>node</code>保存</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">node</span><br><span class="hljs-title">&#123;</span><br><span class="hljs-title">int</span> l,r,sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>l</code>和<code>r</code>表示线段的左右端点，<code>sum</code>表示线段的和</p><p>如果用数组存储，一棵二叉树，左孩子下标为<code>2*i</code>，右孩子下标为<code>2*i+1</code><br />因此，每一个节点的<code>sum</code>值为：<code>tree[i].sum=tree[2*i].sum+tree[2*i+1].sum</code></p><h4 id="递归建树"><a class="markdownIt-Anchor" href="#递归建树"></a> 递归建树</h4><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">void</span> build(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)<br>&#123;<br><span class="hljs-comment">//i:当前节点编号 l:左端点 r:右端点 </span><br>tree[i].l=l;<br>tree[i].r=r;<br><span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><br><span class="hljs-keyword">if</span>(l==r)<br>&#123;<br>tree[i].<span class="hljs-built_in">sum</span>=<span class="hljs-type">array</span>[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>build(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span><br>build(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span><br><span class="hljs-comment">//更新线段和 </span><br>tree[i].<span class="hljs-built_in">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-built_in">sum</span>+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-built_in">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型一单点修改区间查询"><a class="markdownIt-Anchor" href="#类型一单点修改区间查询"></a> 类型一：单点修改，区间查询</h3><p>单点修改：给第<code>idx</code>个数加<code>k</code><br />区间查询：输出区间[x,y]内所有数的和</p><h4 id="单点修改"><a class="markdownIt-Anchor" href="#单点修改"></a> 单点修改</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> mod1(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> idx,<span class="hljs-built_in">int</span> k)<br>&#123;<br><span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>+=k;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(idx&lt;=mid)<br>mod1(<span class="hljs-number">2</span>*i,idx,k);<br><span class="hljs-keyword">else</span><br>mod1(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,idx,k);<br><span class="hljs-comment">//更新线段和</span><br>tree[i].<span class="hljs-keyword">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span>+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="区间查询"><a class="markdownIt-Anchor" href="#区间查询"></a> 区间查询</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//区间查询</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query1</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//如果当前区间完全被查询区间包括，返回当前区间的和 </span><br><span class="hljs-keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)<br><span class="hljs-keyword">return</span> tree[i].sum;<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-comment">//如果左孩子区间与查询区间相交，进入左子树 </span><br><span class="hljs-keyword">if</span>(l&lt;=mid)<br>res+=<span class="hljs-built_in">query1</span>(<span class="hljs-number">2</span>*i,l,r);<br><span class="hljs-comment">//如果右孩子区间与查询区间相交，进入右子树</span><br><span class="hljs-keyword">if</span>(r&gt;mid)<br>res+=<span class="hljs-built_in">query1</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r);<br> <span class="hljs-keyword">return</span> res;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h4><p><a href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1</a></p><p><strong>题目描述</strong></p><p>如题，已知一个数列，你需要进行下面两种操作：</p><ul><li><p>将某一个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span></p></li><li><p>求出某区间每一个数的和</p></li></ul><p><strong>输入格式</strong></p><p>第一行包含两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span></span></span></span>，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个用空格分隔的整数，其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数字表示数列第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 项的初始值。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 行每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个整数，表示一个操作，具体如下：</p><ul><li><p><code>1 x k</code>  含义：将第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></p></li><li><p><code>2 x y</code>  含义：输出区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 内每个数的和</p></li></ul><p><strong>输出格式</strong></p><p>输出包含若干行整数，即为所有操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的结果。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> -<span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">14<br>16<br></code></pre></td></tr></table></figure><p><strong>【数据范围】</strong></p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">1\le m \le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>；<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>70</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">70\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">7</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1\le n,m \le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>；<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1\le n,m \le 5\times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</p><p>ac代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> nums[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> l,r,sum;<br>&#125;tree[<span class="hljs-number">4</span>*N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//i:当前节点编号 l:左端点 r:右端点 </span><br>tree[i].l=l;<br>tree[i].r=r;<br><span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><br><span class="hljs-keyword">if</span>(l==r)<br>&#123;<br>tree[i].sum=nums[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span><br><span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span><br><span class="hljs-comment">//更新线段和 </span><br>tree[i].sum=tree[<span class="hljs-number">2</span>*i].sum+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].sum;<br>&#125;<br><span class="hljs-comment">//单点修改 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mod1</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<br>&#123;<br>tree[i].sum+=k;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(idx&lt;=mid)<br><span class="hljs-built_in">mod1</span>(<span class="hljs-number">2</span>*i,idx,k);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">mod1</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,idx,k);<br><span class="hljs-comment">//更新线段和</span><br>tree[i].sum=tree[<span class="hljs-number">2</span>*i].sum+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].sum;<br>&#125;<br><span class="hljs-comment">//区间查询</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query1</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//如果当前区间完全被查询区间包括，返回当前区间的和 </span><br><span class="hljs-keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)<br><span class="hljs-keyword">return</span> tree[i].sum;<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-comment">//如果左孩子区间与查询区间相交，进入左子树 </span><br><span class="hljs-keyword">if</span>(l&lt;=mid)<br>res+=<span class="hljs-built_in">query1</span>(<span class="hljs-number">2</span>*i,l,r);<br><span class="hljs-comment">//如果右孩子区间与查询区间相交，进入右子树</span><br><span class="hljs-keyword">if</span>(r&gt;mid)<br>res+=<span class="hljs-built_in">query1</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r);<br> <span class="hljs-keyword">return</span> res;<br>&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cin&gt;&gt;nums[i];<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><span class="hljs-type">int</span> op,a,b;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;<br><span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br><span class="hljs-built_in">mod1</span>(<span class="hljs-number">1</span>,a,b);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)<br>cout&lt;&lt;<span class="hljs-built_in">query1</span>(<span class="hljs-number">1</span>,a,b)&lt;&lt;endl;<br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="类型二区间修改单点查询"><a class="markdownIt-Anchor" href="#类型二区间修改单点查询"></a> 类型二：区间修改，单点查询</h3><p>区间修改：给区间<code>[a,b]</code>每个数加k<br />单点查询：查询第<code>x</code>个数的值</p><p>思路：把修改区间所覆盖的区间加k，然后单点查询时从上到下将所有k相加</p><h4 id="区间修改"><a class="markdownIt-Anchor" href="#区间修改"></a> 区间修改</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)<br>&#123;<br><span class="hljs-comment">//完全在区间内，+k </span><br><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>+=k;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-comment">//落在左区间 </span><br><span class="hljs-keyword">if</span>(l&lt;=mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<br><span class="hljs-comment">//落在右区间 </span><br><span class="hljs-keyword">if</span>(r&gt;mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="单点查询"><a class="markdownIt-Anchor" href="#单点查询"></a> 单点查询</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> x)<br>&#123;<br><span class="hljs-comment">//从上到下计算所有k的和 </span><br><span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<br><span class="hljs-keyword">return</span> tree[i].<span class="hljs-keyword">sum</span>;<br><span class="hljs-built_in">int</span> res=tree[i].<span class="hljs-keyword">sum</span>;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid)<br>res+=query(<span class="hljs-number">2</span>*i,x);<br><span class="hljs-keyword">else</span><br>res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,x);<br><span class="hljs-keyword">return</span> res;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h4><p><a href="https://www.luogu.com.cn/problem/P3368">P3368 树状数组 2</a></p><p><strong>题目描述</strong></p><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li><p>将某区间每一个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>；</p></li><li><p>求出某一个数的值。</p></li></ol><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个用空格分隔的整数，其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数字表示数列第 $i $ 项的初始值。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>个整数，表示一个操作，具体如下：</p><p>操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>： 格式：<code>1 x y k</code> 含义：将区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 内每个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>；</p><p>操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>： 格式：<code>2 x</code> 含义：输出第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 个数的值。</p><p><strong>输出格式</strong></p><p>输出包含若干行整数，即为所有操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的结果。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span> -<span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">6<br>10<br></code></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">2</span>;<br><span class="hljs-built_in">int</span> nums[N];<br>struct node<br>&#123;<br><span class="hljs-built_in">int</span> l,r,<span class="hljs-keyword">sum</span>;<br>&#125;tree[<span class="hljs-number">4</span>*N];<br><span class="hljs-keyword">void</span> build(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)<br>&#123;<br>tree[i].l=l;<br>tree[i].r=r;<br>tree[i].<span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>; <br><span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><br><span class="hljs-keyword">if</span>(l==r)<br><span class="hljs-keyword">return</span>; <br><span class="hljs-built_in">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>build(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span><br>build(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span><br>&#125;<br><br><span class="hljs-comment">//区间修改</span><br><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)<br>&#123;<br><span class="hljs-comment">//完全在区间内，+k </span><br><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>+=k;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-comment">//落在左区间 </span><br><span class="hljs-keyword">if</span>(l&lt;=mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<br><span class="hljs-comment">//落在右区间 </span><br><span class="hljs-keyword">if</span>(r&gt;mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);<br>&#125; <br><span class="hljs-comment">//单点查询</span><br><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> x)<br>&#123;<br><span class="hljs-comment">//从上到下计算所有k的和 </span><br><span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<br><span class="hljs-keyword">return</span> tree[i].<span class="hljs-keyword">sum</span>;<br><span class="hljs-built_in">int</span> res=tree[i].<span class="hljs-keyword">sum</span>;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid)<br>res+=query(<span class="hljs-number">2</span>*i,x);<br><span class="hljs-keyword">else</span><br>res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,x);<br><span class="hljs-keyword">return</span> res;<br>&#125; <br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cin&gt;&gt;nums[i];<br>build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><span class="hljs-built_in">int</span> op,a,b,c;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>cin&gt;&gt;op;<br><span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>&#123;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">1</span>,a,b,c);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)<br>&#123;<br>cin&gt;&gt;a;<br>cout&lt;&lt;query(<span class="hljs-number">1</span>,a)+nums[a]&lt;&lt;endl; <br>&#125;<br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>数据规模与约定</strong></p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">N\le8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">M\le10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>；</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>70</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">70\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">7</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">N\le 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">M\le10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>；</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo separator="true">,</mo><mi>M</mi><mo>≤</mo><mn>500000</mn></mrow><annotation encoding="application/x-tex">1 \leq N, M\le 500000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \leq x, y \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，保证任意时刻序列中任意元素的绝对值都不大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>。</p><p>ac代码：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">2</span>;<br><span class="hljs-built_in">int</span> nums[N];<br>struct node<br>&#123;<br><span class="hljs-built_in">int</span> l,r,<span class="hljs-keyword">sum</span>;<br>&#125;tree[<span class="hljs-number">4</span>*N];<br><span class="hljs-keyword">void</span> build(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)<br>&#123;<br>tree[i].l=l;<br>tree[i].r=r;<br>tree[i].<span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>; <br><span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><br><span class="hljs-keyword">if</span>(l==r)<br><span class="hljs-keyword">return</span>; <br><span class="hljs-built_in">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>build(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span><br>build(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span><br>&#125;<br><br><span class="hljs-comment">//区间修改</span><br><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)<br>&#123;<br><span class="hljs-comment">//完全在区间内，+k </span><br><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>+=k;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-comment">//落在左区间 </span><br><span class="hljs-keyword">if</span>(l&lt;=mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<br><span class="hljs-comment">//落在右区间 </span><br><span class="hljs-keyword">if</span>(r&gt;mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);<br>&#125; <br><span class="hljs-comment">//单点查询</span><br><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> x)<br>&#123;<br><span class="hljs-comment">//从上到下计算所有k的和 </span><br><span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<br><span class="hljs-keyword">return</span> tree[i].<span class="hljs-keyword">sum</span>;<br><span class="hljs-built_in">int</span> res=tree[i].<span class="hljs-keyword">sum</span>;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid)<br>res+=query(<span class="hljs-number">2</span>*i,x);<br><span class="hljs-keyword">else</span><br>res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,x);<br><span class="hljs-keyword">return</span> res;<br>&#125; <br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cin&gt;&gt;nums[i];<br>build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><span class="hljs-built_in">int</span> op,a,b,c;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>cin&gt;&gt;op;<br><span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>&#123;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">1</span>,a,b,c);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)<br>&#123;<br>cin&gt;&gt;a;<br>cout&lt;&lt;query(<span class="hljs-number">1</span>,a)+nums[a]&lt;&lt;endl; <br>&#125;<br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="类型三-区间修改区间查询"><a class="markdownIt-Anchor" href="#类型三-区间修改区间查询"></a> 类型三： 区间修改，区间查询</h3><p>需要定义一个懒标记，然后每次修改或查询需要进行<code>pushdown</code></p><p>pushdown步骤：</p><ul><li>当前节点懒标记不为0时，给左右子节点的懒标记加上父亲的懒标记</li><li>更新左右子节点的sum</li><li>父节点的懒标记置0</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">void pushdown(int i)<br>&#123;<br>if(tree<span class="hljs-comment">[i]</span>.lz)<br>&#123;<br>tree<span class="hljs-comment">[2*i]</span>.lz+=tree<span class="hljs-comment">[i]</span>.lz;<br>tree<span class="hljs-comment">[2*i+1]</span>.lz+=tree<span class="hljs-comment">[i]</span>.lz;<br>int mid=tree<span class="hljs-comment">[i]</span>.l+tree<span class="hljs-comment">[i]</span>.r&gt;&gt;1;<br>tree<span class="hljs-comment">[2*i]</span>.sum+=tree<span class="hljs-comment">[i]</span>.lz*(mid-tree<span class="hljs-comment">[i]</span>.l+1);<br>tree<span class="hljs-comment">[2*i+1]</span>.sum+=tree<span class="hljs-comment">[i]</span>.lz*(tree<span class="hljs-comment">[i]</span>.r-mid);<br>tree<span class="hljs-comment">[i]</span>.lz=0;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="区间修改-2"><a class="markdownIt-Anchor" href="#区间修改-2"></a> 区间修改</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)<br>&#123;<br><span class="hljs-comment">//区间被完全包括，更新sum，lz </span><br><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>+=k*(tree[i].r-tree[i].l+<span class="hljs-number">1</span>);<br>tree[i].lz+=k;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>pushdown(i);<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(l&lt;=mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<br><span class="hljs-keyword">if</span>(r&gt;mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);<br><span class="hljs-comment">//更新和</span><br>tree[i].<span class="hljs-keyword">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span> +tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="区间查询-2"><a class="markdownIt-Anchor" href="#区间查询-2"></a> 区间查询</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)<br>&#123;<br>//区间被完全包括，返回<span class="hljs-built_in">sum</span> <br><span class="hljs-built_in">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br>return tree[i].<span class="hljs-built_in">sum</span>;<br>pushdown(i);<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span>=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">if</span>(l&lt;=<span class="hljs-built_in">mid</span>)<br>res+=query(<span class="hljs-number">2</span>*i,l,r);<br><span class="hljs-built_in">if</span>(r&gt;<span class="hljs-built_in">mid</span>)<br>res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r);<br>return res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例题-3"><a class="markdownIt-Anchor" href="#例题-3"></a> 例题</h4><p><a href="https://www.luogu.com.cn/problem/P3372">P3372【模板】线段树 1</a></p><p><strong>题目描述</strong></p><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</li><li>求出某区间每一个数的和。</li></ol><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n, m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span></span></span></span>，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个用空格分隔的整数，其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数字表示数列第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 项的初始值。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 行每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个整数，表示一个操作，具体如下：</p><ol><li><code>1 x y k</code>：将区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x, y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 内每个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</li><li><code>2 x y</code>：输出区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x, y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 内每个数的和。</li></ol><p><strong>输出格式</strong><br />输出包含若干行整数，即为所有操作 2 的结果。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">11<br>8<br>20<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">n \le 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">m \le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>。<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>70</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">70\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">7</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><msup><mn>10</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n \le {10}^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.848448em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">0</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.848448em;"><span style="top:-3.09734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><msup><mn>10</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">m \le {10}^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.848448em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">0</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.848448em;"><span style="top:-3.09734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>。<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \le n, m \le {10}^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.848448em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">0</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.848448em;"><span style="top:-3.09734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</p><p>保证任意时刻数列中所有元素的绝对值之和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>10</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">\le {10}^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.848448em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">0</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.848448em;"><span style="top:-3.09734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>。</p><p>ac代码：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>typedef <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">2</span>;<br><span class="hljs-built_in">int</span> nums[N];<br>struct node<br>&#123;<br>ll l,r,<span class="hljs-keyword">sum</span>,lz;<br>&#125;tree[<span class="hljs-number">4</span>*N];<br><span class="hljs-keyword">void</span> build(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)<br>&#123; <br>tree[i].l=l;<br>tree[i].r=r;<br>tree[i].lz=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><br><span class="hljs-keyword">if</span>(l==r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>=nums[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ll mid=(l+r)/<span class="hljs-number">2</span>;<br>build(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span><br>build(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span><br><span class="hljs-comment">//更新线段和 </span><br>tree[i].<span class="hljs-keyword">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span>+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>;<br>&#125;<br><span class="hljs-keyword">void</span> pushdown(<span class="hljs-built_in">int</span> i)<br>&#123;<br><span class="hljs-keyword">if</span>(tree[i].lz)<br>&#123;<br>tree[<span class="hljs-number">2</span>*i].lz+=tree[i].lz;<br>tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].lz+=tree[i].lz;<br>ll mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br>tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span>+=tree[i].lz*(mid-tree[i].l+<span class="hljs-number">1</span>);<br>tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>+=tree[i].lz*(tree[i].r-mid);<br>tree[i].lz=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)<br>&#123;<br><span class="hljs-comment">//区间被完全包括，更新sum，lz </span><br><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>+=k*(tree[i].r-tree[i].l+<span class="hljs-number">1</span>);<br>tree[i].lz+=k;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>pushdown(i);<br>ll mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(l&lt;=mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<br><span class="hljs-keyword">if</span>(r&gt;mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);<br><span class="hljs-comment">//更新和</span><br>tree[i].<span class="hljs-keyword">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span> +tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>;<br>&#125;<br>ll query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)<br>&#123;<br><span class="hljs-comment">//区间被完全包括，返回sum </span><br><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br><span class="hljs-keyword">return</span> tree[i].<span class="hljs-keyword">sum</span>;<br>pushdown(i);<br>ll mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br>ll res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(l&lt;=mid)<br>res+=query(<span class="hljs-number">2</span>*i,l,r);<br><span class="hljs-keyword">if</span>(r&gt;mid)<br>res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cin&gt;&gt;nums[i];<br>build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><span class="hljs-built_in">int</span> op,a,b,c;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>cin&gt;&gt;op;<br><span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>&#123;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">1</span>,a,b,c);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)<br>&#123;<br>cin&gt;&gt;a&gt;&gt;b;<br>cout&lt;&lt;query(<span class="hljs-number">1</span>,a,b)&lt;&lt;endl;<br>&#125;<br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进制转换与大阶乘</title>
    <link href="/2022/08/27/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%A4%A7%E9%98%B6%E4%B9%98/"/>
    <url>/2022/08/27/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%A4%A7%E9%98%B6%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li></ul></li><li><a href="#%E5%A4%A7%E9%98%B6%E4%B9%98">大阶乘</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-1">题目</a></li></ul></li></ul><!-- /TOC --><h3 id="进制转换"><a class="markdownIt-Anchor" href="#进制转换"></a> 进制转换</h3><blockquote><p>下面的模板可用于36以内进制任意转换</p></blockquote><h4 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h4><p>将M进制的数X转换为N进制的数输出。<br />输入的第一行包括两个整数：M和N(2&lt;=M,N&lt;=36)。<br />下面的一行输入一个数X，X是M进制的数，现在要求你将M进制的数X转换成N进制的数输出。</p><p>input:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">36</span> <span class="hljs-number">9</span><br><span class="hljs-attribute">XYZZA765</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">10374545654665<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">convert</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s,<span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> len=s.size();<br>    <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">string</span> res;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        <span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>,tmp1=<span class="hljs-number">0</span>,tmp2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=i;j&lt;len;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[j]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[j]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>                tmp1=s[j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">else</span><br>                tmp1=s[j]-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">10</span>;<br>            <span class="hljs-built_in">int</span> t=k*a+tmp1;<br>            k=t%b;<br>            tmp2=t/b;<br>            <span class="hljs-keyword">if</span>(tmp2&lt;=<span class="hljs-number">9</span>)<br>                s[j]=tmp2+<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">else</span><br>                s[j]=tmp2<span class="hljs-number">-10</span>+<span class="hljs-string">&#x27;A&#x27;</span>;<br>            <br>        &#125;<br>        <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">9</span>)<br>            res+=k+<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            res+=k<span class="hljs-number">-10</span>+<span class="hljs-string">&#x27;A&#x27;</span>;<br>        <span class="hljs-keyword">while</span>(s[i]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            ++i;<br>    &#125;<br>    reverse(res.begin(),res.end());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> m,n;<br>    <span class="hljs-built_in">string</span> s;<br>    cin&gt;&gt;m&gt;&gt;n;<br>    cin&gt;&gt;s;<br>    cout&lt;&lt;convert(s,m,n)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="大阶乘"><a class="markdownIt-Anchor" href="#大阶乘"></a> 大阶乘</h3><h4 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h4><p>输入一个正整数N，输出N的阶乘<br />N&lt;=1000</p><p>input:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>int a[100000];<br>int main()<br>&#123;<br>    int n;<br>    cin&gt;&gt;n; <br>    int <span class="hljs-attribute">ws</span>=1;<br>    a[0]=1;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=2;i&lt;=n;++i)<br>    &#123;<br>        int <span class="hljs-attribute">k</span>=0;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=0;j&lt;ws;++j)<br>        &#123;<br>            int <span class="hljs-attribute">t</span>=i*a[j]+k;<br>            <span class="hljs-attribute">k</span>=t/10;<br>            a[j]=t%10;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(k)<br>        &#123;<br>            a[ws]=k%10;<br>            k/=10;<br>            ++ws;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=ws-1;i&gt;=0;--i)<br>        cout&lt;&lt;a[i];<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常见问题</title>
    <link href="/2022/08/26/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/26/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#cs%E5%9F%BA%E7%A1%80">CS基础</a><ul><li><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">进程和线程的区别</a></li></ul></li><li><a href="#c">C++</a><ul><li><a href="#c%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97">c++中的static关键字</a></li><li><a href="#c%E6%A8%A1%E6%9D%BF">c++模板</a></li><li><a href="#c%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB">c++深拷贝和浅拷贝的区别</a></li><li><a href="#c%E5%A4%9A%E6%80%81">c++多态</a></li><li><a href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0">虚函数与纯虚函数</a></li><li><a href="#c%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">c++智能指针</a></li><li><a href="#const-%E5%92%8C-volatile%E8%BE%A8%E6%9E%90">const 和 volatile辨析</a></li><li><a href="#null-%E5%92%8C-nullptr%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5nulllptr">NULL 和 nullptr的区别是什么，为什么引入nulllptr？</a></li><li><a href="#git-fetch%E5%92%8Cgit-pull%E7%9A%84%E5%8C%BA%E5%88%AB">git fetch和git pull的区别</a></li><li><a href="#delete%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9F%A5%E9%81%93%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E7%9A%84">delete[]是怎样知道数组长度的？</a></li><li><a href="#%E7%A8%8B%E5%BA%8F%E6%98%AF%E4%BB%8Emain-%E5%87%BD%E6%95%B0%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E5%90%97">程序是从main 函数开始执行的吗？</a></li></ul></li><li><a href="#python">python</a><ul><li><a href="#python%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">python的垃圾回收机制</a></li></ul></li><li><a href="#deep-learning">deep learning</a><ul><li><a href="#%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B">判别模型和生成模型</a></li><li><a href="#%E8%BD%AC%E7%BD%AE%E5%8D%B7%E7%A7%AF%E5%92%8C%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF">转置卷积和空洞卷积</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">数据集不平衡的处理方式</a></li><li><a href="#tensorflow%E5%92%8Cpytorch%E7%9A%84%E5%8C%BA%E5%88%AB">tensorflow和pytorch的区别</a></li><li><a href="#transformer%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81">transformer中的位置编码</a></li><li><a href="#%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%92%8C%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%9A%84%E5%8C%BA%E5%88%AB">自注意力和注意力的区别</a></li><li><a href="#unet%E5%8E%9F%E7%90%86">Unet原理</a></li></ul></li></ul><!-- /TOC --><h1 id="cs基础"><a class="markdownIt-Anchor" href="#cs基础"></a> CS基础</h1><h2 id="进程和线程的区别"><a class="markdownIt-Anchor" href="#进程和线程的区别"></a> 进程和线程的区别</h2><blockquote><p>进程是资源分配的基本单位，线程是资源调度的基本单位(轻量级进程)</p></blockquote><ul><li>多个线程共享地址空间/资源，而进程之间的地址空间/资源是独立的</li><li>一个线程只能属于一个进程，一个进程可以有多个线程</li><li>创建/撤销线程的系统开销明显小于进程</li></ul><h1 id="c"><a class="markdownIt-Anchor" href="#c"></a> C++</h1><h2 id="c中的static关键字"><a class="markdownIt-Anchor" href="#c中的static关键字"></a> c++中的static关键字</h2><p>加载顺序（面向对象）</p><ul><li>静态-&gt;非静态-&gt;构造方法</li><li>父类静态-子类静态-父类非静态-父类构造-子类非静态-子类构造</li></ul><p>静态成员变量(面向对象)</p><ul><li>所有对象共享,不属于某个对象，可以通过类名访问，也可通过对象访问</li><li>在编译阶段分配内存，分配在数据区（全局区）</li><li>类内声明，类外初始化(class::var)</li><li>sizeof不会计算静态成员变量</li></ul><p>静态成员函数(面向对象)</p><ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li><li>不含this指针(不能被实例使用)</li></ul><p>静态全局变量(面向过程)</p><ul><li>在数据区分配内存</li><li>未初始化会自动初始化为0</li><li>整个文件内可见，文件外不可见</li></ul><p>静态局部变量(面向过程)</p><ul><li>在数据区分配内存</li><li>一般在声明处初始化，未初始化会自动初始化为0</li><li>静态局部变量始终驻留在数据区，但他的作用域是局部作用域，当定义它的函数或语句块结束，其作用域随之结束</li></ul><blockquote><p>总结：静态变量具有全局变量的生命周期，但只能作用于自己的作用域。</p></blockquote><hr /><h2 id="c模板"><a class="markdownIt-Anchor" href="#c模板"></a> c++模板</h2><blockquote><p>模板是c++泛型编程的主要使用的技术</p></blockquote><p><strong>函数模板</strong></p><p>创建一个通用的函数，函数返回值类型和形参可以不指定，用一个虚拟的类型来表示</p><p>声明一个模板<code>template&lt;typename T&gt;</code>或者<code>template&lt;class T&gt;</code></p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">double</span> a=<span class="hljs-number">10.5</span>,b=<span class="hljs-number">20.00002</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;自动类型推导&quot;</span>&lt;&lt;endl;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,<span class="hljs-built_in">sum</span>(a,b));<br>cout&lt;&lt;<span class="hljs-string">&quot;显示指定类型&quot;</span>&lt;&lt;endl;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,<span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">double</span>&gt;(a,b));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>注意</p><ul><li>自动推导类型需要推导出一致的类型</li><li>函数模板使用时必须确定<code>T</code>的类型</li><li>普通函数和函数模板都可调用时，先调用普通函数</li><li>如果类型和函数模板更匹配，则优先调用函数模板</li></ul><p><strong>类模板</strong></p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">M</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>T name;<br>M age;<br><span class="hljs-built_in">person</span>(T a,M b):<span class="hljs-built_in">name</span>(a),<span class="hljs-built_in">age</span>(b)&#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;cndh&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>cout&lt;&lt;p.name&lt;&lt;endl;<br>cout&lt;&lt;p.age&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>类模板不能自动推导类型</li><li>类模板可以在模板参数列表中指定默认类型</li><li>类模板中定义的函数在调用时才创建</li></ul><hr /><h2 id="c深拷贝和浅拷贝的区别"><a class="markdownIt-Anchor" href="#c深拷贝和浅拷贝的区别"></a> c++深拷贝和浅拷贝的区别</h2><blockquote><p><strong>浅拷贝</strong> （默认方式）：将原对象的引用直接赋给新对象，只是原对象的一个引用。</p></blockquote><blockquote><p><strong>深拷贝</strong>： 创建一个新的对象，将原对象的各项属性拷贝过来，深拷贝会在堆中额外申请内存来储存数据，当数据成员中有指针时，必须要用深拷贝。</p></blockquote><ul><li>因为申请了新的内存，所以深拷贝改变新对象的属性对原对象没有影响，但是浅拷贝会影响</li><li>当成员中有指针时，必须用深拷贝。因为浅拷贝的新指针和旧指针都指向同一块内存，在新对象和旧对象析构时，已经释放的内存会被再次释放，这时会出现错误。</li></ul><hr /><h2 id="c多态"><a class="markdownIt-Anchor" href="#c多态"></a> c++多态</h2><p>编译时多态：</p><ul><li>编译器多态是通过函数重载和模板实现的。在编译时，根据函数的参数类型或模板参数类型，编译器会选择合适的函数或模板实例化。</li><li>编译器多态是在编译时确定函数调用，因此它的性能较高。</li><li>编译器多态不需要使用虚函数和基类指针或引用，可以直接根据函数的参数类型或模板参数类型来确定函数调用。</li></ul><p>运行时多态：</p><ul><li>运行时多态是通过继承和虚函数实现的。当基类的指针或引用指向派生类对象时，通过虚函数的动态绑定，可以在运行时确定要调用的函数实现。</li><li>运行时多态需要使用虚函数和基类指针或引用来实现，这样可以在运行时根据实际对象的类型来确定调用哪个函数。</li><li>运行时多态在运行时才能确定具体的函数调用，因此它的性能相对较低。</li></ul><p><em><strong>override的作用</strong></em></p><p>保证在派生类中声明的重载函数，与基类的虚函数有相同的签名，核心作用就是用于编译期代码检查。</p><p><em><strong>final</strong></em></p><p>阻止类的进一步派生和虚函数的进一步重写，同时也是一种名为去虚拟化的优化技巧，相当于把运行期多态转换为了编译期多态，提高了执行效率。</p><p><em><strong>多继承存在的问题</strong></em></p><p>命名冲突</p><p><em><strong>向上转型</strong></em></p><p>向上转型是子类指针转换成父类指针</p><p><code>Parent* p =new son();</code></p><p><em><strong>向下转型</strong></em></p><p>因为父类指针不能操作子类独有的函数，即使父类指针指向子类的对象也不行，所以需要向下转型</p><p>向下转型有两种方式<code>dynamic_cast</code>和<code>static_cast</code>,前者更加安全一些</p><p>例如：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">Parent* pS<span class="hljs-keyword">on</span>=new S<span class="hljs-keyword">on</span>();<br>S<span class="hljs-keyword">on</span>* s=dynamic_cast<span class="hljs-variable">&lt;Son*&gt;</span>(pS<span class="hljs-keyword">on</span>);<br></code></pre></td></tr></table></figure><hr /><h2 id="虚函数与纯虚函数"><a class="markdownIt-Anchor" href="#虚函数与纯虚函数"></a> 虚函数与纯虚函数</h2><p><strong>虚函数</strong><br />在类中声明时前面带有virtual关键字的函数，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">example</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>纯虚函数</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">在虚函数后面加`=<span class="hljs-number">0</span>`<br><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">example</span>()</span> = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>虚函数可以在父类中实现，也可以被子类重写实现，是实现运行时多态的方式之一</li><li>纯虚函数不可以在父类实现，必须由子类重写</li><li>含有纯虚函数的类被称为抽象类，抽象类不能实例化</li><li>抽象类的子类如果要实例化，则必须重写纯虚函数</li></ul><p><strong>虚函数怎么实现的？真的更慢吗？</strong></p><ul><li>虚函数是通过虚函数表实现的，每个类都有自己的虚表，对象的首地址处存放有指向虚表的指针。</li><li>当具体调用哪个虚函数可以在编译期间确定的时候，虚函数不一定更慢。</li></ul><h2 id="c智能指针"><a class="markdownIt-Anchor" href="#c智能指针"></a> c++智能指针</h2><p><strong>内存泄漏</strong>：</p><ul><li><p>指因某些原因造成程序未能释放已不再使用的内存。内存泄漏并不是内存消失了，而是由于程序设计的问题，失去对某块内存的控制，导致无法利用该块内存。</p></li><li><p>内存泄漏会导致程序响应越来越慢，甚至崩溃</p></li><li><p>一般有2种内存泄漏，一种是堆区分配的内存没有及时释放，一种是套接字、文件描述符等没有释放，2种情形都会导致资源的浪费</p></li></ul><p><strong>RALL</strong></p><ul><li>RAII（Resource Acquisition Is Initialization）是一种将对象生命周期和资源绑定的技术</li><li>对象创建时获取资源，析构时释放资源</li></ul><p>智能指针就具有RALL的特性</p><p><strong>auto_ptr</strong></p><p>c++98中就已经提供了智能指针auto_ptr</p><p>例如：<code>auto_ptr&lt;int&gt; p(new int)</code>就相当于 <code>int * p=new int</code></p><p>auto_ptr的局限性：</p><ul><li>拷贝或者赋值会导致原指针变为<code>NULL</code>，如<code>p1=p2</code>后，<code>p2变成了NULL</code></li><li>不支持对象数组的内存管理</li></ul><p><strong>unique_ptr</strong></p><p>不能直接进行赋值或者拷贝构造，如：<code>p1 = p2</code>和<code>unique_ptr&lt;int&gt; p1(p2)</code></p><p>如果要强行执行的话要加上<code>move</code>，如：<code>p1 = std::move(p2)</code>和<code>unique_ptr&lt;int&gt; p1(std::move(p2))</code></p><p><strong>shared_ptr</strong></p><p>通过<strong>引用计数</strong>(<code>use_count()</code>)的方式来实现多个<code>shared_ptr</code>对象之间共享资源</p><ul><li>shared_ptr在其内部，给每个资源都有一份计数表，用来记录该份资源被几个指针共享</li><li>在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一</li><li>如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源</li><li>如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了</li></ul><p>注意：两个对象交叉使用<strong>shared_ptr</strong>(互相获得对方的share指针),会导致内存泄漏</p><p><strong>weak_ptr</strong></p><p>专门为了解决上面的<strong>shared_ptr</strong>的问题，不支持RALL，不释放资源，不增加或减少引用计数</p><p>具体参考<a href="https://blog.csdn.net/cpp_learner/article/details/118912592?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166191088916782414982504%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166191088916782414982504&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118912592-null-null.142%5Ev42%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=c%2B%2B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4187">相关链接</a></p><hr /><h2 id="const-和-volatile辨析"><a class="markdownIt-Anchor" href="#const-和-volatile辨析"></a> const 和 volatile辨析</h2><p><strong>const</strong></p><ul><li>被const修饰的变量被视为一个常量，使得变量具有只读属性</li><li>const修饰的变量不是一个真正的只读变量，它只是告诉编译器该变量<strong>不能出现在赋值符号的左边</strong></li></ul><p><em><strong>const修饰指针变量有以下3种情况</strong></em></p><ol><li>const 修饰指针指向的内容，则内容为不可变量。</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const int *p <span class="hljs-operator">=</span> <span class="hljs-number">8</span><span class="hljs-comment">; //指向的内容8不可变</span><br>*p<span class="hljs-operator">=</span><span class="hljs-number">6</span><span class="hljs-comment">; //错误</span><br></code></pre></td></tr></table></figure><ol start="2"><li>const 修饰指针，则指针不可变</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a=<span class="hljs-number">8</span>;<br><span class="hljs-built_in">int</span>* <span class="hljs-keyword">const</span> p = &amp;a;<br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-built_in">int</span>  b = <span class="hljs-number">7</span>;<br>p = &amp;b; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><ol start="3"><li>const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a = <span class="hljs-number">8</span>, b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> * <span class="hljs-keyword">const</span>  p = &amp;a;<br>*p=<span class="hljs-number">1</span>; <span class="hljs-comment">//错误</span><br>p=&amp;b; <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure><p><em><strong>const 修饰对象和成员函数</strong></em></p><ul><li>被const修饰的对象(常对象)或者成员函数(常函数)内不能修改类的成员变量，如果要修改需要给对应的成员变量加mutable关键字</li><li>常对象只能修改常函数</li></ul><p><strong>volatile</strong></p><p>本意为易变的，有以下特点</p><ul><li>volatile指出变量是随时可能变化的，每次使用需要重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。</li><li>被volatile修饰的变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</li></ul><blockquote><p><em><strong>一个变量可以同时被const和volatile修饰吗？</strong></em></p></blockquote><p>可以。const volatile表示一个变量在程序编译期不能被修改且不能被优化；在程序运行期，每次必须从内存中加载变量的值。</p><h2 id="null-和-nullptr的区别是什么为什么引入nulllptr"><a class="markdownIt-Anchor" href="#null-和-nullptr的区别是什么为什么引入nulllptr"></a> NULL 和 nullptr的区别是什么，为什么引入nulllptr？</h2><ul><li>主流编译器中，<code>NULL</code>实际上是一个整数常量，被定义为 0，在 C++11 之前，当我们想要将一个指针初始化为空时，我们通常使用 NULL；</li><li><code>nullptr</code> 是 C++11 中引入的新的关键字，专门用于表示空指针，它不是整数类型，而是特殊的指针类型<code>nullptr_t</code>。</li></ul><p><em><strong>引入nullptr的原因</strong></em></p><ol><li>NULL是整数类型，用户调用foo(NULL)的时候，不能区分调用的是foo(int)还是foo(int*)函数；</li><li>主流编译器中NULL值为0，通过0表示一个无效地址，但是有的架构下，0地址有特定用途，而<code>nullptr</code>指向的永远是一个无效地址。</li></ol><h2 id="git-fetch和git-pull的区别"><a class="markdownIt-Anchor" href="#git-fetch和git-pull的区别"></a> git fetch和git pull的区别</h2><ul><li>git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</li><li>而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</li></ul><blockquote><p>git 连接/添加远程仓库<br />git remote add 仓库名 地址</p></blockquote><h2 id="delete是怎样知道数组长度的"><a class="markdownIt-Anchor" href="#delete是怎样知道数组长度的"></a> delete[]是怎样知道数组长度的？</h2><p>没有标准实现，一种常见的实现方法是，申请内存时，会在返回的指针前面存放这段内存的大小，调用delete[]的时候，就可以知道数组长度了。</p><h2 id="程序是从main-函数开始执行的吗"><a class="markdownIt-Anchor" href="#程序是从main-函数开始执行的吗"></a> 程序是从main 函数开始执行的吗？</h2><p>不是，程序在执行前，会经历一个从磁盘加载程序到内存的过程，这个过程会执行非静态全局变量的初始化。</p><h1 id="python"><a class="markdownIt-Anchor" href="#python"></a> python</h1><h2 id="python的垃圾回收机制"><a class="markdownIt-Anchor" href="#python的垃圾回收机制"></a> python的垃圾回收机制</h2><blockquote><p>python采用的是<strong>引用计数</strong>为主，<strong>标记—清除</strong>和<strong>分代收集</strong>为辅的策略。</p></blockquote><p><strong>引用计数</strong><br />每个对象维护一个字段来记录对象被引用的次数，当新的引用指向该对象的时候，引用计数的值加1,当某个引用失效时，引用计数值减一。当引用计数的值为0时，会释放占用的内存空间。</p><p>缺点：</p><ul><li>需要额外的空间维护引用次数</li><li>对象的循环引用会导致内存泄漏</li></ul><p>引用计数增加的情况：</p><ul><li>对象被创建，例如 a = 23</li><li>对象被引用，例如 b = a</li><li>对象被作为参数，传入到一个函数中，例如 fun(a)</li><li>对象被作为一个元素，存储在容器中</li></ul><p>引用计数减少的情况：</p><ul><li>对象的别名被显式销毁，例如 del a</li><li>对象的别名被赋予新的对象，例如 a = 24</li><li>一个对象离开它的作用域，例如 f 的函数执行完毕时，func函数中的局部变量</li><li>对象所在的容器被销毁，或从容器中删除对象</li></ul><p><strong>分代回收</strong></p><ul><li><p>分代回收是一种以空间换时间的方式，Python将内存根据对象的存活时间划分为不同的集合，每一个集合称为一个代，Python将内存分为了3“代”，分别代表<strong>年轻代</strong>（第0代）、<strong>中年代</strong>（第1代）、<strong>老年代</strong>（第2代），它们对应的是3个链表，它们的垃圾收集频率随着对象的存活时间的增大而减小</p></li><li><p>新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾回收机制就会被触发，把那些可以被回收的对象被回收掉，而那些不会被回收的对象就会被移动到中年代，依次类推， 老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期中。</p></li></ul><p><strong>标记–清除</strong></p><p>是一种基于追踪回收（tracking GC）技术实现的垃圾回收算法。它分为两个阶段：</p><ol><li>标记阶段，GC会把所有的活动对象打上标记</li><li>把那些没有标记的对象（非活动对象）进行回收</li></ol><p><strong>如何判断哪些是活动对象，哪些是非活动对象？</strong></p><p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从跟对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。</p><h1 id="deep-learning"><a class="markdownIt-Anchor" href="#deep-learning"></a> deep learning</h1><h2 id="判别模型和生成模型"><a class="markdownIt-Anchor" href="#判别模型和生成模型"></a> 判别模型和生成模型</h2><p>判别模型：直接学习条件概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(y|x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><br />生成模型：学习联合概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，然后可以计算条件概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(y|x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>以及其他信息，需要的数据量较大</p><p>简单说，要判断一个苹果是好是坏，判别模型会直接给出是好的概率和是坏的概率，而生成模型分别学习出两种苹果各自对应的模型，然后将要预测的苹果的特征分别输入不同模型，然后比较两个模型输出概率的大小，选出合适的类别</p><p>判别模型：</p><ul><li>感知机</li><li>k近邻</li><li>决策树</li><li>逻辑思蒂回归</li><li>svm</li><li>boosting</li><li>最大熵模型</li></ul><p>生成模型：</p><ul><li>朴素贝叶斯</li><li>混合高斯模型</li><li>隐马尔可夫模型</li></ul><h2 id="转置卷积和空洞卷积"><a class="markdownIt-Anchor" href="#转置卷积和空洞卷积"></a> 转置卷积和空洞卷积</h2><p><em><strong>转置卷积</strong></em></p><blockquote><p>在语义分割中，会使用卷积层进行特征提取，然后通过转置卷积做上采样，恢复为原先的尺寸，这样才可以对原来的图像中每个像素都进行分类。<strong>转置卷积不是卷积的逆运算</strong></p></blockquote><p>基本步骤：</p><ul><li>在特征图<strong>中间</strong>(元素和元素之间)填充s-1行，s为步长</li><li>在特征图<strong>四周</strong>填充k-p-1行，k为卷积核大小，p为padding</li><li>将kernel上下、左右翻转（中心对称，顺时针旋转180度）</li><li>做kernel_size不变，s和p均为1的卷积即可</li></ul><p><em><strong>空洞卷积</strong></em></p><ul><li>在卷积核相邻元素之间插入0,具体插入膨胀率(dilation rate)-1个0，然后再做卷积</li><li>主要目的是扩大感受野</li></ul><h2 id="数据集不平衡的处理方式"><a class="markdownIt-Anchor" href="#数据集不平衡的处理方式"></a> 数据集不平衡的处理方式</h2><ol><li>数据增广<ul><li>进行一定的旋转缩放</li><li>RGB三通道提取三张图片</li><li>高斯模糊</li></ul></li><li>人工合成数据</li><li>给每种类别赋予权值，样本少的类别权值可以大一些，样本多的类别权值小一些</li></ol><h2 id="tensorflow和pytorch的区别"><a class="markdownIt-Anchor" href="#tensorflow和pytorch的区别"></a> tensorflow和pytorch的区别</h2><ol><li>tf是谷歌开源的深度学习框架，pytorch是facebook开源的深度学习框架</li><li>在tf1.0时，tf只支持静态的计算图，而pytorch支持动态的计算图，但是tf2.0也支持动态计算图了</li><li>tf的api更详细更丰富，pytorch的代码更简洁</li><li>tf有tensorboard这样的可视化工具，但实际上现在pytorch也能使用tensorboard</li></ol><h2 id="transformer中的位置编码"><a class="markdownIt-Anchor" href="#transformer中的位置编码"></a> transformer中的位置编码</h2><blockquote><p>为什么需要位置编码？</p></blockquote><ul><li>位置和词语的顺序是任何语言的重要组成部分。它们定义了语法，从而决定了句子的实际语义。循环神经网络（RNN）本质上考虑了词语的顺序；它们按照顺序逐个解析句子中的词语。这样可以将词语的顺序整合到RNN的主干中。</li><li>Transformer架构放弃了循环机制，转而采用<strong>多头自注意机制</strong>，大大加快训练时间。从理论上讲，它可以捕捉到句子中更长的依赖关系。由于句子中的<strong>每个词语同时通过Transformer的编码器/解码器，模型本身对于每个词语的位置/顺序没有任何概念。</strong></li></ul><blockquote><p>位置编码的计算？</p></blockquote><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mover accent="true"><msub><mi>p</mi><mi>t</mi></msub><mo stretchy="true">→</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><msup><mo stretchy="false">)</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>:</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>k</mi></msub><mi mathvariant="normal">.</mi><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mtext> </mtext></mrow><mi>i</mi><mo>=</mo><mn>2</mn><mi>k</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>k</mi></msub><mi mathvariant="normal">.</mi><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mtext> </mtext></mrow><mi>i</mi><mo>=</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\left.\overrightarrow{p_t}^{(i)}=f(t)^{(i)}:=\left\{\begin{array}{ll}\sin(\omega_k.t),&amp;\mathrm{if~}i=2k\\\cos(\omega_k.t),&amp;\mathrm{if~}i=2k+1\end{array}\right.\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9525600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span class="svg-align" style="top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.23046em;"><span style="top:-3.40546em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mspace nobreak"> </span></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mspace nobreak"> </span></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中，t代表位置，i代表维度。p代表第t个位置，第i个维度的值。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\omega_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的计算如下：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>ω</mi><mi>k</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1000</mn><msup><mn>0</mn><mrow><mn>2</mn><mi>k</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\omega_k=\frac1{10000^{2k/d}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.0254399999999997em;vertical-align:-0.704em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2960000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.814em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">/</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.704em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>有以下特点：</p><ul><li>奇数维度之间或者偶数维度之间周期不同。</li><li>除了表示绝对位置信息外，还可以很好的表示相对位置信息。给定k,存在一个固定的与k相关的线性变换矩阵，从而由pos的位置编码线性变换而得到pos+k的位置编码。这个相对位置信息可能可以被模型发现而利用。因为绝对位置信息只保证了各个位置不一样，但是并不是像0,1,2这样的有明确前后关系的编码。</li></ul><blockquote><p>CV中使用位置编码</p></blockquote><p>与nlp中类似，cv中的每个像素和patch也有自己的位置信息，通常cv中位置编码有以下两种：</p><ul><li>绝对位置编码：一般是可学习的，实现非常简洁，初始化一个形状和经过patch_embedding后的输出x相同的参数，然后直接加到x上，在训练阶段一起训练，有点像加了一个可学习的bias，VIT中使用的就是这种方式。</li><li>相对位置编码：绝对位置编码是在patch_embedding之后，计算自注意力(Q,K,V)之前，而相对位置编码是在计算自注意力的时候加入的，如下式</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Attention</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>SoftMax</mtext><mo stretchy="false">(</mo><mfrac><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><msqrt><mi>d</mi></msqrt></mfrac><mo>+</mo><mi>B</mi><mo stretchy="false">)</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\text{Attention}(Q,K,V)=\text{SoftMax}(\frac{QK^T}{\sqrt{d}}+B)V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Attention</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.448331em;vertical-align:-0.93em;"></span><span class="mord text"><span class="mord">SoftMax</span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.17778em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.93222em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">d</span></span></span><span style="top:-2.89222em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.10777999999999999em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p><p>在swin transformer中，将二维位置信息转换为一维位置信息，然后去根据相对位置偏移表查询具体的值，位置偏移表的值是训练出来的，在文章中，相对位置编码效果好于绝对位置编码。具体参考<a href="https://blog.csdn.net/qq_43733107/article/details/127077056">这里</a></p><blockquote><p>为什么往往小数据集上卷积效果好于tranformer?</p></blockquote><ul><li>在小数据集上，相比卷积transformer缺少内在偏置，因此需要加入相对位置编码来解决这个问题，而对于特大数据集，transformer就可以学习到卷积的内在偏置，即这也是为什么在小数据集上transformer的效果不如卷积，而在大数据集上，transformer效果优于卷积。</li></ul><h2 id="自注意力和注意力的区别"><a class="markdownIt-Anchor" href="#自注意力和注意力的区别"></a> 自注意力和注意力的区别</h2><p>注意力机制的查询和键是不同来源的，而自注意力机制的查询和键则都是来自于同一组的元素，如对于一张图片，q和k都来自于这张图片的patch或者特征。</p><blockquote><p>个人对于DETR的decoder中的q，k,v的理解</p></blockquote><p>query是每张图设置的预测的proposals的数量，例如一张图的gt有20个bbox，然后query为100，那么网络会产生100个proposals，然后用匈牙利算法求得100个query和20个bbox的最优匹配</p><p>对于decoder的多头注意力，我理解的是kv来自encoder是因为encoder中将图像的特征进行了编码，然后由于需要产生100个proposals，所以就用外部的q来计算encoder产生的k的权重信息，比如qk^T-&gt;[16,100,32]*[16,32,576]=[16,100,576]，这里[100,576]代表了100个query在576个特征上的权重或者相似度信息，然后乘v[16,576,32]，输出是[16,100,32]，reshape为[100,2,256]，encoder的输出[576,2,256]经过decoder后映射为[100,2,256]，因此加入的query可能是为了学习encoder的输出中的特征信息，然后将特征的维度降到100，然后从这100个proposals中取匹配最佳的gt。</p><h2 id="unet原理"><a class="markdownIt-Anchor" href="#unet原理"></a> Unet原理</h2><ul><li>本质是像素级别的分类</li><li>网络呈现<code>U</code>型，左边部分主要是做特征提取，最后得到14*14的特征图，右边是上采样和通道拼接，用转置卷积做上采样，然后与对应shape的特征图做通道维度的concat，最后得到与原图shape相等的输出，输出通道是类别数。</li><li>缺点是计算量大，上采样很难恢复全局信息。</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/08/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/08/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a></li><li><a href="#%E9%80%92%E5%BD%92%E7%9A%84%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9%E7%9A%84%E7%A5%96%E5%85%88">递归的查找节点的祖先</a></li><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li></ul><!-- /TOC --><h3 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h3><blockquote><p>通过一个数组来保存各个节点的祖先，所有连通的节点的祖先相同，常用于解决最小生成树，图的连通性等问题</p></blockquote><h3 id="递归的查找节点的祖先"><a class="markdownIt-Anchor" href="#递归的查找节点的祖先"></a> 递归的查找节点的祖先</h3><p>首先假设有<code>N</code>个节点，定义一个数组<code>vset[N]</code>记录所有节点的祖先，<code>vset[N]初始化为-1</code></p><p>定义一个<code>find</code>函数来查找祖先</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> <span class="hljs-keyword">find</span>(<span class="hljs-keyword">int</span> a)<br>&#123;<br>    <span class="hljs-keyword">if</span>(vset[a]==-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        vset[a]=<span class="hljs-keyword">find</span>(vset[a]);<br>        <span class="hljs-keyword">return</span> vset[a];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p>有<code>n</code>条道路，<code>m</code>个村庄,计算出使所有村庄连通的最低成本</p><p>输入n,m，然后输入n行，每一行输入u,v,w表示两个村庄的编号和道路成本</p><p>输出使所有村庄连通的最低成本</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1000</span>;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; vi;<br><span class="hljs-type">int</span> vset[<span class="hljs-number">1000</span>];<br><span class="hljs-function">vector&lt;vi&gt; <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-number">1000</span>,vi(<span class="hljs-number">3</span>))</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(vset[a]==<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        vset[a]=<span class="hljs-built_in">find</span>(vset[a]);<br>        <span class="hljs-keyword">return</span> vset[a];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(vset,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(vset));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;e[i][<span class="hljs-number">0</span>]&gt;&gt;e[i][<span class="hljs-number">1</span>]&gt;&gt;e[i][<span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(e.<span class="hljs-built_in">begin</span>(),e.<span class="hljs-built_in">end</span>(),[](vi a,vi b)&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>]&lt;b[<span class="hljs-number">2</span>];<br>    &#125;);<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(vi&amp; t: e)<br>    &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">find</span>(t[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> y=<span class="hljs-built_in">find</span>(t[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span>(x!=y)<br>        &#123;<br>            ++cnt;<br>            ans+=t[<span class="hljs-number">2</span>];<br>            vset[x]=y;<br>            <span class="hljs-keyword">if</span>(cnt==n<span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重排链表</title>
    <link href="/2022/08/25/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/08/25/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8">重排链表</a></li><li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">反转链表</a></li><li><a href="#%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8">合并链表</a></li><li><a href="#%E9%A2%98%E8%A7%A3">题解</a></li></ul><!-- /TOC --><h3 id="重排链表"><a class="markdownIt-Anchor" href="#重排链表"></a> 重排链表</h3><blockquote><p>来源于leetcode上的一道题 <a href="https://leetcode.cn/problems/reorder-list/">重排链表</a>，因为这到题涉及到许多链表的知识，正好拿来复习一下</p></blockquote><p>题目描述</p><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：<br /><code>L0 → L1 → … → Ln - 1 → Ln</code></p><p>请将其重新排列后变为：</p><p><code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</code></p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><ul><li>先找到链表的中点</li><li>将链表后半段反转</li><li>将前后两端重新合并</li></ul><h3 id="找到链表中点快慢指针"><a class="markdownIt-Anchor" href="#找到链表中点快慢指针"></a> 找到链表中点（快慢指针）</h3><blockquote><p>设置两个指针，其中快的指针每次移动2次，慢指针移动一次，当快指针到达尾部，慢指针的位置就是中点</p></blockquote><p>代码：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autoit">ListNode* middleNode(ListNode* head) &#123;<br>        ListNode *low=head<span class="hljs-comment">;</span><br>        ListNode *fast=head<span class="hljs-comment">;</span><br>        //如果有偶数个节点，以下条件找到的是右侧中点<br>        //如果要找左侧中点，改为：fast-&gt;<span class="hljs-keyword">next</span>!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;<span class="hljs-keyword">next</span>-&gt;<span class="hljs-keyword">next</span>!=<span class="hljs-literal">NULL</span>即可<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;<span class="hljs-keyword">next</span>!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            low=low-&gt;<span class="hljs-keyword">next</span><span class="hljs-comment">;</span><br>            fast=fast-&gt;<span class="hljs-keyword">next</span>-&gt;<span class="hljs-keyword">next</span><span class="hljs-comment">;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> low<span class="hljs-comment">;</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h3><blockquote><p>其实反转链表可以用线性表做，时间复杂度差不多，但这里还是回归链表操作</p></blockquote><p>代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ListNode* reverseList(ListNode* head) &#123;<br>        ListNode* <span class="hljs-attribute">pre</span>=<span class="hljs-literal">NULL</span>;<br>        ListNode* <span class="hljs-attribute">l</span>=head;<br>        <span class="hljs-keyword">while</span>(l!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            ListNode* <span class="hljs-attribute">tmp</span>=l-&gt;next;<br>            l-&gt;<span class="hljs-attribute">next</span>=pre;<br>            <span class="hljs-attribute">pre</span>=l;<br>            <span class="hljs-attribute">l</span>=tmp;<br>        &#125;<br>        return pre;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="合并链表"><a class="markdownIt-Anchor" href="#合并链表"></a> 合并链表</h3><blockquote><p>将l1和l2交错合并</p></blockquote><p>代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void merge(ListNode* l1,ListNode* l2)<br>&#123;<br>    <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">NULL</span>&amp;&amp;l2!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        ListNode* <span class="hljs-attribute">l1t</span>=l1-&gt;next;<br>        ListNode* <span class="hljs-attribute">l2t</span>=l2-&gt;next;<br>        l1-&gt;<span class="hljs-attribute">next</span>=l2;<br>        <span class="hljs-attribute">l1</span>=l1t;<br>        l2-&gt;<span class="hljs-attribute">next</span>=l1;<br>        <span class="hljs-attribute">l2</span>=l2t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void reorderList(ListNode* head) &#123;<br>    ListNode* <span class="hljs-attribute">mid</span>=middleNode(head);<br>    ListNode* <span class="hljs-attribute">l1</span>=head;<br>    ListNode* <span class="hljs-attribute">l2</span>=mid-&gt;next;<br>    mid-&gt;<span class="hljs-attribute">next</span>=<span class="hljs-literal">NULL</span>;<br>    ListNode* <span class="hljs-attribute">r</span>=reverseList(l2);<br>    merge(l1,r);<br>&#125;<br>ListNode* reverseList(ListNode* head) &#123;<br>    ListNode* <span class="hljs-attribute">pre</span>=<span class="hljs-literal">NULL</span>;<br>    ListNode* <span class="hljs-attribute">l</span>=head;<br>    <span class="hljs-keyword">while</span>(l!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        ListNode* <span class="hljs-attribute">tmp</span>=l-&gt;next;<br>        l-&gt;<span class="hljs-attribute">next</span>=pre;<br>        <span class="hljs-attribute">pre</span>=l;<br>        <span class="hljs-attribute">l</span>=tmp;<br>    &#125;<br>    return pre;<br>&#125;<br>ListNode* middleNode(ListNode* head) &#123;<br>    ListNode *<span class="hljs-attribute">low</span>=head;<br>    ListNode <span class="hljs-number">*fa</span><span class="hljs-attribute">st</span>=head;<br>    <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;next-&gt;next!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-attribute">low</span>=low-&gt;next;<br>        <span class="hljs-attribute">fast</span>=fast-&gt;next-&gt;next;<br>    &#125;<br>    return low;<br>&#125;<br>void merge(ListNode* l1,ListNode* l2)<br>&#123;<br>    <br>    <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">NULL</span>&amp;&amp;l2!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        ListNode* <span class="hljs-attribute">l1t</span>=l1-&gt;next;<br>        ListNode* <span class="hljs-attribute">l2t</span>=l2-&gt;next;<br>        l1-&gt;<span class="hljs-attribute">next</span>=l2;<br>        <span class="hljs-attribute">l1</span>=l1t;<br>        l2-&gt;<span class="hljs-attribute">next</span>=l1;<br>        <span class="hljs-attribute">l2</span>=l2t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>差分与前缀和</title>
    <link href="/2022/08/24/%E5%B7%AE%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2022/08/24/%E5%B7%AE%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%89%8D%E7%BC%80%E5%92%8C">前缀和</a></li><li><a href="#%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">一维前缀和</a></li><li><a href="#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">二维前缀和</a></li><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li><li><a href="#%E5%B7%AE%E5%88%86">差分</a></li><li><a href="#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86">一维差分</a></li><li><a href="#%E4%BE%8B%E9%A2%98-1">例题</a></li><li><a href="#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86">二维差分</a></li><li><a href="#%E4%BE%8B%E9%A2%98-2">例题</a></li></ul><!-- /TOC --><h3 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h3><blockquote><p>前缀和指的是序列的前n项和</p></blockquote><h3 id="一维前缀和"><a class="markdownIt-Anchor" href="#一维前缀和"></a> 一维前缀和</h3><p>先看一个例题：<br />输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。<br />如果使用暴力枚举，时间复杂度为 <code>O(n*m)</code>,但是使用前缀和的话，时间复杂度可降为 <code>O(n)</code><br />input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>6<br>10<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>;<br><span class="hljs-type">int</span> a[N]; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n,m,l,r;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>cin&gt;&gt;a[i];<br>a[i]+=a[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>cin&gt;&gt;l&gt;&gt;r;<br>cout&lt;&lt;a[r]-a[l<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维前缀和"><a class="markdownIt-Anchor" href="#二维前缀和"></a> 二维前缀和</h3><p>每一个元素<code>a[i][j]</code>表示左上角和第<code>i</code>行，第<code>j</code>列围成的元素之和</p><p>更新方式： <code>a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]</code></p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p>输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。<br />对于每个询问输出子矩阵中所有数的和</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">17<br>27<br>21<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int N=1e3;<br>int a<span class="hljs-comment">[N]</span><span class="hljs-comment">[N]</span>; <br>int main()<br>&#123;<br>int n,m,q;<br>int x1,y1,x2,y2;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>for(int i=1;i&lt;=n;++i)<br>&#123;<br>for(int j=1;j&lt;=m;++j)<br>&#123;<br>cin&gt;&gt;a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>;<br>a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>+=a<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>+a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>-a<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>;<br>&#125;<br>&#125;<br>while(q--)<br>&#123;<br>cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br>cout&lt;&lt;a<span class="hljs-comment">[x2]</span><span class="hljs-comment">[y2]</span>-a<span class="hljs-comment">[x1-1]</span><span class="hljs-comment">[y2]</span>-a<span class="hljs-comment">[x2]</span><span class="hljs-comment">[y1-1]</span>+a<span class="hljs-comment">[x1-1]</span><span class="hljs-comment">[y1-1]</span>&lt;&lt;endl;<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="差分"><a class="markdownIt-Anchor" href="#差分"></a> 差分</h3><blockquote><p>可以看作前缀和的逆运算</p></blockquote><h3 id="一维差分"><a class="markdownIt-Anchor" href="#一维差分"></a> 一维差分</h3><p>常用于给数组的某个区间段<code>[l,r]</code>加上某个数<code>c</code>，可以减小时间复杂度</p><ul><li>先构造差分数组：<code>b[i]=a[i]-a[i-1]</code></li><li>构造好之后 <code>b[l]+=c</code>,<code>b[r+1]-=c</code></li><li>然后根据<code>b[i]+=b[i-1]</code>计算前缀和数组，就是最终答案</li></ul><h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3><p>输入一个长度为n的整数序列。<br />接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。<br />请你输出进行完所有操作后的序列。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>;<br><span class="hljs-type">int</span> a[N],b[N]; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n,m,l,r,c;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>cin&gt;&gt;a[i];<br>b[i]=a[i]-a[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>b[l]+=c;<br>b[r+<span class="hljs-number">1</span>]-=c;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>b[i]+=b[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维差分"><a class="markdownIt-Anchor" href="#二维差分"></a> 二维差分</h3><p>常用于给某个子矩阵的每个元素加上 c</p><ul><li>二维差分数组的构造：<br /><code>b[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]</code></li><li>修改差分数组：  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">b<span class="hljs-comment">[x1]</span><span class="hljs-comment">[y1]</span>+=c;<br>b<span class="hljs-comment">[x1]</span><span class="hljs-comment">[y2+1]</span>-=c;<br>b<span class="hljs-comment">[x2+1]</span><span class="hljs-comment">[y1]</span>-=c;<br>b<span class="hljs-comment">[x2+1]</span><span class="hljs-comment">[y2+1]</span>+=c;<br></code></pre></td></tr></table></figure></li><li>生成前缀和数组：<br /><code>b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];</code></li></ul><h3 id="例题-3"><a class="markdownIt-Anchor" href="#例题-3"></a> 例题</h3><p>输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。<br />每个操作都要将选中的子矩阵中的每个元素的值加上c。<br />请你将进行完所有操作后的矩阵输出。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int <span class="hljs-symbol">N</span>=<span class="hljs-number">1e3</span>;<br>int a[<span class="hljs-symbol">N</span>][<span class="hljs-symbol">N</span>],b[<span class="hljs-symbol">N</span>][<span class="hljs-symbol">N</span>]; <br>int main()<br>&#123;<br>int n,m,q;<br>int x1,y1,x2,y2,c;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>for(int j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br>cin&gt;&gt;a[i][j];<br>b[i][j]=a[i][j]-a[i<span class="hljs-number">-1</span>][j]-a[i][j<span class="hljs-number">-1</span>]+a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;<br>while(q--)<br>&#123;<br>cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;<br>b[x1][y1]+=c;<br>b[x1][y2+<span class="hljs-number">1</span>]-=c;<br>b[x2+<span class="hljs-number">1</span>][y1]-=c;<br>b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]+=c;<br>&#125;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>for(int j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>b[i][j]+=b[i<span class="hljs-number">-1</span>][j]+b[i][j<span class="hljs-number">-1</span>]-b[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>&#125;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>for(int j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>cout&lt;&lt;b[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>cout&lt;&lt;endl;<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速幂矩阵幂</title>
    <link href="/2022/08/23/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9F%A9%E9%98%B5%E5%B9%82/"/>
    <url>/2022/08/23/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9F%A9%E9%98%B5%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BE%8B1-%E5%BF%AB%E9%80%9F%E5%B9%82">例1 快速幂</a></li><li><a href="#%E4%BE%8B2-%E7%9F%A9%E9%98%B5%E5%B9%82">例2 矩阵幂</a></li></ul><!-- /TOC --><blockquote><p><strong>快速幂</strong> 快速幂常用于计算指数非常大的幂，核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。</p></blockquote><p><em>直接看例题</em></p><h3 id="例1-快速幂"><a class="markdownIt-Anchor" href="#例1-快速幂"></a> 例1 快速幂</h3><p>输入三个数字a,b,c,输出 a^b <strong>mod</strong> c<br />input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">10</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a,b,c;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ksm</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br>a=a%c;<br><span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>)<br>ans=(ans*a)%c;<br>a=(a*a)%c;<br>b/=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>cout&lt;&lt;<span class="hljs-built_in">ksm</span>()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例2-矩阵幂"><a class="markdownIt-Anchor" href="#例2-矩阵幂"></a> 例2 矩阵幂</h3><p>描述<br />给定一个n*n的矩阵，输出矩阵的k次方</p><p>输入描述<br />有多组输入，第一行输入n和k<br />后面n行输入矩阵元素<br />2&lt;=n&lt;=10,1&lt;=k&lt;=5<br />输出描述<br />每组输入输出矩阵的k次方<br />input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">3</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">153 </span><span class="hljs-number">96</span><br><span class="hljs-symbol">108 </span><span class="hljs-number">81</span><br><span class="hljs-symbol">1216 </span><span class="hljs-number">1248</span> <span class="hljs-number">708</span><br><span class="hljs-symbol">1089 </span><span class="hljs-number">927</span> <span class="hljs-number">504</span><br><span class="hljs-symbol">1161 </span><span class="hljs-number">1151</span> <span class="hljs-number">739</span><br><span class="hljs-symbol">47 </span><span class="hljs-number">29</span> <span class="hljs-number">41</span> <span class="hljs-number">22</span> <span class="hljs-number">16</span><br><span class="hljs-symbol">147 </span><span class="hljs-number">103</span> <span class="hljs-number">73</span> <span class="hljs-number">116</span> <span class="hljs-number">94</span><br><span class="hljs-symbol">162 </span><span class="hljs-number">108</span> <span class="hljs-number">153</span> <span class="hljs-number">168</span> <span class="hljs-number">126</span><br><span class="hljs-symbol">163 </span><span class="hljs-number">67</span> <span class="hljs-number">112</span> <span class="hljs-number">158</span> <span class="hljs-number">122</span><br><span class="hljs-symbol">152 </span><span class="hljs-number">93</span> <span class="hljs-number">93</span> <span class="hljs-number">111</span> <span class="hljs-number">97</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">M</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> row;<br>    <span class="hljs-built_in">int</span> col;<br>    <span class="hljs-built_in">int</span> m[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];<br>    M(<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> c):row(r),col(c)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;col;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==j)<br>                    m[i][j]=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    m[i][j]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;      <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">input</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;col;++j)<br>                cin&gt;&gt;m[i][j];<br>        &#125; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;col;++j)<br>                cout&lt;&lt;m[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>            cout&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    M <span class="hljs-keyword">operator</span>* (<span class="hljs-keyword">const</span> M&amp; t) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-function">M <span class="hljs-title">ans</span>(<span class="hljs-params">row,t.col</span>)</span>;<br>        memset(ans.m,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(ans.m));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;t.col;++j)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;k&lt;col;++k)<br>                &#123;<br>                    ans.m[i][j]+=m[i][k]*t.m[k][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function">M <span class="hljs-title">ksm</span>(<span class="hljs-params">M a,<span class="hljs-built_in">int</span> k</span>)</span><br>&#123;<br>    <span class="hljs-function">M <span class="hljs-title">ans</span>(<span class="hljs-params">a.row,a.col</span>)</span>;<br>    <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(k%<span class="hljs-number">2</span>)<br>            ans=ans*a;<br>        a=a*a;<br>        k/=<span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans; <br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> n,k;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;k)<br>    &#123;<br>        <span class="hljs-function">M <span class="hljs-title">a</span>(<span class="hljs-params">n,n</span>)</span>;<br>        a.input();<br>        M ans=ksm(a,k);<br>        ans.output();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最短路</title>
    <link href="/2022/08/22/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2022/08/22/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BE%8B1-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF-%E6%B4%9B%E8%B0%B7p4779">例1 单源最短路 洛谷p4779</a></li><li><a href="#spfa">SPFA</a></li><li><a href="#dijkstra%E6%99%AE%E9%80%9A%E7%89%88">Dijkstra普通版</a></li><li><a href="#dijkstra%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88ac">Dijkstra堆优化版(AC)</a><ul><li><a href="#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AD%98%E5%9B%BE">链式前向星存图</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E4%BE%8B2-%E6%9C%80%E5%A4%9A%E7%BB%8F%E8%BF%87k%E6%9D%A1%E8%BE%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF">例2 最多经过k条边的最短路</a></li><li><a href="#bellmanford">Bellmanford</a></li><li><a href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E8%A7%A3%E6%9C%80%E7%9F%AD%E8%B7%AF">并查集解最短路</a></li></ul><!-- /TOC --><h3 id="例1-单源最短路-洛谷p4779"><a class="markdownIt-Anchor" href="#例1-单源最短路-洛谷p4779"></a> 例1 单源最短路 洛谷p4779</h3><p>题目描述</p><p>给定一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 条有向边的带非负权图，请你计算从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 出发，到每个点的距离。</p><p>数据保证你能从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 出发到任意点。</p><p>输入格式</p><p>第一行为三个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">n, m, s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span></span></span></span>。<br />第二行起 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行三个非负整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i, v_i, w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，表示从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 有一条权值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的有向边。</p><p>输出格式</p><p>输出一行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个空格分隔的非负整数，表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 到每个点的距离。</p><p>样例输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>提示</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq n \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq m \leq 2\times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \leq u_i, v_i\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>w</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">0 \leq w_i \leq 10 ^ 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>,</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mo>∑</mo><msub><mi>w</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">0 \leq \sum w_i \leq 10 ^ 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。</p><h3 id="spfa"><a class="markdownIt-Anchor" href="#spfa"></a> SPFA</h3><blockquote><p>此题用spfa会超时,这里写的代码弱化了数据范围，存图也直接用二维数组了，主要是复习spfa的思路</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,s;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> mp[N][N];<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> vis[N]; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(mp,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(mp));<br><span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dist));<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br>dist[s]=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> u,v,w;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>&#123;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>mp[u][v]=w;<br>&#125;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(s);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>vis[t]=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">if</span>(dist[i]&gt;dist[t]+mp[t][i])<br>&#123;<br>dist[i]=dist[t]+mp[t][i];<br><span class="hljs-keyword">if</span>(!vis[i])<br>&#123;<br>vis[i]=<span class="hljs-literal">true</span>;<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br>&#125;<br>&#125;<br>&#125; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cout&lt;&lt;dist[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dijkstra普通版"><a class="markdownIt-Anchor" href="#dijkstra普通版"></a> Dijkstra普通版</h3><blockquote><p>此题用普通Dijkstra会超时,这里写的代码弱化了数据范围，存图也直接用二维数组了，主要是复习dj的思路</p></blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs excel">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>,m,s;<br>const <span class="hljs-built_in">int</span> <span class="hljs-built_in">N</span>=<span class="hljs-number">1</span>e4+<span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> mp[<span class="hljs-built_in">N</span>][<span class="hljs-built_in">N</span>];<br><span class="hljs-built_in">int</span> dist[<span class="hljs-built_in">N</span>];<br>bool vis[<span class="hljs-built_in">N</span>]; <br><span class="hljs-built_in">int</span> main()<br>&#123;<br>memset(mp,<span class="hljs-number">0</span>x3f,sizeof(mp));<br>memset(dist,<span class="hljs-number">0</span>x3f,sizeof(dist));<br>cin&gt;&gt;<span class="hljs-built_in">n</span>&gt;&gt;m&gt;&gt;s;<br>dist[s]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> u,v,w;<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>&#123;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>mp[u][v]=w;<br>&#125;<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">n</span>;++i)<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>=-<span class="hljs-number">1</span>;<br>for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-built_in">n</span>;++j)<br>&#123;<br><span class="hljs-built_in">if</span>(!vis[j]&amp;&amp;(<span class="hljs-built_in">t</span>==-<span class="hljs-number">1</span>||dist[<span class="hljs-built_in">t</span>]&gt;dist[j]))<br><span class="hljs-built_in">t</span>=j;<br>&#125;<br>vis[<span class="hljs-built_in">t</span>]=<span class="hljs-built_in">true</span>;<br>for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-built_in">n</span>;++j)<br>&#123;<br>dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[<span class="hljs-built_in">t</span>]+mp[<span class="hljs-built_in">t</span>][j]);<br>&#125;<br>&#125;<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">n</span>;++i)<br>cout&lt;&lt;dist[i]&lt;&lt;&#x27; &#x27;;<br>cout&lt;&lt;endl;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dijkstra堆优化版ac"><a class="markdownIt-Anchor" href="#dijkstra堆优化版ac"></a> Dijkstra堆优化版(AC)</h3><h4 id="链式前向星存图"><a class="markdownIt-Anchor" href="#链式前向星存图"></a> 链式前向星存图</h4><p>题目中给的节点数很多，属于稀疏图，二维数组无法存储，所以需要使用<strong>链式前向星</strong>存储，方法如下：</p><p>定义一个数组<code>head[]</code>,<code>head[a]</code>表示以a为起始点的最后一条边的序号</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span>：表示边的序号</p><p>结构体<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">edge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span></span></span></span>，存储边</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> edge<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">to</span>;<span class="hljs-comment">//这条边指向的点 </span><br><span class="hljs-built_in">int</span> next;<span class="hljs-comment">//这条边的邻边的序号 </span><br><span class="hljs-built_in">int</span> w;<span class="hljs-comment">//这条边的权值 </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>加边，如果是无向图，交换u和v再add一次即可</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hsp">void add(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> w)<br>&#123;<br>++<span class="hljs-keyword">cnt</span><span class="hljs-comment">;</span><br>e[<span class="hljs-keyword">cnt</span>].to=v<span class="hljs-comment">;</span><br>e[<span class="hljs-keyword">cnt</span>].w=w<span class="hljs-comment">;</span><br>e[<span class="hljs-keyword">cnt</span>].next=head[u]<span class="hljs-comment">;</span><br>head[u]=<span class="hljs-keyword">cnt</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>遍历以a为起点的所有边</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=head[a];i!=0;<span class="hljs-attribute">i</span>=edge[i].next)<br></code></pre></td></tr></table></figure><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,s;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> head[N];<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-comment">//边 </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br><span class="hljs-type">int</span> to;<span class="hljs-comment">//这条边指向的点 </span><br><span class="hljs-type">int</span> next;<span class="hljs-comment">//这条边的邻边的序号 </span><br><span class="hljs-type">int</span> w;<span class="hljs-comment">//这条边的权值 </span><br>&#125;e[<span class="hljs-number">2</span>*N];<br><span class="hljs-comment">//优先级队列的节点</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w;<br><span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> nn,<span class="hljs-type">int</span> ww):<span class="hljs-built_in">n</span>(nn),<span class="hljs-built_in">w</span>(ww)&#123;&#125;<br><span class="hljs-comment">//重载运算符&lt;，为了建立小顶堆 </span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> node&amp; t) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> w&gt;t.w;<br>&#125;<br>&#125;; <br><span class="hljs-comment">//加边 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>++cnt;<br>e[cnt].to=v;<br>e[cnt].w=w;<br>e[cnt].next=head[u];<br>head[u]=cnt;<br>&#125;<br>priority_queue&lt;node&gt; q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br><span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>dis[s]=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> u,v,w;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>&#123;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br><span class="hljs-built_in">add</span>(u,v,w);<br>&#125;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(s,<span class="hljs-number">0</span>));<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>node t=q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>u=t.n;<br><span class="hljs-keyword">if</span>(!vis[u])<br>&#123;<br>vis[u]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)<br>&#123;<br>v=e[i].to;<br>w=e[i].w;<br><span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)<br>&#123;<br>dis[v]=dis[u]+w;<br><span class="hljs-keyword">if</span>(!vis[v])<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(v,dis[v]));<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cout&lt;&lt;dis[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例2-最多经过k条边的最短路"><a class="markdownIt-Anchor" href="#例2-最多经过k条边的最短路"></a> 例2 最多经过k条边的最短路</h3><p>描述<br />给定 n 个点，m条有向边，起点s，终点d，最大边数k</p><p>第一行输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>d</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n,m,s,d,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span><br />后面m行输入m条边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i,v_i,w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>输出从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>最多经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>条边时的最短路径<br />input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">100</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">100</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">500</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">200<br></code></pre></td></tr></table></figure><h3 id="bellmanford"><a class="markdownIt-Anchor" href="#bellmanford"></a> Bellmanford</h3><blockquote><p>Bellmanford常用于解决此类有边数限制的最短路</p></blockquote><p>代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> n,m,s,d,k;<br><span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;<br>const <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100</span>][N];<br><span class="hljs-type">bool</span> vis[N];<br>struct edge<br>&#123;<br><span class="hljs-type">int</span> u,v,w;<br>//edge(<span class="hljs-type">int</span> uu,<span class="hljs-type">int</span> vv,<span class="hljs-type">int</span> ww):u(uu),v(vv),w(ww)&#123;&#125;<br>&#125;e[N];<br><span class="hljs-type">int</span> main()<br>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d&gt;&gt;k;<br>memset(dp,<span class="hljs-number">0x3f</span>,sizeof(dp));<br>dp[<span class="hljs-number">0</span>][s]=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> u,v,w;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>&#123;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>e[i].u=u;<br>e[i].v=v;<br>e[i].w=w;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br>u=e[j].u;<br>v=e[j].v;<br>w=e[j].w;<br>dp[i][v]=min(dp[i][v],dp[i<span class="hljs-number">-1</span>][u]+w);<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> ans=inf;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i)<br>&#123;<br>ans=min(dp[i][d],ans);<br>&#125; <br><span class="hljs-keyword">if</span>(ans==inf)<br>cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并查集解最短路"><a class="markdownIt-Anchor" href="#并查集解最短路"></a> 并查集解最短路</h3><p>先看一个例题</p><p><a href="https://www.nowcoder.com/practice/a29d0b5eb46b4b90bfa22aa98cf5ff17?tpId=40&amp;tqId=21438&amp;rp=1&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan&amp;difficulty=&amp;judgeStatus=&amp;tags=/question-ranking">最短路径</a></p><p><strong>描述</strong></p><p>N个城市，标号从0到N-1，M条道路，第K条道路（K从0开始）的长度为2^K，求编号为0的城市到其他城市的最短距离</p><p><strong>输入描述</strong></p><p>第一行两个正整数N（2&lt;=N&lt;=100）M(M&lt;=500),表示有N个城市，M条道路 接下来M行两个整数，表示相连的两个城市的编号</p><p><strong>输出描述</strong></p><p>N-1行，表示0号城市到其他城市的最短路，如果无法到达，输出-1，数值太大的以MOD 100000 的结果输出。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">8<br>9<br>11<br></code></pre></td></tr></table></figure><blockquote><p>思路：对于这道题，第k条边的长度为2^k，也就是说，第k条边会比前面所有边的和还要大。所以用并查集来做，当新加入边的两个端点u和v不连通时，这条边就是u到v的最短距离，因为后续如果再次出现以uv为端点的边，一定会比当前长度长。加入uv边后，更新两端点各自连通子图中各点间的距离即可。</p></blockquote><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">102</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e5</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> mp[N][N];<br><span class="hljs-type">int</span> vset[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ksm</span><span class="hljs-params">(ll a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br>    a=a%c;<br>    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>)<br>            ans=(ans*a)%c;<br>        a=(a*a)%c;<br>        b/=<span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(vset[a]==<span class="hljs-number">-1</span>)<br><span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">else</span><br>&#123;<br>vset[a]=<span class="hljs-built_in">find</span>(vset[a]);<br><span class="hljs-keyword">return</span> vset[a];<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(vset,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(vset));<br>    <span class="hljs-built_in">memset</span>(mp,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(mp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>    mp[i][i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> u,v,w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;m;++k)<br>    &#123;<br>        cin&gt;&gt;u&gt;&gt;v;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">find</span>(u);<br>        <span class="hljs-type">int</span> y=<span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-comment">//当两点不连通的时候才加入该边，此时该边是u到v的最短边</span><br><span class="hljs-keyword">if</span>(x!=y)<br>&#123;<br>w=<span class="hljs-built_in">ksm</span>(<span class="hljs-number">2</span>,k,mod);<br><span class="hljs-comment">//更新两个连通子图间各点的距离 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)==x)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(j)==y)<br>&#123;<br>mp[i][j]=mp[j][i]=(mp[i][u]+w+mp[v][j])%mod;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//连接两个连通子图</span><br>vset[x]=y; <br>&#125; <br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)<br>    cout&lt;&lt;mp[<span class="hljs-number">0</span>][i]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2022/08/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BE%8B%E9%A2%98101%E8%83%8C%E5%8C%85">例题1：01背包</a></li><li><a href="#%E4%BE%8B%E9%A2%982%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">例题2：完全背包</a></li></ul><!-- /TOC --><blockquote><p><em><strong>背包问题</strong></em> 是经典的一类动态规划类型的题目，一般是有n种物品，每个物品有对应的价值w，然后背包体积为V，求能装入的物品的最大价值。</p></blockquote><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><p>设 <strong>dp[i][j]</strong> 为前 i 个物品，背包容量为 j 的最大价值。</p><p>那么考虑第i个物品是否放入，有两种情况：</p><ul><li>如果不放，那么等同于前 <strong>i−1</strong> 个物品，容量为j的背包的最优方案。</li><li>如果放，那么等同于前 <strong>i−1</strong> 个物品，容量为 <strong>j−v[i]</strong> 的背包的最优方案，再加上第i个物品的价值。</li></ul><p>那么可以得到转移方程：</p><p><em><strong>dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i])</strong></em></p><p>最终的答案就是 <strong>dp[n][V]</strong></p><p>观察到dp数组，第i行仅跟上一行有关系，故可以压缩一维，为了防止dp[i−1][j−v[i]]被覆盖掉，第二维度须<strong>反向枚举</strong>。</p><h4 id="例题101背包"><a class="markdownIt-Anchor" href="#例题101背包"></a> 例题1：01背包</h4><p>你有一个背包，最多能容纳的体积是V，现在有n个物品，第i个物品的体积为vi,价值为wi。</p><ol><li>求这个背包至多能装多大价值的物品？</li><li>若背包恰好装满，求至多能装多大价值的物品？</li></ol><p>输入第一行n,V<br />后面n行，输入第i件物品的体积vi和价值wi<br />输出：两个问题的答案，各占一行，如果无解输出0</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">14<br>9<br></code></pre></td></tr></table></figure><p>题解：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int n,V;<br>const int N=1005;<br>int v<span class="hljs-comment">[N]</span>,w<span class="hljs-comment">[N]</span>;<br>int dp<span class="hljs-comment">[N]</span>;<br>int main()<br>&#123;<br>    cin&gt;&gt;n&gt;&gt;V;<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;v<span class="hljs-comment">[i]</span>;<br>        cin&gt;&gt;w<span class="hljs-comment">[i]</span>;<br>    &#125;<br>    //不要求装满<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        for(int j=V;j&gt;=v<span class="hljs-comment">[i]</span>;--j)<br>            dp<span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[j-v<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>);<br>    &#125;<br>    cout&lt;&lt;dp<span class="hljs-comment">[V]</span>&lt;&lt;endl;<br>    <br>    //要求装满<br>    memset(dp,-0x3f,sizeof(dp));<br>    dp<span class="hljs-comment">[0]</span>=0;<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        for(int j=V;j&gt;=v<span class="hljs-comment">[i]</span>;--j)<br>            dp<span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[j-v<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>);<br>    &#125;<br>    if(dp<span class="hljs-comment">[V]</span>&gt;0)<br>        cout&lt;&lt;dp<span class="hljs-comment">[V]</span>&lt;&lt;endl;<br>    else<br>        cout&lt;&lt;0&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例题2完全背包"><a class="markdownIt-Anchor" href="#例题2完全背包"></a> 例题2：完全背包</h4><p>描述与例题1相同，不过每种物品有<strong>任意</strong>个</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">13</span><br><span class="hljs-symbol">13 </span><span class="hljs-number">189</span><br><span class="hljs-symbol">17 </span><span class="hljs-number">360</span><br><span class="hljs-symbol">19 </span><span class="hljs-number">870</span><br><span class="hljs-symbol">14 </span><span class="hljs-number">184</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">298</span><br><span class="hljs-symbol">16 </span><span class="hljs-number">242</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">596<br>189<br></code></pre></td></tr></table></figure><p>题解：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int n,V;<br>const int N=1005;<br>int v<span class="hljs-comment">[N]</span>,w<span class="hljs-comment">[N]</span>;<br>int dp<span class="hljs-comment">[N]</span>;<br>int main()<br>&#123;<br>    cin&gt;&gt;n&gt;&gt;V;<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;v<span class="hljs-comment">[i]</span>;<br>        cin&gt;&gt;w<span class="hljs-comment">[i]</span>;<br>    &#125;<br>    //不要求装满<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        for(int j=v<span class="hljs-comment">[i]</span>;j&lt;=V;++j)<br>            dp<span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[j-v<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>);<br>    &#125;<br>    cout&lt;&lt;dp<span class="hljs-comment">[V]</span>&lt;&lt;endl;<br>    <br>    //要求装满<br>    memset(dp,-0x3f,sizeof(dp));<br>    dp<span class="hljs-comment">[0]</span>=0;<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        for(int j=v<span class="hljs-comment">[i]</span>;j&lt;=V;++j)<br>            dp<span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[j-v<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>);<br>    &#125;<br>    if(dp<span class="hljs-comment">[V]</span>&gt;0)<br>        cout&lt;&lt;dp<span class="hljs-comment">[V]</span>&lt;&lt;endl;<br>    else<br>        cout&lt;&lt;0&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯</title>
    <link href="/2022/08/22/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2022/08/22/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><em><strong>回溯</strong></em>  核心思想和dfs相似，主要通过递归寻找可行解</p></blockquote><!-- TOC --><ul><li><a href="#%E4%BE%8B%E9%A2%981">例题1:</a></li><li><a href="#%E4%BE%8B%E9%A2%982">例题2:</a></li></ul><!-- /TOC --><h3 id="例题1"><a class="markdownIt-Anchor" href="#例题1"></a> 例题1:</h3><p>给定一个数组a[]和target的值，找出数组中可以使数字和为target的不同组合，输出所有符合要求的组合</p><ul><li>数组中数字可以重复使用</li><li>1,1,5和1,5,1视为一种方式<br />input:</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>题解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,target;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; vi;<br><span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(N)</span></span>;<br>vi tmp;<br>vector&lt;vi&gt; ans; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bk</span><span class="hljs-params">(<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(idx==n)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)<br>    &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">bk</span>(idx+<span class="hljs-number">1</span>,target);<br>    <span class="hljs-keyword">if</span>(target&gt;=a[idx])<br>    &#123;<br>        tmp.<span class="hljs-built_in">push_back</span>(a[idx]);<br>        <span class="hljs-built_in">bk</span>(idx,target-a[idx]);<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;target;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>cin&gt;&gt;a[i];<br><br>    <span class="hljs-built_in">bk</span>(<span class="hljs-number">0</span>,target);<br>    <span class="hljs-keyword">for</span>(vi&amp; t:ans)<br>    &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> tt :t)<br>    cout&lt;&lt;tt&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题2"><a class="markdownIt-Anchor" href="#例题2"></a> 例题2:</h3><p>给定一个数组a[]和target的值，找出数组中可以使数字和为target的不同组合，输出所有符合要求的组合</p><ul><li>数组中每个数字最多使用一次</li><li>1,1,5和1,5,1视为一种方式<br />input:</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>题解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,target;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; vi;<br><span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(N)</span></span>;<br>vi tmp;<br>vector&lt;vi&gt; ans; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bk</span><span class="hljs-params">(<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(idx==n)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)<br>    &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=idx;i&lt;n;++i)<br>    &#123;<br>    <span class="hljs-keyword">if</span>(target&gt;=a[i])<br>    &#123;<br>    <span class="hljs-keyword">if</span>(i&gt;idx&amp;&amp;a[i]==a[i<span class="hljs-number">-1</span>])<br>    <span class="hljs-keyword">continue</span>;<br>    tmp.<span class="hljs-built_in">push_back</span>(a[i]);<br>    <span class="hljs-built_in">bk</span>(i+<span class="hljs-number">1</span>,target-a[i]);<br>    tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;target;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>cin&gt;&gt;a[i];<br><br>    <span class="hljs-built_in">bk</span>(<span class="hljs-number">0</span>,target);<br>    <span class="hljs-keyword">for</span>(vi&amp; t:ans)<br>    &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> tt :t)<br>    cout&lt;&lt;tt&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kmp算法</title>
    <link href="/2022/08/21/kmp%E7%AE%97%E6%B3%95/"/>
    <url>/2022/08/21/kmp%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><em><strong>kmp</strong></em> 算法的核心思想：当匹配失败时，主串指针不回退，而是根据 <em><strong>next</strong></em> 数组，从适当的位置重新匹配，相比于暴力匹配，跳过了不可能匹配成功的部分，大大提升了效率</p></blockquote><blockquote><p><em><strong>next</strong></em> 数组每个位置的值表示前缀集合和后缀集合交集中,最长元素的长度</p></blockquote><pre><code class="hljs">        p:    a b a b a b c a    next[i]:  0 0 1 2 3 4 0 1</code></pre><p>例题:</p><p>给你两个字符串 s 和 p ，请你在 s 字符串中找出 p 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。</p><p>input:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abacdf</span><br><span class="hljs-attribute">acd</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p>题解</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>const int <span class="hljs-attribute">N</span>=1e5;<br>int nxt[N];<br>void get_next(string p)<br>&#123;<br>int <span class="hljs-attribute">len</span>=p.size();<br>int <span class="hljs-attribute">i</span>=1,j=0;<br><span class="hljs-keyword">while</span>(i&lt;len)<br>&#123;<br><span class="hljs-keyword">if</span>(p[i]==p[j])<br>&#123;<br>nxt[i]=j+1;<br>++i;<br>++j;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-attribute">j</span>==0)<br>&#123;<br>nxt[i]=0;<br>++i;<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-attribute">j</span>=nxt[j-1];<br>&#125;<br>&#125; <br>int main()<br>&#123;<br>string s,p;<br>cin&gt;&gt;s&gt;&gt;p;<br>int <span class="hljs-attribute">m</span>=s.size(),n=p.size();<br>int <span class="hljs-attribute">ans</span>=-1;<br><br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0,j=0;i&lt;m;++i)<br>&#123;<br><span class="hljs-keyword">while</span>(j&gt;0&amp;&amp;s[i]!=p[j])<br><span class="hljs-attribute">j</span>=nxt[j-1];<br><span class="hljs-keyword">if</span>(s[i]==p[j])<br>++j;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">j</span>==n)<br><span class="hljs-attribute">ans</span>=i-j+1;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经</title>
    <link href="/2022/08/21/%E9%9D%A2%E7%BB%8F/"/>
    <url>/2022/08/21/%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#2022%E4%B8%AA%E4%BA%BA%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%A2%84%E6%8E%A8%E5%85%8D%E8%AE%B0%E5%BD%95">2022个人夏令营/预推免记录😢</a><ul><li><a href="#%E5%90%89%E5%A4%A7ai">吉大ai</a></li><li><a href="#%E8%A5%BF%E4%BA%A4cs">西交cs</a></li><li><a href="#%E5%8D%8E%E7%A7%91%E7%BD%91%E5%AE%89">华科网安</a></li><li><a href="#%E5%8C%97%E9%82%AE">北邮</a></li><li><a href="#%E5%9B%BD%E9%98%B2%E7%A7%91%E5%A4%A7%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B">国防科大系统工程</a></li><li><a href="#%E6%B5%99%E8%BD%AF">浙软</a></li><li><a href="#%E5%8D%97%E5%A4%A7cs">南大cs</a></li><li><a href="#%E5%8C%97%E8%88%AAai">北航ai</a></li><li><a href="#%E4%B8%9C%E5%8D%97cs">东南cs</a></li></ul></li><li><a href="#%E9%A2%84%E6%8E%A8%E5%85%8D">预推免</a><ul><li><a href="#%E5%A4%8D%E6%97%A6">复旦</a></li><li><a href="#%E8%A5%BF%E4%BA%A4">西交</a></li><li><a href="#%E5%93%88%E5%B7%A5%E5%A4%A7">哈工大</a></li><li><a href="#%E5%8C%97%E8%88%AAai-1">北航ai</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul><!-- /TOC --><h2 id="2022个人夏令营预推免记录"><a class="markdownIt-Anchor" href="#2022个人夏令营预推免记录"></a> 2022个人夏令营/预推免记录😢</h2><h3 id="吉大ai"><a class="markdownIt-Anchor" href="#吉大ai"></a> 吉大ai</h3><ul><li>自我介绍</li><li>英文翻译</li><li>抽题目回答</li></ul><p>我抽到的是关于聚类的：</p><ul><li>什么是聚类</li><li>聚类和分类区别</li><li>聚类的性能指标</li><li>层次聚类方法有哪些？</li><li><em>后两个也是关于层次聚类的，忘了。。。</em></li></ul><h3 id="西交cs"><a class="markdownIt-Anchor" href="#西交cs"></a> 西交cs</h3><p>夏令营没有优营，没有考核，先报名然后团队内部面试（聊天）</p><h3 id="华科网安"><a class="markdownIt-Anchor" href="#华科网安"></a> 华科网安</h3><p>有机试，5道题，150min,题目记不清了，难度中等，机试成绩不计入总成绩，仅作为参考<br />面试就自我介绍，然后聊聊天，最后优营40人，大概1/3</p><h3 id="北邮"><a class="markdownIt-Anchor" href="#北邮"></a> 北邮</h3><p>入营未参加</p><h3 id="国防科大系统工程"><a class="markdownIt-Anchor" href="#国防科大系统工程"></a> 国防科大系统工程</h3><p>入营未参加</p><h3 id="浙软"><a class="markdownIt-Anchor" href="#浙软"></a> 浙软</h3><p>入营选择方向，一共八个方向，每个方向会布置任务，做完提交即可，按完成质量评优营</p><p>时间紧，随便做了下就交了，最后普通营员</p><h3 id="南大cs"><a class="markdownIt-Anchor" href="#南大cs"></a> 南大cs</h3><ul><li><p><strong>笔试</strong><br />很多要计算的题，题量挺大的<br /><strong>数据结构</strong>：排序算法性能，希尔排序序列、红黑树、b树、最短路径算法(dijkstra,bellford,floyd)、最小生成树、线性探测、优先级队列、汉诺塔问题、还有好几个读程序的题<br /><strong>计组</strong>：组相联映射、cache和主存给定命中率计算时间、想不起来了。。。<br />os：linux终端退出的符号，jvm，进程通信、一些语言特性（rust，ruby，scala），访管指令，还有一堆指令。。<br /><strong>计网</strong>：无类寻址，拥塞窗口、数据链路层、ip协议、后面记的不清楚了。。。。</p></li><li><p><strong>面试</strong><br />先英文介绍merge sort，问一些项目问题，然后问了个数学题（怎么在球面上确定一点？），然后问了下生活上的兴趣之类的</p></li></ul><h3 id="北航ai"><a class="markdownIt-Anchor" href="#北航ai"></a> 北航ai</h3><p>今年是第二届夏令营，入营120/1000，优营60</p><ul><li>先英文自我介绍</li><li>政治：谈谈科教兴国的理解</li><li>聊聊项目</li><li>因为我在下午，可能是老师累了把，没有问专业课，最后优营了</li></ul><p>北航和老师聊，问了些问题，都是比较底层的细节问题，<br />还记得的有：</p><ul><li>python 垃圾回收机制</li><li>c++ 智能指针的原理</li><li>如何判断链表有没有环</li></ul><h3 id="东南cs"><a class="markdownIt-Anchor" href="#东南cs"></a> 东南cs</h3><p>入营318人</p><ul><li>面试<ul><li>3分钟自我介绍</li><li>英文问题：cv的相关任务、参加的实践活动</li><li>聊聊天，没有问专业课</li></ul></li></ul><hr /><hr /><hr /><h2 id="预推免"><a class="markdownIt-Anchor" href="#预推免"></a> 预推免</h2><h3 id="复旦"><a class="markdownIt-Anchor" href="#复旦"></a> 复旦</h3><p>机试：给3道题，2个小时的时间，自己做不用oj，然后做完把解题思路和代码提交就行了</p><p>感觉题都挺难的，数据规模也很大，我也刷了一段时间题，感觉难度有OI提高组级别吧，也可能是我tcl😢</p><p>英语：上来先自我介绍，然后让我介绍自己专业，学了什么。前面说的还行，后面几个问题也没准备，就说的磕磕绊绊。。。</p><p>面试：问得不是特别难，基本都答上来了。就是深度学习的一些基础知识还有数据结构的一些算法和复杂度，问得倒是很细，代码细节都问，但不难。</p><p>结果：候补第1。然后中午有老师打电话过来说那边夏令营会空出来几个名额，基本会候补到。</p><h3 id="西交"><a class="markdownIt-Anchor" href="#西交"></a> 西交</h3><p>面试和夏令营一样，没问什么专业课，感觉类似于聊天。</p><h3 id="哈工大"><a class="markdownIt-Anchor" href="#哈工大"></a> 哈工大</h3><p>报的是卓越工程师学院的人工智能，开始报名的很早，竞争相对没那么激烈。本来打算报本部和哈深的，后面给忘了😄</p><p>这个预推免体验不是很好，具体的就不多说了，反正各个环节安排的不是很合理，甚至面试的时候问题还没回答完，就被打断然后被要求退出会议了。</p><p>结果：第二天出结果了，通过了，要签承诺书什么的。</p><h3 id="北航ai-2"><a class="markdownIt-Anchor" href="#北航ai-2"></a> 北航ai</h3><p>最想去的学校，感觉夏令营优营也没什么优势。预推免还问的挺难的，比如问<em>广义的特征向量</em>，图形学里面的点云的什么公式之类的，感觉都很难😢😢😢😢</p><p>26日下午3点半收到拟录取邮件了</p><p>最后还是北航😄</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>感觉自己水平很一般，就是运气好了一点吧，希望别被buaa的大佬们碾压了。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
