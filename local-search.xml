<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常见排序算法</title>
    <link href="/2022/08/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/08/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li><li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li><li><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8Fradix-sort">基数排序（Radix Sort)</a></li><li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li><li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fmerge-sort">归并排序（Merge Sort）</a></li><li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li><li><a href="#%E6%A1%B6%E6%8E%92%E5%BA%8Fbucket-sort">桶排序（Bucket Sort）</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li></ul><!-- /TOC --><blockquote><p>这篇博客主要总结一下常见排序算法及其时间复杂度</p></blockquote><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好</th><th style="text-align:center">最差</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">插入排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">不稳定</td></tr></tbody></table><h3 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h3><blockquote><p>每次选择一个元素，并且将这个元素和前面元素进行比较，然后插入到合适的位置</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void insert_sort(int arr[], int length)&#123;    int i,j;    for (i &#x3D; 1; i &lt; length; i++) &#123;        int tmp &#x3D; arr[i];        for (j &#x3D; i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; tmp; j--) &#123;            arr[j] &#x3D; arr[j - 1];        &#125;        arr[j] &#x3D; tmp;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h3><blockquote><p>插入排序的升级版，初始间隔<em>gap</em>为元素数目的一般，每次间隔<em>gap</em>个元素进行插入排序，直到gap为1</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void shellSort(int arr[], int n) &#123;     for (int gap &#x3D; n&#x2F;2; gap &gt; 0; gap &#x2F;&#x3D; 2)     &#123;         for (int i &#x3D; gap; i &lt; n; i +&#x3D; 1)         &#123;             int temp &#x3D; arr[i];             int j;                         for (j &#x3D; i; j &gt;&#x3D; gap &amp;&amp; arr[j - gap] &gt; temp; j -&#x3D; gap)                 arr[j] &#x3D; arr[j - gap];             arr[j] &#x3D; temp;         &#125;     &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="基数排序radix-sort"><a class="markdownIt-Anchor" href="#基数排序radix-sort"></a> 基数排序（Radix Sort)</h3><blockquote><p>将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程是将所有待比较数值统一为同样的数位长度，数位较短的数前面补零，然后从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">int getMax(int arr[], int n) &#123;     int mx &#x3D; arr[0];     for (int i &#x3D; 1; i &lt; n; i++)         if (arr[i] &gt; mx)             mx &#x3D; arr[i];     return mx; &#125; void countSort(int arr[], int n, int exp) &#123;     int output[n];     int i, count[10] &#x3D; &#123;0&#125;;       for (i &#x3D; 0; i &lt; n; i++)         count[ (arr[i]&#x2F;exp)%10 ]++;       for (i &#x3D; 1; i &lt; 10; i++)         count[i] +&#x3D; count[i - 1]; &#x2F;&#x2F;此时count[i]每位数字存放的位置，实际下标还要-1      for (i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#x2F;&#x2F;从后往前保证稳定性    &#123;         output[count[ (arr[i]&#x2F;exp)%10 ] - 1] &#x3D; arr[i];         count[ (arr[i]&#x2F;exp)%10 ]--;     &#125;       for (i &#x3D; 0; i &lt; n; i++)         arr[i] &#x3D; output[i]; &#125;   void radixsort(int arr[], int n) &#123;     int m &#x3D; getMax(arr, n);     for (int exp &#x3D; 1; m&#x2F;exp &gt; 0; exp *&#x3D; 10)         countSort(arr, n, exp); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3><blockquote><p>每次比较相邻两个元素大小，然后交换位置，每次将最大或最小的元素放到最后</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void bubblesort(int arr[],int len)&#123;for(int i&#x3D;0;i&lt;len-1;++i)&#123;for( int j&#x3D;0;j&lt;len-i-1;++j)&#123;if(arr[j]&gt;arr[j+1])&#123;int t&#x3D;arr[j];arr[j]&#x3D;arr[j+1];arr[j+1]&#x3D;t;&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="归并排序merge-sort"><a class="markdownIt-Anchor" href="#归并排序merge-sort"></a> 归并排序（Merge Sort）</h3><blockquote><p>主要思想是分治（Divide and Conquer），将数组不断分成两个部分，对分开的部分比较然后拼接</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void merge(int arr[], int l, int m, int r) &#123;     int i, j, k;     int n1 &#x3D; m - l + 1;     int n2 &#x3D;  r - m;     int L[n1], R[n2];     for (i &#x3D; 0; i &lt; n1; i++)         L[i] &#x3D; arr[l + i];     for (j &#x3D; 0; j &lt; n2; j++)         R[j] &#x3D; arr[m + 1+ j];     i &#x3D; 0;     j &#x3D; 0;     k &#x3D; l;     while (i &lt; n1 &amp;&amp; j &lt; n2)     &#123;         if (L[i] &lt;&#x3D; R[j])         &#123;             arr[k] &#x3D; L[i];             i++;         &#125;         else        &#123;             arr[k] &#x3D; R[j];             j++;         &#125;         k++;     &#125;       while (i &lt; n1)     &#123;         arr[k] &#x3D; L[i];         i++;         k++;     &#125;       while (j &lt; n2)     &#123;         arr[k] &#x3D; R[j];         j++;         k++;     &#125; &#125;   void mergeSort(int arr[], int l, int r) &#123;     if (l &lt; r)     &#123;         int m &#x3D; l+r&gt;&gt;1;         mergeSort(arr, l, m);         mergeSort(arr, m+1, r);         merge(arr, l, m, r);     &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3><blockquote><p>主要是建立小顶堆或者大顶堆，排序的时候，每次取出堆顶元素，然后剩下元素重新建堆，<s>建堆可以直接用STL的make_heap()😄</s></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void heapify(int arr[], int n, int i) &#123;     int maxv &#x3D; i;     int l &#x3D; 2*i + 1;      int r &#x3D; 2*i + 2;     if (l &lt; n &amp;&amp; arr[l] &gt; arr[maxv])         maxv &#x3D; l;     if (r &lt; n &amp;&amp; arr[r] &gt; arr[maxv])         maxv &#x3D; r;     if (maxv !&#x3D; i)     &#123;         swap(arr[i], arr[maxv]);         heapify(arr, n, maxv);     &#125; &#125;void heapsort(int arr[],int len)&#123;    &#x2F;&#x2F;建堆    for(int i&#x3D;len&#x2F;2-1;i&gt;&#x3D;0;--i)        heapify(arr,len;i);    &#x2F;&#x2F;排序    for(int i&#x3D;len-1;i&gt;&#x3D;0;--i)    &#123;        swap(arr[i],a[0]);&#x2F;&#x2F;堆顶放到最后        heapify(arr,i,0);&#x2F;&#x2F;重新调整    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="桶排序bucket-sort"><a class="markdownIt-Anchor" href="#桶排序bucket-sort"></a> 桶排序（Bucket Sort）</h3><blockquote><p>将数组分到有限数量的桶中，再对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">\\该代码只适合正数数组的排序void bucketSort(float arr[], int n) &#123;     vector&lt;float&gt; b[n];     for (int i&#x3D;0; i&lt;n; i++)     &#123;        int bi &#x3D; n*arr[i];        b[bi].push_back(arr[i]);     &#125;     for (int i&#x3D;0; i&lt;n; i++)        sort(b[i].begin(), b[i].end());     int index &#x3D; 0;     for (int i &#x3D; 0; i &lt; n; i++)         for (int j &#x3D; 0; j &lt; b[i].size(); j++)           arr[index++] &#x3D; b[i][j]; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3><blockquote><p>核心思想也是分治，每次选择一个pivot(一般选第一个)，设置左右端点两个指针，每一趟调整将比pivot元素小的值放到左指针位置，比pivot元素大的值放到位置，这样左半部分就小于右半部分，然后递归，分别对左右两个部分进行快排</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">int adjust(int arr[],int l,int r)&#123;int t&#x3D;arr[l];while(l&lt;r)&#123;while(l&lt;r&amp;&amp;arr[r]&gt;&#x3D;t)--r;arr[l]&#x3D;arr[r];while(l&lt;r&amp;&amp;arr[l]&lt;&#x3D;t)++l;arr[r]&#x3D;arr[l];&#125;arr[l]&#x3D;t;return l;&#125;void quicksort(int arr[],int l,int r)&#123;if(l&lt;r)&#123;int pos&#x3D;adjust(arr,l,r);quicksort(arr,l,pos);quicksort(arr,pos+1,r);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日期计算</title>
    <link href="/2022/08/29/%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97/"/>
    <url>/2022/08/29/%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>先来看一道题</p><p>输入一年中的一天，输出这一天是星期几</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">14 October 2001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Sunday<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>用以下公式计算天数：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi>X</mi><mo>−</mo><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>4</mn><mo>−</mo><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>100</mn><mo>+</mo><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>400</mn><mo>+</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">S=X-1+(X-1)/4-(X-1)/100+(X-1)/400+C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></p><p>其中，<code>X</code>是年份，<code>C</code>表示这一天是这一年的第<code>C</code>天</p><p>计算出<code>S</code>后用<code>S%7</code>判断星期几即可</p><p>代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;&#x2F;&#x2F; S&#x3D;X-1+(X-1)&#x2F;4-(X-1)&#x2F;100+(X-1)&#x2F;400+Cbool isrun(int n)&#123;    if(n%4&#x3D;&#x3D;0&amp;&amp;n%100||n%400&#x3D;&#x3D;0)        return true;    return false;&#125;int main()&#123;    int d,y;    string m;    vector&lt;pair&lt;string,int&gt;&gt; mon&#x3D;&#123;&#123;&quot;January&quot;,31&#125;,&#123;&quot;February&quot;,28&#125;,    &#123;&quot;March&quot;,31&#125;,&#123;&quot;April&quot;,30&#125;,&#123;&quot;May&quot;,31&#125;,&#123;&quot;June&quot;,30&#125;,&#123;&quot;July&quot;,31&#125;,    &#123;&quot;August&quot;,31&#125;,&#123;&quot;September&quot;,30&#125;,&#123;&quot;October&quot;,31&#125;,&#123;&quot;November&quot;,30&#125;,                                  &#123;&quot;December&quot;,31&#125;&#125;;    while(cin&gt;&gt;d&gt;&gt;m&gt;&gt;y)    &#123;        int flag&#x3D;0;        if(isrun(y))            flag&#x3D;1;        int sum&#x3D;0;        for(auto it&#x3D;mon.begin();it!&#x3D;mon.end();++it)        &#123;            if(it-&gt;first!&#x3D;m)                   sum+&#x3D;it-&gt;second;            else                break;        &#125;        sum&#x3D;sum+d+flag;        int s&#x3D;y-1+(y-1)&#x2F;4-(y-1)&#x2F;100+(y-1)&#x2F;400+sum;        switch(s%7)        &#123;            case 0:                 cout&lt;&lt;&quot;Sunday&quot;&lt;&lt;endl;                break;            case 1:                 cout&lt;&lt;&quot;Monday&quot;&lt;&lt;endl;                break;            case 2:                 cout&lt;&lt;&quot;Tuesday&quot;&lt;&lt;endl;                break;            case 3:                 cout&lt;&lt;&quot;Wednesday&quot;&lt;&lt;endl;                break;            case 4:                 cout&lt;&lt;&quot;Thursday&quot;&lt;&lt;endl;                break;            case 5:                 cout&lt;&lt;&quot;Friday&quot;&lt;&lt;endl;                break;            case 6:                 cout&lt;&lt;&quot;Saturday&quot;&lt;&lt;endl;                break;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="/2022/08/27/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/08/27/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BA%BF%E6%AE%B5%E6%A0%91">线段树</a><ul><li><a href="#%E9%80%92%E5%BD%92%E5%BB%BA%E6%A0%91">递归建树</a></li></ul></li><li><a href="#%E7%B1%BB%E5%9E%8B%E4%B8%80%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">类型一：单点修改，区间查询</a><ul><li><a href="#%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9">单点修改</a></li><li><a href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">区间查询</a></li><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li></ul></li><li><a href="#%E7%B1%BB%E5%9E%8B%E4%BA%8C%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2">类型二：区间修改，单点查询</a><ul><li><a href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9">区间修改</a></li><li><a href="#%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2">单点查询</a></li><li><a href="#%E4%BE%8B%E9%A2%98-1">例题</a></li></ul></li><li><a href="#%E7%B1%BB%E5%9E%8B%E4%B8%89-%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">类型三： 区间修改，区间查询</a><ul><li><a href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9-1">区间修改</a></li><li><a href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2-1">区间查询</a></li><li><a href="#%E4%BE%8B%E9%A2%98-2">例题</a></li></ul></li></ul><!-- /TOC --><h3 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h3><blockquote><p>能把对区间的修改、查询的时间复杂度由 O(n) 变为 O(logn)</p></blockquote><p>线段树实际上也是一种二叉树，每个节点用一个结构体<code>node</code>保存</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">struct node&#123;int l,r,sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>其中，<code>l</code>和<code>r</code>表示线段的左右端点，<code>sum</code>表示线段的和</p><p>如果用数组存储，一棵二叉树，左孩子下标为<code>2*i</code>，右孩子下标为<code>2*i+1</code><br />因此，每一个节点的<code>sum</code>值为：<code>tree[i].sum=tree[2*i].sum+tree[2*i+1].sum</code></p><h4 id="递归建树"><a class="markdownIt-Anchor" href="#递归建树"></a> 递归建树</h4><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void build(int i,int l,int r)&#123;&#x2F;&#x2F;i:当前节点编号 l:左端点 r:右端点 tree[i].l&#x3D;l;tree[i].r&#x3D;r;&#x2F;&#x2F;如果是叶子节点，赋值并返回 if(l&#x3D;&#x3D;r)&#123;tree[i].sum&#x3D;array[l];return;&#125;int mid&#x3D;(l+r)&#x2F;2;build(2*i,l,mid);&#x2F;&#x2F;建左子树 build(2*i+1,mid+1,r);&#x2F;&#x2F;建右子树 &#x2F;&#x2F;更新线段和 tree[i].sum&#x3D;tree[2*i].sum+tree[2*i+1].sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="类型一单点修改区间查询"><a class="markdownIt-Anchor" href="#类型一单点修改区间查询"></a> 类型一：单点修改，区间查询</h3><p>单点修改：给第<code>idx</code>个数加<code>k</code><br />区间查询：输出区间[x,y]内所有数的和</p><h4 id="单点修改"><a class="markdownIt-Anchor" href="#单点修改"></a> 单点修改</h4><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void mod1(int i,int idx,int k)&#123;if(tree[i].l&#x3D;&#x3D;tree[i].r)&#123;tree[i].sum+&#x3D;k;return;&#125;int mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;if(idx&lt;&#x3D;mid)mod1(2*i,idx,k);elsemod1(2*i+1,idx,k);&#x2F;&#x2F;更新线段和tree[i].sum&#x3D;tree[2*i].sum+tree[2*i+1].sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="区间查询"><a class="markdownIt-Anchor" href="#区间查询"></a> 区间查询</h4><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;区间查询int query1(int i,int l,int r)&#123;&#x2F;&#x2F;如果当前区间完全被查询区间包括，返回当前区间的和 if(tree[i].l&gt;&#x3D;l&amp;&amp;tree[i].r&lt;&#x3D;r)return tree[i].sum;int res&#x3D;0;int mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;&#x2F;&#x2F;如果左孩子区间与查询区间相交，进入左子树 if(l&lt;&#x3D;mid)res+&#x3D;query1(2*i,l,r);&#x2F;&#x2F;如果右孩子区间与查询区间相交，进入右子树if(r&gt;mid)res+&#x3D;query1(2*i+1,l,r); return res;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h4><p><a href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1</a></p><p><strong>题目描述</strong></p><p>如题，已知一个数列，你需要进行下面两种操作：</p><ul><li><p>将某一个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span></p></li><li><p>求出某区间每一个数的和</p></li></ul><p><strong>输入格式</strong></p><p>第一行包含两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span></span></span></span>，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个用空格分隔的整数，其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数字表示数列第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 项的初始值。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 行每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个整数，表示一个操作，具体如下：</p><ul><li><p><code>1 x k</code>  含义：将第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></p></li><li><p><code>2 x y</code>  含义：输出区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 内每个数的和</p></li></ul><p><strong>输出格式</strong></p><p>输出包含若干行整数，即为所有操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的结果。</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">5 51 5 4 2 31 1 32 2 51 3 -11 4 22 1 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">1416<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>【数据范围】</strong></p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">1\le m \le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>；<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>70</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">70\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">7</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1\le n,m \le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>；<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1\le n,m \le 5\times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</p><p>ac代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;5e5+2;int nums[N];struct node&#123;int l,r,sum;&#125;tree[4*N];void build(int i,int l,int r)&#123;&#x2F;&#x2F;i:当前节点编号 l:左端点 r:右端点 tree[i].l&#x3D;l;tree[i].r&#x3D;r;&#x2F;&#x2F;如果是叶子节点，赋值并返回 if(l&#x3D;&#x3D;r)&#123;tree[i].sum&#x3D;nums[l];return;&#125;int mid&#x3D;(l+r)&#x2F;2;build(2*i,l,mid);&#x2F;&#x2F;建左子树 build(2*i+1,mid+1,r);&#x2F;&#x2F;建右子树 &#x2F;&#x2F;更新线段和 tree[i].sum&#x3D;tree[2*i].sum+tree[2*i+1].sum;&#125;&#x2F;&#x2F;单点修改 void mod1(int i,int idx,int k)&#123;if(tree[i].l&#x3D;&#x3D;tree[i].r)&#123;tree[i].sum+&#x3D;k;return;&#125;int mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;if(idx&lt;&#x3D;mid)mod1(2*i,idx,k);elsemod1(2*i+1,idx,k);&#x2F;&#x2F;更新线段和tree[i].sum&#x3D;tree[2*i].sum+tree[2*i+1].sum;&#125;&#x2F;&#x2F;区间查询int query1(int i,int l,int r)&#123;&#x2F;&#x2F;如果当前区间完全被查询区间包括，返回当前区间的和 if(tree[i].l&gt;&#x3D;l&amp;&amp;tree[i].r&lt;&#x3D;r)return tree[i].sum;int res&#x3D;0;int mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;&#x2F;&#x2F;如果左孩子区间与查询区间相交，进入左子树 if(l&lt;&#x3D;mid)res+&#x3D;query1(2*i,l,r);&#x2F;&#x2F;如果右孩子区间与查询区间相交，进入右子树if(r&gt;mid)res+&#x3D;query1(2*i+1,l,r); return res;&#125; int main()&#123;int n,m;cin&gt;&gt;n&gt;&gt;m;for(int i&#x3D;1;i&lt;&#x3D;n;++i)cin&gt;&gt;nums[i];build(1,1,n);int op,a,b;while(m--)&#123;cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;if(op&#x3D;&#x3D;1)mod1(1,a,b);else if(op&#x3D;&#x3D;2)cout&lt;&lt;query1(1,a,b)&lt;&lt;endl;&#125; return 0;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="类型二区间修改单点查询"><a class="markdownIt-Anchor" href="#类型二区间修改单点查询"></a> 类型二：区间修改，单点查询</h3><p>区间修改：给区间<code>[a,b]</code>每个数加k<br />单点查询：查询第<code>x</code>个数的值</p><p>思路：把修改区间所覆盖的区间加k，然后单点查询时从上到下将所有k相加</p><h4 id="区间修改"><a class="markdownIt-Anchor" href="#区间修改"></a> 区间修改</h4><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void mod(int i,int l,int r,int k)&#123;&#x2F;&#x2F;完全在区间内，+k if(l&lt;&#x3D;tree[i].l&amp;&amp;r&gt;&#x3D;tree[i].r)&#123;tree[i].sum+&#x3D;k;return ;&#125;int mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;&#x2F;&#x2F;落在左区间 if(l&lt;&#x3D;mid)mod(2*i,l,r,k);&#x2F;&#x2F;落在右区间 if(r&gt;mid)mod(2*i+1,l,r,k);&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="单点查询"><a class="markdownIt-Anchor" href="#单点查询"></a> 单点查询</h4><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">int query(int i,int x)&#123;&#x2F;&#x2F;从上到下计算所有k的和 if(tree[i].l&#x3D;&#x3D;tree[i].r)return tree[i].sum;int res&#x3D;tree[i].sum;int mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;if(x&lt;&#x3D;mid)res+&#x3D;query(2*i,x);elseres+&#x3D;query(2*i+1,x);return res;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h4><p><a href="https://www.luogu.com.cn/problem/P3368">P3368 树状数组 2</a></p><p><strong>题目描述</strong></p><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li><p>将某区间每一个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>；</p></li><li><p>求出某一个数的值。</p></li></ol><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个用空格分隔的整数，其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数字表示数列第 $i $ 项的初始值。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>个整数，表示一个操作，具体如下：</p><p>操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>： 格式：<code>1 x y k</code> 含义：将区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 内每个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>；</p><p>操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>： 格式：<code>2 x</code> 含义：输出第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 个数的值。</p><p><strong>输出格式</strong></p><p>输出包含若干行整数，即为所有操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的结果。</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">5 51 5 4 2 31 2 4 2#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;5e5+2;int nums[N];struct node&#123;int l,r,sum;&#125;tree[4*N];void build(int i,int l,int r)&#123;tree[i].l&#x3D;l;tree[i].r&#x3D;r;tree[i].sum&#x3D;0; &#x2F;&#x2F;如果是叶子节点，赋值并返回 if(l&#x3D;&#x3D;r)return; int mid&#x3D;(l+r)&#x2F;2;build(2*i,l,mid);&#x2F;&#x2F;建左子树 build(2*i+1,mid+1,r);&#x2F;&#x2F;建右子树 &#125;&#x2F;&#x2F;区间修改void mod(int i,int l,int r,int k)&#123;&#x2F;&#x2F;完全在区间内，+k if(l&lt;&#x3D;tree[i].l&amp;&amp;r&gt;&#x3D;tree[i].r)&#123;tree[i].sum+&#x3D;k;return ;&#125;int mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;&#x2F;&#x2F;落在左区间 if(l&lt;&#x3D;mid)mod(2*i,l,r,k);&#x2F;&#x2F;落在右区间 if(r&gt;mid)mod(2*i+1,l,r,k);&#125; &#x2F;&#x2F;单点查询int query(int i,int x)&#123;&#x2F;&#x2F;从上到下计算所有k的和 if(tree[i].l&#x3D;&#x3D;tree[i].r)return tree[i].sum;int res&#x3D;tree[i].sum;int mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;if(x&lt;&#x3D;mid)res+&#x3D;query(2*i,x);elseres+&#x3D;query(2*i+1,x);return res;&#125; int main()&#123;int n,m;cin&gt;&gt;n&gt;&gt;m;for(int i&#x3D;1;i&lt;&#x3D;n;++i)cin&gt;&gt;nums[i];build(1,1,n);int op,a,b,c;while(m--)&#123;cin&gt;&gt;op;if(op&#x3D;&#x3D;1)&#123;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;mod(1,a,b,c);&#125;else if(op&#x3D;&#x3D;2)&#123;cin&gt;&gt;a;cout&lt;&lt;query(1,a)+nums[a]&lt;&lt;endl; &#125;&#125; return 0;&#125; 2 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">610<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>数据规模与约定</strong></p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">N\le8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">M\le10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>；</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>70</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">70\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">7</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">N\le 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">M\le10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>；</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo separator="true">,</mo><mi>M</mi><mo>≤</mo><mn>500000</mn></mrow><annotation encoding="application/x-tex">1 \leq N, M\le 500000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \leq x, y \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，保证任意时刻序列中任意元素的绝对值都不大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>。</p><p>ac代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;5e5+2;int nums[N];struct node&#123;int l,r,sum;&#125;tree[4*N];void build(int i,int l,int r)&#123;tree[i].l&#x3D;l;tree[i].r&#x3D;r;tree[i].sum&#x3D;0; &#x2F;&#x2F;如果是叶子节点，赋值并返回 if(l&#x3D;&#x3D;r)return; int mid&#x3D;(l+r)&#x2F;2;build(2*i,l,mid);&#x2F;&#x2F;建左子树 build(2*i+1,mid+1,r);&#x2F;&#x2F;建右子树 &#125;&#x2F;&#x2F;区间修改void mod(int i,int l,int r,int k)&#123;&#x2F;&#x2F;完全在区间内，+k if(l&lt;&#x3D;tree[i].l&amp;&amp;r&gt;&#x3D;tree[i].r)&#123;tree[i].sum+&#x3D;k;return ;&#125;int mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;&#x2F;&#x2F;落在左区间 if(l&lt;&#x3D;mid)mod(2*i,l,r,k);&#x2F;&#x2F;落在右区间 if(r&gt;mid)mod(2*i+1,l,r,k);&#125; &#x2F;&#x2F;单点查询int query(int i,int x)&#123;&#x2F;&#x2F;从上到下计算所有k的和 if(tree[i].l&#x3D;&#x3D;tree[i].r)return tree[i].sum;int res&#x3D;tree[i].sum;int mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;if(x&lt;&#x3D;mid)res+&#x3D;query(2*i,x);elseres+&#x3D;query(2*i+1,x);return res;&#125; int main()&#123;int n,m;cin&gt;&gt;n&gt;&gt;m;for(int i&#x3D;1;i&lt;&#x3D;n;++i)cin&gt;&gt;nums[i];build(1,1,n);int op,a,b,c;while(m--)&#123;cin&gt;&gt;op;if(op&#x3D;&#x3D;1)&#123;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;mod(1,a,b,c);&#125;else if(op&#x3D;&#x3D;2)&#123;cin&gt;&gt;a;cout&lt;&lt;query(1,a)+nums[a]&lt;&lt;endl; &#125;&#125; return 0;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="类型三-区间修改区间查询"><a class="markdownIt-Anchor" href="#类型三-区间修改区间查询"></a> 类型三： 区间修改，区间查询</h3><p>需要定义一个懒标记，然后每次修改或查询需要进行<code>pushdown</code></p><p>pushdown步骤：</p><ul><li>当前节点懒标记不为0时，给左右子节点的懒标记加上父亲的懒标记</li><li>更新左右子节点的sum</li><li>父节点的懒标记置0</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void pushdown(int i)&#123;if(tree[i].lz)&#123;tree[2*i].lz+&#x3D;tree[i].lz;tree[2*i+1].lz+&#x3D;tree[i].lz;int mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;tree[2*i].sum+&#x3D;tree[i].lz*(mid-tree[i].l+1);tree[2*i+1].sum+&#x3D;tree[i].lz*(tree[i].r-mid);tree[i].lz&#x3D;0;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="区间修改-2"><a class="markdownIt-Anchor" href="#区间修改-2"></a> 区间修改</h4><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void mod(int i,int l,int r,int k)&#123;&#x2F;&#x2F;区间被完全包括，更新sum，lz if(l&lt;&#x3D;tree[i].l&amp;&amp;r&gt;&#x3D;tree[i].r)&#123;tree[i].sum+&#x3D;k*(tree[i].r-tree[i].l+1);tree[i].lz+&#x3D;k;return;&#125;pushdown(i);int mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;if(l&lt;&#x3D;mid)mod(2*i,l,r,k);if(r&gt;mid)mod(2*i+1,l,r,k);&#x2F;&#x2F;更新和tree[i].sum&#x3D;tree[2*i].sum +tree[2*i+1].sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="区间查询-2"><a class="markdownIt-Anchor" href="#区间查询-2"></a> 区间查询</h4><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">int query(int i,int l,int r)&#123;&#x2F;&#x2F;区间被完全包括，返回sum if(l&lt;&#x3D;tree[i].l&amp;&amp;r&gt;&#x3D;tree[i].r)return tree[i].sum;pushdown(i);int mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;int res&#x3D;0;if(l&lt;&#x3D;mid)res+&#x3D;query(2*i,l,r);if(r&gt;mid)res+&#x3D;query(2*i+1,l,r);return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="例题-3"><a class="markdownIt-Anchor" href="#例题-3"></a> 例题</h4><p><a href="https://www.luogu.com.cn/problem/P3372">P3372【模板】线段树 1</a></p><p><strong>题目描述</strong></p><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</li><li>求出某区间每一个数的和。</li></ol><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n, m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span></span></span></span>，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个用空格分隔的整数，其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数字表示数列第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 项的初始值。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 行每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个整数，表示一个操作，具体如下：</p><ol><li><code>1 x y k</code>：将区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x, y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 内每个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</li><li><code>2 x y</code>：输出区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x, y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 内每个数的和。</li></ol><p><strong>输出格式</strong><br />输出包含若干行整数，即为所有操作 2 的结果。</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">5 51 5 4 2 32 2 41 2 3 22 3 41 1 5 12 1 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">11820<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>提示</strong></p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">n \le 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">m \le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>。<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>70</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">70\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">7</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><msup><mn>10</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n \le {10}^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.848448em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">0</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.848448em;"><span style="top:-3.09734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><msup><mn>10</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">m \le {10}^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.848448em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">0</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.848448em;"><span style="top:-3.09734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>。<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \le n, m \le {10}^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.848448em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">0</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.848448em;"><span style="top:-3.09734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</p><p>保证任意时刻数列中所有元素的绝对值之和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>10</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">\le {10}^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.848448em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">0</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.848448em;"><span style="top:-3.09734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>。</p><p>ac代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int N&#x3D;1e5+2;int nums[N];struct node&#123;ll l,r,sum,lz;&#125;tree[4*N];void build(int i,int l,int r)&#123; tree[i].l&#x3D;l;tree[i].r&#x3D;r;tree[i].lz&#x3D;0;&#x2F;&#x2F;如果是叶子节点，赋值并返回 if(l&#x3D;&#x3D;r)&#123;tree[i].sum&#x3D;nums[l];return;&#125;ll mid&#x3D;(l+r)&#x2F;2;build(2*i,l,mid);&#x2F;&#x2F;建左子树 build(2*i+1,mid+1,r);&#x2F;&#x2F;建右子树 &#x2F;&#x2F;更新线段和 tree[i].sum&#x3D;tree[2*i].sum+tree[2*i+1].sum;&#125;void pushdown(int i)&#123;if(tree[i].lz)&#123;tree[2*i].lz+&#x3D;tree[i].lz;tree[2*i+1].lz+&#x3D;tree[i].lz;ll mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;tree[2*i].sum+&#x3D;tree[i].lz*(mid-tree[i].l+1);tree[2*i+1].sum+&#x3D;tree[i].lz*(tree[i].r-mid);tree[i].lz&#x3D;0;&#125;&#125;void mod(int i,int l,int r,int k)&#123;&#x2F;&#x2F;区间被完全包括，更新sum，lz if(l&lt;&#x3D;tree[i].l&amp;&amp;r&gt;&#x3D;tree[i].r)&#123;tree[i].sum+&#x3D;k*(tree[i].r-tree[i].l+1);tree[i].lz+&#x3D;k;return;&#125;pushdown(i);ll mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;if(l&lt;&#x3D;mid)mod(2*i,l,r,k);if(r&gt;mid)mod(2*i+1,l,r,k);&#x2F;&#x2F;更新和tree[i].sum&#x3D;tree[2*i].sum +tree[2*i+1].sum;&#125;ll query(int i,int l,int r)&#123;&#x2F;&#x2F;区间被完全包括，返回sum if(l&lt;&#x3D;tree[i].l&amp;&amp;r&gt;&#x3D;tree[i].r)return tree[i].sum;pushdown(i);ll mid&#x3D;tree[i].l+tree[i].r&gt;&gt;1;ll res&#x3D;0;if(l&lt;&#x3D;mid)res+&#x3D;query(2*i,l,r);if(r&gt;mid)res+&#x3D;query(2*i+1,l,r);return res;&#125;int main()&#123;int n,m;cin&gt;&gt;n&gt;&gt;m;for(int i&#x3D;1;i&lt;&#x3D;n;++i)cin&gt;&gt;nums[i];build(1,1,n);int op,a,b,c;while(m--)&#123;cin&gt;&gt;op;if(op&#x3D;&#x3D;1)&#123;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;mod(1,a,b,c);&#125;else if(op&#x3D;&#x3D;2)&#123;cin&gt;&gt;a&gt;&gt;b;cout&lt;&lt;query(1,a,b)&lt;&lt;endl;&#125;&#125; return 0;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进制转换与大阶乘</title>
    <link href="/2022/08/27/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%A4%A7%E9%98%B6%E4%B9%98/"/>
    <url>/2022/08/27/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%A4%A7%E9%98%B6%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li></ul></li><li><a href="#%E5%A4%A7%E9%98%B6%E4%B9%98">大阶乘</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-1">题目</a></li></ul></li></ul><!-- /TOC --><h3 id="进制转换"><a class="markdownIt-Anchor" href="#进制转换"></a> 进制转换</h3><blockquote><p>下面的模板可用于36以内进制任意转换</p></blockquote><h4 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h4><p>将M进制的数X转换为N进制的数输出。<br />输入的第一行包括两个整数：M和N(2&lt;=M,N&lt;=36)。<br />下面的一行输入一个数X，X是M进制的数，现在要求你将M进制的数X转换成N进制的数输出。</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">36 9XYZZA765<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">10374545654665<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;string convert(string s,int a,int b)&#123;    int len&#x3D;s.size();    int i&#x3D;0;    string res;    while(i&lt;len)    &#123;#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int a[100000];int main()&#123;    int n;    cin&gt;&gt;n;     int ws&#x3D;1;    a[0]&#x3D;1;    for(int i&#x3D;2;i&lt;&#x3D;n;++i)    &#123;        int k&#x3D;0;        for(int j&#x3D;0;j&lt;ws;++j)        &#123;            int t&#x3D;i*a[j]+k;            k&#x3D;t&#x2F;10;            a[j]&#x3D;t%10;        &#125;        while(k)        &#123;            a[ws]&#x3D;k%10;            k&#x2F;&#x3D;10;            ++ws;        &#125;    &#125;    for(int i&#x3D;ws-1;i&gt;&#x3D;0;--i)        cout&lt;&lt;a[i];    return 0;&#125;)        &#123;            if(s[j]&gt;&#x3D;&#39;0&#39;&amp;&amp;s[j]&lt;&#x3D;&#39;9&#39;)                tmp1&#x3D;s[j]-&#39;0&#39;;            else                tmp1&#x3D;s[j]-&#39;A&#39;+10;            int t&#x3D;k*a+tmp1;            k&#x3D;t%b;            tmp2&#x3D;t&#x2F;b;            if(tmp2&lt;&#x3D;9)                s[j]&#x3D;tmp2+&#39;0&#39;;            else                s[j]&#x3D;tmp2-10+&#39;A&#39;;                    &#125;        if(k&lt;&#x3D;9)            res+&#x3D;k+&#39;0&#39;;        else            res+&#x3D;k-10+&#39;A&#39;;        while(s[i]&#x3D;&#x3D;&#39;0&#39;)            ++i;    &#125;    reverse(res.begin(),res.end());    return res;&#125;int main()&#123;    int m,n;    string s;    cin&gt;&gt;m&gt;&gt;n;    cin&gt;&gt;s;    cout&lt;&lt;convert(s,m,n)&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="大阶乘"><a class="markdownIt-Anchor" href="#大阶乘"></a> 大阶乘</h3><h4 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h4><p>输入一个正整数N，输出N的阶乘<br />N&lt;=1000</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">1000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int a[100000];int main()&#123;    int n;    cin&gt;&gt;n;     int ws&#x3D;1;    a[0]&#x3D;1;    for(int i&#x3D;2;i&lt;&#x3D;n;++i)    &#123;        int k&#x3D;0;        for(int j&#x3D;0;j&lt;ws;++j)        &#123;            int t&#x3D;i*a[j]+k;            k&#x3D;t&#x2F;10;            a[j]&#x3D;t%10;        &#125;        while(k)        &#123;            a[ws]&#x3D;k%10;            k&#x2F;&#x3D;10;            ++ws;        &#125;    &#125;    for(int i&#x3D;ws-1;i&gt;&#x3D;0;--i)        cout&lt;&lt;a[i];    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常见问题</title>
    <link href="/2022/08/26/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/26/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#c%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97">c++中的static关键字</a></li><li><a href="#c%E6%A8%A1%E6%9D%BF">c++模板</a></li><li><a href="#c%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB">c++深拷贝和浅拷贝的区别</a></li><li><a href="#c%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">c++智能指针</a></li></ul><!-- /TOC --><h2 id="c中的static关键字"><a class="markdownIt-Anchor" href="#c中的static关键字"></a> c++中的static关键字</h2><p>加载顺序（面向对象）</p><ul><li>静态-&gt;非静态-&gt;构造方法</li><li>父类静态-子类静态-父类非静态-父类构造-子类非静态-子类构造</li></ul><p>静态成员变量(面向对象)</p><ul><li>所有对象共享,不属于某个对象，可以通过类名访问，也可通过对象访问</li><li>在编译阶段分配内存，分配在数据区（全局区）</li><li>类内声明，类外初始化(class::var)</li><li>sizeof不会计算静态成员变量</li></ul><p>静态成员函数(面向对象)</p><ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul><p>静态全局变量(面向过程)</p><ul><li>在数据区分配内存</li><li>未初始化会自动初始化为0</li><li>整个文件内可见，文件外不可见</li></ul><p>静态局部变量(面向过程)</p><ul><li>在数据区分配内存</li><li>一般在声明处初始化，未初始化会自动初始化为0</li><li>静态局部变量始终驻留在数据区，但他的作用域是局部作用域，当定义它的函数或语句块结束，其作用域随之结束</li></ul><blockquote><p>总结：静态变量具有全局变量的生命周期，但只能作用于自己的作用域。</p></blockquote><hr /><h2 id="c模板"><a class="markdownIt-Anchor" href="#c模板"></a> c++模板</h2><blockquote><p>模板是c++泛型编程的主要使用的技术</p></blockquote><p><strong>函数模板</strong></p><p>创建一个通用的函数，函数返回值类型和形参可以不指定，用一个虚拟的类型来表示</p><p>声明一个模板<code>template&lt;typename T&gt;</code>或者<code>template&lt;class T&gt;</code></p><p>示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt;T sum(T a,T b)&#123;return a+b;&#125;int main()&#123;double a&#x3D;10.5,b&#x3D;20.00002;cout&lt;&lt;&quot;自动类型推导&quot;&lt;&lt;endl;printf(&quot;%lf\n&quot;,sum(a,b));cout&lt;&lt;&quot;显示指定类型&quot;&lt;&lt;endl;printf(&quot;%lf&quot;,sum&lt;double&gt;(a,b));return 0;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>注意</p><ul><li>自动推导类型需要推导出一致的类型</li><li>函数模板使用时必须确定<code>T</code>的类型</li><li>普通函数和函数模板都可调用时，先调用普通函数</li><li>如果类型和函数模板更匹配，则优先调用函数模板</li></ul><p><strong>类模板</strong></p><p>示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;class T,class M&gt;class person&#123;public:T name;M age;person(T a,M b):name(a),age(b)&#123;&#125;&#125;;int main()&#123;person&lt;string,int&gt; p(&quot;cndh&quot;,18);cout&lt;&lt;p.name&lt;&lt;endl;cout&lt;&lt;p.age&lt;&lt;endl;return 0;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>注意：</p><ul><li>类模板不能自动推导类型</li><li>类模板可以在模板参数列表中指定默认类型</li><li>类模板中定义的函数在调用时才创建</li></ul><hr /><h2 id="c深拷贝和浅拷贝的区别"><a class="markdownIt-Anchor" href="#c深拷贝和浅拷贝的区别"></a> c++深拷贝和浅拷贝的区别</h2><blockquote><p><strong>浅拷贝</strong> （默认方式）：将原对象的引用直接赋给新对象，只是原对象的一个引用。</p></blockquote><blockquote><p><strong>深拷贝</strong>： 创建一个新的对象，将原对象的各项属性拷贝过来，深拷贝会在堆中额外申请内存来储存数据，当数据成员中有指针时，必须要用深拷贝。</p></blockquote><ul><li>因为申请了新的内存，所以深拷贝改变新对象的属性对原对象没有影响，但是浅拷贝会影响</li><li>当成员中有指针时，必须用深拷贝。因为浅拷贝的新指针和旧指针都指向同一块内存，在新对象和旧对象析构时，已经释放的内存会被再次释放，这时会出现错误。</li></ul><hr /><h2 id="c智能指针"><a class="markdownIt-Anchor" href="#c智能指针"></a> c++智能指针</h2><p><strong>内存泄漏</strong>：</p><ul><li><p>指因某些原因造成程序未能释放已不再使用的内存。内存泄漏并不是内存消失了，而是由于程序设计的问题，失去对某块内存的控制，导致无法利用该块内存。</p></li><li><p>内存泄漏会导致程序响应越来越慢，甚至崩溃</p></li><li><p>一般有2种内存泄漏，一种是堆区分配的内存没有及时释放，一种是套接字、文件描述符等没有释放，2种情形都会导致资源的浪费</p></li></ul><p><strong>RALL</strong></p><ul><li>RAII（Resource Acquisition Is Initialization）是一种将对象生命周期和资源绑定的技术</li><li>对象创建时获取资源，析构时释放资源</li></ul><p>智能指针就具有RALL的特性</p><p><strong>auto_ptr</strong></p><p>c++98中就已经提供了智能指针auto_ptr</p><p>例如：<code>auto_ptr&lt;int&gt; p(new int)</code>就相当于 <code>int * p=new int</code></p><p>auto_ptr的局限性：</p><ul><li>拷贝或者赋值会导致原指针变为<code>NULL</code>，如<code>p1=p2</code>后，<code>p2变成了NULL</code></li><li>不支持对象数组的内存管理</li></ul><p><strong>unique_ptr</strong></p><p>不能直接进行赋值或者拷贝构造，如：<code>p1 = p2</code>和<code>unique_ptr&lt;int&gt; p1(p2)</code></p><p>如果要强行执行的话要加上<code>move</code>，如：<code>p1 = std::move(p2)</code>和<code>unique_ptr&lt;int&gt; p1(std::move(p2))</code></p><p><strong>shared_ptr</strong></p><p>通过<strong>引用计数</strong>(<code>use_count()</code>)的方式来实现多个<code>shared_ptr</code>对象之间共享资源</p><ul><li>shared_ptr在其内部，给每个资源都有一份计数表，用来记录该份资源被几个指针共享</li><li>在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一</li><li>如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源</li><li>如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了</li></ul><p>注意：两个对象交叉使用<strong>shared_ptr</strong>(互相获得对方的share指针),会导致内存泄漏</p><p><strong>weak_ptr</strong></p><p>专门为了解决上面的<strong>shared_ptr</strong>的问题，不支持RALL，不释放资源，不增加或减少引用计数</p><p>具体参考<a href="https://blog.csdn.net/cpp_learner/article/details/118912592?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166191088916782414982504%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166191088916782414982504&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118912592-null-null.142%5Ev42%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=c%2B%2B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4187">相关链接</a></p><hr />]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/08/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/08/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a></li><li><a href="#%E9%80%92%E5%BD%92%E7%9A%84%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9%E7%9A%84%E7%A5%96%E5%85%88">递归的查找节点的祖先</a></li><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li></ul><!-- /TOC --><h3 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h3><blockquote><p>通过一个数组来保存各个节点的祖先，所有连通的节点的祖先相同，常用于解决最小生成树，图的连通性等问题</p></blockquote><h3 id="递归的查找节点的祖先"><a class="markdownIt-Anchor" href="#递归的查找节点的祖先"></a> 递归的查找节点的祖先</h3><p>首先假设有<code>N</code>个节点，定义一个数组<code>vset[N]</code>记录所有节点的祖先，<code>vset[N]初始化为-1</code></p><p>定义一个<code>find</code>函数来查找祖先</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">int find(int a)&#123;    if(vset[a]&#x3D;&#x3D;-1)        return a;    else    &#123;        vset[a]&#x3D;find(vset[a]);        return vset[a];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p>有<code>n</code>条道路，<code>m</code>个村庄,计算出使所有村庄连通的最低成本</p><p>输入n,m，然后输入n行，每一行输入u,v,w表示两个村庄的编号和道路成本</p><p>输出使所有村庄连通的最低成本</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">3 31 2 11 3 22 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;1000;typedef vector&lt;int&gt; vi;int vset[1000];vector&lt;vi&gt; e(1000,vi(3));int find(int a)&#123;    if(vset[a]&#x3D;&#x3D;-1)        return a;    else    &#123;        vset[a]&#x3D;find(vset[a]);        return vset[a];    &#125;&#125;int main()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    memset(vset,-1,sizeof(vset));    for(int i&#x3D;1;i&lt;&#x3D;n;++i)    &#123;        cin&gt;&gt;e[i][0]&gt;&gt;e[i][1]&gt;&gt;e[i][2];    &#125;    sort(e.begin(),e.end(),[](vi a,vi b)&#123;        return a[2]&lt;b[2];    &#125;);    int ans&#x3D;0,cnt&#x3D;0;    for(vi&amp; t: e)    &#123;        int x&#x3D;find(t[0]);        int y&#x3D;find(t[1]);        if(x!&#x3D;y)        &#123;            ++cnt;            ans+&#x3D;t[2];            vset[x]&#x3D;y;            if(cnt&#x3D;&#x3D;n-1)                break;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重排链表</title>
    <link href="/2022/08/25/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/08/25/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8">重排链表</a></li><li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">反转链表</a></li><li><a href="#%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8">合并链表</a></li><li><a href="#%E9%A2%98%E8%A7%A3">题解</a></li></ul><!-- /TOC --><h3 id="重排链表"><a class="markdownIt-Anchor" href="#重排链表"></a> 重排链表</h3><blockquote><p>来源于leetcode上的一道题 <a href="https://leetcode.cn/problems/reorder-list/">重排链表</a>，因为这到题涉及到许多链表的知识，正好拿来复习一下</p></blockquote><p>题目描述</p><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：<br /><code>L0 → L1 → … → Ln - 1 → Ln</code></p><p>请将其重新排列后变为：</p><p><code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</code></p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><ul><li>先找到链表的中点</li><li>将链表后半段反转</li><li>将前后两端重新合并</li></ul><h3 id="找到链表中点快慢指针"><a class="markdownIt-Anchor" href="#找到链表中点快慢指针"></a> 找到链表中点（快慢指针）</h3><blockquote><p>设置两个指针，其中快的指针每次移动2次，慢指针移动一次，当快指针到达尾部，慢指针的位置就是中点</p></blockquote><p>代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">ListNode* middleNode(ListNode* head) &#123;        ListNode *low&#x3D;head;        ListNode *fast&#x3D;head;        &#x2F;&#x2F;如果有偶数个节点，以下条件找到的是右侧中点        &#x2F;&#x2F;如果要找左侧中点，改为：fast-&gt;next!&#x3D;NULL&amp;&amp;fast-&gt;next-&gt;next!&#x3D;NULL即可        while(fast!&#x3D;NULL&amp;&amp;fast-&gt;next!&#x3D;NULL)        &#123;            low&#x3D;low-&gt;next;            fast&#x3D;fast-&gt;next-&gt;next;        &#125;        return low;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h3><blockquote><p>其实反转链表可以用线性表做，时间复杂度差不多，但这里还是回归链表操作</p></blockquote><p>代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">ListNode* reverseList(ListNode* head) &#123;        ListNode* pre&#x3D;NULL;        ListNode* l&#x3D;head;        while(l!&#x3D;NULL)        &#123;            ListNode* tmp&#x3D;l-&gt;next;            l-&gt;next&#x3D;pre;            pre&#x3D;l;            l&#x3D;tmp;        &#125;        return pre;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="合并链表"><a class="markdownIt-Anchor" href="#合并链表"></a> 合并链表</h3><blockquote><p>将l1和l2交错合并</p></blockquote><p>代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void merge(ListNode* l1,ListNode* l2)&#123;    while(l1!&#x3D;NULL&amp;&amp;l2!&#x3D;NULL)    &#123;        ListNode* l1t&#x3D;l1-&gt;next;        ListNode* l2t&#x3D;l2-&gt;next;        l1-&gt;next&#x3D;l2;        l1&#x3D;l1t;        l2-&gt;next&#x3D;l1;        l2&#x3D;l2t;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void reorderList(ListNode* head) &#123;    ListNode* mid&#x3D;middleNode(head);    ListNode* l1&#x3D;head;    ListNode* l2&#x3D;mid-&gt;next;    mid-&gt;next&#x3D;NULL;    ListNode* r&#x3D;reverseList(l2);    merge(l1,r);&#125;ListNode* reverseList(ListNode* head) &#123;    ListNode* pre&#x3D;NULL;    ListNode* l&#x3D;head;    while(l!&#x3D;NULL)    &#123;        ListNode* tmp&#x3D;l-&gt;next;        l-&gt;next&#x3D;pre;        pre&#x3D;l;        l&#x3D;tmp;    &#125;    return pre;&#125;ListNode* middleNode(ListNode* head) &#123;    ListNode *low&#x3D;head;    ListNode *fast&#x3D;head;    while(fast-&gt;next!&#x3D;NULL&amp;&amp;fast-&gt;next-&gt;next!&#x3D;NULL)    &#123;        low&#x3D;low-&gt;next;        fast&#x3D;fast-&gt;next-&gt;next;    &#125;    return low;&#125;void merge(ListNode* l1,ListNode* l2)&#123;        while(l1!&#x3D;NULL&amp;&amp;l2!&#x3D;NULL)    &#123;        ListNode* l1t&#x3D;l1-&gt;next;        ListNode* l2t&#x3D;l2-&gt;next;        l1-&gt;next&#x3D;l2;        l1&#x3D;l1t;        l2-&gt;next&#x3D;l1;        l2&#x3D;l2t;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>差分与前缀和</title>
    <link href="/2022/08/24/%E5%B7%AE%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2022/08/24/%E5%B7%AE%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%89%8D%E7%BC%80%E5%92%8C">前缀和</a></li><li><a href="#%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">一维前缀和</a></li><li><a href="#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">二维前缀和</a></li><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li><li><a href="#%E5%B7%AE%E5%88%86">差分</a></li><li><a href="#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86">一维差分</a></li><li><a href="#%E4%BE%8B%E9%A2%98-1">例题</a></li><li><a href="#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86">二维差分</a></li><li><a href="#%E4%BE%8B%E9%A2%98-2">例题</a></li></ul><!-- /TOC --><h3 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h3><blockquote><p>前缀和指的是序列的前n项和</p></blockquote><h3 id="一维前缀和"><a class="markdownIt-Anchor" href="#一维前缀和"></a> 一维前缀和</h3><p>先看一个例题：<br />输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。<br />如果使用暴力枚举，时间复杂度为 <code>O(n*m)</code>,但是使用前缀和的话，时间复杂度可降为 <code>O(n)</code><br />input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">5 32 1 3 6 41 21 32 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">3610<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;1e5;int a[N]; int main()&#123;int n,m,l,r;cin&gt;&gt;n&gt;&gt;m;for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;cin&gt;&gt;a[i];a[i]+&#x3D;a[i-1];&#125;while(m--)&#123;cin&gt;&gt;l&gt;&gt;r;cout&lt;&lt;a[r]-a[l-1]&lt;&lt;endl;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="二维前缀和"><a class="markdownIt-Anchor" href="#二维前缀和"></a> 二维前缀和</h3><p>每一个元素<code>a[i][j]</code>表示左上角和第<code>i</code>行，第<code>j</code>列围成的元素之和</p><p>更新方式： <code>a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]</code></p><p>即下图中：紫色区域+绿色区域-红色区域</p><p><img src="https://img-blog.csdnimg.cn/20201214201734653.png" alt="" /></p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p>输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。<br />对于每个询问输出子矩阵中所有数的和</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">3 4 31 7 2 43 6 2 82 1 2 31 1 2 22 1 3 41 3 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">172721<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;1e3;int a[N][N]; int main()&#123;int n,m,q;int x1,y1,x2,y2;cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;for(int j&#x3D;1;j&lt;&#x3D;m;++j)&#123;cin&gt;&gt;a[i][j];a[i][j]+&#x3D;a[i-1][j]+a[i][j-1]-a[i-1][j-1];&#125;&#125;while(q--)&#123;cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;cout&lt;&lt;a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1]&lt;&lt;endl;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="差分"><a class="markdownIt-Anchor" href="#差分"></a> 差分</h3><blockquote><p>可以看作前缀和的逆运算</p></blockquote><h3 id="一维差分"><a class="markdownIt-Anchor" href="#一维差分"></a> 一维差分</h3><p>常用于给数组的某个区间段<code>[l,r]</code>加上某个数<code>c</code>，可以减小时间复杂度</p><ul><li>先构造差分数组：<code>b[i]=a[i]-a[i-1]</code></li><li>构造好之后 <code>b[l]+=c</code>,<code>b[r+1]-=c</code></li><li>然后根据<code>b[i]+=b[i-1]</code>计算前缀和数组，就是最终答案</li></ul><h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3><p>输入一个长度为n的整数序列。<br />接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。<br />请你输出进行完所有操作后的序列。</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">6 31 2 2 1 2 11 3 13 5 11 6 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">3 4 5 3 4 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;1e3;int a[N],b[N]; int main()&#123;int n,m,l,r,c;cin&gt;&gt;n&gt;&gt;m;for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;cin&gt;&gt;a[i];b[i]&#x3D;a[i]-a[i-1];&#125;while(m--)&#123;cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;b[l]+&#x3D;c;b[r+1]-&#x3D;c;&#125;for(int i&#x3D;1;i&lt;&#x3D;n;++i)b[i]+&#x3D;b[i-1];for(int i&#x3D;1;i&lt;&#x3D;n;++i)cout&lt;&lt;b[i]&lt;&lt;&#39; &#39;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="二维差分"><a class="markdownIt-Anchor" href="#二维差分"></a> 二维差分</h3><p>常用于给某个子矩阵的每个元素加上 c</p><ul><li>二维差分数组的构造：<br /><code>b[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]</code></li><li>修改差分数组：  <figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">b[x1][y1]+&#x3D;c;b[x1][y2+1]-&#x3D;c;b[x2+1][y1]-&#x3D;c;b[x2+1][y2+1]+&#x3D;c;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li><li>生成前缀和数组：<br /><code>b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];</code></li></ul><h3 id="例题-3"><a class="markdownIt-Anchor" href="#例题-3"></a> 例题</h3><p>输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。<br />每个操作都要将选中的子矩阵中的每个元素的值加上c。<br />请你将进行完所有操作后的矩阵输出。</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">3 4 31 2 2 13 2 2 11 1 1 11 1 2 2 11 3 2 3 23 1 3 4 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">2 3 4 14 3 4 12 2 2 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;1e3;int a[N][N],b[N][N]; int main()&#123;int n,m,q;int x1,y1,x2,y2,c;cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;for(int j&#x3D;1;j&lt;&#x3D;m;++j)&#123;cin&gt;&gt;a[i][j];b[i][j]&#x3D;a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1];&#125;&#125;while(q--)&#123;cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;b[x1][y1]+&#x3D;c;b[x1][y2+1]-&#x3D;c;b[x2+1][y1]-&#x3D;c;b[x2+1][y2+1]+&#x3D;c;&#125;for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;for(int j&#x3D;1;j&lt;&#x3D;m;++j)b[i][j]+&#x3D;b[i-1][j]+b[i][j-1]-b[i-1][j-1];&#125;for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;for(int j&#x3D;1;j&lt;&#x3D;m;++j)cout&lt;&lt;b[i][j]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速幂矩阵幂</title>
    <link href="/2022/08/23/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9F%A9%E9%98%B5%E5%B9%82/"/>
    <url>/2022/08/23/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9F%A9%E9%98%B5%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BE%8B1-%E5%BF%AB%E9%80%9F%E5%B9%82">例1 快速幂</a></li><li><a href="#%E4%BE%8B2-%E7%9F%A9%E9%98%B5%E5%B9%82">例2 矩阵幂</a></li></ul><!-- /TOC --><blockquote><p><strong>快速幂</strong> 快速幂常用于计算指数非常大的幂，核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。</p></blockquote><p><em>直接看例题</em></p><h3 id="例1-快速幂"><a class="markdownIt-Anchor" href="#例1-快速幂"></a> 例1 快速幂</h3><p>输入三个数字a,b,c,输出 a^b <strong>mod</strong> c<br />input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">2 10 10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int a,b,c;int ksm()&#123;int ans&#x3D;1;a&#x3D;a%c;while(b&gt;0)&#123;if(b%2)ans&#x3D;(ans*a)%c;a&#x3D;(a*a)%c;b&#x2F;&#x3D;2;&#125;return ans;&#125;int main()&#123;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;cout&lt;&lt;ksm()&lt;&lt;endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="例2-矩阵幂"><a class="markdownIt-Anchor" href="#例2-矩阵幂"></a> 例2 矩阵幂</h3><p>描述<br />给定一个n*n的矩阵，输出矩阵的k次方</p><p>输入描述<br />有多组输入，第一行输入n和k<br />后面n行输入矩阵元素<br />2&lt;=n&lt;=10,1&lt;=k&lt;=5<br />输出描述<br />每组输入输出矩阵的k次方<br />input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">2 29 89 33 34 8 49 3 03 5 75 24 0 3 0 10 0 5 8 58 9 8 5 39 6 1 7 87 2 5 7 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">153 96108 811216 1248 7081089 927 5041161 1151 73947 29 41 22 16147 103 73 116 94162 108 153 168 126163 67 112 158 122152 93 93 111 97<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;class M&#123;public:    int row;    int col;    int m[11][11];    M(int r,int c):row(r),col(c)    &#123;        for(int i&#x3D;0;i&lt;row;++i)        &#123;            for(int j&#x3D;0;j&lt;col;++j)            &#123;                if(i&#x3D;&#x3D;j)                    m[i][j]&#x3D;1;                else                    m[i][j]&#x3D;0;            &#125;        &#125;          &#125;    void input()    &#123;        for(int i&#x3D;0;i&lt;row;++i)        &#123;            for(int j&#x3D;0;j&lt;col;++j)                cin&gt;&gt;m[i][j];        &#125;     &#125;    void output()    &#123;        for(int i&#x3D;0;i&lt;row;++i)        &#123;            for(int j&#x3D;0;j&lt;col;++j)                cout&lt;&lt;m[i][j]&lt;&lt;&#39; &#39;;            cout&lt;&lt;endl;        &#125;    &#125;    M operator* (const M&amp; t) const    &#123;        M ans(row,t.col);        memset(ans.m,0,sizeof(ans.m));        for(int i&#x3D;0;i&lt;row;++i)        &#123;            for(int j&#x3D;0;j&lt;t.col;++j)            &#123;                for(int k&#x3D;0;k&lt;col;++k)                &#123;                    ans.m[i][j]+&#x3D;m[i][k]*t.m[k][j];                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;M ksm(M a,int k)&#123;    M ans(a.row,a.col);    while(k&gt;0)    &#123;        if(k%2)            ans&#x3D;ans*a;        a&#x3D;a*a;        k&#x2F;&#x3D;2;    &#125;    return ans; &#125;int main()&#123;    int n,k;    while(cin&gt;&gt;n&gt;&gt;k)    &#123;        M a(n,n);        a.input();        M ans&#x3D;ksm(a,k);        ans.output();    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最短路</title>
    <link href="/2022/08/22/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2022/08/22/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BE%8B1-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF-%E6%B4%9B%E8%B0%B7p4779">例1 单源最短路 洛谷p4779</a></li><li><a href="#spfa">SPFA</a></li><li><a href="#dijkstra%E6%99%AE%E9%80%9A%E7%89%88">Dijkstra普通版</a></li><li><a href="#dijkstra%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88ac">Dijkstra堆优化版(AC)</a><ul><li><a href="#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AD%98%E5%9B%BE">链式前向星存图</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E4%BE%8B2-%E6%9C%80%E5%A4%9A%E7%BB%8F%E8%BF%87k%E6%9D%A1%E8%BE%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF">例2 最多经过k条边的最短路</a></li><li><a href="#bellmanford">Bellmanford</a></li><li><a href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E8%A7%A3%E6%9C%80%E7%9F%AD%E8%B7%AF">并查集解最短路</a></li></ul><!-- /TOC --><h3 id="例1-单源最短路-洛谷p4779"><a class="markdownIt-Anchor" href="#例1-单源最短路-洛谷p4779"></a> 例1 单源最短路 洛谷p4779</h3><p>题目描述</p><p>给定一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 条有向边的带非负权图，请你计算从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 出发，到每个点的距离。</p><p>数据保证你能从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 出发到任意点。</p><p>输入格式</p><p>第一行为三个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">n, m, s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span></span></span></span>。<br />第二行起 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行三个非负整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i, v_i, w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，表示从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 有一条权值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的有向边。</p><p>输出格式</p><p>输出一行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个空格分隔的非负整数，表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 到每个点的距离。</p><p>样例输入</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">4 6 11 2 22 3 22 4 11 3 53 4 31 4 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>样例输出</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">0 2 4 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>提示</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq n \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq m \leq 2\times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \leq u_i, v_i\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>w</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">0 \leq w_i \leq 10 ^ 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>,</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mo>∑</mo><msub><mi>w</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">0 \leq \sum w_i \leq 10 ^ 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。</p><h3 id="spfa"><a class="markdownIt-Anchor" href="#spfa"></a> SPFA</h3><blockquote><p>此题用spfa会超时,这里写的代码弱化了数据范围，存图也直接用二维数组了，主要是复习spfa的思路</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int n,m,s;const int N&#x3D;1e4+1;int mp[N][N];int dist[N];bool vis[N]; int main()&#123;memset(mp,0x3f,sizeof(mp));memset(dist,0x3f,sizeof(dist));cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;dist[s]&#x3D;0;int u,v,w;for(int i&#x3D;1;i&lt;&#x3D;m;++i)&#123;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;mp[u][v]&#x3D;w;&#125;queue&lt;int&gt; q;q.push(s);while(!q.empty())&#123;int t&#x3D;q.front();q.pop();vis[t]&#x3D;false;for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;if(dist[i]&gt;dist[t]+mp[t][i])&#123;dist[i]&#x3D;dist[t]+mp[t][i];if(!vis[i])&#123;vis[i]&#x3D;true;q.push(i);&#125;&#125;&#125;&#125; for(int i&#x3D;1;i&lt;&#x3D;n;++i)cout&lt;&lt;dist[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="dijkstra普通版"><a class="markdownIt-Anchor" href="#dijkstra普通版"></a> Dijkstra普通版</h3><blockquote><p>此题用普通Dijkstra会超时,这里写的代码弱化了数据范围，存图也直接用二维数组了，主要是复习dj的思路</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int n,m,s;const int N&#x3D;1e4+1;int mp[N][N];int dist[N];bool vis[N]; int main()&#123;memset(mp,0x3f,sizeof(mp));memset(dist,0x3f,sizeof(dist));cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;dist[s]&#x3D;0;int u,v,w;for(int i&#x3D;1;i&lt;&#x3D;m;++i)&#123;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;mp[u][v]&#x3D;w;&#125;for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;int t&#x3D;-1;for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;if(!vis[j]&amp;&amp;(t&#x3D;&#x3D;-1||dist[t]&gt;dist[j]))t&#x3D;j;&#125;vis[t]&#x3D;true;for(int j&#x3D;1;j&lt;&#x3D;n;++j)&#123;dist[j]&#x3D;min(dist[j],dist[t]+mp[t][j]);&#125;&#125;for(int i&#x3D;1;i&lt;&#x3D;n;++i)cout&lt;&lt;dist[i]&lt;&lt;&#39; &#39;;cout&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="dijkstra堆优化版ac"><a class="markdownIt-Anchor" href="#dijkstra堆优化版ac"></a> Dijkstra堆优化版(AC)</h3><h4 id="链式前向星存图"><a class="markdownIt-Anchor" href="#链式前向星存图"></a> 链式前向星存图</h4><p>题目中给的节点数很多，属于稀疏图，二维数组无法存储，所以需要使用<strong>链式前向星</strong>存储，方法如下：</p><p>定义一个数组<code>head[]</code>,<code>head[a]</code>表示以a为起始点的最后一条边的序号</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span>：表示边的序号</p><p>结构体<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">edge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span></span></span></span>，存储边</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">struct edge&#123;int to;&#x2F;&#x2F;这条边指向的点 int next;&#x2F;&#x2F;这条边的邻边的序号 int w;&#x2F;&#x2F;这条边的权值 &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>加边，如果是无向图，交换u和v再add一次即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void add(int u,int v,int w)&#123;++cnt;e[cnt].to&#x3D;v;e[cnt].w&#x3D;w;e[cnt].next&#x3D;head[u];head[u]&#x3D;cnt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>遍历以a为起点的所有边</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">for(int i&#x3D;head[a];i!&#x3D;0;i&#x3D;edge[i].next)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int n,m,s;const int N&#x3D;1e5+5;int head[N];bool vis[N];int dis[N];int cnt;&#x2F;&#x2F;边 struct edge&#123;int to;&#x2F;&#x2F;这条边指向的点 int next;&#x2F;&#x2F;这条边的邻边的序号 int w;&#x2F;&#x2F;这条边的权值 &#125;e[2*N];&#x2F;&#x2F;优先级队列的节点struct node&#123;int n;int w;node(int nn,int ww):n(nn),w(ww)&#123;&#125;&#x2F;&#x2F;重载运算符&lt;，为了建立小顶堆 bool operator&lt; (const node&amp; t) const&#123;return w&gt;t.w;&#125;&#125;; &#x2F;&#x2F;加边 void add(int u,int v,int w)&#123;++cnt;e[cnt].to&#x3D;v;e[cnt].w&#x3D;w;e[cnt].next&#x3D;head[u];head[u]&#x3D;cnt;&#125;priority_queue&lt;node&gt; q;int main()&#123;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;memset(dis,0x3f,sizeof(dis));dis[s]&#x3D;0;int u,v,w;for(int i&#x3D;1;i&lt;&#x3D;m;++i)&#123;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;add(u,v,w);&#125;q.push(node(s,0));while(!q.empty())&#123;node t&#x3D;q.top();q.pop();u&#x3D;t.n;if(!vis[u])&#123;vis[u]&#x3D;true;for(int i&#x3D;head[u];i;i&#x3D;e[i].next)&#123;v&#x3D;e[i].to;w&#x3D;e[i].w;if(dis[v]&gt;dis[u]+w)&#123;dis[v]&#x3D;dis[u]+w;if(!vis[v])q.push(node(v,dis[v]));&#125;&#125;&#125;&#125;for(int i&#x3D;1;i&lt;&#x3D;n;++i)cout&lt;&lt;dis[i]&lt;&lt;&#39; &#39;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="例2-最多经过k条边的最短路"><a class="markdownIt-Anchor" href="#例2-最多经过k条边的最短路"></a> 例2 最多经过k条边的最短路</h3><p>描述<br />给定 n 个点，m条有向边，起点s，终点d，最大边数k</p><p>第一行输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>d</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n,m,s,d,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span><br />后面m行输入m条边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i,v_i,w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>输出从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>最多经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>条边时的最短路径<br />input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">3 3 1 3 21 2 1002 3 1001 3 500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">200<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="bellmanford"><a class="markdownIt-Anchor" href="#bellmanford"></a> Bellmanford</h3><blockquote><p>Bellmanford常用于解决此类有边数限制的最短路</p></blockquote><p>代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int n,m,s,d,k;int inf&#x3D;0x3f3f3f3f;const int N&#x3D;1e4+5;int dp[100][N];bool vis[N];struct edge&#123;int u,v,w;&#x2F;&#x2F;edge(int uu,int vv,int ww):u(uu),v(vv),w(ww)&#123;&#125;&#125;e[N];int main()&#123;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d&gt;&gt;k;memset(dp,0x3f,sizeof(dp));dp[0][s]&#x3D;0;int u,v,w;for(int i&#x3D;1;i&lt;&#x3D;m;++i)&#123;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;e[i].u&#x3D;u;e[i].v&#x3D;v;e[i].w&#x3D;w;&#125;for(int i&#x3D;1;i&lt;&#x3D;k;++i)&#123;for(int j&#x3D;1;j&lt;&#x3D;m;++j)&#123;u&#x3D;e[j].u;v&#x3D;e[j].v;w&#x3D;e[j].w;dp[i][v]&#x3D;min(dp[i][v],dp[i-1][u]+w);&#125;&#125;int ans&#x3D;inf;for(int i&#x3D;1;i&lt;&#x3D;k;++i)&#123;ans&#x3D;min(dp[i][d],ans);&#125; if(ans&#x3D;&#x3D;inf)cout&lt;&lt;-1&lt;&lt;endl;elsecout&lt;&lt;ans&lt;&lt;endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="并查集解最短路"><a class="markdownIt-Anchor" href="#并查集解最短路"></a> 并查集解最短路</h3><p>先看一个例题</p><p><a href="https://www.nowcoder.com/practice/a29d0b5eb46b4b90bfa22aa98cf5ff17?tpId=40&amp;tqId=21438&amp;rp=1&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan&amp;difficulty=&amp;judgeStatus=&amp;tags=/question-ranking">最短路径</a></p><p><strong>描述</strong></p><p>N个城市，标号从0到N-1，M条道路，第K条道路（K从0开始）的长度为2^K，求编号为0的城市到其他城市的最短距离</p><p><strong>输入描述</strong></p><p>第一行两个正整数N（2&lt;=N&lt;=100）M(M&lt;=500),表示有N个城市，M条道路 接下来M行两个整数，表示相连的两个城市的编号</p><p><strong>输出描述</strong></p><p>N-1行，表示0号城市到其他城市的最短路，如果无法到达，输出-1，数值太大的以MOD 100000 的结果输出。</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">4 41 22 31 30 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">8911<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p>思路：对于这道题，第k条边的长度为2^k，也就是说，第k条边会比前面所有边的和还要大。所以用并查集来做，当新加入边的两个端点u和v不连通时，这条边就是u到v的最短距离，因为后续如果再次出现以uv为端点的边，一定会比当前长度长。加入uv边后，更新两端点各自连通子图中各点间的距离即可。</p></blockquote><p>代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;102;const int mod&#x3D;1e5;typedef long long ll;int mp[N][N];int vset[N];int ksm(ll a,int b,int c)&#123;    int ans&#x3D;1;    a&#x3D;a%c;    while(b&gt;0)    &#123;        if(b%2)            ans&#x3D;(ans*a)%c;        a&#x3D;(a*a)%c;        b&#x2F;&#x3D;2;    &#125;    return ans;&#125;int find(int a)&#123;if(vset[a]&#x3D;&#x3D;-1)return a;else&#123;vset[a]&#x3D;find(vset[a]);return vset[a];&#125;&#125;int main()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    memset(vset,-1,sizeof(vset));    memset(mp,-1,sizeof(mp));    for(int i&#x3D;0;i&lt;n;++i)    mp[i][i]&#x3D;0;    int u,v,w;    for(int k&#x3D;0;k&lt;m;++k)    &#123;        cin&gt;&gt;u&gt;&gt;v;        int x&#x3D;find(u);        int y&#x3D;find(v);        &#x2F;&#x2F;当两点不连通的时候才加入该边，此时该边是u到v的最短边if(x!&#x3D;y)&#123;w&#x3D;ksm(2,k,mod);&#x2F;&#x2F;更新两个连通子图间各点的距离 for(int i&#x3D;0;i&lt;n;++i)&#123;if(find(i)&#x3D;&#x3D;x)&#123;for(int j&#x3D;0;j&lt;n;++j)&#123;if(find(j)&#x3D;&#x3D;y)&#123;mp[i][j]&#x3D;mp[j][i]&#x3D;(mp[i][u]+w+mp[v][j])%mod;&#125;&#125;&#125;&#125;&#x2F;&#x2F;连接两个连通子图vset[x]&#x3D;y; &#125;     &#125;    for(int i&#x3D;1;i&lt;n;++i)    cout&lt;&lt;mp[0][i]&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2022/08/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BE%8B%E9%A2%98101%E8%83%8C%E5%8C%85">例题1：01背包</a></li><li><a href="#%E4%BE%8B%E9%A2%982%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">例题2：完全背包</a></li></ul><!-- /TOC --><blockquote><p><em><strong>背包问题</strong></em> 是经典的一类动态规划类型的题目，一般是有n种物品，每个物品有对应的价值w，然后背包体积为V，求能装入的物品的最大价值。</p></blockquote><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><p>设 <strong>dp[i][j]</strong> 为前 i 个物品，背包容量为 j 的最大价值。</p><p>那么考虑第i个物品是否放入，有两种情况：</p><ul><li>如果不放，那么等同于前 <strong>i−1</strong> 个物品，容量为j的背包的最优方案。</li><li>如果放，那么等同于前 <strong>i−1</strong> 个物品，容量为 <strong>j−v[i]</strong> 的背包的最优方案，再加上第i个物品的价值。</li></ul><p>那么可以得到转移方程：</p><p><em><strong>dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i])</strong></em></p><p>最终的答案就是 <strong>dp[n][V]</strong></p><p>观察到dp数组，第i行仅跟上一行有关系，故可以压缩一维，为了防止dp[i−1][j−v[i]]被覆盖掉，第二维度须<strong>反向枚举</strong>。</p><h4 id="例题101背包"><a class="markdownIt-Anchor" href="#例题101背包"></a> 例题1：01背包</h4><p>你有一个背包，最多能容纳的体积是V，现在有n个物品，第i个物品的体积为vi,价值为wi。</p><ol><li>求这个背包至多能装多大价值的物品？</li><li>若背包恰好装满，求至多能装多大价值的物品？</li></ol><p>输入第一行n,V<br />后面n行，输入第i件物品的体积vi和价值wi<br />输出：两个问题的答案，各占一行，如果无解输出0</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">3 52 104 51 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">149<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>题解：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int n,V;const int N&#x3D;1005;int v[N],w[N];int dp[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;V;    for(int i&#x3D;1;i&lt;&#x3D;n;++i)    &#123;        cin&gt;&gt;v[i];        cin&gt;&gt;w[i];    &#125;    &#x2F;&#x2F;不要求装满    for(int i&#x3D;1;i&lt;&#x3D;n;++i)    &#123;        for(int j&#x3D;V;j&gt;&#x3D;v[i];--j)            dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]);    &#125;    cout&lt;&lt;dp[V]&lt;&lt;endl;        &#x2F;&#x2F;要求装满    memset(dp,-0x3f,sizeof(dp));    dp[0]&#x3D;0;    for(int i&#x3D;1;i&lt;&#x3D;n;++i)    &#123;        for(int j&#x3D;V;j&gt;&#x3D;v[i];--j)            dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]);    &#125;    if(dp[V]&gt;0)        cout&lt;&lt;dp[V]&lt;&lt;endl;    else        cout&lt;&lt;0&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="例题2完全背包"><a class="markdownIt-Anchor" href="#例题2完全背包"></a> 例题2：完全背包</h4><p>描述与例题1相同，不过每种物品有<strong>任意</strong>个</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">6 1313 18917 36019 87014 1846 29816 242<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">596189<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>题解：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int n,V;const int N&#x3D;1005;int v[N],w[N];int dp[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;V;    for(int i&#x3D;1;i&lt;&#x3D;n;++i)    &#123;        cin&gt;&gt;v[i];        cin&gt;&gt;w[i];    &#125;    &#x2F;&#x2F;不要求装满    for(int i&#x3D;1;i&lt;&#x3D;n;++i)    &#123;        for(int j&#x3D;v[i];j&lt;&#x3D;V;++j)            dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]);    &#125;    cout&lt;&lt;dp[V]&lt;&lt;endl;        &#x2F;&#x2F;要求装满    memset(dp,-0x3f,sizeof(dp));    dp[0]&#x3D;0;    for(int i&#x3D;1;i&lt;&#x3D;n;++i)    &#123;        for(int j&#x3D;v[i];j&lt;&#x3D;V;++j)            dp[j]&#x3D;max(dp[j],dp[j-v[i]]+w[i]);    &#125;    if(dp[V]&gt;0)        cout&lt;&lt;dp[V]&lt;&lt;endl;    else        cout&lt;&lt;0&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯</title>
    <link href="/2022/08/22/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2022/08/22/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><em><strong>回溯</strong></em>  核心思想和dfs相似，主要通过递归寻找可行解</p></blockquote><!-- TOC --><ul><li><a href="#%E4%BE%8B%E9%A2%981">例题1:</a></li><li><a href="#%E4%BE%8B%E9%A2%982">例题2:</a></li></ul><!-- /TOC --><h3 id="例题1"><a class="markdownIt-Anchor" href="#例题1"></a> 例题1:</h3><p>给定一个数组a[]和target的值，找出数组中可以使数字和为target的不同组合，输出所有符合要求的组合</p><ul><li>数组中数字可以重复使用</li><li>1,1,5和1,5,1视为一种方式<br />input:</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">3 82 3 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">3 52 3 32 2 2 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>题解</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int n,target;const int N&#x3D;1e5+5;typedef vector&lt;int&gt; vi;vi a(N);vi tmp;vector&lt;vi&gt; ans; void bk(int idx,int target)&#123;    if(idx&#x3D;&#x3D;n)        return;    if(target&#x3D;&#x3D;0)    &#123;        ans.push_back(tmp);        return;    &#125;    bk(idx+1,target);    if(target&gt;&#x3D;a[idx])    &#123;        tmp.push_back(a[idx]);        bk(idx,target-a[idx]);        tmp.pop_back();    &#125;&#125;int main()&#123;cin&gt;&gt;n&gt;&gt;target;for(int i&#x3D;0;i&lt;n;++i)cin&gt;&gt;a[i];    bk(0,target);    for(vi&amp; t:ans)    &#123;    for(int tt :t)    cout&lt;&lt;tt&lt;&lt;&#39; &#39;;    cout&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="例题2"><a class="markdownIt-Anchor" href="#例题2"></a> 例题2:</h3><p>给定一个数组a[]和target的值，找出数组中可以使数字和为target的不同组合，输出所有符合要求的组合</p><ul><li>数组中每个数字最多使用一次</li><li>1,1,5和1,5,1视为一种方式<br />input:</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">7 810 1 2 7 6 1 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">1 71 6 12 67 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>题解</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int n,target;const int N&#x3D;1e5+5;typedef vector&lt;int&gt; vi;vi a(N);vi tmp;vector&lt;vi&gt; ans; void bk(int idx,int target)&#123;    if(idx&#x3D;&#x3D;n)        return;    if(target&#x3D;&#x3D;0)    &#123;        ans.push_back(tmp);        return;    &#125;    for(int i&#x3D;idx;i&lt;n;++i)    &#123;    if(target&gt;&#x3D;a[i])    &#123;    if(i&gt;idx&amp;&amp;a[i]&#x3D;&#x3D;a[i-1])    continue;    tmp.push_back(a[i]);    bk(i+1,target-a[i]);    tmp.pop_back();    &#125;    &#125;&#125;int main()&#123;cin&gt;&gt;n&gt;&gt;target;for(int i&#x3D;0;i&lt;n;++i)cin&gt;&gt;a[i];    bk(0,target);    for(vi&amp; t:ans)    &#123;    for(int tt :t)    cout&lt;&lt;tt&lt;&lt;&#39; &#39;;    cout&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kmp算法</title>
    <link href="/2022/08/21/kmp%E7%AE%97%E6%B3%95/"/>
    <url>/2022/08/21/kmp%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><em><strong>kmp</strong></em> 算法的核心思想：当匹配失败时，主串指针不回退，而是根据 <em><strong>next</strong></em> 数组，从适当的位置重新匹配，相比于暴力匹配，跳过了不可能匹配成功的部分，大大提升了效率</p></blockquote><blockquote><p><em><strong>next</strong></em> 数组每个位置的值表示前缀集合和后缀集合交集中,最长元素的长度</p></blockquote><figure><div class="code-wrapper"><pre class="language-none"><code class="language-none">        p:    a b a b a b c a    next[i]:  0 0 1 2 3 4 0 1</code></pre></div></figure><p>例题:</p><p>给你两个字符串 s 和 p ，请你在 s 字符串中找出 p 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。</p><p>input:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">abacdfacd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>output:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>题解</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N&#x3D;1e5;int nxt[N];void get_next(string p)&#123;int len&#x3D;p.size();int i&#x3D;1,j&#x3D;0;while(i&lt;len)&#123;if(p[i]&#x3D;&#x3D;p[j])&#123;nxt[i]&#x3D;j+1;++i;++j;&#125;else if(j&#x3D;&#x3D;0)&#123;nxt[i]&#x3D;0;++i;&#125;elsej&#x3D;nxt[j-1];&#125;&#125; int main()&#123;string s,p;cin&gt;&gt;s&gt;&gt;p;int m&#x3D;s.size(),n&#x3D;p.size();int ans&#x3D;-1;for(int i&#x3D;0,j&#x3D;0;i&lt;m;++i)&#123;while(j&gt;0&amp;&amp;s[i]!&#x3D;p[j])j&#x3D;nxt[j-1];if(s[i]&#x3D;&#x3D;p[j])++j;if(j&#x3D;&#x3D;n)ans&#x3D;i-j+1;&#125;cout&lt;&lt;ans&lt;&lt;endl;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经</title>
    <link href="/2022/08/21/%E9%9D%A2%E7%BB%8F/"/>
    <url>/2022/08/21/%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#2022%E4%B8%AA%E4%BA%BA%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%A2%84%E6%8E%A8%E5%85%8D%E8%AE%B0%E5%BD%95">2022个人夏令营/预推免记录😢</a><ul><li><a href="#%E5%90%89%E5%A4%A7ai">吉大ai</a></li><li><a href="#%E8%A5%BF%E4%BA%A4cs">西交cs</a></li><li><a href="#%E5%8D%8E%E7%A7%91%E7%BD%91%E5%AE%89">华科网安</a></li><li><a href="#%E5%8D%97%E5%A4%A7cs">南大cs</a></li><li><a href="#%E5%8C%97%E8%88%AAai">北航ai</a></li><li><a href="#%E4%B8%9C%E5%8D%97cs">东南cs</a></li></ul></li></ul><!-- /TOC --><h2 id="2022个人夏令营预推免记录"><a class="markdownIt-Anchor" href="#2022个人夏令营预推免记录"></a> 2022个人夏令营/预推免记录😢</h2><h3 id="吉大ai"><a class="markdownIt-Anchor" href="#吉大ai"></a> 吉大ai</h3><ul><li>自我介绍</li><li>英文翻译</li><li>抽题目回答</li></ul><p>我抽到的是关于聚类的：</p><ul><li>什么是聚类</li><li>聚类和分类区别</li><li>聚类的性能指标</li><li>层次聚类方法有哪些？</li><li><em>后两个也是关于层次聚类的，忘了。。。</em></li></ul><h3 id="西交cs"><a class="markdownIt-Anchor" href="#西交cs"></a> 西交cs</h3><p>夏令营没有优营，没有考核，先报名然后团队内部面试（聊天）</p><h3 id="华科网安"><a class="markdownIt-Anchor" href="#华科网安"></a> 华科网安</h3><p>有机试，5道题，150min,题目记不清了，难度中等，机试成绩不计入总成绩，仅作为参考<br />面试就自我介绍，然后聊聊天，最后优营40人，大概1/3</p><h3 id="南大cs"><a class="markdownIt-Anchor" href="#南大cs"></a> 南大cs</h3><ul><li><p><strong>笔试</strong><br />很多要计算的题，题量挺大的<br /><strong>数据结构</strong>：排序算法性能，希尔排序序列、红黑树、b树、最短路径算法(dijkstra,bellford,floyd)、最小生成树、线性探测、优先级队列、汉诺塔问题、还有好几个读程序的题<br /><strong>计组</strong>：组相联映射、cache和主存给定命中率计算时间、想不起来了。。。<br />os：linux终端退出的符号，jvm，进程通信、一些语言特性（rust，ruby，scala），访管指令，还有一堆指令。。<br /><strong>计网</strong>：无类寻址，拥塞窗口、数据链路层、ip协议、后面记的不清楚了。。。。</p></li><li><p><strong>面试</strong><br />先英文介绍merge sort，问一些项目问题，然后问了个数学题（怎么在球面上确定一点？），然后问了下生活上的兴趣之类的</p></li></ul><h3 id="北航ai"><a class="markdownIt-Anchor" href="#北航ai"></a> 北航ai</h3><p>今年是第二届夏令营，入营120/1000，优营60</p><ul><li>先英文自我介绍</li><li>政治：谈谈科教兴国的理解</li><li>聊聊项目</li><li>因为我在下午，可能是老师累了把，没有问专业课，最后优营了</li></ul><p>北航和老师聊，问了些问题，都是比较底层的细节问题，<br />还记得的有：</p><ul><li>python 垃圾回收机制</li><li>c++ 智能指针的原理</li><li>如何判断链表有没有环</li></ul><h3 id="东南cs"><a class="markdownIt-Anchor" href="#东南cs"></a> 东南cs</h3><p>入营318人</p><ul><li>面试<ul><li>3分钟自我介绍</li><li>英文问题：cv的相关任务、参加的实践活动</li><li>聊聊天，没有问专业课</li></ul></li></ul><hr />]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
