<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>最少步行次数</title>
    <link href="/2025/08/31/%E6%9C%80%E5%B0%91%E6%AD%A5%E8%A1%8C%E6%AC%A1%E6%95%B0/"/>
    <url>/2025/08/31/%E6%9C%80%E5%B0%91%E6%AD%A5%E8%A1%8C%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="最少步行次数"><a class="markdownIt-Anchor" href="#最少步行次数"></a> 最少步行次数</h2><!-- TOC --><ul><li><a href="#%E6%9C%80%E5%B0%91%E6%AD%A5%E8%A1%8C%E6%AC%A1%E6%95%B0">最少步行次数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://niumacode.com/training/185/problem/P1832">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在一片神奇的魔法森林中，有 n 个魔法节点，每个节点都有一个传送门。第 i 个节点的传送门会把你传送到 ai号节点。多多每次可以选择坐传送门从 i 节点传送到 ai 节点，或者选择步行到相邻的节点 i−1 或 i+1 节点。当然多多是个喜欢偷懒的人，所以它能坐传送门就尽量不步行。现在多多从 1 号节点出发，想知道到达每个节点需要经过的最少步行次数。</p><p>输入：</p><p>第一行一个整数 n (1≤n≤2×10^5)，表示节点数。第二行 n 个整数 a1,a2,…,an (1≤ai≤n)，表示第 i 个节点的传送门会把你传送到 ai 号节点。</p><p>输出：</p><p>输出一行 n 个整数，第 i 个整数表示多多从 1 号节点出发到达 i 号节点需要经过的最少步行次数。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>0-1 权图最短路问题，需要用到双端队列。</p><ul><li>首先将第一个节点加入队列，步行次数为 0。</li><li>然后每次从队列头部取出一个节点，尝试更新右侧和左侧节点的最少步行次数，如果更新成功则将该节点加入队列尾部</li><li>更新完左右两侧节点后，再尝试当前节点对应的传送位置的最少步行次数，如果更新成功则将该节点加入队列头部。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll=<span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>        cin&gt;&gt;a[i];<br>        a[i]--;<br>    &#125;<br>    <span class="hljs-type">int</span> inf=<span class="hljs-number">1e9</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n,inf)</span></span>;<br>    deque&lt;<span class="hljs-type">int</span>&gt; dq;<br><br>    dis[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dq.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> u = dq.<span class="hljs-built_in">front</span>();<br>        dq.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">if</span>(u + <span class="hljs-number">1</span> &lt; n &amp;&amp; dis[u] + <span class="hljs-number">1</span> &lt; dis[u+<span class="hljs-number">1</span>])&#123;<br>            dis[u+<span class="hljs-number">1</span>] = dis[u] + <span class="hljs-number">1</span>;<br>            dq.<span class="hljs-built_in">push_back</span>(u+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(u - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; dis[u] + <span class="hljs-number">1</span> &lt; dis[u<span class="hljs-number">-1</span>])&#123;<br>            dis[u<span class="hljs-number">-1</span>] = dis[u] + <span class="hljs-number">1</span>;<br>            dq.<span class="hljs-built_in">push_back</span>(u<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> v = a[u];<br>        <span class="hljs-keyword">if</span>(dis[u] &lt; dis[v])&#123;<br>            dis[v] = dis[u];<br>            dq.<span class="hljs-built_in">push_front</span>(v);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t:dis)&#123;<br>        cout&lt;&lt;t&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>配置中心和长轮询</title>
    <link href="/2025/07/21/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%92%8C%E9%95%BF%E8%BD%AE%E8%AF%A2/"/>
    <url>/2025/07/21/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%92%8C%E9%95%BF%E8%BD%AE%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%92%8C%E9%95%BF%E8%BD%AE%E8%AF%A2">配置中心和长轮询</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83">为什么要用配置中心？</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F">数据交互模式</a><ul><li><a href="#%E6%8E%A8%E6%A8%A1%E5%BC%8F">推模式</a></li><li><a href="#%E6%8B%89%E6%A8%A1%E5%BC%8F">拉模式</a></li></ul></li><li><a href="#%E9%95%BF%E8%BD%AE%E8%AF%A2%E5%92%8C%E8%BD%AE%E8%AF%A2">长轮询和轮询</a></li><li><a href="#%E9%95%BF%E8%BD%AE%E8%AF%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">长轮询的基本原理</a></li><li><a href="#%E6%8C%82%E8%B5%B7%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">挂起的三种方式</a><ul><li><a href="#while%E5%BE%AA%E7%8E%AF">while循环</a></li><li><a href="#%E9%80%9A%E8%BF%87wait%E5%92%8Cnotify%E9%85%8D%E5%90%88futuregettimeout%E5%AE%9E%E7%8E%B0">通过wait和notify，配合<code>future.get(timeout)</code>实现：</a></li><li><a href="#scheduleasynccontext%E5%AE%9E%E7%8E%B0">schedule+AsyncContext实现：</a></li></ul></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E9%95%BF%E8%BD%AE%E8%AF%A2%E4%B8%8D%E7%94%A8%E9%95%BF%E8%BF%9E%E6%8E%A5">为什么用长轮询不用长连接？</a></li></ul></li></ul><!-- /TOC --><h1 id="配置中心和长轮询"><a class="markdownIt-Anchor" href="#配置中心和长轮询"></a> 配置中心和长轮询</h1><h2 id="为什么要用配置中心"><a class="markdownIt-Anchor" href="#为什么要用配置中心"></a> 为什么要用配置中心？</h2><p>传统的静态配置方式想要修改某个配置时，必须修改后重新启动上线，这样某些配置如果频繁改动，就会影响到线上业务的运行效率，配置中心就可以很好的解决这个问题。</p><p>配置中心最主要的能力就是配置的动态推送，可能很多人一位配置中心是通过长连接实现的，实际上主流的配置中心主要是通过长轮询的方式来实现配置的动态推送。</p><p>长连接和长轮询的主要区别是：</p><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">长连接 (Long Connection)</th><th style="text-align:left">长轮询 (Long Polling)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>本质</strong></td><td style="text-align:left">TCP 连接的复用，多个HTTP请求可以复用一个TCP长连接</td><td style="text-align:left">应用层的请求响应模式</td></tr><tr><td style="text-align:left"><strong>服务端行为</strong></td><td style="text-align:left">快速响应请求，但保持 TCP 连接不关闭</td><td style="text-align:left">挂起请求，直到有数据更新或超时再响应</td></tr><tr><td style="text-align:left"><strong>实现方式</strong></td><td style="text-align:left">双方通过 HTTP 协议头 <code>Connection: keep-alive</code> 控制</td><td style="text-align:left">服务端通过编程逻辑实现请求挂起，与客户端无关</td></tr><tr><td style="text-align:left"><strong>目的</strong></td><td style="text-align:left">减少 TCP 连接建立和断开的开销</td><td style="text-align:left">降低轮询频率，模拟实时数据推送</td></tr></tbody></table><h2 id="数据交互模式"><a class="markdownIt-Anchor" href="#数据交互模式"></a> 数据交互模式</h2><h3 id="推模式"><a class="markdownIt-Anchor" href="#推模式"></a> 推模式</h3><p>推模式指的是服务端主动向客户端推送数据更新，客户端无需频繁请求服务器。推模式通常使用 WebSocket 或 Server-Sent Events (SSE) 实现。缺点是客户端的消费能力有限时，可能会导致数据积压。</p><h3 id="拉模式"><a class="markdownIt-Anchor" href="#拉模式"></a> 拉模式</h3><p>拉模式指的是客户端主动向服务端发出请求，拉取数据，优点是不存在数据积压的问题，缺点是可能不够及时，拉取数据的频率不好确定。</p><h2 id="长轮询和轮询"><a class="markdownIt-Anchor" href="#长轮询和轮询"></a> 长轮询和轮询</h2><p>普通的轮询是每隔一定时间拉取一次数据，存在以下问题：</p><ul><li><strong>延迟性</strong>：数据更新后需要等待下一个轮询周期才能获取到最新数据。</li><li><strong>资源浪费</strong>：即使没有数据更新，仍然会发送请求，浪费带宽和服务器资源。</li><li><strong>轮询间隔</strong>：需要合理设置轮询间隔，过短会增加服务器负担，过长会导致数据延迟。</li></ul><p>而长轮询的方式是，如果服务端数据没有变更，服务端会挂起请求，直到数据变更或超时后再响应。这样可以有效减少请求次数和延迟。</p><h2 id="长轮询的基本原理"><a class="markdownIt-Anchor" href="#长轮询的基本原理"></a> 长轮询的基本原理</h2><p>一般长轮询各个部分的工作流程如下：</p><ul><li>客户端发起长轮询：<ul><li>客户端发送 HTTP 请求到服务端，请求包含配置中心的地址和监听的dataId</li></ul></li><li>服务端监听数据变化：<ul><li>服务端维护dataId和长轮询的映射关系，如果dataId对应的配置发生变化，则会为响应写入更新后的配置内容</li><li>如果直到超时还没有数据变化，服务端会返回一个304响应，304代表“未改变”，并不代表错误</li></ul></li><li>客户端处理响应：根据响应码做出相应处理，之后再次发起长轮询请求。</li></ul><h2 id="挂起的三种方式"><a class="markdownIt-Anchor" href="#挂起的三种方式"></a> 挂起的三种方式</h2><h3 id="while循环"><a class="markdownIt-Anchor" href="#while循环"></a> while循环</h3><p>这是最朴素的实现方式，通过while循环不断检查数据是否变化，直到超时或数据变化为止。缺点是会浪费CPU资源。</p><h3 id="通过wait和notify配合futuregettimeout实现"><a class="markdownIt-Anchor" href="#通过wait和notify配合futuregettimeout实现"></a> 通过wait和notify，配合<code>future.get(timeout)</code>实现：</h3><ul><li>当数据没有变更时，通过obj.wait()方法挂起当前线程，让出cpu资源，等待数据变更时通过obj.notifyAll()唤醒线程。</li><li>仅使用wait和notify的话，如果没有数据变更，线程会一直wait，为了达到超时效果，可以使用<code>future.get(timeout)</code>方法来设置超时时间。当抛出<code>TimeoutException</code>时，说明超时了，此时可以返回304响应。</li></ul><blockquote><p>这种方式的缺点是，如果数据长时间没有变化，可能会不断的抛出异常，处理效率很低。</p></blockquote><h3 id="scheduleasynccontext实现"><a class="markdownIt-Anchor" href="#scheduleasynccontext实现"></a> schedule+AsyncContext实现：</h3><p>Diamond中，采用这种更优雅的方式实现长轮询。</p><p>首先需要介绍一下AsyncContext：<br />AsyncContext是Servlet 3.0中引入的异步处理支持类。其主要作用是释放Servlet容器的线程，使其不必因等待耗时业务（如数据库操作、跨网络调用等）而一直处于阻塞状态。</p><p>具体来说，它的作用体现在以下几点：</p><ul><li><strong>线程解耦与资源释放</strong>：允许Servlet线程将耗时的业务逻辑委派给一个独立的异步线程处理，而Servlet线程本身可以立即返回到容器中，去处理其他新的请求。这样可以先释放容器分配给请求的线程和相关资源，减轻系统负担。</li><li><strong>提升并发能力</strong>：通过避免Servlet线程长时间被占用，服务器可以用有限的线程处理更多的并发请求，从而显著提高应用的并发处理速度和整体性能，尤其是在高并发场景下非常有用 123。</li><li><strong>延迟响应</strong>：请求的响应将被延后，直到异步线程中的业务处理完成。异步线程可以直接生成响应数据，或者将请求转发给其他Servlet。</li></ul><p>所以，为了不让长轮训一直占用servlet容器的线程，一般通过AsyncContext将请求交给异步线程处理，处理完成后通过asyncContext的<code>complete()</code>方法来结束请求。</p><p>整体流程如下：</p><ul><li>首先，通过维护一个<code>ScheduledThreadPool</code>来执行不同任务。</li><li>当订阅者携带一个dataId来拉取数据时，先通过<code>startAsync()</code>创建一个AsyncContext对象，表示将请求转换为异步方式，然后会根据这个dataId创建一个worker，并将AsyncContext对象传给新建的worker，这个worker的run方法中，会通过schedule方法在一定时间后执行<code>sendResponse(null)</code>方法，发送超时响应，send之前需要先从队列中remove掉这个worker。</li><li>如果发生了数据变更，会创建一个执行数据变更的worker，这个worker中会根据dataId从队列中找出对应的woker，然后调用这个worker的<code>sendResponse(data)</code>方法，发送数据变更响应，同样，send之前需要先从队列中remove掉这个worker。</li><li><code>sendResponse</code>方法中，会向AsyncContext对象中写入数据，并调用<code>complete()</code>方法结束请求。</li></ul><h2 id="为什么用长轮询不用长连接"><a class="markdownIt-Anchor" href="#为什么用长轮询不用长连接"></a> 为什么用长轮询不用长连接？</h2><ul><li>长轮询实现更简单，通过HTTP协议即可实现，而HTTP使用十分广泛</li><li>大多数语言都支持HTTP的客户端</li><li>一些配置中心计划未来会改造为长连接，比如nacos</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>比特位计数</title>
    <link href="/2025/07/19/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <url>/2025/07/19/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="比特位计数"><a class="markdownIt-Anchor" href="#比特位计数"></a> 比特位计数</h2><!-- TOC --><ul><li><a href="#%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0">比特位计数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/counting-bits/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数 n ，对于 0 &lt;= i &lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>解释：<br><span class="hljs-number">0</span> <span class="hljs-comment">--&gt; 0</span><br><span class="hljs-number">1</span> <span class="hljs-comment">--&gt; 1</span><br><span class="hljs-number">2</span> <span class="hljs-comment">--&gt; 10</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>对于每个数字 <code>i</code>，其二进制表示中 1 的个数可以通过 <code>i &amp; (i - 1)</code> 来计算。这个操作会将 <code>i</code> 的最低位的 1 变为 0，因此可以通过动态规划来计算每个数字的比特位计数。<br />动态方程可以表示为<code>dp[i]=dp[i&amp;(i-1)]+1</code>，其中 <code>dp[i]</code> 表示数字 <code>i</code> 的比特位计数。</p><blockquote><p>cpp中可以使用 <code>__builtin_popcount</code> 函数来直接计算整数的二进制表示中 1 的个数。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>            dp[i] = dp[i&amp;(i<span class="hljs-number">-1</span>)] + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// dp[i]=__builtin_popcount(i);</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>交错字符串</title>
    <link href="/2025/07/15/%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2025/07/15/%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="交错字符串"><a class="markdownIt-Anchor" href="#交错字符串"></a> 交错字符串</h2><!-- TOC --><ul><li><a href="#%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2">交错字符串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/interleaving-string/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</p><p>示例：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;aabcc&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;dbbca&quot;</span>, <span class="hljs-built_in">s3</span> = <span class="hljs-string">&quot;aadbbcbcac&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用<code>dp[i][j]</code>表示s1的前i个字符和s2的前j个字符能否交错组成s3的前i+j个字符。</p><ul><li>初始化<code>dp[0][0] = true</code></li><li>对于每个<code>dp[i][j]</code>，如果s1的第i个字符等于s3的第i+j-1个字符，且<code>dp[i-1][j]</code>为true，则<code>dp[i][j]</code>为true。</li><li>如果s2的第j个字符等于s3的第i+j-1个字符，且<code>dp[i][j-1]</code>为true，则<code>dp[i][j]</code>为true。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInterleave</span><span class="hljs-params">(string s1, string s2, string s3)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=s1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m=s2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n+m!=s3.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m+<span class="hljs-number">1</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>                <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)<br>                    dp[i][j] |=(s1[i<span class="hljs-number">-1</span>]==s3[i+j<span class="hljs-number">-1</span>]&amp;&amp;dp[i<span class="hljs-number">-1</span>][j]);<br>                <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>)<br>                    dp[i][j] |=(s2[j<span class="hljs-number">-1</span>]==s3[i+j<span class="hljs-number">-1</span>]&amp;&amp;dp[i][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>删除多余括号</title>
    <link href="/2025/07/07/%E5%88%A0%E9%99%A4%E5%A4%9A%E4%BD%99%E6%8B%AC%E5%8F%B7/"/>
    <url>/2025/07/07/%E5%88%A0%E9%99%A4%E5%A4%9A%E4%BD%99%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="删除多余括号"><a class="markdownIt-Anchor" href="#删除多余括号"></a> 删除多余括号</h2><!-- TOC --><ul><li><a href="#%E5%88%A0%E9%99%A4%E5%A4%9A%E4%BD%99%E6%8B%AC%E5%8F%B7">删除多余括号</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/remove-invalid-parentheses/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。</p><p>返回所有可能的结果。答案可以按 任意顺序 返回。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">示例 <span class="hljs-number">1</span>：<br><br>输入：s = <span class="hljs-string">&quot;()())()&quot;</span><br>输出：[<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要思路和bfs类似，创建两个set,一个存储当前层的字符串，一个存储下一层的字符串。</p><ul><li>每次遍历当前层的字符串，检查是否有效，如果有效则加入答案中。</li><li>如果当前层没有有效字符串，则遍历当前层set中的每个字符串的每个字符，每次删除一个括号，加入下一层set中。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string s)</span></span>&#123;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s)&#123;<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;(&#x27;</span>)<br>                ++cnt;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                --cnt;<br>                <span class="hljs-keyword">if</span>(cnt&lt;<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt==<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">removeInvalidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        unordered_set&lt;string&gt; curst;<br>        curst.<span class="hljs-built_in">insert</span>(s);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">for</span>(string ss:curst)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(ss))&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(ss);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> ans;<br>            unordered_set&lt;string&gt; nextst;<br>            <span class="hljs-keyword">for</span>(string t:curst)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t.<span class="hljs-built_in">size</span>();i++)&#123;<br>                    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;t[i]==t[i<span class="hljs-number">-1</span>])<br>                        <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">if</span>(t[i]==<span class="hljs-string">&#x27;(&#x27;</span>||t[i]==<span class="hljs-string">&#x27;)&#x27;</span>)<br>                        nextst.<span class="hljs-built_in">insert</span>(t.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,i)+t.<span class="hljs-built_in">substr</span>(i+<span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>            curst=nextst;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>暑期整理</title>
    <link href="/2025/07/05/%E6%9A%91%E6%9C%9F%E6%95%B4%E7%90%86/"/>
    <url>/2025/07/05/%E6%9A%91%E6%9C%9F%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%A8%A1%E5%9E%8B%E8%AF%84%E6%B5%8B%E5%B9%B3%E5%8F%B0">分布式模型评测平台</a><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD">主要功能</a></li><li><a href="#%E5%85%B3%E9%94%AE%E6%A8%A1%E5%9D%97">关键模块</a><ul><li><a href="#%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F">调度方式</a><ul><li><a href="#%E6%97%A7%E7%89%88%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F">旧版调度方式</a></li><li><a href="#%E6%96%B0%E7%89%88%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F">新版调度方式</a></li></ul></li><li><a href="#zookeeper%E7%9A%84%E4%BD%BF%E7%94%A8">zookeeper的使用</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF">基本信息</a></li><li><a href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">工作流程</a></li></ul></li><li><a href="#%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC">任务状态流转</a></li><li><a href="#redis%E7%9A%84%E4%BD%BF%E7%94%A8">redis的使用</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="分布式模型评测平台"><a class="markdownIt-Anchor" href="#分布式模型评测平台"></a> 分布式模型评测平台</h1><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>该平台主要用于将业务数据批量上传给大模型，通过大模型的能力完成判断是否存在违规行为、责任划分等业务内容，同时还可以根据大模型的返回结果，制定相应的评测规则，对大模型的判断结果进行打分，评价大模型的业务能力，平台的主要功能包括数据导入、任务创建、模型评测、工作流评测、自定义评测规则、结果导出等，可服务于企业内部多种业务需求。</p><h2 id="主要功能"><a class="markdownIt-Anchor" href="#主要功能"></a> 主要功能</h2><p>TODO:</p><h2 id="关键模块"><a class="markdownIt-Anchor" href="#关键模块"></a> 关键模块</h2><h3 id="调度方式"><a class="markdownIt-Anchor" href="#调度方式"></a> 调度方式</h3><h4 id="旧版调度方式"><a class="markdownIt-Anchor" href="#旧版调度方式"></a> 旧版调度方式</h4><p>旧版调度模式下，主要的工作流程如下：</p><ol><li>新建评测任务</li><li>定时任务扫描到新建的任务，然后开始处理</li><li>处理每个任务时，首先可以从在线数据源中或者本地上传的评测集中获取数据，通过获取的数据构建众多tasks,然后将这些task写入到数据库中</li><li>接下来，从模型的维度将task的id通过lpush添加到redis队列，其中redis的key是通过<code>modelName+index</code>设置的，index是模型对应的队列</li><li>在应用启动时，会给模型评测的Diamond配置增加一个监听器，监听对应配置变更，当配置变化时，会给配置里的每个模型启动2个工作线程，提交到线程池，具体来说，实际上是一个模型对应2个redis队列，然后通过2个工作线程，分别从对应redis队列取出task来处理，也就是一个线程处理一个redis队列的tasks</li><li>工作线程取出task后，先尝试获取锁，这里获取锁是主要通过一个lua脚本限流，因为大模型的api通常是有调用频率限制的，这里评测的数据可能很多，调用时需要限流。获取到锁之后，向对应模型发送请求，并获取请求结果，如果请求失败则进行3～5次的重试，请求成功后，将task结果更新到数据库中。</li></ol><p><strong>存在的问题</strong>：<br />旧版的调度方式下，一个模型默认分配两个队列，并且由两个工作线程处理，如果多个用户同时创建任务，可能会导致某个模型的队列排队的task过多，导致一些用户的任务长时间得不到处理。</p><h4 id="新版调度方式"><a class="markdownIt-Anchor" href="#新版调度方式"></a> 新版调度方式</h4><p>新版调度方式与旧版调度方式相比，主要的区别在于：</p><ul><li>新版的调度方式中，redis队列的key是<code>modelName+AK</code>，并且通过zookeeper对资源节点进行监听</li><li>每个<code>modelName+AK</code>都会对应一个zk资源节点，也对应一个存放task的redis队列，zk会根据资源节点创建对应的线程并提交，默认一个资源节点对应2个线程。</li><li>运行时，通过一个定时任务来判断redis队列是否为空，如果一段时间内redis队列为空，则删除对应的zk资源节点，释放资源，同时zk监听到资源节点被删除后，会自动关闭对应的线程。</li></ul><h3 id="zookeeper的使用"><a class="markdownIt-Anchor" href="#zookeeper的使用"></a> zookeeper的使用</h3><p>在新的调度方式中，zookeeper主要用于管理模型的资源节点并实时创建和释放工作线程。实际使用中，主要通过使用CuratorFramework实现一些zk客户端的操作，包括创建节点、删除节点、监听节点变化等。</p><h4 id="基本信息"><a class="markdownIt-Anchor" href="#基本信息"></a> 基本信息</h4><p>主要角色包括：master和slave</p><p><strong>master的职责：</strong></p><ul><li>初始化leader信息：即在<code>leader_info/&#123;master_host&#125;</code>路径下创建一个临时节点，将leader的更新时间等信息写入到这个节点</li><li>设置分片信息：在<code>sharding_info_path</code>路径下创建一个临时节点，设置当前分片信息，实际上一个机器就是一个分片id，并对应当前机器的host</li><li>设置执行节点信息：这是实现资源动态调度的关键之一，这里拉取<code>node_info_path</code>下所有子节点的名称，然后拉取<code>election_assets</code>下所有子节点的名称（所有申请的<code>model+ak</code>资源），然后为每个节点的执行节点写入所有assets信息，执行节点路径为<code>node_executor_info_path/&#123;node_host&#125;</code>。</li><li>更新zk的选举状态：更新<code>election_status_path</code>节点的选举状态</li><li>更新自身选举状态：finish or not</li><li>关闭slave的监听器：因为master可能是由slave转过来的，所以需要关闭之前slave的监听器，如果有的话</li><li>更新集群稳定信息：在<code>leader_info/&#123;host&#125;</code>路径下更新集群稳定的时间</li><li>通过守护线程，同步集群节点信息、同步集群心跳检测信息、同步集群执行节点信息、监测集群稳定状态等</li></ul><p><strong>salve职责：</strong></p><ul><li>监听切片信息：添加一个监听器，主要从<code>sharding_info_path</code>路径下获取切片信息，获取到切片信息后，更新自身的切片信息，切片信息是一个ConcurrentSkipListMap，保证并发安全、有序性和<code>logn</code>的查询性能，key是切片id，value是切片对应的host</li></ul><blockquote><p>监听步骤：</p><ol><li>创建客户端的NodeCache对象cache，指定客户端和监听的路径</li><li>创建NodeCacheListener对象listener，重写其<code>nodeChanged</code>方法，定义监听到节点变化时的处理逻辑</li><li><code>cache.getListenable().addListener(listener)</code>将监听器添加</li><li><code>cache.start()</code>启动监听器</li></ol></blockquote><ul><li>监听选举状态：添加一个监听器，主要从<code>election_status_path</code>路径下获取选举状态，获取到选举状态后，更新自身的选举状态</li></ul><p><strong>守护线程基础知识：</strong><br />守护线程（Daemon Thread），也叫后台线程，是Java中的一种特殊线程。它在后台为其他非守护线程（即用户线程）提供通用服务，但它本身不属于程序中不可或缺的部分</p><p>守护线程与普通线程的核心区别是：当JVM中不存在任何一个正在运行的<strong>非守护线程</strong>时，JVM进程就会退出。<br />也就是说，只要还有任何一个非守护线程在运行，程序就不会终止。而当所有非守护线程都执行完毕后，JVM会强制终止所有仍在运行的守护线程，然后退出。守护线程拥有自动结束自己生命周期的特性，而非守护线程不具备。</p><p>一个非常典型的例子就是JVM的垃圾回收（GC）线程。GC线程就是一个守护线程，它在后台默默回收内存。如果GC线程是普通线程，那么即使我们的主业务逻辑（main线程等）已经全部执行完毕，只要GC线程还在运行，JVM就永远无法退出，这显然是不合理的。</p><p>总结一下就是：非守护线程结束后，jvm就会退出，jvm退出时，会终止所有守护线程</p><h4 id="工作流程"><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h4><p>SpringBoot应用启动时，主要通过client服务执行每个节点的一系列流程：</p><ol><li>创建CuratorFramework客户端</li><li>当前节点信息写入：在<code>node_info_path/&#123;node_host&#125;</code>路径下创建一个临时节点</li><li>创建执行节点：在<code>node_executor_info_path/&#123;node_host&#125;</code>路径下创建一个执行节点，并启动监听器，这是动态调度的关键。该监听器监听到节点变化时，会执行以下操作：<ul><li>拉取当前执行节点<code>node_executor_info_path/&#123;node_host&#125;</code>下的所有资源名称，然后和旧的资源名称进行对比，找出新增的资源和删除的资源</li><li>对于新增的资源，每个资源创建两个线程，提交到线程池</li><li>对于删除的资源，关闭对应的线程，并从map中移除资源</li></ul></li><li>leader选举：通过LeaderLatch的start启动自动选主，并监听当前客户端的选主状态，如果当前客户端是leader,则执行一系列操作，包括关闭之前的slave监听器、更新选举状态、设置分片信息、设置leader信息、启动守护线程任务等，如果已经不再是leader了，则更新选举状态并关闭守护线程任务，并执行作为slave的监听器。</li><li>启动心跳检测：当前客户端每30s更新一下心跳信息，并打印日志</li><li>监听node_info_path路径下的节点变化：添加一个监听器，监听子节点发生增删改时，执行以下操作：<ul><li>如过当前节点是leader, 执行更新分片信息、更新选举状态、更新执行节点信息等操作</li><li>如果发生了重连，leader和slave都重新写入节点信息</li></ul></li><li>监听election_assets路径下的节点变化：添加一个监听器，监听子节点资源发生增删的情况，由master节点重新写入执行节点信息</li></ol><h3 id="任务状态流转"><a class="markdownIt-Anchor" href="#任务状态流转"></a> 任务状态流转</h3><p>评测任务的状态流传主要是通过不同的定时任务实现的，不同的定时任务实现schedulerx的JavaProcessor接口，并重写process方法，来执行对应的处理逻辑，整体状态的流转如下：</p><ul><li>评测任务创建，状态转为waiting,待执行状态</li><li>定时任务扫描待执行状态的评测任务，取最早的一个评测任务开始执行，执行时将评测任务对应的数据转为task导入到数据库，然后插入redis队列，完成后状态转为执行中，此时对应worker开始从redis队列取task并执行，如果有上游依赖任务，则将评测任务状态改为待重试。</li><li>定时任务扫描所有待重试状态的评测任务，执行时先查询该任务的上游依赖任务是否已经完成，如果完成可以执行导入数据库和redis队列的逻辑，如果上游任务未完成，且已经超过8小时都未完成，则将评测任务状态改为失败，否则继续等待上游任务完成。</li><li>当所有task都执行完成时，将评测任务状态改为待评分</li><li>定时任务扫描待评分状态的评测任务，取最早的一个评测任务开始执行，执行时将评测任务的每个task结果进行打分，打分规则由用户定义的js脚本决定，当所有task完成评分后，将评测任务状态改为待计算指标</li><li>定时任务扫描待计算指标的评测任务，取最早的一个评测任务开始执行，执行时统计所有task的准确率、完成率等指标，完成后将评测任务状态改为已完成</li><li>定时任务扫描所有已完成的任务，将所有task的结果导出到指定数据源中，将状态更改为导出完成</li></ul><h3 id="redis的使用"><a class="markdownIt-Anchor" href="#redis的使用"></a> redis的使用</h3><p>在此项目中，redis主要有下面的用途：</p><ul><li>**存放模型评测任务的所有task：**用一个redis队列存放评测任务的task，队列的key是<code>modelName+AK</code>，通过lpush将task放入redis队列，每个机器会创建worker并通过rpop来从对应队列中取出task并消费</li><li>**定时任务分布式锁：**因为有多个机器都要执行定时任务，为了确保同一时间只有一个机器在执行定时任务，所以使用redis的setnx命令来实现分布式锁，超时时间为10分钟，执行完定时任务后删除分布式锁。</li><li>**作为评测任务查询的缓存：**因为每个task执行时，需要通过id查询评测任务信息，所以每次查询时，先从redis缓存中获取评测任务信息，如果没有则从数据库中查询，然后放入redis缓存中，设置过期时间为1小时，在更新时，先更新数据库，再删除redis缓存，降低数据不一致的风险。</li><li>**更新任务执行进度：**因为每个评测任务对应很多task，为了及时更新task的执行进度，用redis的hash结构存储评测任务的进度信息，比如当前完成数量，成功数量，失败数量等等，key是评测任务的id, field是进度的名称，value是进度的值，使用hIncrement命令更新进度信息，当所有task都执行完后，通过hgetAll命令获取所有进度信息，更新评测任务的状态。</li><li>**模型并发限流：**因为大模型的api通常有调用频率限制，所以在worker获取task时，通过lua脚本尝试获取锁，lua脚本中，主要将模型将当前worker线程的UUID和时间戳存在zset中，UUID作为member，时间戳作为score，每次获取锁时，先删除过期的member，然后判断当前member数量是否超过限制，如果超过限制则返回失败，否则添加当前member并返回成功，并发限制数可以通过diamond动态配置。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mcp学习</title>
    <link href="/2025/06/10/mcp%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/06/10/mcp%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#mcp%E5%AD%A6%E4%B9%A0">mcp学习</a><ul><li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li><li><a href="#%E4%BD%BF%E7%94%A8spring-ai%E5%88%9B%E5%BB%BAmcp-server">使用Spring AI创建mcp server</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li><li><a href="#%E5%9F%BA%E4%BA%8Estdio%E7%9A%84mcp%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0">基于stdio的mcp服务端实现</a></li><li><a href="#%E5%9F%BA%E4%BA%8Esse%E7%9A%84mcp%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0">基于SSE的mcp服务端实现</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8spring-ai%E5%88%9B%E5%BB%BAmcp-client">使用Spring AI创建mcp client</a><ul><li><a href="#%E5%9F%BA%E4%BA%8Estdio%E7%9A%84mcp-client%E5%AE%9E%E7%8E%B0">基于stdio的mcp client实现</a></li><li><a href="#%E5%9F%BA%E4%BA%8Esse%E7%9A%84mcp-client%E5%AE%9E%E7%8E%B0">基于SSE的mcp client实现</a></li></ul></li><li><a href="#agent%E4%BD%BF%E7%94%A8mcp%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">agent使用mcp的工作流程</a></li><li><a href="#sse%E5%92%8Cstreamable-http%E7%9A%84%E5%AF%B9%E6%AF%94">SSE和Streamable HTTP的对比</a><ul><li><a href="#sseserver-sent-events%E7%9A%84%E9%97%AE%E9%A2%98">SSE（Server-Sent Events）的问题</a></li><li><a href="#streamable-http%E7%9A%84%E4%BC%98%E5%8A%BF">Streamable HTTP的优势</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="mcp学习"><a class="markdownIt-Anchor" href="#mcp学习"></a> mcp学习</h1><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>模型上下文协议（model context protocol）是由Anthropic提出的一种协议，它给LLM和各类工具提供了一种标准化的桥梁，让LLM可以使用各种工具和API。</p><h2 id="使用spring-ai创建mcp-server"><a class="markdownIt-Anchor" href="#使用spring-ai创建mcp-server"></a> 使用Spring AI创建mcp server</h2><h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3><p>Spring AI MCP包括以下组件：</p><ul><li>Spring AI服务端：使用Spring AI框架构建想要通过MCP访问数据的AI应用程序。</li><li>Spring MCP客户端：MCP协议的spring ai实现，一个客户端可以配置多个mcp server</li></ul><p>此外，Spring提供了两种机制快速搭建mcp server：</p><ul><li>基于stdio的进程间通信传输，以独立的进程运行在本地，比较适合轻量级的工具</li><li>基于SSE（server sent events）进行远程服务访问，适合mcp server部署在远程服务器上，客户端通过http请求等方式访问。</li></ul><h3 id="基于stdio的mcp服务端实现"><a class="markdownIt-Anchor" href="#基于stdio的mcp服务端实现"></a> 基于stdio的mcp服务端实现</h3><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-mcp-server-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在<code>application.yml</code>中配置mcp服务端</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>    <span class="hljs-attr">main:</span><br>        <span class="hljs-attr">web-application-type:</span> <span class="hljs-string">none</span> <span class="hljs-comment"># 禁用web应用程序类型</span><br>        <span class="hljs-attr">banner-mode:</span> <span class="hljs-string">off</span> <span class="hljs-comment"># 禁用banner</span><br>    <span class="hljs-attr">ai:</span><br>        <span class="hljs-attr">mcp:</span><br>            <span class="hljs-attr">server:</span><br>                <span class="hljs-attr">stdio:</span> <span class="hljs-literal">true</span><br>                <span class="hljs-attr">name:</span> <span class="hljs-string">my-weather-server</span><br>                <span class="hljs-attr">version:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><ol start="3"><li>实现mcp工具，通过<code>@Tool</code>注解标记工具方法，其中<code>decription</code>可以添加对工具的描述，<code>@ToolParameter</code>可以标明工具具体的接收参数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeatherTool</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebClient webClient;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeatherTool</span><span class="hljs-params">(WebClient.Builder webClientBuilder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.webClient = webClientBuilder<br>            .baseUrl(<span class="hljs-string">&quot;https://api.open-meteo.com/v1&quot;</span>)<br>            .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Tool(description = &quot;根据经纬度获取天气预报&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getWeatherForecast</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@ToolParameter(description = &quot;纬度，如39.9042&quot;)</span> String latitude,</span><br><span class="hljs-params">            <span class="hljs-meta">@ToolParameter(description = &quot;经度，如116.4074&quot;)</span> String longitude)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> webClient.get()<br>                .uri(uriBuilder -&gt; uriBuilder<br>                    .path(<span class="hljs-string">&quot;/forecast&quot;</span>)<br>                    .queryParam(<span class="hljs-string">&quot;latitude&quot;</span>, latitude)<br>                    .queryParam(<span class="hljs-string">&quot;longitude&quot;</span>, longitude)<br>                    .queryParam(<span class="hljs-string">&quot;current&quot;</span>, <span class="hljs-string">&quot;temperature_2m,wind_speed_10m&quot;</span>)<br>                    .queryParam(<span class="hljs-string">&quot;timezone&quot;</span>, <span class="hljs-string">&quot;auto&quot;</span>)<br>                    .build())<br>                .retrieve()<br>                .bodyToMono(String.class)<br>                .block();<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;天气信息&quot;</span>+ response;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Error fetching weather data: &quot;</span> + e.getMessage();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Tool(description = &quot;根据经纬度获取空气质量信息&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAirQuality</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@ToolParameter(description = &quot;纬度，如39.9042&quot;)</span> String latitude,</span><br><span class="hljs-params">            <span class="hljs-meta">@ToolParameter(description = &quot;经度，如116.4074&quot;)</span> String longitude)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> webClient.get()<br>                .uri(uriBuilder -&gt; uriBuilder<br>                    .path(<span class="hljs-string">&quot;/air-quality&quot;</span>)<br>                    .queryParam(<span class="hljs-string">&quot;latitude&quot;</span>, latitude)<br>                    .queryParam(<span class="hljs-string">&quot;longitude&quot;</span>, longitude)<br>                    .queryParam(<span class="hljs-string">&quot;timezone&quot;</span>, <span class="hljs-string">&quot;auto&quot;</span>)<br>                    .build())<br>                .retrieve()<br>                .bodyToMono(String.class)<br>                .block();<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;空气质量信息&quot;</span> + response;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Error fetching air quality data: &quot;</span> + e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>注册mcp工具，主要是返回<code>ToolCallbackProvider</code>的bean</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ToolCallbackProvider <span class="hljs-title function_">weatherTools</span><span class="hljs-params">(WeatherTool weatherTool)</span> &#123;<br>    <span class="hljs-keyword">return</span> MethodToolCallbackProvider.builder()<br>            .toolObjects(weatherTool)<br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>启动应用程序，mcp服务端会监听标准输入输出流，等待客户端的请求。</li></ol><h3 id="基于sse的mcp服务端实现"><a class="markdownIt-Anchor" href="#基于sse的mcp服务端实现"></a> 基于SSE的mcp服务端实现</h3><p>基于SSE的mcp服务端通过http协议进行通信，适合远程服务访问，具体流程与stdio非常类似</p><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-mcp-server-webflux-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li>在<code>application.yml</code>中配置mcp服务端</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 设置端口号</span><br><span class="hljs-attr">spring:</span><br>    <span class="hljs-attr">ai:</span><br>        <span class="hljs-attr">mcp:</span><br>            <span class="hljs-attr">server:</span><br>                <span class="hljs-attr">name:</span> <span class="hljs-string">my-weather-server</span><br>                <span class="hljs-attr">version:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><ol start="3"><li>实现mcp工具，通过<code>@Tool</code>注解标记工具方法，其中<code>decription</code>可以添加对工具的描述，<code>@ToolParameter</code>可以标明工具具体的接收参数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeatherTool</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebClient webClient;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeatherTool</span><span class="hljs-params">(WebClient.Builder webClientBuilder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.webClient = webClientBuilder<br>            .baseUrl(<span class="hljs-string">&quot;https://api.open-meteo.com/v1&quot;</span>)<br>            .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Tool(description = &quot;根据经纬度获取天气预报&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getWeatherForecast</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@ToolParameter(description = &quot;纬度，如39.9042&quot;)</span> String latitude,</span><br><span class="hljs-params">            <span class="hljs-meta">@ToolParameter(description = &quot;经度，如116.4074&quot;)</span> String longitude)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> webClient.get()<br>                .uri(uriBuilder -&gt; uriBuilder<br>                    .path(<span class="hljs-string">&quot;/forecast&quot;</span>)<br>                    .queryParam(<span class="hljs-string">&quot;latitude&quot;</span>, latitude)<br>                    .queryParam(<span class="hljs-string">&quot;longitude&quot;</span>, longitude)<br>                    .queryParam(<span class="hljs-string">&quot;current&quot;</span>, <span class="hljs-string">&quot;temperature_2m,wind_speed_10m&quot;</span>)<br>                    .queryParam(<span class="hljs-string">&quot;timezone&quot;</span>, <span class="hljs-string">&quot;auto&quot;</span>)<br>                    .build())<br>                .retrieve()<br>                .bodyToMono(String.class)<br>                .block();<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;天气信息&quot;</span>+ response;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Error fetching weather data: &quot;</span> + e.getMessage();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Tool(description = &quot;根据经纬度获取空气质量信息&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAirQuality</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@ToolParameter(description = &quot;纬度，如39.9042&quot;)</span> String latitude,</span><br><span class="hljs-params">            <span class="hljs-meta">@ToolParameter(description = &quot;经度，如116.4074&quot;)</span> String longitude)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> webClient.get()<br>                .uri(uriBuilder -&gt; uriBuilder<br>                    .path(<span class="hljs-string">&quot;/air-quality&quot;</span>)<br>                    .queryParam(<span class="hljs-string">&quot;latitude&quot;</span>, latitude)<br>                    .queryParam(<span class="hljs-string">&quot;longitude&quot;</span>, longitude)<br>                    .queryParam(<span class="hljs-string">&quot;timezone&quot;</span>, <span class="hljs-string">&quot;auto&quot;</span>)<br>                    .build())<br>                .retrieve()<br>                .bodyToMono(String.class)<br>                .block();<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;空气质量信息&quot;</span> + response;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Error fetching air quality data: &quot;</span> + e.getMessage();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>注册mcp工具，主要是返回<code>ToolCallbackProvider</code>的bean</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ToolCallbackProvider <span class="hljs-title function_">weatherTools</span><span class="hljs-params">(WeatherTool weatherTool)</span> &#123;<br>    <span class="hljs-keyword">return</span> MethodToolCallbackProvider.builder()<br>            .toolObjects(weatherTool)<br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>启动应用程序，mcp服务端会监听HTTP请求，等待客户端的请求。</li></ol><h2 id="使用spring-ai创建mcp-client"><a class="markdownIt-Anchor" href="#使用spring-ai创建mcp-client"></a> 使用Spring AI创建mcp client</h2><p>客户端同样通过stdio或SSE两种方式进行通信，具体流程与服务端类似。</p><h3 id="基于stdio的mcp-client实现"><a class="markdownIt-Anchor" href="#基于stdio的mcp-client实现"></a> 基于stdio的mcp client实现</h3><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-mcp-client-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在<code>application.yml</code>中配置mcp服务器</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>    <span class="hljs-attr">ai:</span><br>        <span class="hljs-attr">dashscope:</span><br>            <span class="hljs-attr">api-key:</span> <span class="hljs-string">YOUR_API_KEY</span> <span class="hljs-comment"># 替换为你的API密钥</span><br>        <span class="hljs-attr">mcp:</span><br>            <span class="hljs-attr">client:</span><br>                <span class="hljs-attr">stdio:</span><br>                    <span class="hljs-attr">servers-configuration:</span> <span class="hljs-string">classpath:/mcp-servers-config.json</span> <span class="hljs-comment"># MCP服务器配置文件路径</span><br></code></pre></td></tr></table></figure><ol start="3"><li>创建MCP服务器配置文件<code>mcp-servers-config.json</code>，内容如下：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mcpServers&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">//定义名为&quot;weather&quot;的MCP服务器</span><br>    <span class="hljs-attr">&quot;weather&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-comment">//指定启动命令</span><br>        <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;-Dspring.ai.mcp.server.stdio=true&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Dspring.main.web-application-type=none&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-jar&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;path/to/your/weather-server.jar&quot;</span>  # 替换为你的MCP服务器JAR包路径<br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-comment">//指定环境变量</span><br>        <span class="hljs-attr">&quot;env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-comment">// 可以添加更多的MCP服务器配置</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>编写启动类进行测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">McpClientApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(McpClientApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CommandLineRunner <span class="hljs-title function_">predefineQuestions</span><span class="hljs-params">(</span><br><span class="hljs-params">        ChatClient.Builder chatClientBuilder,</span><br><span class="hljs-params">        ToolCallbackProvider tools,</span><br><span class="hljs-params">        ConfigurableApplicationContext context</span><br><span class="hljs-params">    )</span> &#123;<br>        <span class="hljs-keyword">return</span> args -&gt; &#123;<br>            <span class="hljs-comment">// 创建ChatClient实例</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">chatClient</span> <span class="hljs-operator">=</span> chatClientBuilder<br>                .defaultTools(tools) <span class="hljs-comment">//传入预定义的工具</span><br>                .build();<br><br>            <span class="hljs-comment">// 定义预设问题</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">question1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;请告诉我北京的天气预报&quot;</span>;<br>            <br>            <span class="hljs-comment">// 打印问题</span><br>            System.out.println(<span class="hljs-string">&quot;问题: &quot;</span> + question1);<br><br>            <span class="hljs-comment">//调用LLM并打印响应</span><br>            System.out.println(<span class="hljs-string">&quot;响应: &quot;</span> + chatClient.prompt(question1)<br>                .call()<br>                .content());<br>            <br>            context.close();<br>        &#125;;    <br>                <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于sse的mcp-client实现"><a class="markdownIt-Anchor" href="#基于sse的mcp-client实现"></a> 基于SSE的mcp client实现</h3><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-mcp-client-webflux-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在<code>application.yml</code>中配置mcp服务器</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>    <span class="hljs-attr">ai:</span><br>        <span class="hljs-attr">dashscope:</span><br>            <span class="hljs-attr">api-key:</span> <span class="hljs-string">YOUR_API_KEY</span> <span class="hljs-comment"># 替换为你的API密钥</span><br>        <span class="hljs-attr">mcp:</span><br>            <span class="hljs-attr">client:</span><br>                <span class="hljs-attr">sse:</span><br>                    <span class="hljs-attr">connections:</span><br>                        <span class="hljs-attr">server1:</span><br>                            <span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost:8080</span> <span class="hljs-string">//替换为你的MCP服务器地址</span><br>                        <span class="hljs-attr">server2:</span> <span class="hljs-string">xxxx</span><br></code></pre></td></tr></table></figure><ol start="3"><li>编写启动类进行测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">McpClientApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(McpClientApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CommandLineRunner <span class="hljs-title function_">predefineQuestions</span><span class="hljs-params">(</span><br><span class="hljs-params">        ChatClient.Builder chatClientBuilder,</span><br><span class="hljs-params">        ToolCallbackProvider tools,</span><br><span class="hljs-params">        ConfigurableApplicationContext context</span><br><span class="hljs-params">    )</span> &#123;<br>        <span class="hljs-keyword">return</span> args -&gt; &#123;<br>            <span class="hljs-comment">// 创建ChatClient实例</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">chatClient</span> <span class="hljs-operator">=</span> chatClientBuilder<br>                .defaultTools(tools) <span class="hljs-comment">//传入预定义的工具</span><br>                .build();<br><br>            <span class="hljs-comment">// 定义预设问题</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">question1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;请告诉我北京的天气预报&quot;</span>;<br>            <br>            <span class="hljs-comment">// 打印问题</span><br>            System.out.println(<span class="hljs-string">&quot;问题: &quot;</span> + question1);<br><br>            <span class="hljs-comment">//调用LLM并打印响应</span><br>            System.out.println(<span class="hljs-string">&quot;响应: &quot;</span> + chatClient.prompt(question1)<br>                .call()<br>                .content());<br>            <br>            context.close();<br>        &#125;;    <br>                <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="agent使用mcp的工作流程"><a class="markdownIt-Anchor" href="#agent使用mcp的工作流程"></a> agent使用mcp的工作流程</h2><pre><code class=" mermaid">sequenceDiagram    participant User    participant AI_Agent as AI Agent (MCP Host)    participant MCP_Client as MCP Client    participant MCP_Server as MCP Server    participant External_Tool_or_DataSource as External Tool/Data Source    User-&gt;&gt;AI_Agent: 发送任务请求 (例如：查询数据库，执行操作)    AI_Agent-&gt;&gt;MCP_Client: 接收用户请求并决定需要外部工具或数据     AI_Agent-&gt;&gt;MCP_Server: 请求可用的工具和数据端点     MCP_Server--&gt;&gt;AI_Agent: 返回可用的工具、资源和提示信息     AI_Agent-&gt;&gt;AI_Agent: 基于请求选择合适的工具或资源     AI_Agent-&gt;&gt;MCP_Client: 通过MCP协议向MCP客户端发送结构化请求    MCP_Client-&gt;&gt;MCP_Server: 将请求转发给对应的MCP服务器     MCP_Server-&gt;&gt;External_Tool_or_DataSource: 将AI请求翻译成外部工具/数据源能理解的命令 (使用其原生API)     External_Tool_or_DataSource--&gt;&gt;MCP_Server: 执行操作并返回结果     MCP_Server--&gt;&gt;MCP_Client: 将结果格式化为AI可理解的格式，并通过MCP协议返回     MCP_Client--&gt;&gt;AI_Agent: 接收处理后的结果     AI_Agent-&gt;&gt;AI_Agent: 处理 retrieved data 并应用上下文推理 (例如：进行总结，生成回复)    AI_Agent--&gt;&gt;User: 提供响应或执行后续操作</code></pre><p>工作流程解释：</p><ul><li><strong>用户发起请求</strong>: 用户向AI Agent发送一个任务请求，这可能是一个需要访问外部信息或执行特定操作的查询。</li><li><strong>AI Agent决策</strong>: AI Agent (作为MCP Host) 接收到用户请求后，会通过其内部逻辑判断是否需要与外部工具或数据源交互来完成任务。</li><li><strong>工具发现</strong>: AI Agent向连接的MCP服务器请求其可提供的工具、资源和预定义提示的列表。MCP服务器会告知AI Agent它所能提供的功能（例如，列出文件、查询数据库等）。</li><li><strong>选择工具</strong>: AI Agent根据用户请求和MCP服务器提供的能力，决定调用哪个合适的工具或资源。</li><li><strong>发送结构化请求</strong>: AI Agent通过MCP客户端，遵循MCP协议，向选定的MCP服务器发送一个结构化请求，其中包含所需操作的参数。</li><li><strong>MCP服务器执行</strong>: MCP服务器接收到请求后，将其翻译成外部工具或数据源能够理解的原生API调用或命令。</li><li><strong>外部系统响应</strong>: 外部工具或数据源执行相应的操作（例如，查询数据库、创建工单、读取文件等）并返回结果给MCP服务器。</li><li><strong>结果格式化与返回</strong>: MCP服务器将从外部系统获得的结果格式化为AI Agent可以理解的统一格式，然后通过MCP客户端返回给AI Agent。</li><li><strong>AI Agent处理</strong>: AI Agent接收到结果后，会对其进行处理，应用其上下文推理能力，例如对数据进行总结，或根据结果生成最终响应。</li><li><strong>用户收到响应</strong>: AI Agent将最终的响应或执行的操作结果反馈给用户。</li></ul><h2 id="sse和streamable-http的对比"><a class="markdownIt-Anchor" href="#sse和streamable-http的对比"></a> SSE和Streamable HTTP的对比</h2><h3 id="sseserver-sent-events的问题"><a class="markdownIt-Anchor" href="#sseserver-sent-events的问题"></a> SSE（Server-Sent Events）的问题</h3><ul><li><p><strong>不支持断线重连/恢复</strong><br />当 SSE 连接断开时，所有会话状态丢失，客户端必须重新建立连接并初始化整个会话。例如，正在执行的大型文档分析任务会因 WiFi 不稳定而完全中断，迫使用户重新开始整个过程。</p></li><li><p><strong>服务器需维护长连接</strong><br />服务器必须为每个客户端维护一个长时间的 SSE 连接，大量并发用户会导致资源消耗剧增。当服务器需要重启或扩容时，所有连接都会中断，影响用户体验和系统可靠性。</p></li><li><p><strong>服务器消息只能通过 SSE 传递</strong><br />即使是简单的请求-响应交互，服务器也必须通过 SSE 通道返回信息，造成不必要的复杂性和开销。对于某些环境（如云函数）不适合长时间保持 SSE 连接。</p></li><li><p><strong>基础设施兼容性限制</strong><br />许多现有的 Web 基础设施如 CDN、负载均衡器、API 网关等可能不能正确处理长时间的 SSE 连接，企业防火墙可能会强制关闭超时连接，导致服务不可靠。</p></li></ul><h3 id="streamable-http的优势"><a class="markdownIt-Anchor" href="#streamable-http的优势"></a> Streamable HTTP的优势</h3><p>相比原有 HTTP+SSE 机制，Streamable HTTP 引入了几项关键改进：</p><ul><li>统一 Endpoint：移除专门的 <code>/sse</code> 端点，所有通信通过单一端点（当前官方 sdk 实现为 <code>/mcp</code>）进行</li><li>按需流式传输：服务器可灵活选择是返回普通 HTTP 响应还是升级为 SSE 流</li><li>会话标识：引入会话 ID 机制，支持状态管理和恢复</li><li>灵活初始化：客户端可通过空 GET 请求主动初始化 SSE 流</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ZooKeeper学习</title>
    <link href="/2025/06/03/ZooKeeper%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/06/03/ZooKeeper%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#zookeeper%E5%AD%A6%E4%B9%A0">ZooKeeper学习</a><ul><li><a href="#zookeeper%E7%AE%80%E4%BB%8B">ZooKeeper简介</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%8F%E8%B0%83%E9%97%AE%E9%A2%98">分布式环境下的数据协调问题</a></li><li><a href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE">一致性协议</a><ul><li><a href="#%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE2pc">二阶段提交协议（2PC）</a></li><li><a href="#%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE3pc">三阶段提交协议（3PC）</a></li></ul></li><li><a href="#zk%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7">ZK如何保证数据一致性？</a><ul><li><a href="#%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD">消息广播</a></li><li><a href="#%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D">崩溃恢复</a></li><li><a href="#%E9%80%89%E4%B8%BEleader%E7%9A%84%E8%BF%87%E7%A8%8B">选举leader的过程</a></li></ul></li><li><a href="#zk%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">ZK的数据结构</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">相关基础知识</a><ul><li><a href="#%E4%BC%9A%E8%AF%9D">会话</a></li><li><a href="#acl">ACL</a></li><li><a href="#watcher%E6%9C%BA%E5%88%B6">Watcher机制</a></li></ul></li><li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85">数据发布和订阅</a></li><li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">负载均衡</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">分布式锁</a><ul><li><a href="#%E6%8E%92%E4%BB%96%E9%94%81">排他锁</a></li><li><a href="#%E5%85%B1%E4%BA%AB%E9%94%81">共享锁</a></li></ul></li><li><a href="#master%E9%80%89%E4%B8%BE">master选举</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="zookeeper学习"><a class="markdownIt-Anchor" href="#zookeeper学习"></a> ZooKeeper学习</h1><h2 id="zookeeper简介"><a class="markdownIt-Anchor" href="#zookeeper简介"></a> ZooKeeper简介</h2><p>ZooKeeper是一个开源的分布式协调服务框架，其一致性是通过基于 Paxos 算法的 ZAB 协议完成的。其主要功能包括：配置维护、分布式同步、集群管理等。</p><h2 id="分布式环境下的数据协调问题"><a class="markdownIt-Anchor" href="#分布式环境下的数据协调问题"></a> 分布式环境下的数据协调问题</h2><ul><li>分布式环境下，无法保证顺序：单机环境下A和B的顺序是由调用顺序决定的，而在分布式环境下，A和B的顺序可能会因为网络延迟等因素而改变。</li><li>分布式环境下，无法明确执行结果：分布式环境下，A即使执行成功了，如果网络传输超时了，也无法判断A是否执行成功。</li><li>分布式环境下，无法保证数据一致性：分布式环境下，多个节点可能会同时修改同一份数据，导致数据不一致。</li></ul><h2 id="一致性协议"><a class="markdownIt-Anchor" href="#一致性协议"></a> 一致性协议</h2><h3 id="二阶段提交协议2pc"><a class="markdownIt-Anchor" href="#二阶段提交协议2pc"></a> 二阶段提交协议（2PC）</h3><p>一种分布式事务协议，分为准备（投票）阶段和提交阶段。<br />投票阶段：</p><ol><li>协调者向所有参与者发送prepare请求，通知参与者执行事务</li><li>参与者收到请求后，执行事务并记录undo日志和redo日志，但不提交事务</li><li>参与者向协调者发送事务执行结果（Yes或者No）</li></ol><p>提交阶段：</p><ol><li>如果所有参与者都返回yes，协调者向所有参与者发送commit请求，通知参与者提交事务，参与者提交事务并返回ack给协调者</li><li>如果有参与者返回no，协调者向所有参与者发送rollback请求，通知参与者回滚事务，参与者根据undo日志回滚事务并返回ack给协调者</li></ol><p>存在的问题：</p><ol><li>容错低，有一个参与者挂了，整个事务就无法完成</li><li>性能低，同步期间所有资源被锁定，资源利用率低</li><li>数据不一致，协调者发送commit命令期间挂了，有的参与者提交了事务，有的没有提交。</li></ol><h3 id="三阶段提交协议3pc"><a class="markdownIt-Anchor" href="#三阶段提交协议3pc"></a> 三阶段提交协议（3PC）</h3><p>在2PC的基础上增加了一个选票预收集阶段，分为预投票、投票和提交三个阶段。</p><ul><li>预投票阶段：协调者向所有参与者发送请求，询问是否可以执行事务，参与者根据自身状态返回Yes或No。</li><li>投票阶段：如果所有参与者都返回Yes，协调者向所有参与者发送prepare请求，参与者执行事务并记录undo日志和redo日志；如果有参与者返回No，协调者向所有参与者发送中断请求，中断事务。</li><li>提交阶段：流程和2PC类似</li></ul><p>3PC仍然没有解决一致性问题</p><h2 id="zk如何保证数据一致性"><a class="markdownIt-Anchor" href="#zk如何保证数据一致性"></a> ZK如何保证数据一致性？</h2><p>ZK主要通过ZAB协议来保证数据的一致性，ZAB协议包括两种工作模式崩溃恢复和消息广播。</p><h3 id="消息广播"><a class="markdownIt-Anchor" href="#消息广播"></a> 消息广播</h3><p>和二阶段提交的思想类似。当客户端写请求到来时，leader会生成一个事务请求，发送给集群的follower，follower收到请求后，执行事务并写入日志，返回结果（yes 或者 no）给leader。如果半数以上的follower返回yes，leader就会向所有follower发送commit请求，follower接受到请求后提交事务。</p><p>要注意的是：</p><ul><li>投票阶段不需要所有follower都返回yes，只需要半数以上的follower返回yes即可。</li><li>leader会维护一个队列保证请求顺序性</li><li>ZAB 中还定义了一个 全局单调递增的事务 ZXID ，它是一个 64 位 long 型，其中高 32 位表示 epoch 年代，低 32 位表示递增的事务 id。epoch 是会根据 Leader 的变化而变化的，当一个 Leader 挂了，新的 Leader 上位的时候，年代（epoch）就 +1，而低 32 位则从0开始重新计数。这个设计也保证了顺序性。</li></ul><h3 id="崩溃恢复"><a class="markdownIt-Anchor" href="#崩溃恢复"></a> 崩溃恢复</h3><p>当leader出现故障或者集群中没有过半服务器与leader通信时，ZK会进行崩溃恢复。主要分三步：</p><ol><li>选举新的leader：ZK会通过投票的方式选举出一个新的leader</li><li>leader获取所有follower提交的最大事务集合</li><li>follower从leader那里同步最新的事务集合，未同步的follower不会被加入到可用列表</li></ol><p>过程中需要保证：</p><ul><li>leader上提交过的事务，最终被所有服务器都提交</li><li>leader上未提交的事务被丢弃</li></ul><h3 id="选举leader的过程"><a class="markdownIt-Anchor" href="#选举leader的过程"></a> 选举leader的过程</h3><p>选举leader的过程简单来说就是发起投票，接受投票，根据收到的投票改变自己的投票，直到某个节点获得过半数的投票为止。</p><ul><li>开始时，每个节点给自己投票，投票内容为<code>自己机器ID+自己提交的最大事务ZXID</code>，然后把投票内容发送给其他节点。</li><li>收到投票后先比较ZXID，如果ZXID相同，则比较机器ID。如果收到的投票比自己的投票大，则更新自己的投票内容为收到的投票内容，并将自己的投票发送给其他节点。</li></ul><h2 id="zk的数据结构"><a class="markdownIt-Anchor" href="#zk的数据结构"></a> ZK的数据结构</h2><p>ZK使用树来维护数据，每个节点都是一个ZNode，ZNode又分为三大类</p><ul><li>持久性节点：创建后一直存在于服务器，直到主动删除</li><li>临时性节点：创建后只在客户端会话存活期间存在，客户端断开连接后自动删除</li><li>顺序节点：创建后会在节点名称后加上一个自增的数字，表示顺序</li></ul><h2 id="相关基础知识"><a class="markdownIt-Anchor" href="#相关基础知识"></a> 相关基础知识</h2><h3 id="会话"><a class="markdownIt-Anchor" href="#会话"></a> 会话</h3><p><code>zk</code> 客户端和服务端是通过 <code>TCP</code> 长连接 维持的会话机制，其实对于会话来说可以理解为 保持连接状态 。在 <code>zookeeper</code> 中，会话还有对应的事件，比如 <code>CONNECTION_LOSS</code> 连接丢失事件、<code>SESSION_MOVED</code> 会话转移事件、<code>SESSION_EXPIRED</code> 会话超时失效事件 。</p><h3 id="acl"><a class="markdownIt-Anchor" href="#acl"></a> ACL</h3><p>ACL 为 Access Control Lists ，它是一种权限控制。在 zookeeper 中定义了 5 种权限，它们分别为：</p><ul><li>CREATE：创建子节点的权限。</li><li>READ：获取节点数据和子节点列表的权限。</li><li>WRITE：更新节点数据的权限。</li><li>DELETE：删除子节点的权限。</li><li>ADMIN：设置节点 ACL 的权限。</li></ul><h3 id="watcher机制"><a class="markdownIt-Anchor" href="#watcher机制"></a> Watcher机制</h3><p>Watcher 为事件监听器，是 zk 非常重要的一个特性，很多功能都依赖于它，它有点类似于订阅的方式，即客户端向服务端 注册 指定的 watcher ，当服务端符合了 watcher 的某些事件或要求则会 向客户端发送事件通知 ，客户端收到通知后找到自己定义的 Watcher 然后 执行相应的回调方法 。</p><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h2><h3 id="数据发布和订阅"><a class="markdownIt-Anchor" href="#数据发布和订阅"></a> 数据发布和订阅</h3><p>Zookeeper 通过推拉相结合的方式实现客户端与服务端的交互：<br />客户端向服务端注册节点，一旦相应节点的数据变更，服务端就会向“监听”该节点的客户端发送 Watcher 事件通知，客户端接收到通知后需要 <strong>主动</strong> 到服务端获取最新的数据。比如全局配置信息管理</p><h3 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h3><p>可以通过临时节点实现负载均衡<br />具体地，我们需要在集群的每一个 Server 中都使用 Zookeeper 客户端连接 Zookeeper 服务端，同时用 Server 自身的地址信息在服务端<strong>指定目录下创建临时节点</strong>。当客户端请求调用集群服务时，首先通过 Zookeeper 获取该目录下的节点列表 （即所有可用的 Server），随后根据不同的负载均衡策略将请求转发到某一具体的 Server。</p><h3 id="分布式锁"><a class="markdownIt-Anchor" href="#分布式锁"></a> 分布式锁</h3><p>ZK的分布式锁也是通过临时节点实现的。</p><h4 id="排他锁"><a class="markdownIt-Anchor" href="#排他锁"></a> 排他锁</h4><p>因为创建节点的唯一性（ZXID），我们可以让多个客户端同时创建一个临时节点，创建成功的就说明获取到了锁 。然后没有获取到锁的客户端也像上面选主的非主节点创建一个 监听器 进行节点状态的监听，如果这个互斥锁被释放了可以调用回调函数重新获得锁。如果客户端挂了，那么临时节点也就会被删除，其他客户端就可以重新获取锁，无需担心锁的释放问题</p><h4 id="共享锁"><a class="markdownIt-Anchor" href="#共享锁"></a> 共享锁</h4><p>因为ZXID的有序性，所以创建的节点也是有序的。当创建节点时，如果比自己小的节点都是读请求，则可以获取到锁，如果比自己小的节点有写请求，则需要等待写请求完成后才能获取锁。</p><p>羊群效应：<br />集群很大时，子节点列表会很大，会创建大量的监听器，但是只有最近的节点接到事件后可以执行，所以造成了资源浪费。<br />改进：<br />读请求只监听比自己小的最近的写请求的节点的状态，写请求只监听比自己小一号的节点的状态。这样就可以减少监听器的数量，避免羊群效应。</p><h3 id="master选举"><a class="markdownIt-Anchor" href="#master选举"></a> master选举</h3><p>ZK的master选举也是通过临时节点实现的。所有节点在ZK中创建同一个临时节点，只有一个客户端能创建成功。</p><p>如何避免脑裂？</p><ul><li>脑裂指某个master挂了，然后选出了新的master，但是旧的master一段时间后恢复了，导致两个master同时存在的情况。</li><li>解决方法是master需要定时更新zk集群的节点，并且为master设置ACL权限，仅master可更新节点，旧的master恢复时发现自己无法更新节点，就会变成follower。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo学习</title>
    <link href="/2025/05/25/Dubbo%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/05/25/Dubbo%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#dubbo%E5%AD%A6%E4%B9%A0">Dubbo学习</a><ul><li><a href="#dubbo%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6">Dubbo架构的核心组件</a></li><li><a href="#dubbo%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">Dubbo的工作流程</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">基本使用</a></li><li><a href="#spi%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88dubbo%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0">SPI机制是什么？Dubbo如何扩展默认实现？</a><ul><li><a href="#spi%E6%9C%BA%E5%88%B6">SPI机制</a></li><li><a href="#dubbo%E6%89%A9%E5%B1%95%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0">Dubbo扩展默认实现</a></li></ul></li><li><a href="#dubbo%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5">Dubbo的负载均衡策略</a></li><li><a href="#%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84rpc%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84">一次完整的RPC是怎样的？</a></li><li><a href="#rpc%E5%92%8Chttp%E7%9A%84%E5%8C%BA%E5%88%AB">RPC和http的区别？</a></li></ul></li></ul><!-- /TOC --><h2 id="dubbo学习"><a class="markdownIt-Anchor" href="#dubbo学习"></a> Dubbo学习</h2><p>Dubbo是一个高性能的Java RPC框架，提供了分布式服务治理的解决方案。它支持多种协议和序列化方式，能够实现服务的注册、发现、调用等功能。</p><h3 id="dubbo架构的核心组件"><a class="markdownIt-Anchor" href="#dubbo架构的核心组件"></a> Dubbo架构的核心组件</h3><ul><li>Container： 服务运行容器，负责加载、运行服务提供者。必须。</li><li>Provider： 暴露服务的服务提供方，会向注册中心注册自己提供的服务。必须。</li><li>Consumer： 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。</li><li>Registry： 服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者。非必须。</li><li>Monitor： 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。 非必须</li></ul><h3 id="dubbo的工作流程"><a class="markdownIt-Anchor" href="#dubbo的工作流程"></a> Dubbo的工作流程</h3><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><ul><li><p>引入dubbo和zookeeper的依赖</p></li><li><p>服务提供方定义接口和实现类</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HelloService</span> &#123;<br>    <span class="hljs-title class_">String</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-title class_">String</span> name);<br>&#125;<br><br><span class="hljs-comment">// @Service: 这是 Dubbo 框架的注解，用于标记一个类为服务提供者。使得 Dubbo 可以自动扫描并将服务发布到注册中心，供消费者发现和调用。</span><br><span class="hljs-meta">@Service</span>(interfaceClass=<span class="hljs-title class_">HelloService</span>.<span class="hljs-property">class</span> , retries=-<span class="hljs-number">1</span>, version=<span class="hljs-string">&quot;1.0.0&quot;</span>, timeout=<span class="hljs-number">15000</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HelloService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;【producer】 Hello, &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>服务消费者调用服务提供方的接口</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerService</span> &#123;<br><span class="hljs-comment">// @Reference 是 Dubbo 框架中的一个注解，用于在消费者端标记对 Dubbo 服务的引用。</span><br>    <span class="hljs-comment">// Dubbo 框架会自动为该注解标记的字段或方法参数注入代理对象。这个代理对象封装了底层的远程调用逻辑，使得消费者可以像调用本地方法一样调用远程服务。</span><br>    <span class="hljs-meta">@Reference</span>(retries=-<span class="hljs-number">1</span>, version=<span class="hljs-string">&quot;1.0.0&quot;</span>, timeout = <span class="hljs-number">15000</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">HelloService</span> helloService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">consumerSayHello</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)&#123;<br>        <span class="hljs-title class_">String</span> hello = helloService.<span class="hljs-title function_">sayHello</span>(name);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;[consumer] &quot;</span>+ hello);<br>        <span class="hljs-keyword">return</span> hello;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spi机制是什么dubbo如何扩展默认实现"><a class="markdownIt-Anchor" href="#spi机制是什么dubbo如何扩展默认实现"></a> SPI机制是什么？Dubbo如何扩展默认实现？</h3><h4 id="spi机制"><a class="markdownIt-Anchor" href="#spi机制"></a> SPI机制</h4><p>SPI 的具体原理是这样的：将接口的实现类放在配置文件中，在程序运行过程中读取配置文件，通过反射加载实现类。这样，我们可以在运行的时候，动态替换接口的实现类。和 IoC 的解耦思想是类似的。</p><p>实现步骤如下：</p><ul><li>定义一个接口</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">Search</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-keyword">String</span>&gt; searchDoc(<span class="hljs-keyword">String</span> keyword);   <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义两个不同的实现类</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSearch</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Search</span></span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-keyword">String</span>&gt; searchDoc(<span class="hljs-keyword">String</span> keyword) &#123;<br>        System.out.println(<span class="hljs-string">&quot;文件搜索 &quot;</span>+keyword);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseSearch</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Search</span></span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-keyword">String</span>&gt; searchDoc(<span class="hljs-keyword">String</span> keyword) &#123;<br>        System.out.println(<span class="hljs-string">&quot;数据库搜索 &quot;</span>+keyword);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在 META-INF/services 目录下创建一个文件，文件名为接口的全限定名，内容为实现类的全限定名</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"># <span class="hljs-keyword">META</span>-<span class="hljs-keyword">INF</span>/services/com.example.spi.<span class="hljs-keyword">Search</span><br>com.example.spi.FileSearch<br></code></pre></td></tr></table></figure><ul><li>测试结果</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> TestCase &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        ServiceLoader&lt;<span class="hljs-keyword">Search</span>&gt; s = ServiceLoader.<span class="hljs-keyword">load</span>(<span class="hljs-keyword">Search</span>.<span class="hljs-keyword">class</span>);<br>        Iterator&lt;<span class="hljs-keyword">Search</span>&gt; iterator = s.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>           <span class="hljs-keyword">Search</span> <span class="hljs-keyword">search</span> =  iterator.next();<br>           <span class="hljs-keyword">search</span>.searchDoc(&quot;hello world&quot;);<br>        &#125;<br>    &#125;<br>&#125;<br>//输出文件搜索 hello world<br></code></pre></td></tr></table></figure><ul><li>如果在<code>com.example.spi.Search</code>文件里写上两个实现类，那最后的输出结果就是两行了。这就是因为<code>ServiceLoader.load(Search.class)</code>在加载某接口时，会去META-INF/services下找接口的全限定名文件，再根据里面的内容加载相应的实现类。</li></ul><h4 id="dubbo扩展默认实现"><a class="markdownIt-Anchor" href="#dubbo扩展默认实现"></a> Dubbo扩展默认实现</h4><p>比如使用自定义的负载均衡器，可以这么做：</p><ul><li>定义一个实现类实现<code>LoadBalance</code>接口</li><li>将实现类的路径添加到<code>META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance</code>文件中</li></ul><h3 id="dubbo的负载均衡策略"><a class="markdownIt-Anchor" href="#dubbo的负载均衡策略"></a> Dubbo的负载均衡策略</h3><ul><li>加权轮询</li><li>加权随机，默认的负载均衡策略</li><li>最小活跃数</li><li>一致性哈希等<br />具体解释可以到<a href="https://lqz2.github.io/2022/08/26/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">常见问题</a>里查看</li></ul><h3 id="一次完整的rpc是怎样的"><a class="markdownIt-Anchor" href="#一次完整的rpc是怎样的"></a> 一次完整的RPC是怎样的？</h3><ol><li><p>调用方持续把请求参数对象序列化成二进制数据，经过 TCP 传输到服务提供方；</p></li><li><p>服务提供方从 TCP 通道里面接收到二进制数据；</p></li><li><p>根据 RPC 协议，服务提供方将二进制数据分割出不同的请求数据，经过反序列化将二进制数据逆向还原出请求对象，找到对应的实现类，完成真正的方法调用；</p></li><li><p>然后服务提供方再把执行结果序列化后，回写到对应的 TCP 通道里面；</p></li><li><p>调用方获取到应答的数据包后，再反序列化成应答对象。</p></li></ol><h3 id="rpc和http的区别"><a class="markdownIt-Anchor" href="#rpc和http的区别"></a> RPC和http的区别？</h3><p>RPC（远程过程调用）是一种面向“方法”的调用模型，让我们可以像调用本地函数一样调用远程服务；而HTTP是一种面向“资源”的应用层协议，我们通过URL来定位资源，用GET、POST等方法来操作它</p><ol><li>核心思想与抽象级别不同<br />RPC：是面向方法 (Action-oriented) 的。开发者关注的是“我需要调用哪个服务的哪个方法”。<br />HTTP：是面向资源 (Resource-oriented) 的。开发者关注的是“我要操作哪个资源”。</li><li>传输效率与协议不同<br />RPC：通常追求高性能。它经常使用二进制协议（如Protobuf）进行序列化，报文体积小，解析速度快。通信方式上，它倾向于使用长连接，避免了频繁创建和销毁连接的开销。<br />HTTP：通常使用文本协议（如JSON/XML），可读性好但冗余信息多，报文体积大。它多为短连接，每次请求都可能需要建立新的TCP连接（虽然有Keep-Alive优化），效率相对较低。</li><li>服务治理能力不同<br />RPC：成熟的RPC框架（如gRPC、Dubbo）通常内置了完善的服务治理能力。比如服务发现、负载均衡、熔断降级、限流等功能。<br />HTTP：本身不带服务治理能力。要实现类似的功能，通常需要依赖外部组件或基础设施，比如通过Nginx做负载均衡，通过Consul/Nacos做服务发现，通过API网关来实现熔断和限流。</li><li>应用场景不同<br />RPC：因其高性能、高效率和完善的服务治理，主要用于公司内部的微服务之间调用。<br />HTTP：主要用于对外暴露的服务，它的普适性是最大的优势。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Guava缓存学习</title>
    <link href="/2025/05/22/Guava%E7%BC%93%E5%AD%98%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/05/22/Guava%E7%BC%93%E5%AD%98%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="guava缓存学习"><a class="markdownIt-Anchor" href="#guava缓存学习"></a> Guava缓存学习</h1><h2 id="guava简介"><a class="markdownIt-Anchor" href="#guava简介"></a> Guava简介</h2><p>Guava是Google封装的基础工具包，主要用于<strong>本地缓存</strong>，提供了以下能力：</p><ul><li>封装了缓存与数据源的交互流程，使得开发更关注于业务操作</li><li>提供线程安全的存取操作，类比ConcurrentHashMap</li><li>提供了多种缓存过期策略，刷新策略</li><li>提供缓存命中率的监控</li></ul><h2 id="基础使用"><a class="markdownIt-Anchor" href="#基础使用"></a> 基础使用</h2><p>下面是一个简单的示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> key</span>) &#123;<br>    <span class="hljs-keyword">return</span> key.<span class="hljs-title function_">toUpperCase</span>();<br>&#125;<br><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">testCache</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Cache</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>&gt; cache = <span class="hljs-title class_">CacheBuilder</span>.<span class="hljs-title function_">newBuilder</span>()<br>            .<span class="hljs-title function_">build</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheLoader</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">load</span>(<span class="hljs-title class_">String</span> key) throws <span class="hljs-title class_">Exception</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-title function_">convert</span>(key);<br>                &#125;<br>            &#125;);<br>    <span class="hljs-title function_">assertEquals</span>(<span class="hljs-string">&quot;HELLO&quot;</span>, cache.<span class="hljs-title function_">getUnchecked</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-title function_">assertEquals</span>(<span class="hljs-string">&quot;HELLO&quot;</span>, cache.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    <span class="hljs-title function_">assertEquals</span>(<span class="hljs-number">1</span>, cache.<span class="hljs-title function_">size</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的load方法可以理解为从数据源加载数据的过程。</p><p>当调用<code>getUnchecked</code>方法或者<code>get</code>方法时，Guava的行为如下：</p><ul><li>如果缓存命中，则直接返回</li><li>缓存未命中，会调用load接口，加载进缓存，返回缓存值</li><li>多线程下，A线程load时，会阻塞B线程的请求，直到缓存加载完毕</li></ul><h2 id="预加载缓存"><a class="markdownIt-Anchor" href="#预加载缓存"></a> 预加载缓存</h2><p>预加载缓存一般用于以下场景：</p><ul><li>秒杀场景，事先将热点商品加载到缓存</li><li>系统启动时，预加载一些数据到缓存</li></ul><p>预加载缓存一般用put：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">cache.<span class="hljs-keyword">put</span>(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br></code></pre></td></tr></table></figure><p>上面的put方法会直接将数据放入缓存中，不会调用load方法。</p><blockquote><p>不要使用get方法来预加载数据，因为get方法会调用load方法，可能会导致性能问题。</p></blockquote><h2 id="缓存过期"><a class="markdownIt-Anchor" href="#缓存过期"></a> 缓存过期</h2><h3 id="缓存固定数量的值"><a class="markdownIt-Anchor" href="#缓存固定数量的值"></a> 缓存固定数量的值</h3><p>通过maximumSize方法设置缓存的最大值，当缓存超过最大值时，Guava会自动进行缓存淘汰。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lasso">@Test<br><span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> maxSizeTest()&#123;<br>    <span class="hljs-keyword">Cache</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">cache</span> = CacheBuilder.newBuilder()<br>            .maximumSize(<span class="hljs-number">2</span>)<br>            .build(<span class="hljs-literal">new</span> CacheLoader&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt;() &#123;<br>                @Override<br>                <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> load(<span class="hljs-built_in">String</span> key) throws Exception &#123;<br>                    <span class="hljs-keyword">return</span> convert(key);<br>                &#125;<br>            &#125;);<br>    <span class="hljs-keyword">cache</span>.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>    <span class="hljs-keyword">cache</span>.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>    assertEquals(<span class="hljs-number">2</span>, <span class="hljs-keyword">cache</span>.size());<br>    <span class="hljs-keyword">cache</span>.getIfPresent(<span class="hljs-string">&quot;key1&quot;</span>);<br>    <span class="hljs-keyword">cache</span>.put(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br>    assertEquals(<span class="hljs-number">2</span>, <span class="hljs-keyword">cache</span>.size());<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>getIfPresent()</code>与<code>getUnchecked()</code>和<code>get()</code>的区别在于，当缓存未命中时，<code>getIfPresent()</code>不会调用load方法，而是返回null。</p><h3 id="lru过期策略"><a class="markdownIt-Anchor" href="#lru过期策略"></a> LRU过期策略</h3><p>Guava Cache 默认采用LRU（Least Recently Used）算法来淘汰缓存中的数据。LRU算法会优先淘汰最久未使用的数据。<br />上面的例子中，key2会被淘汰，因为key2是最久未使用的。</p><h3 id="缓存固定时间"><a class="markdownIt-Anchor" href="#缓存固定时间"></a> 缓存固定时间</h3><p>Guava Cache还可以给缓存设置过期时间，常见的有：</p><ul><li>expireAfterAccess：访问后多久过期</li><li>expireAfterWrite：写入后多久过期</li></ul><h2 id="移除缓存"><a class="markdownIt-Anchor" href="#移除缓存"></a> 移除缓存</h2><p>Guava Cache中移除缓存主要有两种方式：</p><ul><li>cache.invalidate(key)：移除单个缓存</li><li>cache.invalidateAll()：移除所有缓存</li></ul><h2 id="缓存刷新"><a class="markdownIt-Anchor" href="#缓存刷新"></a> 缓存刷新</h2><h3 id="手动刷新"><a class="markdownIt-Anchor" href="#手动刷新"></a> 手动刷新</h3><p>通过refresh()方法手动刷新缓存，refresh()方法会调用load方法，重新加载数据到缓存中。</p><p>需要注意的是：refresh()方法不会阻塞get方法，所以refresh期间，get方法会返回旧的缓存值。</p><h3 id="定时刷新"><a class="markdownIt-Anchor" href="#定时刷新"></a> 定时刷新</h3><p>通过refreshAfterWrite方法设置定时刷新时间，Guava会在指定时间后自动刷新缓存。</p><h2 id="缓存命中统计"><a class="markdownIt-Anchor" href="#缓存命中统计"></a> 缓存命中统计</h2><p>Guava Cache提供了缓存命中率的统计功能，可以通过recordStats()方法来记录缓存命中率。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lasso">@Test<br><span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> testCacheStats() &#123;<br>    <span class="hljs-keyword">Cache</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">cache</span> = CacheBuilder.newBuilder()<br>            .maximumSize(<span class="hljs-number">2</span>)<br>            .recordStats()<br>            .build(<span class="hljs-literal">new</span> CacheLoader&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt;() &#123;<br>                @Override<br>                <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> load(<span class="hljs-built_in">String</span> key) throws Exception &#123;<br>                    <span class="hljs-keyword">return</span> convert(key);<br>                &#125;<br>            &#125;);<br>    <span class="hljs-keyword">cache</span>.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>    <span class="hljs-keyword">cache</span>.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>    CacheStats stats = <span class="hljs-keyword">cache</span>.stats();<br>    System.out.println(<span class="hljs-string">&quot;Cache Stats: &quot;</span> + stats);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="缓存移除通知"><a class="markdownIt-Anchor" href="#缓存移除通知"></a> 缓存移除通知</h2><p>如果希望在缓存失效或者被移除时进行一些回调处理，可以使用removalListener方法来添加移除通知。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lasso">@Test<br><span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> testCacheRemovalListener() &#123;<br>    <span class="hljs-keyword">Cache</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">cache</span> = CacheBuilder.newBuilder()<br>            .maximumSize(<span class="hljs-number">2</span>)<br>            .removalListener(cacheItem -&gt; &#123;<br>                System.out.println(cacheItem+<span class="hljs-string">&quot; was removed&quot;</span>+<span class="hljs-string">&quot;caused by &quot;</span>+cacheItem.getCause());<br>            &#125;)<br>            .build(<span class="hljs-literal">new</span> CacheLoader&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt;() &#123;<br>                @Override<br>                <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> load(<span class="hljs-built_in">String</span> key) throws Exception &#123;<br>                    <span class="hljs-keyword">return</span> convert(key);<br>                &#125;<br>            &#125;);<br>    <span class="hljs-keyword">cache</span>.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>    <span class="hljs-keyword">cache</span>.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>    <span class="hljs-keyword">cache</span>.invalidate(<span class="hljs-string">&quot;key1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常见问题"><a class="markdownIt-Anchor" href="#常见问题"></a> 常见问题</h2><h3 id="为什么不用redis"><a class="markdownIt-Anchor" href="#为什么不用redis"></a> 为什么不用redis？</h3><p>如果本地缓存能解决，没必要引入一个中间件</p><h3 id="如何保证缓存和数据源一致性"><a class="markdownIt-Anchor" href="#如何保证缓存和数据源一致性"></a> 如何保证缓存和数据源一致性？</h3><ul><li>一般在数据敏感度不高的场景，短暂的不一致可以接受</li><li>另外的情况，可以设置定期刷新缓存或者手动刷新缓存的机制，比如给页面添加一个刷新按钮，当数据源更新后刷新缓存，或者定期刷新缓存</li><li>通过配置中心协调和同步</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组中重复出现的数据</title>
    <link href="/2025/04/25/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <url>/2025/04/25/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="数组中重复出现的数据"><a class="markdownIt-Anchor" href="#数组中重复出现的数据"></a> 数组中重复出现的数据</h2><!-- TOC --><ul><li><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E6%8D%AE">数组中重复出现的数据</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 最多两次 。请你找出所有出现 两次 的整数，并以数组形式返回。</p><p>你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间（不包括存储输出所需的空间）的算法解决此问题。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>某byte三面题，前两面手撕都做出来了，这道题卡住了💔💔💔</p><p>思路是遍历数组，把当前元素的值作为索引</p><ul><li>如果索引位置处是正数，将他取反</li><li>如果索引位置处是负数，说明这个索引已经使用过了，加入结果集</li></ul><p>感觉就属于做过的秒杀，没做过的坐牢💔</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-type">int</span> idx=<span class="hljs-built_in">abs</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(nums[idx<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">0</span>)<br>                nums[idx<span class="hljs-number">-1</span>]=-nums[idx<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">else</span><br>                ans.<span class="hljs-built_in">push_back</span>(idx);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组中第k大的数</title>
    <link href="/2025/04/13/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0/"/>
    <url>/2025/04/13/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="数组中第k大的数"><a class="markdownIt-Anchor" href="#数组中第k大的数"></a> 数组中第k大的数</h2><!-- TOC --><ul><li><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0">数组中第k大的数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4], k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>之前第一遍直接拿堆做了，实际上用快排可以达到O(n)的复杂度</p><p>思路就是快排，每次快排后，pivot左边的数都小于它，pivot右边的数都大于它，所以pivot的位置就固定了<br />因此，当pivot==n-k时，对应的数就是第k大的数<br />与快排不同的是，每次移动后，不用同时对左右两个区间递归，而是选择n-k所在的区间递归，有点像二分查找</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> adjust(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)&#123;<br>        <span class="hljs-keyword">int</span> tl=l,tr=r;<br>        <span class="hljs-keyword">int</span> t=nums[l];<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;nums[r]&gt;=t)<br>                --r;<br>            nums[l]=nums[r];<br>            <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;nums[l]&lt;=t)<br>                ++l;<br>            nums[r]=nums[l];<br>        &#125;<br>        nums[l]=t;<br>        <span class="hljs-keyword">if</span>(l==<span class="hljs-keyword">target</span>)<br>            <span class="hljs-keyword">return</span> nums[l];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&lt;<span class="hljs-keyword">target</span>)<br>            <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">adjust</span><span class="hljs-params">(nums,l+<span class="hljs-number">1</span>,tr,<span class="hljs-keyword">target</span>)</span></span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">adjust</span><span class="hljs-params">(nums,tl,l<span class="hljs-number">-1</span>,<span class="hljs-keyword">target</span>)</span></span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n=nums.size();<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">adjust</span><span class="hljs-params">(nums,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,n-k)</span></span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>耗时最短线路</title>
    <link href="/2025/04/10/%E8%80%97%E6%97%B6%E6%9C%80%E7%9F%AD%E7%BA%BF%E8%B7%AF/"/>
    <url>/2025/04/10/%E8%80%97%E6%97%B6%E6%9C%80%E7%9F%AD%E7%BA%BF%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="耗时最短线路"><a class="markdownIt-Anchor" href="#耗时最短线路"></a> 耗时最短线路</h2><!-- TOC --><ul><li><a href="#%E8%80%97%E6%97%B6%E6%9C%80%E7%9F%AD%E7%BA%BF%E8%B7%AF">耗时最短线路</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://oj.niumacode.com/training/63/problem/P1509">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>大湾区某城市地铁线路非常密集，乘客很难一眼看出选择哪条线路乘坐比较合适，为了解决这个问题，地铁公司希望你开发一个程序帮助乘客挑选合适的乘坐线路，使得乘坐时间最短，地铁公司可以提供的数据是各相邻站点之间的乘坐时间。</p><p>输入说明：<br />第一行:N，站点总数,3&lt;=N&lt;=20.<br />第二行:乘宫的出发和到达站点。<br />第三行起:相邻站点之间的乘坐时间，每对站点一行，站点名称是单个小写字母，站点名一定包括出发和到<br />达站点，输入保证只有一个唯一解;<br />结束行:0000</p><p>输出说明：耗时最短的线路</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<br><span class="hljs-number">12</span><br><span class="hljs-selector-tag">a</span> e<br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-number">2</span><br><span class="hljs-selector-tag">b</span> c <span class="hljs-number">2</span><br>c d <span class="hljs-number">2</span><br>d e <span class="hljs-number">2</span><br>f <span class="hljs-selector-tag">b</span> <span class="hljs-number">3</span><br><span class="hljs-selector-tag">b</span> g <span class="hljs-number">3</span><br>g h <span class="hljs-number">2</span><br>h <span class="hljs-selector-tag">i</span> <span class="hljs-number">3</span><br>j h <span class="hljs-number">2</span><br>h e <span class="hljs-number">3</span><br>e k <span class="hljs-number">2</span><br>k <span class="hljs-selector-tag">i</span> <span class="hljs-number">4</span><br><span class="hljs-number">0000</span><br><br>输出：<br><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c d e<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>常规堆优化的dijkstra，不过节点数目很少，所以二维数组存图即可，由于要输出路径，所以需要一个前驱数组来存储前驱节点，每次松弛成功后同步更新前驱节点即可</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> mp[<span class="hljs-number">26</span>][<span class="hljs-number">26</span>];<br><span class="hljs-type">int</span> dis[<span class="hljs-number">26</span>];<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">26</span>];<br><span class="hljs-type">int</span> pre[<span class="hljs-number">26</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> w;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> nn,<span class="hljs-type">int</span> ww):<span class="hljs-built_in">n</span>(nn),<span class="hljs-built_in">w</span>(ww)&#123;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node&amp; t) <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> w&gt;t.w;<br>    &#125;<br>&#125;;<br><br>priority_queue&lt;node&gt; pq;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">char</span> s, d;<br>    cin&gt;&gt;s&gt;&gt;d;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    <span class="hljs-built_in">memset</span>(mp,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(mp));<br>    <span class="hljs-built_in">memset</span>(pre,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(pre));<br>    dis[s-<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        string s1,s2;<br>        <span class="hljs-type">int</span> jl;<br>        cin&gt;&gt;s1;<br>        <span class="hljs-keyword">if</span>(s1==<span class="hljs-string">&quot;0000&quot;</span>)<br>            <span class="hljs-keyword">break</span>;<br>        cin&gt;&gt;s2&gt;&gt;jl;<br>        <br>        mp[s1[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>][s2[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]=jl;<br>    &#125;<br>    <br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(s-<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>        node t=pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> u=t.n;<br>        <span class="hljs-keyword">if</span>(!vis[u])&#123;<br>            vis[u]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>                <span class="hljs-keyword">if</span>(dis[u]+mp[u][i]&lt;dis[i])&#123;<br>                    dis[i]=dis[u]+mp[u][i];<br>                    pre[i]=u;<br>                    <span class="hljs-keyword">if</span>(!vis[i])<br>                        pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(i,dis[i]));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans=d-<span class="hljs-string">&#x27;a&#x27;</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(ans);<br>    <span class="hljs-keyword">while</span>(ans!=s-<span class="hljs-string">&#x27;a&#x27;</span>)&#123;<br>        ans=pre[ans];<br>        v.<span class="hljs-built_in">push_back</span>(ans);<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> tt:v)<br>        cout&lt;&lt;<span class="hljs-built_in">char</span>(tt+<span class="hljs-string">&#x27;a&#x27;</span>)&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实现哈希表</title>
    <link href="/2025/04/09/%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2025/04/09/%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="实现哈希表"><a class="markdownIt-Anchor" href="#实现哈希表"></a> 实现哈希表</h2><!-- TOC --><ul><li><a href="#%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8">实现哈希表</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/design-hashmap/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p><p>实现 MyHashMap 类：</p><p>MyHashMap() 用空映射初始化对象<br />void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。<br />int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。<br />void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MyHashMap&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;remove&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">2</span>]]<br>输出：<br>[null, null, null, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, null, <span class="hljs-number">1</span>, null, <span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>之前面试中让现场写，没准备过，手写的数组+链表，链表实现有些不完善的地方，这里重新做一遍，链表直接用的c++的list<br />总体思路就是无论什么操作，都是先获取哈希值，然后找到索引，遍历链表，找到对应的值</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHashMap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt; mp;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> sz=<span class="hljs-number">1e5</span>+<span class="hljs-number">7</span>;<br><br>    <span class="hljs-built_in">MyHashMap</span>():<span class="hljs-built_in">mp</span>(sz) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> key%sz;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-type">int</span> idx=<span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=mp[idx].<span class="hljs-built_in">begin</span>();it!=mp[idx].<span class="hljs-built_in">end</span>();++it)&#123;<br>            <span class="hljs-keyword">if</span>((*it).first==key)&#123;<br>                (*it).second=value;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        mp[idx].<span class="hljs-built_in">push_back</span>(&#123;key,value&#125;);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> idx=<span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=mp[idx].<span class="hljs-built_in">begin</span>();it!=mp[idx].<span class="hljs-built_in">end</span>();++it)&#123;<br>            <span class="hljs-keyword">if</span>((*it).first==key)&#123;<br>                <span class="hljs-keyword">return</span> (*it).second;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> idx=<span class="hljs-built_in">hash</span>(key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=mp[idx].<span class="hljs-built_in">begin</span>();it!=mp[idx].<span class="hljs-built_in">end</span>();++it)&#123;<br>            <span class="hljs-keyword">if</span>((*it).first==key)&#123;<br>                mp[idx].<span class="hljs-built_in">erase</span>(it);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>拼团交易学习</title>
    <link href="/2025/04/01/%E6%8B%BC%E5%9B%A2%E4%BA%A4%E6%98%93%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/04/01/%E6%8B%BC%E5%9B%A2%E4%BA%A4%E6%98%93%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%B0%8F%E5%9E%8B%E6%94%AF%E4%BB%98%E5%95%86%E5%9F%8E">小型支付商城</a><ul><li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE">介绍一下这个项目</a></li></ul></li><li><a href="#%E6%8B%BC%E5%9B%A2%E4%BA%A4%E6%98%93%E5%AD%A6%E4%B9%A0">拼团交易学习</a><ul><li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE-1">介绍一下这个项目</a></li><li><a href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B">整体流程</a></li><li><a href="#%E8%AE%B2%E8%AE%B2ddd%E5%92%8C%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84">讲讲DDD和六边形架构？</a></li><li><a href="#%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB">贫血模型和充血模型的区别？</a></li><li><a href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84%E5%90%84%E4%B8%AA%E9%A2%86%E5%9F%9F%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%8D%8F%E4%BD%9C">项目中的领域模型是如何划分的？各个领域之间如何协作？</a></li><li><a href="#%E8%A7%84%E5%88%99%E6%A0%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E7%9A%84">规则树设计模型怎么使用的？</a></li><li><a href="#%E8%AF%95%E7%AE%97%E9%80%BB%E8%BE%91%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">试算逻辑怎么实现的？</a></li><li><a href="#%E4%BA%BA%E7%BE%A4%E6%A0%87%E7%AD%BE%E8%BF%87%E6%BB%A4%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0">人群标签过滤怎么实现？</a></li><li><a href="#%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AEdcc%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">动态配置(DCC)怎么实现的？</a></li><li><a href="#%E4%BA%A4%E6%98%93%E8%A7%84%E5%88%99%E8%BF%87%E6%BB%A4%E6%80%8E%E4%B9%88%E7%94%A8%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%9A%84">交易规则过滤怎么用责任链模式实现的？</a></li><li><a href="#%E4%BA%A4%E6%98%93%E7%BB%93%E7%AE%97%E8%BF%87%E6%BB%A4%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">交易结算过滤怎么实现的？</a></li><li><a href="#%E7%BB%93%E7%AE%97%E8%A7%A6%E8%BE%BE%E7%9A%84%E5%9B%9E%E8%B0%83%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84">结算触达的回调是怎么做的？</a></li><li><a href="#%E9%A1%B9%E7%9B%AE%E9%87%8C%E9%94%81%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84">项目里锁怎么用的？</a></li><li><a href="#ddd%E9%A2%86%E5%9F%9F%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1">DDD领域之间如何通信？</a></li></ul></li></ul><!-- /TOC --><h1 id="小型支付商城"><a class="markdownIt-Anchor" href="#小型支付商城"></a> 小型支付商城</h1><h2 id="介绍一下这个项目"><a class="markdownIt-Anchor" href="#介绍一下这个项目"></a> 介绍一下这个项目</h2><p>该项目主要围绕下单支付场景，实现了扫码登陆、商品下单、支付、超时关单等功能</p><p>涉及的数据库表主要有：支付订单表<br />支付订单表包含的主要字段有：</p><ul><li>自增id</li><li>用户id</li><li>商品id</li><li>订单id</li><li>订单金额</li><li>订单状态</li><li>支付表单url</li><li>支付时间 …</li></ul><h1 id="拼团交易学习"><a class="markdownIt-Anchor" href="#拼团交易学习"></a> 拼团交易学习</h1><h2 id="介绍一下这个项目-2"><a class="markdownIt-Anchor" href="#介绍一下这个项目-2"></a> 介绍一下这个项目</h2><p>项目是我在是我在日常使用拼多多、腾讯、京东等服务平台，交易支付时候，了解到这样的一种营销手段。它可以通过用户自传播方式增强交易量，也是拼多多最开始起家形成巨大规模的一个业务逻辑。因此非常感兴趣这样的系统，所以根据网络上的资料，学习并完成了这样的一个系统。</p><p>库表是怎么设计的？<br />首先，从运营的角度，要考虑的有：</p><ul><li><p>拼团活动表：设定了拼团活动id、成团规则、人群标签标识、商品id、折扣id等。</p></li><li><p>折扣配置表：因为折扣有时还可以叠加，所以还拆分出一个折扣配置表，里面包含了折扣的描述、折扣的表达式等信息。</p></li><li><p>人群标签表：专门来做人群设计记录的，这3张表就是为了把符合规则的人群ID，也就是用户ID，全部跑任务到一个记录下进行使用。比如黑玫瑰人群、高净值人群、拼团履约率90%以上的人群等。</p></li></ul><p>从用户的角度：</p><ul><li>用户有一个拼团账户表，记录了用户参与拼团参与数据，比如拼团次数限制，拼团次数消耗等</li><li>拼团表，包含活动id，拼团单号，拼团状态，参与人数，回调url等信息；还要有一个拼团明细表，包含拼团单号，拼团来源，拼团渠道，商品id，外部交易单号等信息</li><li>拼团成功后，还要发送回调通知，所以还要有一个回调任务表，包含回调的url，回调的次数，回调的状态等信息</li></ul><h2 id="整体流程"><a class="markdownIt-Anchor" href="#整体流程"></a> 整体流程</h2><ul><li>用户查看拼团商品，涉及到统一切量、人群标签过滤、优惠试算等操作</li><li>用户参与拼团，涉及到拼团优惠组装，创建拼团订单，创建支付单等操作</li><li>扫码支付，支付完成后，收到支付回调，更新支付结果、拼团信息</li><li>等拼团目标完成后，发起回调通知，触发商品发货等操作</li></ul><h2 id="讲讲ddd和六边形架构"><a class="markdownIt-Anchor" href="#讲讲ddd和六边形架构"></a> 讲讲DDD和六边形架构？</h2><p>DDD 指的是领域驱动设计，是一种软件开发思想，将软件的核心聚焦于业务领域本身，使得软件设计能够精确地反映业务模型。<br />DDD 的建模过程，是以一个用户为起点，通过行为命令，发起行为动作，串联整个业务</p><p>六边形架构，也称为端口和适配器架构。</p><ul><li>端口是核心领域定义的接口，代表了核心领域与外界进行交互的方式。</li><li>适配器是实现端口接口的具体代码，负责将外部请求与核心领域的端口进行转换和适配。</li></ul><p>在本项目中，六边形架构通过适配器层隔离核心业务与外部依赖（如数据库、Redis）。例如，订单结算的核心逻辑独立于HTTP回调或MQ监听的具体实现，提升核心代码的稳定性和可测试性。</p><h2 id="贫血模型和充血模型的区别"><a class="markdownIt-Anchor" href="#贫血模型和充血模型的区别"></a> 贫血模型和充血模型的区别？</h2><ul><li>贫血模型的对象一般只包含数据和简单的 getter/setter 方法，业务逻辑通常在service层中实现，适合一般业务逻辑简单、以增删改查为主的场景。</li><li>充血模型的对象包含数据和业务逻辑，也就是数据和行为封装在一起，service层通常会变得更薄，适合复杂业务逻辑的场景。</li></ul><h2 id="项目中的领域模型是如何划分的各个领域之间如何协作"><a class="markdownIt-Anchor" href="#项目中的领域模型是如何划分的各个领域之间如何协作"></a> 项目中的领域模型是如何划分的？各个领域之间如何协作？</h2><p>通过四色建模和业务场景分析，划分出活动域、标签域、交易域3种领域</p><ul><li>活动域：负责拼团活动的定义、管理和规则设置</li><li>标签域：负责处理用户标签和人群分组，控制参与资格</li><li>交易域：处理订单、支付和结算相关业务</li></ul><p>协作方式：</p><ul><li>领域服务调用：如交易域的结算服务调用活动域的服务</li><li>聚合根：如GroupBuyOrderAggregate聚合了用户、活动和优惠信息</li><li>领域事件：通过事件驱动不同领域间的协作</li></ul><h2 id="规则树设计模型怎么使用的"><a class="markdownIt-Anchor" href="#规则树设计模型怎么使用的"></a> 规则树设计模型怎么使用的？</h2><p>例如用户查看优惠信息后，一般可以看到优惠后的价格，这就需要进行试算操作，这里的试算操作就是一个规则树的设计模型</p><p>首先定义一个通用的规则树结构，主要包含StrategyMapper，StrategyHandler接口</p><ul><li>StrategyMapper：定义了get方法，用于获取要执行的节点</li><li>StrategyHandler：定义了apply方法，用于受理执行的业务流程</li></ul><p>还要定义一个策略路由的抽象类，实现上面两个接口</p><ul><li>其中的router方法中，通过get方法获取下一个要执行的节点，然后执行apply方法</li><li>在apply方法中，首先通过多线程异步加载数据，然后执行doApply方法执行具体的业务逻辑</li></ul><p>在活动域中，在试算部分，定义各个节点如RootNode，SwitchNode，MarketNode，EndNode等</p><ul><li>每个节点都实现了doApply方法和get方法，doApply方法中执行具体的业务逻辑，返回router方法调用，get方法返回下一个节点</li><li>特别是marketNode节点，还实现了multiThread方法，通过线程池实现多线程异步加载数据</li></ul><p>总的来说，以根节点为入口，子节点为具体规则。通过组合模式构建树形结构，支持动态扩展节点。</p><h2 id="试算逻辑怎么实现的"><a class="markdownIt-Anchor" href="#试算逻辑怎么实现的"></a> 试算逻辑怎么实现的？</h2><p>MarketNode节点的doApply方法实现了具体的试算逻辑</p><p>试算采用了策略模式，包括直减、满减、折扣、N元购四种策略</p><ul><li>定义一个接口，其中包含calculate方法，进行判断是否属于活动人群以及计算试算结果</li><li>然后定义四个实现类，分别实现doCalculate方法，并在注解中指定策略名称，例如：</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-meta">@Service</span>(<span class="hljs-string">&quot;N&quot;</span>)<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NCalculateService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDiscountCalculateService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-type">BigDecimal</span> doCalculate(<span class="hljs-type">BigDecimal</span> originalPrice, <span class="hljs-type">GroupBuyActivityDiscountVO</span>.<span class="hljs-type">GroupBuyDiscount</span> groupBuyDiscount) &#123;<br>        log.info(<span class="hljs-string">&quot;优惠策略折扣计算:&#123;&#125;&quot;</span>, groupBuyDiscount.getDiscountType().getCode());<br><br>        <span class="hljs-comment">// 折扣表达式 - 直接为优惠后的金额</span><br>        <span class="hljs-type">String</span> marketExpr = groupBuyDiscount.getMarketExpr();<br>        <span class="hljs-comment">// n元购</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BigDecimal</span>(marketExpr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在MarketNode节点中，通过Map的方式注入，并调用calculate方法完成试算</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> Map&lt;<span class="hljs-keyword">String</span>, IDiscountCalculateService&gt; discountCalculateServiceMap;<br><span class="hljs-comment">// 优惠试算</span><br>IDiscountCalculateService discountCalculateService = discountCalculateServiceMap.<span class="hljs-keyword">get</span>(groupBuyDiscount.getMarketPlan());<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == discountCalculateService) &#123;<br>    log.info(<span class="hljs-string">&quot;不存在&#123;&#125;类型的折扣计算服务，支持类型为:&#123;&#125;&quot;</span>, groupBuyDiscount.getMarketPlan(), JSON.toJSONString(discountCalculateServiceMap.keySet()));<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">AppException</span>(ResponseCode.E0001.getCode(), ResponseCode.E0001.getInfo());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="人群标签过滤怎么实现"><a class="markdownIt-Anchor" href="#人群标签过滤怎么实现"></a> 人群标签过滤怎么实现？</h2><p>一般活动都是针对特定群体的，人群标签过滤就是把用户分成不同的群体，每个群体有一个tagId，每个tagId对于每个活动有一个tagScope字段，用来配置该活动是否可见、可参与<br />tagId，用于标识可参与活动的人群，如果没有tagId，则说明所有人都可参与活动<br />在redis的bitmap中存了人群标签，key为tagId，value为userId</p><p>人群标签过滤的逻辑如下：</p><ul><li>在试算时，如果人群标签为空或者用户在bitmap中，则说明当前用户可参与活动，进行试算优惠价格，否则返回原价</li><li>试算完后在tagNode中设置活动可见、可参与状态<ul><li>如果人群标签为空，则说明当前活动可见、可参与</li><li>如果人群标签不为空，如果当前活动可见或者用户在bitmap中，则说明当前活动可见；如果当前活动可参与或者用户在bitmap中，则说明当前活动可参与</li></ul></li></ul><h2 id="动态配置dcc怎么实现的"><a class="markdownIt-Anchor" href="#动态配置dcc怎么实现的"></a> 动态配置(DCC)怎么实现的？</h2><p>在SwitchNode节点中，主要做一些是否降级、切量拦截等操作</p><p>主要基于redis的发布订阅模式实现，具体步骤如下：</p><ul><li>首先定义一个自定义注解DCCValue，如果使用了该注解可以由spring管理相应的属性</li><li>然后定义一个DCCService类，其中的downGrade和cutRange属性都使用了@DCCValue注解，并定义判断是否降级和是否在切量范围内的方法</li></ul><blockquote><p>接下来就是动态配置的核心：</p></blockquote><ul><li>定义一个动态配置管理的工厂实现BeanPostProcessor接口</li><li>在Bean初始化后，首先获取目标类和目标对象，然后遍历目标类属性，如果加了@DCCValue注解，则获取注解的值，并在redis中获取最新的值，然后更新属性的配置值，如果redis中没有值，则使用默认值，最后将key和原始对象保存到map中</li><li>通过redis的RTopic添加监听器，监听订阅消息，当有消息发布时，获取最新的值，在redis中更新，并在map获取到目标对象，然后通过反射获取到目标类，然后对属性进行更新</li></ul><p>最后，在controller中定义updateConfig方法，发布订阅消息，要进行动态更新时，调用该方法即可。</p><h2 id="交易规则过滤怎么用责任链模式实现的"><a class="markdownIt-Anchor" href="#交易规则过滤怎么用责任链模式实现的"></a> 交易规则过滤怎么用责任链模式实现的？</h2><p>首先要和规则树一样，定义一个责任链的抽象模板：</p><ul><li>定义一个接口LogicHandler，包含next和apply方法，next方法用于获取下一个节点，apply方法用于受理业务逻辑</li><li>然后定义一个链表，每个节点元素都是一个LogicHandler，链表实现了LogicHandler接口的apply方法，在apply方法中调用当前节点的apply方法，直到apply方法返回不为null或者链表遍历完毕结束</li><li>定义一个装配器类LinkArmory，用来通过循环的方式将节点添加到责任链链表中</li></ul><p>接下来，交易规则过滤包括活动可用性过滤和用户参与性过滤</p><ul><li>活动可用性过滤：定义一个类实现LogicHandler接口，重写apply方法，返回下一个节点，apply方法主要检验活动的状态，活动是否过期，并把活动信息设置到上下文中</li><li>用户参与性过滤：定义一个类实现LogicHandler接口，重写apply方法，返回参与次数，apply方法主要校验用户参与次数，防止用户无限次参与。</li><li>定义一个工厂类，通过LinkArmory装配器将两个过滤器添加到责任链中，然后在对应service中调用apply方法就可以进行交易规则过滤了</li></ul><h2 id="交易结算过滤怎么实现的"><a class="markdownIt-Anchor" href="#交易结算过滤怎么实现的"></a> 交易结算过滤怎么实现的？</h2><p>与交易规则过滤类似，仍然用定义好的责任链模板即可，只不过有4个不同职责的节点：</p><ul><li>黑名单渠道过滤：校验支付渠道是否符合要求</li><li>交易单号过滤：校验交易单号是否存在</li><li>支付时间过滤：判断支付完成的时间是否在活动时间内</li><li>结束节点：返回封装数据</li></ul><h2 id="结算触达的回调是怎么做的"><a class="markdownIt-Anchor" href="#结算触达的回调是怎么做的"></a> 结算触达的回调是怎么做的？</h2><p>回调通过http和MQ两种方式实现，支持两种方式并行，http主要针对外部系统发送回调，MQ主要针对内部系统发送回调</p><ul><li>http回调基于OkHttpClient实现，如果是http类型需要配置notifyUrl</li><li>MQ回调基于RabbitMQ实现</li><li>为了保证性能，采用了异步的方式，通过线程池异步发送回调</li><li>为了保证可靠性，防止回调发送失败，设置了定时任务，定时执行回调</li></ul><h2 id="项目里锁怎么用的"><a class="markdownIt-Anchor" href="#项目里锁怎么用的"></a> 项目里锁怎么用的？</h2><p>用到了独占锁和乐观锁</p><p>独占锁通过<code>redisson.getLock()</code>获取，主要用于定时任务发送回调通知时，因为在分布式架构下，会有n个实例部署，定时任务会有n个实例执行，所以需要加锁，那个实例抢到锁就执行</p><p>乐观锁用在交易下单时的责任链中，用来抢占库存时作为incr的兜底。<br />首先在拼团下单时，除了活动状态和用户参与次数过滤外，还要进行库存占用过滤</p><ul><li>进行库存占用过滤时，通过动态上下文获取到组队的目标量，有效期时间，以及组队的key和恢复量key，恢复量是每当下单修改数据库失败后，就对该恢复量key进行incr操作，表示失败的次数</li><li>接下来先获取恢复量，然后对组队的key进行incr操作得到一个占用值，如果占用值大于目标量+恢复量，则说明已完成目标，将组队key对应的value设置为target，返回false表示占用失败</li><li>如果占用值符合要求，那么就对组队key+占用值通过setnx加锁，作为兜底，防止出现相同的占用值</li></ul><h2 id="ddd领域之间如何通信"><a class="markdownIt-Anchor" href="#ddd领域之间如何通信"></a> DDD领域之间如何通信？</h2><ol><li>ddd 内部领域间，domain 下的各个领域，是通过 trigger 串联的。如果是更复杂的系统，会有一个单独的 cases 层来串联。</li><li>和外部系统的对接，是通过基础设施层，使用 http、rpc 等方式与外部通信。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>钢琴弹奏</title>
    <link href="/2025/03/28/%E9%92%A2%E7%90%B4%E5%BC%B9%E5%A5%8F/"/>
    <url>/2025/03/28/%E9%92%A2%E7%90%B4%E5%BC%B9%E5%A5%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="钢琴弹奏"><a class="markdownIt-Anchor" href="#钢琴弹奏"></a> 钢琴弹奏</h2><!-- TOC --><ul><li><a href="#%E9%92%A2%E7%90%B4%E5%BC%B9%E5%A5%8F">钢琴弹奏</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://oj.niumacode.com/training/49/problem/P1466">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>游游有 26 个按键的琴，按下第一个按键可以奏出 a，第二个按键可以奏出 b ，…，第二十六个按键可以奏出z 。</p><p>现在给出了一个乐谱的演奏方式，由数字组成，包含[0,9] ，但由于不考虑空格致使游戏不允许输入的情况，例子如 s=12 ，表示先按下第一个按键，然后按第二个按键，也可能按下第十二个按键。而对于120，只能先按下第一个键，然后再按第二十个按键，因为不存在第零个按键。</p><p>现在请你帮助游游计算有多少种本质不同的合适演奏方式。</p><p>对于两种演奏方式，只要存在一个位置的按键不同则认为是不同的演奏方式，由于结果可能很大，请对 <code>10^9+7</code> 取模后输出。</p><p>输入描述</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">每个测试文件均包含多组测试数。第一行输入一个整数 <span class="hljs-built_in">T</span>(<span class="hljs-number">1</span> &lt;<span class="hljs-built_in">T</span> &lt;<span class="hljs-number">10</span> )代表数据组数,每组测试数据描述如下<span class="hljs-symbol">:</span> 对于每一组测试数据<span class="hljs-symbol">:</span> 第一行一个整数<span class="hljs-built_in">n</span> (<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">n</span> &lt; <span class="hljs-number">10</span>^<span class="hljs-number">5</span>)。 第二行一个长度为<span class="hljs-built_in">n</span> 的字符串s ，保证输入仅含数字[<span class="hljs-number">0</span>,<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>输出描述</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">输出共 <span class="hljs-built_in">T</span> 行，每行一个整数，表示本质不同的合法演奏方式，结果对<span class="hljs-number">10</span>^<span class="hljs-number">9</span>+<span class="hljs-number">7</span>取模。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>动态规划，令 dp[i] 表示前 i 个字符的合法演奏方式数：</p><ul><li>dp[0] = 1 表示空串有 1 种合法方法；</li><li>若 s[i-1] ≠ ‘0’，则 dp[i] += dp[i-1]；</li><li>若<code>i&gt;1</code>时，如果由 s[i-2] 和 s[i-1] 组成的两位数在 [10，26] 范围内，dp[i] += dp[i-2]。</li><li>最后 dp[n] 就是答案，过程中都要对 10^9+7 取模。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll=<span class="hljs-type">long</span> <span class="hljs-type">long</span> ;<br><span class="hljs-type">const</span> ll M=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin&gt;&gt;T;<br>    <span class="hljs-type">int</span> n;<br>    string s;<br>    <span class="hljs-keyword">while</span>(T--)&#123;<br>        cin&gt;&gt;n;<br>        cin&gt;&gt;s;<br>        <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;0&#x27;</span>)<br>                dp[i]=(dp[i]+dp[i<span class="hljs-number">-1</span>])%M;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">int</span> t=(s[i<span class="hljs-number">-2</span>]-<span class="hljs-string">&#x27;0&#x27;</span>)*<span class="hljs-number">10</span>+s[i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(t&gt;=<span class="hljs-number">10</span>&amp;&amp;t&lt;=<span class="hljs-number">26</span>)<br>                    dp[i]=(dp[i]+dp[i<span class="hljs-number">-2</span>])%M;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;dp[n]%M&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>火柴拼正方形</title>
    <link href="/2025/03/23/%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2025/03/23/%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="火柴拼正方形"><a class="markdownIt-Anchor" href="#火柴拼正方形"></a> 火柴拼正方形</h2><!-- TOC --><ul><li><a href="#%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2">火柴拼正方形</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/matchsticks-to-square/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。</p><p>如果你能使这个正方形，则返回 true ，否则返回 false 。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: matchsticks = [1,1,2,2,2]</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: 能拼成一个边长为2的正方形，每边两根火柴。</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>2025323虾皮笔试第3题，做的时蒙过了0.4的用例，看了题解才知道读错题了，火柴是拼接，不是叠加。<br />主要思路是回溯，每次给每条边加火柴，当加火柴后边长合法且dfs返回也为真，则返回true。当所有火柴都能用完时返回true，否则返回false。<br />为了降低时间复杂度，可以降序排序再dfs</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge, vector&lt;<span class="hljs-type">int</span>&gt;&amp; matchsticks)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(idx==matchsticks.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)&#123;<br>            edge[i]+=matchsticks[idx];<br>            <span class="hljs-keyword">if</span>(edge[i]&lt;=target&amp;&amp;<span class="hljs-built_in">dfs</span>(idx+<span class="hljs-number">1</span>,target,edge,matchsticks))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            edge[i]-=matchsticks[idx];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">makesquare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; matchsticks)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t:matchsticks)<br>            sum+=t;<br>        <span class="hljs-keyword">if</span>(sum%<span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">sort</span>(matchsticks.<span class="hljs-built_in">begin</span>(),matchsticks.<span class="hljs-built_in">end</span>(),[](<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;<br>            <span class="hljs-keyword">return</span> a&gt;b;<br>        &#125;);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">edge</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,sum/<span class="hljs-number">4</span>,edge,matchsticks);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>小红的排列</title>
    <link href="/2025/03/22/%E5%B0%8F%E7%BA%A2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2025/03/22/%E5%B0%8F%E7%BA%A2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="小红的排列"><a class="markdownIt-Anchor" href="#小红的排列"></a> 小红的排列</h2><!-- TOC --><ul><li><a href="#%E5%B0%8F%E7%BA%A2%E7%9A%84%E6%8E%92%E5%88%97">小红的排列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>小红给定一个数字x，现在她准备把其数位上的数字重新排列，例如x=213，重排后可以是<code>[123，132，231，312，321]</code>，但不能是213，因为其没有进行重排，又例如 10，仅存在<code>[1]</code>，重排后的数字忽略掉前导零。</p><p>现在请你帮助小红计算有多少个重排后的数字 y，使得其数位之和是一个质数。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">输入描述：<br>第一行一个整数 <span class="hljs-built_in">T</span>(<span class="hljs-number">1</span> &lt; T &lt; <span class="hljs-number">10</span>^<span class="hljs-number">5</span>)，表示数据组数，对于每组数据格式为:一个整数 <span class="hljs-built_in">x</span>(<span class="hljs-number">1</span> &lt; x &lt; <span class="hljs-number">10</span>^<span class="hljs-number">9</span>)，表示给定的数字。<br><br>输出描述：<br>对于每组数据，每行输出一个整数，表示满足条件的数字个数。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题不是很难，但是我一看到排列总想着用next_permutation，这样会超时。<br />这道题应该根据字符串的长度计算阶乘，即全排列的个数，然后再根据每一位出现的次数计算阶乘，对全排列去重。<br />比如：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">假设输入的字符串是 <span class="hljs-string">&quot;32413&quot;</span>，其中数字 <span class="hljs-string">&quot;3&quot;</span> 出现了两次。<br><br>字符串长度为 <span class="hljs-number">5</span>，所以 <span class="hljs-number">5</span>! = <span class="hljs-number">120</span><br><span class="hljs-string">&quot;3&quot;</span> 出现 <span class="hljs-number">2</span> 次，所以 <span class="hljs-number">2</span>! = <span class="hljs-number">2</span><br>计算排列数： <span class="hljs-number">120</span> / <span class="hljs-number">2</span> = <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>using <span class="hljs-attribute">ll</span>=long long;<br>ll <span class="hljs-built_in">get</span>(int n)&#123;<br>    ll <span class="hljs-attribute">res</span>=1;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=2;i&lt;=n;++i)<br>        <span class="hljs-attribute">res</span>=res*i;<br>    return res;<br>&#125;<br><br>int main()&#123;<br>int T;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)&#123;<br>        int x;<br>        cin&gt;&gt;x;<br>        string <span class="hljs-attribute">s</span>=to_string(x);<br>        int <span class="hljs-attribute">sum</span>=0;<br>        vector&lt;int&gt; cnt(10);<br>        <span class="hljs-keyword">for</span>(char c:s)&#123;<br>            sum+=c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            ++cnt[c-<span class="hljs-string">&#x27;0&#x27;</span>];<br>        &#125;<br>        bool <span class="hljs-attribute">isZ</span>=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=2;i*i&lt;=sum;++i)&#123;<br>            <span class="hljs-keyword">if</span>(sum%<span class="hljs-attribute">i</span>==0)&#123;<br>                <span class="hljs-attribute">isZ</span>=<span class="hljs-literal">true</span>;<br>                break;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-attribute">isZ</span>==true||sum==1)&#123;<br>            cout&lt;&lt;0&lt;&lt;endl;<br>            continue;<br>        &#125;<br>        ll <span class="hljs-attribute">ans</span>=get(s.size());<br>        <span class="hljs-keyword">for</span>(int t:cnt)&#123;<br>            <span class="hljs-attribute">ans</span>=ans/get(t);<br>        &#125;<br>        cout&lt;&lt;ans-1&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>只出现一次数字系列</title>
    <link href="/2025/03/21/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E5%AD%97%E7%B3%BB%E5%88%97/"/>
    <url>/2025/03/21/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E5%AD%97%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="只出现一次数字系列"><a class="markdownIt-Anchor" href="#只出现一次数字系列"></a> 只出现一次数字系列</h1><!-- TOC --><ul><li><a href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E5%AD%97%E7%B3%BB%E5%88%97">只出现一次数字系列</a><ul><li><a href="#%E6%9C%891%E4%B8%AA%E5%87%BA%E7%8E%B01%E6%AC%A1%E5%85%B6%E4%BB%96%E5%87%BA%E7%8E%B02%E6%AC%A1">有1个出现1次，其他出现2次</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E6%9C%892%E4%B8%AA%E5%87%BA%E7%8E%B01%E6%AC%A1%E5%85%B6%E4%BB%96%E5%87%BA%E7%8E%B02%E6%AC%A1">有2个出现1次，其他出现2次</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li><li><a href="#%E6%9C%891%E4%B8%AA%E5%87%BA%E7%8E%B01%E6%AC%A1%E5%85%B6%E4%BB%96%E5%87%BA%E7%8E%B03%E6%AC%A1">有1个出现1次，其他出现3次</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-2">代码</a></li></ul></li></ul></li></ul><!-- /TOC --><h2 id="有1个出现1次其他出现2次"><a class="markdownIt-Anchor" href="#有1个出现1次其他出现2次"></a> 有1个出现1次，其他出现2次</h2><p><a href="https://leetcode.cn/problems/single-number/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>直接异或</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a:nums)<br>            t=a^t;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="有2个出现1次其他出现2次"><a class="markdownIt-Anchor" href="#有2个出现1次其他出现2次"></a> 有2个出现1次，其他出现2次</h2><p><a href="https://leetcode.cn/problems/single-number-iii/description/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p><p>你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。</p><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>先异或，再分两组异或</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    vector&lt;<span class="hljs-built_in">int</span>&gt; singleNumber(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> <span class="hljs-symbol">t:nu</span>ms)<br>            <span class="hljs-built_in">sum</span>=<span class="hljs-built_in">sum</span>^<span class="hljs-built_in">t</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">offset</span>=<span class="hljs-number">0</span>;<br>        while(((<span class="hljs-built_in">sum</span>&gt;&gt;<span class="hljs-built_in">offset</span>)&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)<br>            ++<span class="hljs-built_in">offset</span>;<br>        <span class="hljs-built_in">int</span> a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> <span class="hljs-symbol">t:nu</span>ms)&#123;<br>            <span class="hljs-built_in">if</span>(((<span class="hljs-built_in">t</span>&gt;&gt;<span class="hljs-built_in">offset</span>)&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)<br>                a^=<span class="hljs-built_in">t</span>;<br>            else<br>                b^=<span class="hljs-built_in">t</span>;<br>        &#125;<br>        return &#123;a,b&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="有1个出现1次其他出现3次"><a class="markdownIt-Anchor" href="#有1个出现1次其他出现3次"></a> 有1个出现1次，其他出现3次</h2><p><a href="https://leetcode.cn/problems/WGki4K/description/">原题</a></p><h3 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h3><p>给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p><h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3><p>参考<a href="https://leetcode.cn/problems/WGki4K/solutions/976992/jian-zhi-offer-ii-004-zhi-chu-xian-yi-ci-l3ud">题解</a></p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> once=<span class="hljs-number">0</span>,twice=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t:nums)&#123;<br>            once=~twice&amp;(t^once);<br>            twice=~once&amp;(t^twice);<br>        &#125;<br>        <span class="hljs-keyword">return</span> once;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>小红装电脑</title>
    <link href="/2025/03/10/%E5%B0%8F%E7%BA%A2%E8%A3%85%E7%94%B5%E8%84%91/"/>
    <url>/2025/03/10/%E5%B0%8F%E7%BA%A2%E8%A3%85%E7%94%B5%E8%84%91/</url>
    
    <content type="html"><![CDATA[<h2 id="小红装电脑"><a class="markdownIt-Anchor" href="#小红装电脑"></a> 小红装电脑</h2><!-- TOC --><ul><li><a href="#%E5%B0%8F%E7%BA%A2%E8%A3%85%E7%94%B5%E8%84%91">小红装电脑</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>小红准备买一些零件来组装电脑。已知电脑一共有n个零件，每个零件有若干个型号。<br />小红现在知道了每个型号的对应价格a_i​以及性能v_i。小红需要每个零件选择一个型号，在总价格不超过x元的前提下，最终的总性能尽可能大。<br />你能帮帮她吗？</p><p>输入格式</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">第一行输入两个正整数<span class="hljs-built_in">n</span>和x，代表电脑的零件数量以及小红最大的预算。<br>接下来的<span class="hljs-number">3</span>*<span class="hljs-built_in">n</span>行，每三行用来描述一个零件的不同型号的价格和性能。<br>对于每个零件，第一行输入一个正整数m，代表该零件有多少种型号。<br>第二行输入m个正整数a_i，代表该零件第i中型号的价格。<br>第三行输入m个正整数v_i，代表该零件第i中型号的性能。<br><span class="hljs-number">1</span>&lt;=<span class="hljs-built_in">n</span>,m&lt;=<span class="hljs-number">40</span><br><span class="hljs-number">1</span>&lt;= a_i,v_i,x &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">如果无法完成组装，则直接输出<span class="hljs-string">-1</span>。<br>否则输出一个正整数，代表最终最大的性能。<br></code></pre></td></tr></table></figure><p>样例</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入例子：<br>2 4<br>2<br>1 2<br>3 5<br>3<br>3<span class="hljs-number"> 2 </span>3<br>5<span class="hljs-number"> 6 </span>7<br>输出例子：<br>11<br>例子说明：<br>一共需要两个零件。<br>第一个零件选择第二个型号，第二个零件也选择第二个型号。<br>这样总价格为4，总性能为11。<br><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>第一眼看到就感觉是01背包，但是没有找到合适的dp数组来表示，后来看了大佬的思路感觉 dfs 简单明了。</p><p>主要思路就是dfs逆序遍历，每次dfs过程中，遍历当前零件的所有型号，如果当前预算大于等于该型号的价格，那么即可对当前型号进行dfs。<br />当dfs完所有零件后，更新ans即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll=<span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">45</span>;<br>ll num[N], v[N][N], w[N][N], x;<br>ll ans=<span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, ll cost, ll sum)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>        ans=<span class="hljs-built_in">max</span>(ans,sum);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=num[n];++i)&#123;<br>        <span class="hljs-keyword">if</span>(cost&gt;=v[n][i])&#123;<br>            <span class="hljs-built_in">dfs</span>(n<span class="hljs-number">-1</span>,cost-v[n][i],sum+w[n][i]);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-type">int</span> m;<br>        cin&gt;&gt;m;<br>        num[i]=m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>            cin&gt;&gt;v[i][j];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>            cin&gt;&gt;w[i][j];<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(n,x,<span class="hljs-number">0</span>);<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <br>&#125;<br><span class="hljs-comment">// 64 位输出请用 printf(&quot;%lld&quot;)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>寻找重复数</title>
    <link href="/2025/02/02/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <url>/2025/02/02/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="寻找重复数"><a class="markdownIt-Anchor" href="#寻找重复数"></a> 寻找重复数</h2><!-- TOC --><ul><li><a href="#%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0">寻找重复数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/find-the-duplicate-number/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p><p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,3,4,2,2]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>题目要求不使用额外空间，所以不能考虑辅助的数据结构。<br />可以考虑用快慢指针解决，实际上和判断链表中环的入口思路一样。<br />将数组中看作一个链表，数组中的元素就是链表中的节点，数组的元素的值看作是下一个节点的索引。因为存在重复的数，所以这个重复的数就是链表中的环的入口。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;<br>        int <span class="hljs-attribute">n</span>=nums.size();<br>        int <span class="hljs-attribute">slow</span>=0,fast=0;<br>        <span class="hljs-keyword">while</span>(1)&#123;<br>            <span class="hljs-attribute">slow</span>=nums[slow];<br>            <span class="hljs-attribute">fast</span>=nums[nums[fast]];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-attribute">slow</span>==fast)<br>                break;<br>        &#125;<br>        <span class="hljs-attribute">slow</span>=0;<br>        <span class="hljs-keyword">while</span>(slow!=fast)&#123;<br>            <span class="hljs-attribute">slow</span>=nums[slow];<br>            <span class="hljs-attribute">fast</span>=nums[fast];<br>        &#125;<br>        return slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>乘积最大子数组</title>
    <link href="/2025/01/29/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2025/01/29/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="乘积最大子数组"><a class="markdownIt-Anchor" href="#乘积最大子数组"></a> 乘积最大子数组</h2><!-- TOC --><ul><li><a href="#%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84">乘积最大子数组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E6%89%A9%E5%B1%95">扩展</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/maximum-product-subarray/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续<br />子数组<br />（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 32-位 整数。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [2,3,-2,4]</span><br><span class="hljs-section">输出: 6</span><br><span class="hljs-section">解释: 子数组 [2,3] 有最大乘积 6。</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题思路和<strong>最大子数组的和</strong>题目类似，都用动态规划的思路解决。需要注意的是，因为乘法的特性，所以在计算的时候需要同时维护一个最大值和最小值，因为最小值可能会变成最大值。<br />由于是连续的子数组，每次最大最小值只需要从<code>nums[i]</code>和<code>max * nums[i]</code>、<code>min * nums[i]</code>中取最大最小值即可，每次还要更新ans为ans和max中的最大值。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;<br>        int <span class="hljs-attribute">n</span>=nums.size();<br>        int <span class="hljs-attribute">mx</span>=nums[0],<span class="hljs-attribute">mn</span>=nums[0];<br>        int <span class="hljs-attribute">ans</span>=nums[0];<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;n;++i)&#123;<br>            int <span class="hljs-attribute">mxt</span>=mx;<br>            <span class="hljs-attribute">mx</span>=max(&#123;mx*nums[i],mn*nums[i],nums[i]&#125;);<br>            <span class="hljs-attribute">mn</span>=min(&#123;mxt*nums[i],mn*nums[i],nums[i]&#125;);<br>            <span class="hljs-attribute">ans</span>=max(ans,mx);<br>        &#125;<br>        return ans;        <br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h3><p>如果把题目要求改为子序列，参考<a href="https://leetcode.cn/problems/maximum-strength-of-a-group/description/">一个小组的最大实力值</a>，实际上思路也类似，也要维护最大和最小值<br />但是，这里包括选和不选两种情况</p><ul><li>选，对应情况是<code>x,mx*x,mn*x</code></li><li>不选，对应情况是<code>mx</code>或者<code>mn</code></li></ul><p>代码如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    long long maxStrength(vector&lt;int&gt;&amp; nums) &#123;<br>        int <span class="hljs-attribute">n</span>=nums.size();<br>        long long <span class="hljs-attribute">mx</span>=nums[0],<span class="hljs-attribute">mn</span>=nums[0];<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;n;++i)&#123;<br>            long long <span class="hljs-attribute">x</span>=nums[i];<br>            long long <span class="hljs-attribute">tmx</span>=mx;<br>            <span class="hljs-attribute">mx</span>=max(&#123;mx,x,mx*x,mn*x&#125;);<br>            <span class="hljs-attribute">mn</span>=min(&#123;mn,x,tmx*x,mn*x&#125;);<br>        &#125;<br>        return mx;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>完全平方数</title>
    <link href="/2025/01/28/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <url>/2025/01/28/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="完全平方数"><a class="markdownIt-Anchor" href="#完全平方数"></a> 完全平方数</h2><!-- TOC --><ul><li><a href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0">完全平方数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/perfect-squares/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 12<br>输出：3 <br>解释：12 =<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 4 </span>+ 4<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题实际上是一道完全背包问题。可以把n看作背包容量，每个完全平方数看作物品，每个完全平方数的价值为1。这样就可以转化为一个完全背包问题了，且对应装满的情况。<br />关于01背包和完全背包，之前整理了模板<a href="https://lqz2.github.io/2022/08/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">背包问题</a><br />总结下来就是，01背包逆向遍历，完全背包正向遍历，要求装满时dp数组初始化为最大值或最小值且<code>dp[0]=0</code>。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i;j&lt;=n;++j)&#123;<br>                dp[j]=<span class="hljs-built_in">min</span>(dp[j],dp[j-i*i]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分割回文串</title>
    <link href="/2025/01/11/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <url>/2025/01/11/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="分割回文串"><a class="markdownIt-Anchor" href="#分割回文串"></a> 分割回文串</h2><!-- TOC --><ul><li><a href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2">分割回文串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/palindrome-partitioning/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是<br />回文串。返回 s 所有可能的分割方案。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：[[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>可以看作是否选择当前字符作为回文子串的最后一个字符</p><ul><li>选，则判断当前子串是否为回文串，是则将当前子串加入答案，更新回文子串起点，继续递归</li><li>不选，则继续递归，无需更新回文子串起点</li><li>如果当前字符为字符串末尾，则只有选的情况，也就是不选的情况只适用于<code>idx&lt;n-1</code>的情况</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-keyword">if</span>(s[l++]!=s[r--])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; ans,vector&lt;string&gt;&amp; tmp,string s,<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> idx)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(idx==s.<span class="hljs-built_in">size</span>())&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(tmp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//选</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(s,start,idx))&#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(start,idx-start+<span class="hljs-number">1</span>));<br>            <span class="hljs-built_in">dfs</span>(ans,tmp,s,idx+<span class="hljs-number">1</span>,idx+<span class="hljs-number">1</span>);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-comment">//不选</span><br>        <span class="hljs-keyword">if</span>(idx&lt;s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>            <span class="hljs-built_in">dfs</span>(ans,tmp,s,start,idx+<span class="hljs-number">1</span>);<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        vector&lt;string&gt; tmp;<br>        <span class="hljs-built_in">dfs</span>(ans,tmp,s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Trie树</title>
    <link href="/2025/01/04/Trie%E6%A0%91/"/>
    <url>/2025/01/04/Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="trie树"><a class="markdownIt-Anchor" href="#trie树"></a> Trie树</h2><!-- TOC --><ul><li><a href="#trie%E6%A0%91">Trie树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p><p>请你实现 Trie 类：</p><p>Trie() 初始化前缀树对象。<br />void insert(String word) 向前缀树中插入字符串 word 。<br />boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br />boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入<br>[<span class="hljs-string">&quot;Trie&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;search&quot;</span>, <span class="hljs-string">&quot;search&quot;</span>, <span class="hljs-string">&quot;startsWith&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;search&quot;</span>]<br>[[], [<span class="hljs-string">&quot;apple&quot;</span>], [<span class="hljs-string">&quot;apple&quot;</span>], [<span class="hljs-string">&quot;app&quot;</span>], [<span class="hljs-string">&quot;app&quot;</span>], [<span class="hljs-string">&quot;app&quot;</span>], [<span class="hljs-string">&quot;app&quot;</span>]]<br>输出<br>[null, null, true, false, true, null, true]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题需要实现一个Trie树以及一些基本操作。可以维护两个成员变量：</p><ul><li><code>vector&lt;Trie*&gt; next</code>：用于存储子节点的数组</li><li><code>bool isEnd</code>：用于标记是否是一个单词的结尾</li></ul><p>由于是26个小写字母，所以<code>next</code>数组大小初始化为26, isEnd初始化为false。</p><p>插入时，遍历单词的每个字母，如果当前字母在next数组中不存在，则新建一个Trie节点<code>node-&gt;next[c-'a']==new Trie()</code>，然后移动到下一个节点<code>node=node-&gt;next[c-'a']</code>。<br />遍历完字符串后将<code>node-&gt;isEnd=true</code>。</p><p>查找时，遍历单词的每个字母，如果当前字母在next数组中不存在，则返回false，存在则移动到下一个节点。遍历完字符串后，返回<code>node-&gt;isEnd</code>。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> isEnd;<br>    vector&lt;Trie*&gt; next;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>(): <span class="hljs-built_in">next</span>(<span class="hljs-number">26</span>), <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string <span class="hljs-type">word</span>)</span> </span>&#123;<br>        Trie *node=<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:<span class="hljs-type">word</span>)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">nullptr</span>)&#123;<br>                node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            node=node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        node-&gt;isEnd=<span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string <span class="hljs-type">word</span>)</span> </span>&#123;<br>        Trie* node=<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:<span class="hljs-type">word</span>)&#123;<br>            node=node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;isEnd;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        Trie* node=<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:prefix)&#123;<br>            node=node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树基础</title>
    <link href="/2024/12/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/12/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">二叉树最大深度</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91">相同的树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li><li><a href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">对称二叉树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-2">代码</a></li></ul></li><li><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">平衡二叉树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-3">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-3">代码</a></li></ul></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E8%A7%86%E5%9B%BE">二叉树右视图</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-4">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-4">代码</a></li></ul></li><li><a href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">有序数组转为二叉搜索树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-5">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-5">代码</a></li></ul></li><li><a href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">验证二叉搜索树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-6">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-6">代码</a></li></ul></li><li><a href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91">翻转二叉树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-7">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-7">代码</a></li></ul></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84">二叉树的直径</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-8">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-8">代码</a></li></ul></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C">二叉树最大路径和</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-9">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-9">代码</a></li></ul></li><li><a href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%B8%AA%E6%95%B0">不同的二叉搜索树的个数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-10">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-10">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="二叉树最大深度"><a class="markdownIt-Anchor" href="#二叉树最大深度"></a> 二叉树最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个二叉树 root ，返回其最大深度。</p><p>二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>二叉树入门题，最大深度等于左右子树最大深度加1，所以可以递归</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    int maxDepth(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="相同的树"><a class="markdownIt-Anchor" href="#相同的树"></a> 相同的树</h2><p><a href="https://leetcode.cn/problems/same-tree/description/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的</p><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>当两个树的当前节点有一个为空：都为空返回true，否则返回false<br />否则，两个节点值相等，且递归左右子树也为true，才返回true</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coq">class Solution &#123;<br>public:<br>    bool isSameTree(TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-keyword">if</span>(!p|<span class="hljs-type">|!q</span>)<br>            <span class="hljs-keyword">return</span> p==q;<br>        <span class="hljs-keyword">return</span> p-&gt;val==q-&gt;val&amp;&amp; isSameTree(p-&gt;<span class="hljs-built_in">left</span>,q-&gt;<span class="hljs-built_in">left</span>)&amp;&amp; isSameTree(p-&gt;<span class="hljs-built_in">right</span>,q-&gt;<span class="hljs-built_in">right</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="对称二叉树"><a class="markdownIt-Anchor" href="#对称二叉树"></a> 对称二叉树</h2><p><a href="https://leetcode.cn/problems/symmetric-tree/description/">原题</a></p><h3 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h3><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3><p>和相同的树类似，判断左右子树是否对称即可，判断过程与相同的树类似，但比较的是左子树的左节点和右子树的右节点，左子树的右节点和右子树的左节点</p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coq">class Solution &#123;<br>public:<br>    bool func(TreeNode* l, TreeNode* r)&#123;<br>        <span class="hljs-keyword">if</span>(!l|<span class="hljs-type">|!r</span>)<br>            <span class="hljs-keyword">return</span> l==r;<br>        <span class="hljs-keyword">return</span> l-&gt;val==r-&gt;val&amp;&amp;func(l-&gt;<span class="hljs-built_in">left</span>,r-&gt;<span class="hljs-built_in">right</span>)&amp;&amp;func(l-&gt;<span class="hljs-built_in">right</span>,r-&gt;<span class="hljs-built_in">left</span>);<br>    &#125;<br>    bool isSymmetric(TreeNode* root) &#123;<br>        <span class="hljs-keyword">return</span> func(root-&gt;<span class="hljs-built_in">left</span>,root-&gt;<span class="hljs-built_in">right</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="平衡二叉树"><a class="markdownIt-Anchor" href="#平衡二叉树"></a> 平衡二叉树</h2><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">原题</a></p><h3 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4"></a> 题目描述</h3><p>给定一个二叉树，判断它是否是平衡二叉树</p><h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3><p>与求出二叉树的最大深度类似，只是在求左右子树的最大深度时，要判断左右子树的最大深度差是否大于1</p><h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode *t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l=<span class="hljs-built_in">depth</span>(t-&gt;left);<br>        <span class="hljs-keyword">if</span>(l==<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> r=<span class="hljs-built_in">depth</span>(t-&gt;right);<br>        <span class="hljs-keyword">if</span>(r==<span class="hljs-number">-1</span>||<span class="hljs-built_in">abs</span>(l-r)&gt;<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(l,r)+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">depth</span>(root)!=<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树右视图"><a class="markdownIt-Anchor" href="#二叉树右视图"></a> 二叉树右视图</h2><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">原题</a></p><h3 id="题目描述-5"><a class="markdownIt-Anchor" href="#题目描述-5"></a> 题目描述</h3><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><h3 id="思路-5"><a class="markdownIt-Anchor" href="#思路-5"></a> 思路</h3><p>设置一个表示当前深度的标记，当实际深度大于标记时，才将当前节点值加入结果中，递归时先递归右子树，再递归左子树</p><h3 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> cur=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* t, vector&lt;<span class="hljs-type">int</span>&gt;&amp; ans, <span class="hljs-type">int</span> depth)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(depth&gt;cur)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>            ++cur;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(t-&gt;right,ans,depth+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(t-&gt;left,ans,depth+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-built_in">dfs</span>(root,ans,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="有序数组转为二叉搜索树"><a class="markdownIt-Anchor" href="#有序数组转为二叉搜索树"></a> 有序数组转为二叉搜索树</h2><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">原题</a></p><h3 id="题目描述-6"><a class="markdownIt-Anchor" href="#题目描述-6"></a> 题目描述</h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵平衡二叉搜索树。</p><h3 id="思路-6"><a class="markdownIt-Anchor" href="#思路-6"></a> 思路</h3><p>类似归并排序，每次取数组中间元素作为根节点，递归左右子树建立二叉搜索树</p><h3 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(l==r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid],<span class="hljs-built_in">dfs</span>(nums,l,mid),<span class="hljs-built_in">dfs</span>(nums,mid+<span class="hljs-number">1</span>,r));<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="验证二叉搜索树"><a class="markdownIt-Anchor" href="#验证二叉搜索树"></a> 验证二叉搜索树</h2><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/description">原题</a></p><h3 id="题目描述-7"><a class="markdownIt-Anchor" href="#题目描述-7"></a> 题目描述</h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br />节点的右子树只包含 大于 当前节点的数。<br />所有左子树和右子树自身必须也是二叉搜索树。</p><h3 id="思路-7"><a class="markdownIt-Anchor" href="#思路-7"></a> 思路</h3><p>按照中序遍历的顺序，设置一个值pre记录上一个节点的值，递归时判断当前节点值是否大于pre，如果小于等于pre，返回false，更新pre为当前节点值，递归左右子树</p><h3 id="代码-7"><a class="markdownIt-Anchor" href="#代码-7"></a> 代码</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> pre=LLONG_MIN;<br>    <span class="hljs-keyword">bool</span> isValidBST(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(root==nullptr)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span>(!isValidBST(root-&gt;left)||root-&gt;val&lt;=pre)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        pre=root-&gt;val;<br>        <span class="hljs-keyword">return</span> isValidBST(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="翻转二叉树"><a class="markdownIt-Anchor" href="#翻转二叉树"></a> 翻转二叉树</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/description">原题</a></p><h3 id="题目描述-8"><a class="markdownIt-Anchor" href="#题目描述-8"></a> 题目描述</h3><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><h3 id="思路-8"><a class="markdownIt-Anchor" href="#思路-8"></a> 思路</h3><p>递归，先翻转左右子树，再交换左右子树的指针，返回当前节点</p><h3 id="代码-8"><a class="markdownIt-Anchor" href="#代码-8"></a> 代码</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coq">class Solution &#123;<br>public:<br>    TreeNode* invertTree(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(root==nullptr)<br>            <span class="hljs-keyword">return</span> nullptr;<br>        TreeNode* l=invertTree(root-&gt;<span class="hljs-built_in">left</span>);<br>        TreeNode* r=invertTree(root-&gt;<span class="hljs-built_in">right</span>);<br>        root-&gt;<span class="hljs-built_in">left</span>=r;<br>        root-&gt;<span class="hljs-built_in">right</span>=l;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的直径"><a class="markdownIt-Anchor" href="#二叉树的直径"></a> 二叉树的直径</h2><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">原题</a></p><h3 id="题目描述-9"><a class="markdownIt-Anchor" href="#题目描述-9"></a> 题目描述</h3><p>给你一棵二叉树的根节点，返回该树的 直径 。</p><p>二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。</p><p>两节点之间路径的 长度 由它们之间边数表示。</p><h3 id="思路-9"><a class="markdownIt-Anchor" href="#思路-9"></a> 思路</h3><p>直径等于左右子树的最大深度之和，和求最大深度类似，递归时更新最大直径即可</p><h3 id="代码-9"><a class="markdownIt-Anchor" href="#代码-9"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> &amp;maxlen)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l=<span class="hljs-built_in">depth</span>(root-&gt;left, maxlen);<br>        <span class="hljs-type">int</span> r=<span class="hljs-built_in">depth</span>(root-&gt;right, maxlen);<br>        maxlen=<span class="hljs-built_in">max</span>(l+r,maxlen);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(l,r)+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxlen=<span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">depth</span>(root, maxlen);<br>        <span class="hljs-keyword">return</span> maxlen;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树最大路径和"><a class="markdownIt-Anchor" href="#二叉树最大路径和"></a> 二叉树最大路径和</h2><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum">原题</a></p><h3 id="题目描述-10"><a class="markdownIt-Anchor" href="#题目描述-10"></a> 题目描述</h3><p>二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和</p><h3 id="思路-10"><a class="markdownIt-Anchor" href="#思路-10"></a> 思路</h3><p>最大路径和等于左子树最深路径和+右子树最深路径和+当前节点值<br />所以递归时返回当前节点向下的最深路径和，即<code>max(max(l,r)+root-&gt;val,0)</code><br />同时更新最大路径和，即<code>max(l+r+root-&gt;val,ans)</code></p><h3 id="代码-10"><a class="markdownIt-Anchor" href="#代码-10"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    <span class="hljs-built_in">int</span> ans;<br>    <span class="hljs-built_in">int</span> dfs(TreeNode* <span class="hljs-built_in">t</span>)&#123;<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">t</span>==nullptr)<br>            return <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> l=dfs(<span class="hljs-built_in">t</span>-&gt;<span class="hljs-built_in">left</span>);<br>        <span class="hljs-built_in">int</span> r=dfs(<span class="hljs-built_in">t</span>-&gt;<span class="hljs-built_in">right</span>);<br>        ans=<span class="hljs-built_in">max</span>(ans,l+r+<span class="hljs-built_in">t</span>-&gt;val);<br>        return <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(l,r)+<span class="hljs-built_in">t</span>-&gt;val,<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">int</span> maxPathSum(TreeNode* root) &#123;<br>        ans=INT_MIN;<br>        dfs(root);<br>        return ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="不同的二叉搜索树的个数"><a class="markdownIt-Anchor" href="#不同的二叉搜索树的个数"></a> 不同的二叉搜索树的个数</h2><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">原题</a></p><h3 id="题目描述-11"><a class="markdownIt-Anchor" href="#题目描述-11"></a> 题目描述</h3><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><h3 id="思路-11"><a class="markdownIt-Anchor" href="#思路-11"></a> 思路</h3><p>对于从1～n的节点来说，每个节点i都可以作为根节点，左子树为1～i-1的节点，右子树为i+1～n的节点<br />所以，以i为根节点，长度为n的二叉搜索树的个数为左子树的个数乘以右子树的个数<br />即<code>dp[i] =dp[i-1]*dp[n-i]</code><br />将这些情况累加起来即为长度为n的二叉搜索树的个数</p><p>实际上卡特兰数的计算方式也是这种方式<br />卡特兰数即解决：若一个序列的入栈序列为1,2,3,…,n，则有多少不同的出栈序列<br />公式为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>C</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mspace width="1em"/><msub><mi>C</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mfrac><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></mfrac><msub><mi>C</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">C_0 = 1, \quad C_{n+1} = \frac{2(2n + 1)}{n + 2} C_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><h3 id="代码-11"><a class="markdownIt-Anchor" href="#代码-11"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-comment">//        vector&lt;int&gt; dp(n + 1);</span><br><span class="hljs-comment">//        dp[0] = 1;</span><br><span class="hljs-comment">//        dp[1] = 1;</span><br><span class="hljs-comment">//        for(int i=2;i&lt;=n;++i)&#123;</span><br><span class="hljs-comment">//            for(int j=1;j&lt;=i;++j)&#123;</span><br><span class="hljs-comment">//                dp[i] += dp[j-1] * dp[i-j];</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        return dp[n];</span><br>         <span class="hljs-type">long</span> ans=<span class="hljs-number">1</span>;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>             ans=ans*<span class="hljs-number">2</span>*(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>)/(i+<span class="hljs-number">2</span>);<br>         &#125;<br>         <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>路径总和3</title>
    <link href="/2024/12/27/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C3/"/>
    <url>/2024/12/27/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C3/</url>
    
    <content type="html"><![CDATA[<h2 id="路径总和3"><a class="markdownIt-Anchor" href="#路径总和3"></a> 路径总和3</h2><!-- TOC --><ul><li><a href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C3">路径总和3</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/path-sum-iii/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">targetSum</span> = <span class="hljs-number">22</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题实际是二叉树版的和为k的子数组，还是需要用前缀和和哈希表的思想解决，参考<a href="https://lqz2.github.io/2024/12/18/%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/">这里</a><br />要注意的是，由于题目规定只能向下，也就是说遍历右子树之前，要回退左子树的数据，也就是在最后加上<code>--mp[sum]</code></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span>,<span class="hljs-built_in">int</span>&gt; mp;<br>    <span class="hljs-keyword">void</span> dfs(TreeNode* t,<span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> <span class="hljs-keyword">sum</span>, <span class="hljs-built_in">int</span> k, <span class="hljs-built_in">int</span> &amp;ans)&#123;<br>        <span class="hljs-keyword">if</span>(t==nullptr)<br>            <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">sum</span>+=t-&gt;val;<br>        ans+=mp[<span class="hljs-keyword">sum</span>-k];<br>        ++mp[<span class="hljs-keyword">sum</span>];<br>        dfs(t-&gt;left,<span class="hljs-keyword">sum</span>,k,ans);<br>        dfs(t-&gt;right,<span class="hljs-keyword">sum</span>,k,ans);<br>        --mp[<span class="hljs-keyword">sum</span>];<br>    &#125;<br>    <span class="hljs-built_in">int</span> pathSum(TreeNode* root, <span class="hljs-built_in">int</span> targetSum) &#123;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        mp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        dfs(root,<span class="hljs-number">0</span>,targetSum,ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序链表</title>
    <link href="/2024/12/25/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/12/25/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="排序链表"><a class="markdownIt-Anchor" href="#排序链表"></a> 排序链表</h2><!-- TOC --><ul><li><a href="#%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8">排序链表</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/sort-list/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题之前直接用Vector排序的😂，这次用归并排序实现。</p><ul><li>先找到链表的中点</li><li>递归的对左右两部分进行归并排序，返回排序后左右两部分的头结点</li><li>合并两个有序链表</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xl">class Solution &#123;<br>public:<br>    ListNode* merge(ListNode* h1, ListNode* h2)&#123;<br>        ListNode* dummy=new ListNode(-<span class="hljs-number">1</span>);<br>        ListNode* l=dummy,*l1=h1,*l2=h2;<br>        <span class="hljs-keyword">while</span>(l1&amp;&amp;l2)&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(l1-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span>&lt;=l2-&gt;</span>val)&#123;<br>                <span class="hljs-function"><span class="hljs-title">l</span>-&gt;</span>next=l1;<br>                <span class="hljs-function"><span class="hljs-title">l1</span>=l1-&gt;</span>next;<br>                <span class="hljs-function"><span class="hljs-title">l</span>=l-&gt;</span>next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-function"><span class="hljs-title">l</span>-&gt;</span>next=l2;<br>                <span class="hljs-function"><span class="hljs-title">l2</span>=l2-&gt;</span>next;<br>                <span class="hljs-function"><span class="hljs-title">l</span>=l-&gt;</span>next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">l</span>-&gt;</span>next=l1==nullptr? l2:l1;<br>        <span class="hljs-function"><span class="hljs-title">return</span> dummy-&gt;</span>next;<br>    &#125;<br>    ListNode* mergeSort(ListNode* head, ListNode* tail)&#123;<br>        <span class="hljs-keyword">if</span>(head==nullptr)<br>            return head;<br>        <span class="hljs-function"><span class="hljs-title">if</span>(head-&gt;</span>next==tail)&#123;<br>            <span class="hljs-function"><span class="hljs-title">head</span>-&gt;</span>next=nullptr;<br>            return head;<br>        &#125;<br>        ListNode *slow=head,*fast=head;<br>        <span class="hljs-function"><span class="hljs-title">while</span>(fast-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>!=tail&amp;&amp;fast-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>next!=tail)&#123;<br>            <span class="hljs-function"><span class="hljs-title">slow</span>=slow-&gt;</span>next;<br>            <span class="hljs-function"><span class="hljs-title">fast</span>=fast-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>next;<br>        &#125;<br>        L<span class="hljs-function"><span class="hljs-title">istNode</span> *mid=slow-&gt;</span>next;<br>        return merge(mergeSort(head,mid),mergeSort(mid,tail));        <br>    &#125;<br>    ListNode* sortList(ListNode* head) &#123;<br>        return mergeSort(head,nullptr);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>k个一组翻转链表</title>
    <link href="/2024/12/24/k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/12/24/k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="k个一组翻转链表"><a class="markdownIt-Anchor" href="#k个一组翻转链表"></a> k个一组翻转链表</h2><!-- TOC --><ul><li><a href="#k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8">k个一组翻转链表</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[2,1,4,3,5]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题之前也做过，不过用的是辅助数组的方法。这次用在原链表上进行操作。<br />主要就是先确定一个长为k的区间，然后进行翻转，返回翻转后的头节点和尾节点。<br />然后在主函数中进行遍历，每次先找一段长为k的区间，记录这个区间的头节点和尾节点，然后进行翻转，得到新的头节点和尾节点，然后将这个区间的头节点和尾节点连接到原链表上。</p><p>这里顺便记录一下翻转某个区间并返回新的头节点和尾节点的模板：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pair&lt;ListNode*,ListNode*&gt; reverse(ListNode* head, ListNode*tail)&#123;<br>    ListNode* <span class="hljs-attribute">pre</span>=tail-&gt;next;<br>    ListNode* <span class="hljs-attribute">l</span>=head;<br>    <span class="hljs-keyword">while</span>(pre!=tail)&#123;<br>        ListNode* <span class="hljs-attribute">t</span>=l-&gt;next;<br>        l-&gt;<span class="hljs-attribute">next</span>=pre;<br>        <span class="hljs-attribute">pre</span>=l;<br>        <span class="hljs-attribute">l</span>=t;<br>    &#125;<br>    return &#123;pre,head&#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    pair&lt;ListNode*,ListNode*&gt; reverse(ListNode* head, ListNode*tail)&#123;<br>        ListNode* <span class="hljs-attribute">pre</span>=tail-&gt;next;<br>        ListNode* <span class="hljs-attribute">l</span>=head;<br>        <span class="hljs-keyword">while</span>(pre!=tail)&#123;<br>            ListNode* <span class="hljs-attribute">t</span>=l-&gt;next;<br>            l-&gt;<span class="hljs-attribute">next</span>=pre;<br>            <span class="hljs-attribute">pre</span>=l;<br>            <span class="hljs-attribute">l</span>=t;<br>        &#125;<br>        return &#123;pre,head&#125;;<br>    &#125;<br>    ListNode* reverseKGroup(ListNode* head, int k) &#123;<br>        ListNode* <span class="hljs-attribute">dummy</span>=new ListNode(0);<br>        dummy-&gt;<span class="hljs-attribute">next</span>=head;<br>        ListNode* <span class="hljs-attribute">pre</span>=dummy;<br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            ListNode *<span class="hljs-attribute">tail</span>=pre;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;k;++i)&#123;<br>                <span class="hljs-attribute">tail</span>=tail-&gt;next;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-attribute">tail</span>==nullptr)<br>                    return dummy-&gt;next;<br>            &#125;<br>            ListNode* <span class="hljs-attribute">t</span>=tail-&gt;next;<br>            pair&lt;ListNode*,ListNode*&gt; <span class="hljs-attribute">res</span>=reverse(head,tail);<br>            <span class="hljs-attribute">head</span>=res.first;<br>            <span class="hljs-attribute">tail</span>=res.second;<br>            pre-&gt;<span class="hljs-attribute">next</span>=head;<br>            tail-&gt;<span class="hljs-attribute">next</span>=t;<br>            <span class="hljs-attribute">pre</span>=tail;<br>            <span class="hljs-attribute">head</span>=t;<br>        &#125;<br>        return dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>旋转图像</title>
    <link href="/2024/12/22/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2024/12/22/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="旋转图像"><a class="markdownIt-Anchor" href="#旋转图像"></a> 旋转图像</h2><!-- TOC --><ul><li><a href="#%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F">旋转图像</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/rotate-image/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[7,4,1],[8,5,2],[9,6,3]]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题做了之前做过，但是之前的做法比较暴力，直接用了一个新的数组来存储旋转后的结果。<br />其实这道题观察到规律后很简单，先沿着反对角线(右上角到左下角的对角线)翻转，然后再沿着中间的x轴翻转即可。</p><p>然后总结一下矩阵翻转的规律：</p><ul><li>如果要关于对角线翻转，那么只需要将<code>matrix[i][j]</code>和<code>matrix[j][i]</code>交换即可。</li><li>如果要关于x轴翻转，那么只需要将<code>matrix[i][j]</code>和<code>matrix[n-i-1][j]</code>交换即可。</li><li>如果要关于y轴翻转，那么只需要将<code>matrix[i][j]</code>和<code>matrix[i][n-j-1]</code>交换即可。</li><li>如果关于反对角线翻转，那么只需要将<code>matrix[i][j]</code>和<code>matrix[n-j-1][n-i-1]</code>交换即可。</li><li>如果关于中心翻转，那么只需要将<code>matrix[i][j]</code>和<code>matrix[n-i-1][n-j-1]</code>交换即可。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    void <span class="hljs-keyword">rotate</span>(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-keyword">matrix</span>) &#123;<br>        <span class="hljs-keyword">int</span> n=<span class="hljs-keyword">matrix</span>.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n-i;++j)&#123;<br>                swap(<span class="hljs-keyword">matrix</span>[i][j],<span class="hljs-keyword">matrix</span>[n-j<span class="hljs-number">-1</span>][n-i<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                swap(<span class="hljs-keyword">matrix</span>[i][j],<span class="hljs-keyword">matrix</span>[n-i<span class="hljs-number">-1</span>][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>缺失的第一个正数</title>
    <link href="/2024/12/21/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <url>/2024/12/21/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="缺失的第一个正数"><a class="markdownIt-Anchor" href="#缺失的第一个正数"></a> 缺失的第一个正数</h2><!-- TOC --><ul><li><a href="#%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0">缺失的第一个正数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/first-missing-positive/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">示例 1：<br><br>输入：nums = <span class="hljs-comment">[1,2,0]</span><br>输出：3<br>解释：范围 <span class="hljs-comment">[1,2]</span> 中的数字都在数组中。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题要找出不在数组中的最小正整数，对于一个数组(长度为n)，题目要求的数要么在<code>[1,n]</code>之间，要么是n+1。<br />所以可以对数组进行遍历，如果当前数<code>x</code>在<code>[1,n]</code>之间，那么将x所在位置进行标记，遍历结束后，如果<code>[1,n]</code>之间的数都被标记了，那么返回n+1，否则返回第一个没有被标记的数。</p><p>具体步骤如下：</p><ul><li>将数组中的负数和0全部置为n+1</li><li>遍历数组，如果当前数<code>x</code>在<code>[1,n]</code>之间，那么将<code>nums[x-1]</code>进行取反，标记为负数，表示x已经出现过</li><li>再次遍历数组，找到第一个正数<code>nums[i]</code>，返回<code>i+1</code>，如果没有找到，返回<code>n+1</code></li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    <span class="hljs-built_in">int</span> firstMissingPositive(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>=nums.size();<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; v(<span class="hljs-built_in">n</span>);<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">n</span>;++i)&#123;<br>            <span class="hljs-built_in">if</span>(nums[i]&lt;=<span class="hljs-number">0</span>)&#123;<br>                nums[i]=<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">n</span>;++i)&#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>=<span class="hljs-built_in">abs</span>(nums[i]);<br>            <span class="hljs-built_in">if</span>(<span class="hljs-built_in">t</span>&lt;=<span class="hljs-built_in">n</span>)&#123;<br>                nums[<span class="hljs-built_in">t</span>-<span class="hljs-number">1</span>]=-<span class="hljs-built_in">abs</span>(nums[<span class="hljs-built_in">t</span>-<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">n</span>;++i)&#123;<br>            <span class="hljs-built_in">if</span>(nums[i]&gt;<span class="hljs-number">0</span>)<br>                return i+<span class="hljs-number">1</span>;<br>        &#125;<br>        return <span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>有序矩阵中第K小的元素</title>
    <link href="/2024/12/19/%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <url>/2024/12/19/%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="有序矩阵中第k小的元素"><a class="markdownIt-Anchor" href="#有序矩阵中第k小的元素"></a> 有序矩阵中第K小的元素</h2><!-- TOC --><ul><li><a href="#%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">有序矩阵中第K小的元素</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br />请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。</p><p>你必须找到一个内存复杂度优于 <code>O(n^2)</code> 的解决方案。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">示例 1：<br><br>输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,5,9]</span>,<span class="hljs-comment">[10,11,13]</span>,<span class="hljs-comment">[12,13,15]</span>]</span>, k = 8<br>输出：13<br>解释：矩阵中的元素为 <span class="hljs-comment">[1,5,9,10,11,12,13,13,15]</span>，第 8 小元素是 13<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题一般一眼看上去都会想到堆。但是堆并没有很好利用矩阵的有序性，这里采用二分查找的方法。</p><p>首先要解决的是计数问题，给定一个数 mid，如何计算矩阵中小于等于这个数的元素个数？<br />这里采用的是从左下角开始遍历</p><ul><li>如果当前元素小于等于mid，那么这一列的元素都小于等于mid，计数加上列数，然后向右移动一列。</li><li>如果当前元素大于mid，计数不变，然后向上移动一行。</li></ul><p>接下来就是二分查找了，要求找出第k小元素，可以先找出中间数mid，当小于等于mid的元素个数小于k时，说明mid比要找的数小，所以要向右移动，否则向左移动。<br />计数的方法很巧妙，值得学习。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> count(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-keyword">matrix</span>,<span class="hljs-keyword">int</span> mid,<span class="hljs-keyword">int</span> n)&#123;<br>        <span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>,j=<span class="hljs-number">0</span>;<span class="hljs-comment">//从左下角开始</span><br>        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">matrix</span>[i][j]&lt;=mid)&#123;<br>                cnt+=i+<span class="hljs-number">1</span>;<br>                ++j;<br>            &#125;<span class="hljs-keyword">else</span><br>                --i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> kthSmallest(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-keyword">matrix</span>, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">int</span> n=<span class="hljs-keyword">matrix</span>.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">int</span> l=<span class="hljs-keyword">matrix</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],r=<span class="hljs-keyword">matrix</span>[n<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-keyword">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(count(<span class="hljs-keyword">matrix</span>,mid,n)&gt;=k)&#123;<br>                r=mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>和为k的子数组</title>
    <link href="/2024/12/18/%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2024/12/18/%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="和为k的子数组"><a class="markdownIt-Anchor" href="#和为k的子数组"></a> 和为k的子数组</h2><!-- TOC --><ul><li><a href="#%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">和为k的子数组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。<br />子数组是数组中元素的连续非空序列。</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">示例 1：</span><br><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,1], k = 2</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>自己只想到了<code>O(n^2)</code>的解法，但是使用前缀和可以将时间复杂度降低到<code>O(n)</code>。<br />假设前缀和数组为sum[]，那么当<code>sum[i] - sum[j] = k</code>时，说明从j到i的子数组满足条件，实际上就是求<code>sum[j] = sum[i] - k</code>的个数。<br />我们可以用一个变量sum记录累加到当前位置的所有元素之和，用一个哈希表记录sum出现的次数，此时前缀和为sum-k的个数就是满足条件的个数。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> subarraySum(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> n=nums.size();<br>        unordered_map&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt; mp;<br>        mp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">sum</span>+=nums[i];<br>            ans+=mp[<span class="hljs-keyword">sum</span>-k];<br>            ++mp[<span class="hljs-keyword">sum</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据流的中位数</title>
    <link href="/2024/12/15/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2024/12/15/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="数据流的中位数"><a class="markdownIt-Anchor" href="#数据流的中位数"></a> 数据流的中位数</h2><!-- TOC --><ul><li><a href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">数据流的中位数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/find-median-from-data-stream/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p><p>例如 arr = [2,3,4] 的中位数是 3 。<br />例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。<br />实现 MedianFinder 类:</p><p>MedianFinder() 初始化 MedianFinder 对象。</p><p>void addNum(int num) 将数据流中的整数 num 添加到数据结构中。</p><p>double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。</p><p>示例：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入<br>[<span class="hljs-string">&quot;MedianFinder&quot;</span>, <span class="hljs-string">&quot;addNum&quot;</span>, <span class="hljs-string">&quot;addNum&quot;</span>, <span class="hljs-string">&quot;findMedian&quot;</span>, <span class="hljs-string">&quot;addNum&quot;</span>, <span class="hljs-string">&quot;findMedian&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [<span class="hljs-number">3</span>], []]<br>输出<br>[null, null, null, <span class="hljs-number">1.5</span>, null, <span class="hljs-number">2.0</span>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要思路是使用两个堆，一个大顶堆，一个小顶堆，大顶堆存放小于等于中位数的部分，小顶堆存放大于中位数的部分，当总数为奇数时，中位数是大顶堆的堆顶，当总数为偶数时，中位数是两个堆顶的平均值。<br />注意，两个堆的大小差不能超过1，所以在插入元素时，需要移动元素，保证两个堆的大小差不超过1。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> MedianFinder &#123;<br><span class="hljs-keyword">public</span>:<br>    priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, less&lt;<span class="hljs-keyword">int</span>&gt;&gt; pqBig;<br>    priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; pqSma;<br>    MedianFinder() &#123;&#125;<br>    <br>    <span class="hljs-keyword">void</span> addNum(<span class="hljs-keyword">int</span> num) &#123;<br>        <span class="hljs-keyword">if</span>(pqBig.empty()||num&lt;=pqBig.top())&#123;<br>            pqBig.<span class="hljs-keyword">push</span>(num);<br>            <span class="hljs-keyword">if</span>(pqSma.<span class="hljs-keyword">size</span>()+<span class="hljs-number">1</span>&lt;pqBig.<span class="hljs-keyword">size</span>())&#123;<br>                pqSma.<span class="hljs-keyword">push</span>(pqBig.top());<br>                pqBig.<span class="hljs-keyword">pop</span>();<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            pqSma.<span class="hljs-keyword">push</span>(num);<br>            <span class="hljs-keyword">if</span>(pqSma.<span class="hljs-keyword">size</span>()&gt;pqBig.<span class="hljs-keyword">size</span>())&#123;<br>                pqBig.<span class="hljs-keyword">push</span>(pqSma.top());<br>                pqSma.<span class="hljs-keyword">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">double</span> findMedian() &#123;<br>        <span class="hljs-keyword">if</span>(pqBig.<span class="hljs-keyword">size</span>()==pqSma.<span class="hljs-keyword">size</span>())&#123;<br>            <span class="hljs-keyword">return</span> (pqBig.top()+pqSma.top())/<span class="hljs-number">2.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pqBig.top();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>web开发与微服务学习</title>
    <link href="/2024/10/13/web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/10/13/web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="web开发部分"><a class="markdownIt-Anchor" href="#web开发部分"></a> web开发部分</h1><!-- TOC --><ul><li><a href="#web%E5%BC%80%E5%8F%91%E9%83%A8%E5%88%86">web开发部分</a><ul><li><a href="#springboot%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">SpringBoot的启动流程</a></li><li><a href="#spring-ioc">Spring IOC</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">基础概念</a></li><li><a href="#ioc%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">IOC解决了什么问题？</a></li><li><a href="#ioc%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">IOC容器的初始化</a></li></ul></li><li><a href="#spring-bean">Spring Bean</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFspring-beancomponent-%E5%92%8C-bean-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">什么是Spring Bean？@Component 和 @Bean 的区别是什么？</a></li><li><a href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BA-bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B">将一个类声明为 Bean 的注解有哪些?</a></li><li><a href="#bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Bean生命周期</a></li><li><a href="#bean%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96">Bean的循环依赖</a></li></ul></li><li><a href="#springmvc">SpringMVC</a><ul><li><a href="#springmvc%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6">SpringMVC关键组件</a></li><li><a href="#springmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">SpringMVC执行流程</a></li><li><a href="#%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%80%8E%E4%B9%88%E5%81%9A">统一异常处理怎么做？</a></li></ul></li><li><a href="#springboot%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">springboot的依赖注入</a><ul><li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5">构造函数注入</a></li><li><a href="#setter%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5">setter方法注入</a></li><li><a href="#%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5">字段注入</a></li></ul></li><li><a href="#springboot3%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86">springboot3自动配置原理</a><ul><li><a href="#%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4">主要步骤</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">使用示例</a></li></ul></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89starter">自定义starter</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFspringboot-starter">什么是springboot starter</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89starter">如何创建自定义starter</a></li></ul></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a><ul><li><a href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">工厂模式</a></li><li><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a></li><li><a href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">代理模式</a></li><li><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a></li><li><a href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">代理模式和适配器模式的区别？</a></li></ul></li><li><a href="#redis">Redis</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFredis">什么是Redis?</a></li><li><a href="#redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB">Redis为什么快？</a></li></ul></li><li><a href="#jwt%E4%BB%A4%E7%89%8C">JWT令牌</a></li><li><a href="#threadlocal">ThreadLocal</a><ul><li><a href="#%E7%89%B9%E7%82%B9">特点</a></li><li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li></ul></li><li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8">拦截器</a><ul><li><a href="#%E4%BD%9C%E7%94%A8">作用</a></li><li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB">拦截器与过滤器的区别</a></li><li><a href="#%E5%AE%9E%E7%8E%B0">实现</a></li><li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">拦截器的执行顺序</a></li></ul></li><li><a href="#controller%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E6%B3%A8%E8%A7%A3">Controller中的方法接收参数注解</a><ul><li><a href="#requestparam">@RequestParam</a></li><li><a href="#pathvariable">@PathVariable</a></li><li><a href="#requestbody">@RequestBody</a></li><li><a href="#cookievalue">@CookieValue</a></li><li><a href="#requestheader">@RequestHeader</a></li><li><a href="#modelattribute">@ModelAttribute</a></li></ul></li><li><a href="#%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C">参数校验</a><ul><li><a href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3">常用注解</a></li><li><a href="#%E5%BC%80%E5%90%AF%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C">开启参数校验</a></li><li><a href="#validated%E5%92%8Cvalid%E5%8C%BA%E5%88%AB">@Validated和@Valid区别</a></li></ul></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C">自定义参数校验</a><ul><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89state%E6%B3%A8%E8%A7%A3">自定义State注解</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99%E7%9A%84%E7%B1%BB">自定义校验规则的类</a></li></ul></li><li><a href="#redis%E5%AE%9E%E7%8E%B0%E7%99%BB%E9%99%86%E4%B8%BB%E5%8A%A8%E5%A4%B1%E6%95%88">redis实现登陆主动失效</a></li><li><a href="#javascript%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA">JavaScript的导入导出</a><ul><li><a href="#%E9%9D%9E%E9%BB%98%E8%AE%A4%E5%AF%BC%E5%87%BA">非默认导出</a></li><li><a href="#%E9%BB%98%E8%AE%A4%E5%AF%BC%E5%87%BA">默认导出</a></li></ul></li><li><a href="#vue%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">vue基本概念</a></li><li><a href="#vue%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4">vue常用指令</a><ul><li><a href="#ref%E5%92%8Creactive">ref和reactive</a></li><li><a href="#v-for">v-for</a></li><li><a href="#v-bind">v-bind</a></li><li><a href="#v-if-%E5%92%8C-v-show">v-if 和 v-show</a></li><li><a href="#v-on">v-on</a></li><li><a href="#v-model">v-model</a></li></ul></li><li><a href="#let%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB">let和var的区别</a></li><li><a href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">vue生命周期</a></li><li><a href="#axios%E7%9A%84%E4%BD%BF%E7%94%A8">axios的使用</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li><li><a href="#axios%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8">axios响应拦截器</a></li><li><a href="#axios%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA%E5%99%A8">axios请求拦截器</a></li></ul></li><li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">浏览器跨域问题</a><ul><li><a href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">解决方法</a></li></ul></li><li><a href="#vue%E7%9A%84%E8%B7%AF%E7%94%B1">vue的路由</a><ul><li><a href="#vue%E4%B8%AD%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4">vue中路由的使用步骤</a></li><li><a href="#%E8%B7%AF%E7%94%B1%E4%B8%BB%E5%8A%A8%E5%88%87%E6%8D%A2%E7%BB%84%E4%BB%B6">路由主动切换组件</a></li></ul></li><li><a href="#vue%E4%B8%AD%E4%BD%BF%E7%94%A8pinia%E5%8F%8A%E5%85%B6%E6%8C%81%E4%B9%85%E5%8C%96">vue中使用pinia及其持久化</a><ul><li><a href="#pinia%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4">pinia使用步骤</a></li><li><a href="#pinia%E6%8C%81%E4%B9%85%E5%8C%96">pinia持久化</a></li></ul></li></ul></li><li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%83%A8%E5%88%86">微服务部分</a><ul><li><a href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83">注册中心</a><ul><li><a href="#%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">服务治理基础知识</a></li><li><a href="#nacos%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">nacos基础知识</a></li><li><a href="#%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB">环境隔离</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%88%86%E7%BA%A7%E6%A8%A1%E5%9E%8B">服务分级模型</a></li></ul></li><li><a href="#openfeign">OpenFeign</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1">基本用法</a></li><li><a href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0">连接池</a></li><li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">负载均衡</a></li></ul></li><li><a href="#%E7%BD%91%E5%85%B3">网关</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-2">基本用法</a></li><li><a href="#%E7%BD%91%E5%85%B3%E5%AE%9E%E7%8E%B0%E7%99%BB%E9%99%86%E6%A0%A1%E9%AA%8C">网关实现登陆校验</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BD%AC%E5%8F%91%E4%B9%8B%E5%89%8D%E5%81%9A%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C">如何在转发之前做登录校验？</a></li><li><a href="#%E7%BD%91%E5%85%B3%E7%99%BB%E9%99%86%E6%A0%A1%E9%AA%8C%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E5%B0%86%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E7%BB%99%E5%BE%AE%E6%9C%8D%E5%8A%A1">网关登陆校验之后，如何将用户信息传递给微服务？</a></li><li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E4%B9%9F%E4%BC%9A%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E8%BF%99%E7%A7%8D%E8%B0%83%E7%94%A8%E4%B8%8D%E7%BB%8F%E8%BF%87%E7%BD%91%E5%85%B3%E5%8F%88%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF">微服务之间也会相互调用，这种调用不经过网关，又该如何传递用户信息？</a></li></ul></li><li><a href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1">动态路由</a></li></ul></li><li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4">微服务保护</a><ul><li><a href="#%E8%AF%B7%E6%B1%82%E9%99%90%E6%B5%81">请求限流</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB">线程隔离</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD">服务熔断</a></li><li><a href="#%E4%B8%8D%E5%90%8C%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94">不同线程隔离方案对比</a></li><li><a href="#%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95">计数算法</a></li></ul></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">分布式事务</a><ul><li><a href="#seata%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">Seata的基本用法</a></li><li><a href="#xa%E6%A8%A1%E5%BC%8F">XA模式</a></li><li><a href="#at%E6%A8%A1%E5%BC%8F">AT模式</a></li><li><a href="#at%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%84%8F%E5%86%99%E9%97%AE%E9%A2%98">AT模式的脏写问题</a></li><li><a href="#tcc%E6%A8%A1%E5%BC%8F">TCC模式</a></li></ul></li><li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-mq">消息队列 (MQ)</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a></li><li><a href="#rabbitmq%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">RabbitMQ基础知识</a></li><li><a href="#rabbitmq%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B">RabbitMQ交换机类型</a></li><li><a href="#%E5%A3%B0%E6%98%8E%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA">声明队列和交换机</a></li><li><a href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8">消息转换器</a></li><li><a href="#%E5%8F%91%E9%80%81%E8%80%85%E5%8F%AF%E9%9D%A0%E6%80%A7">发送者可靠性</a></li><li><a href="#mq%E5%8F%AF%E9%9D%A0%E6%80%A7">MQ可靠性</a></li><li><a href="#%E6%B6%88%E8%B4%B9%E8%80%85%E5%8F%AF%E9%9D%A0%E6%80%A7">消费者可靠性</a></li><li><a href="#%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF">延迟消息</a></li></ul></li><li><a href="#elasticsearch">ElasticSearch</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1">基础知识</a></li><li><a href="#kibana%E4%B8%AD%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">Kibana中的增删改查</a></li><li><a href="#dsl%E6%9F%A5%E8%AF%A2">DSL查询</a></li><li><a href="#restclient%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C">RestClient基础操作</a></li></ul></li><li><a href="#redis%E4%B8%BB%E4%BB%8E">Redis主从</a></li><li><a href="#redis%E5%93%A8%E5%85%B5">Redis哨兵</a></li><li><a href="#redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4">Redis分片集群</a><ul><li><a href="#%E6%95%A3%E5%88%97%E6%8F%92%E6%A7%BD">散列插槽</a></li></ul></li><li><a href="#redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">Redis数据结构</a><ul><li><a href="#skiplist">SkipList</a></li><li><a href="#sortedset">SortedSet</a></li><li><a href="#bitmap">Bitmap</a></li></ul></li><li><a href="#redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6">Redis内存回收</a><ul><li><a href="#%E5%86%85%E5%AD%98%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5">内存过期策略</a></li><li><a href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">内存淘汰策略</a></li></ul></li><li><a href="#redis%E7%BC%93%E5%AD%98">Redis缓存</a><ul><li><a href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7">缓存一致性</a></li><li><a href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">缓存穿透</a></li><li><a href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">缓存雪崩</a></li><li><a href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">缓存击穿</a></li></ul></li></ul></li></ul><!-- /TOC --><h2 id="springboot的启动流程"><a class="markdownIt-Anchor" href="#springboot的启动流程"></a> SpringBoot的启动流程</h2><p>SpringBoot的启动，其本质就是加载各种配置信息，然后初始化IOC容器并返回</p><p>首先，当我们在启动类执行SpringApplication.run这行代码的时候，在它的方法内部其实会做两个事情：</p><ul><li>创建SpringApplication对象；</li><li>执行run方法。</li></ul><p>在创建SpringApplication对象的时候，在它的构造方法内部主要做3个事情：</p><ul><li>确认web应用类型，一般情况下是Servlet类型，这种类型的应用，将来会自动启动一个tomcat</li><li>从spring.factories配置文件中，加载默认的ApplicationContextInitializer和ApplicationListener</li><li>记录当前应用的主启动类，将来做包扫描使用</li></ul><p>对象创建好了以后，再调用该对象的run方法，在run方法的内部主要做4个事情：</p><ul><li>准备Environment对象，它里面会封装一些当前应用运行环境的参数，比如环境变量等等</li><li>实例化容器，这里仅仅是创建ApplicationContext对象</li><li>容器创建好了以后，会为容器做一些准备工作，比如为容器设置Environment、BeanFactoryPostProcessor后置处理器，并且加载主类对应的Definition</li><li>刷新容器，就是我们常说的refresh，在这里会真正的创建Bean实例</li></ul><p>总结下来，SpringBoot启动的时候核心就两步，创建SpringApplication对象以及run方法的调用，在run方法中会真正的实例化容器，并创建容器中需要的Bean实例，最终返回</p><h2 id="spring-ioc"><a class="markdownIt-Anchor" href="#spring-ioc"></a> Spring IOC</h2><h3 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h3><p>IoC （Inversion of Control ）即控制反转/反转控制。它是一种思想不是一个技术实现。描述的是：Java 开发领域对象的创建以及管理的问题。</p><ul><li>传统的开发方式 ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来使用</li><li>IoC 思想的开发方式 ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面去取即可。</li><li>控制 ：指的是对象创建（实例化、管理）的权力</li><li>反转 ：控制权交给外部环境（IoC 容器）<br /><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/IoC&amp;Aop-ioc-illustration.png" alt="" /></li></ul><h3 id="ioc解决了什么问题"><a class="markdownIt-Anchor" href="#ioc解决了什么问题"></a> IOC解决了什么问题？</h3><p>IoC 的思想就是两方之间不互相依赖，由第三方容器来管理相关资源。这样有什么好处呢？</p><ul><li>对象之间的耦合度或者说依赖程度降低；</li><li>资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。</li></ul><blockquote><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p></blockquote><h3 id="ioc容器的初始化"><a class="markdownIt-Anchor" href="#ioc容器的初始化"></a> IOC容器的初始化</h3><p>IOC容器初始化，核心步骤主要是在<code>AbstractApplicationContext</code>类中的<code>refresh</code>方法中完成的：</p><ul><li>准备BeanFactory，在这一块需要给BeanFactory设置很多属性，比如类加载器、Environment等</li><li>执行BeanFactory后置处理器，这一阶段会扫描要放入到容器中的Bean信息，得到对应的BeanDefinition（注意，这里只扫描，不创建）</li><li>注册BeanPostProcessor，我们自定义的BeanPostProcessor就是在这一阶段被加载的，将来Bean对象实例化好后需要用到</li><li>启动tomcat</li><li>实例化容器中实例化非懒加载的单例Bean，这里需要说的是，多例Bean和懒加载的Bean不会在这个阶段实例化，将来用到的时候再创建</li><li>当容器初始化完毕后，再做一些收尾工作，比如清除缓存等</li></ul><p>总结一下就是，在IOC容器初始化的过程中，首先得准备并执行BeanFactory后置处理器，其次得注册Bean后置处理器，并启动tomcat，最后需要借助于BeanFactory完成Bean的实例化</p><h2 id="spring-bean"><a class="markdownIt-Anchor" href="#spring-bean"></a> Spring Bean</h2><h3 id="什么是spring-beancomponent-和-bean-的区别是什么"><a class="markdownIt-Anchor" href="#什么是spring-beancomponent-和-bean-的区别是什么"></a> 什么是Spring Bean？@Component 和 @Bean 的区别是什么？</h3><p>Bean 代指的就是那些被 IoC 容器所管理的对象。</p><ul><li>@Component 注解作用于类，而@Bean注解作用于方法。</li><li>@Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（SpringBoot默认只能扫描到启动类所在的包及其子包，我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。</li><li>@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean, @Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</li></ul><h3 id="将一个类声明为-bean-的注解有哪些"><a class="markdownIt-Anchor" href="#将一个类声明为-bean-的注解有哪些"></a> 将一个类声明为 Bean 的注解有哪些?</h3><ul><li>@Component：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。</li><li>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li>@Controller : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h3 id="bean生命周期"><a class="markdownIt-Anchor" href="#bean生命周期"></a> Bean生命周期</h3><p>Bean的生命周期总的来说有4个阶段，分别有创建对象、初始化对象、使用对象以及销毁对象，而且这些工作大部分是交给Bean工厂的doCreateBean方法完成的。</p><ul><li><p>在创建对象阶段，先调用构造方法实例化对象，对象有了后会填充该对象的内容，其实就是处理依赖注入。</p></li><li><p>对象创建完毕后，需要做一些初始化的操作，在这里涉及到几个扩展点。</p><ul><li>执行Aware感知接口的回调方法</li><li>执行Bean后置处理器的postProcessBeforeInitialization方法</li><li>执行InitializingBean接口的回调，在这一步如果Bean中有标注了@PostConstruct注解的方法，会先执行它</li><li>执行Bean后置处理器的postProcessAfterInitialization</li><li>把这些扩展点都执行完，Bean的初始化就完成了。</li></ul></li><li><p>在使用阶段就是程序员从容器中获取该Bean使用即可。</p></li><li><p>在容器销毁之前，会先销毁对象，此时会执行DisposableBean接口的回调，这一步如果Bean中有标注了@PreDestroy接口的函数，会先执行它。</p></li></ul><p>简单总结一下，Bean的生命周期共包含四个阶段，其中初始化对象和销毁对象我们程序员可以通过一些扩展点执行自己的代码。</p><h3 id="bean的循环依赖"><a class="markdownIt-Anchor" href="#bean的循环依赖"></a> Bean的循环依赖</h3><p>Bean的循环依赖指的是A依赖B，B又依赖A这样的依赖闭环问题。</p><p>在Spring中，通过三个对象缓存区来解决循环依赖问题，这三个缓存区被定义到了DefaultSingletonBeanRegistry中，分别是singletonObjects用来存储创建完毕的Bean，earlySingletonObjects用来存储未完成依赖注入的Bean，还有SingletonFactories用来存储创建Bean的ObjectFactory。假如说现在A依赖B，B依赖A，整个Bean的创建过程是这样的</p><ul><li><p>首先，调用A的构造方法实例化A，当前的A还没有处理依赖注入，暂且把它称为半成品，此时会把半成品A封装到一个ObjectFactory中，并存储到SingletonFactories缓存区。</p></li><li><p>接下来，要处理A的依赖注入了，由于此时还没有B，所以得先实例化一个B，同样的，半成品B也会被封装到ObjectFactory中，并存储到SingletonFactories缓存区。</p></li><li><p>紧接着，要处理B的依赖注入了，此时会找到SingletonFactories中A对应的ObjectFactory，调用它的getObject方法得到刚才实例化的半成品A（如果需要代理对象，则会自动创建代理对象，将来得到的就是代理对象），把得到的半成品A注入给B，并同时会把半成品A存入到earlySingletonObjects中，将来如果还有其他的类循环依赖了A，就可以直接从earlySingletonObjects中找到它了，那么此时SingletonFactories中创建A的ObjectFactory也可以删除了。</p></li><li><p>至此，B的依赖注入处理完了后，B就创建完毕了，就可以把B的对象存入到singletonObjects中了，并同时删除掉SingletonFactories中创建B的ObjectFactory。</p></li><li><p>B创建完毕后，就可以继续处理A的依赖注入了，把B注入给A，此时A也创建完毕了，就可以把A的对象存储到singletonObjects中，并同时删除掉earlySingletonObjects中的半成品A。</p></li><li><p>至此，A和B对象全部创建完毕，并存储到了singletonObjects中，将来通过容器获取对象，都是从singletonObjects中获取。</p></li></ul><p>总结起来还是一句话，借助于DefaultSingletonBeanRegistry的三个缓存区singletonObjects、earlySingletonObjects、singletonFactories可以解决循环依赖问题。</p><h2 id="springmvc"><a class="markdownIt-Anchor" href="#springmvc"></a> SpringMVC</h2><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。<br />Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p><h3 id="springmvc关键组件"><a class="markdownIt-Anchor" href="#springmvc关键组件"></a> SpringMVC关键组件</h3><ul><li>DispatcherServlet：核心的中央处理器，负责接收请求、分发，并给予客户端响应。</li><li>HandlerMapping：处理器映射器，根据 URL 去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。</li><li>HandlerAdapter：处理器适配器，根据 HandlerMapping 找到的 Handler ，适配执行对应的 Handler；</li><li>Handler：请求处理器，处理实际请求的处理器。</li><li>ViewResolver：视图解析器，根据 Handler 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 DispatcherServlet 响应客户端</li></ul><h3 id="springmvc执行流程"><a class="markdownIt-Anchor" href="#springmvc执行流程"></a> SpringMVC执行流程</h3><ul><li>客户端（浏览器）发送请求， DispatcherServlet拦截请求。</li><li>DispatcherServlet 根据请求信息调用 HandlerMapping 。</li><li>HandlerMapping 根据 URL 去匹配查找能处理的 Handler（也就是我们平常说的 Controller 控制器） ，并会将请求涉及到的拦截器和 Handler 一起封装。</li><li>DispatcherServlet 调用 HandlerAdapter适配器执行 Handler 。</li><li>Handler 完成对用户请求的处理后，会返回一个 ModelAndView 对象给DispatcherServlet，ModelAndView 顾名思义，包含了数据模型以及相应的视图的信息。Model 是返回的数据对象，View 是个逻辑上的 View。</li><li>ViewResolver 会根据逻辑 View 查找实际的 View。</li><li>DispaterServlet 把返回的 Model 传给 View（视图渲染）。</li><li>把 View 返回给请求者（浏览器）</li></ul><h3 id="统一异常处理怎么做"><a class="markdownIt-Anchor" href="#统一异常处理怎么做"></a> 统一异常处理怎么做？</h3><ul><li>定义一个响应的实体类，用来封装异常信息</li><li>定义一个异常处理类，使用<code>@RestControllerAdvice + @ExceptionHandler</code>注解，被@ExceptionHandler注解修饰的方法处理异常。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-keyword">public</span> Result handleException(Exception e)&#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span> Result.error(StringUtils.hasLength(e.getMessage()) ? e.getMessage(): <span class="hljs-string">&quot;操作失败&quot;</span> );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="springboot的依赖注入"><a class="markdownIt-Anchor" href="#springboot的依赖注入"></a> springboot的依赖注入</h2><blockquote><p>依赖注入允许对象在需要使用其他对象时，不用自己去创建，而是由 Spring 框架负责提供这些对象（依赖）。这不仅提高了代码的可测试性，还简化了对象之间的依赖关系管理。</p></blockquote><p>springboot中，依赖注入主要有三种方式。</p><h3 id="构造函数注入"><a class="markdownIt-Anchor" href="#构造函数注入"></a> 构造函数注入</h3><p>构造器注入是通过类的构造函数将依赖传入。在实例化对象时，依赖会通过构造器传递进来。这种方式<strong>最推荐</strong>，原因是它确保了依赖在对象创建时被正确地初始化，并且使对象变得不可变（immutable）。</p><p>常见的用法是：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DependencyService dependencyService;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>@RequiredArgsConstructor</code>注解由lombok提供，作用是为<code>final</code>修饰的成员变量(依赖)自动生成一个构造器，避免手动编写代码。</p><p>优点：</p><ul><li>保证依赖不可变。</li><li>提高了可测试性，便于使用构造器参数进行单元测试。</li><li>强制依赖的存在，避免空指针异常。</li></ul><h3 id="setter方法注入"><a class="markdownIt-Anchor" href="#setter方法注入"></a> setter方法注入</h3><p>Setter方法注入通过 setter 方法将依赖注入到类中。Spring 在实例化对象后，会调用这些 setter 方法进行注入。这种方式适用于依赖是可选项或在运行时需要灵活设置的情况。</p><p>一般用法是：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">DependencyService</span> dependencyService;<br><br>    <span class="hljs-comment">// Setter方法注入</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setDependencyService</span>(<span class="hljs-params">DependencyService dependencyService</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dependencyService</span> = dependencyService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>灵活性高，可以在运行时动态注入</li><li>适合可选的依赖或需要后期修改的依赖<br />缺点：</li><li>依赖对象可能未初始化便被调用，可能导致空指针异常</li><li>类的状态可变</li></ul><h3 id="字段注入"><a class="markdownIt-Anchor" href="#字段注入"></a> 字段注入</h3><p>字段注入直接在类的成员变量上使用 @Autowired 注解进行依赖注入，是最简单的方式。</p><p>一般用法是：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-variable">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">DependencyService</span> dependencyService;<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>代码简单，注入逻辑隐式完成</li></ul><p>缺点：</p><ul><li>不利于单元测试，无法通过构造器或 setter 模拟依赖。</li><li>类的可维护性降低，依赖关系不明显，可能导致隐式的错误。</li></ul><h2 id="springboot3自动配置原理"><a class="markdownIt-Anchor" href="#springboot3自动配置原理"></a> springboot3自动配置原理</h2><h3 id="主要步骤"><a class="markdownIt-Anchor" href="#主要步骤"></a> 主要步骤</h3><ul><li><p>主启动类中，通常使用<code>@SpringBootApplication</code>注解，这个注解是一个组合注解，它包含了<code>@EnableAutoConfiguration</code>注解。</p></li><li><p><code>@EnableAutoConfiguration</code>注解中，通过<code>@Import</code>导入自动配置模块的导入选择器<code>AutoConfigurationImportSelector</code>，它的作用是在启动时扫描指定包路径下的所有自动配置类，并根据应用程序的依赖关系和环境变量等信息，自动地选择需要引入的自动配置类，并将其注册为 Bean</p></li><li><p><code>AutoConfigurationImportSelector</code>导入选择器中实现了selectImports方法，这个方法经过多层调用，最终在<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件中扫描候选的配置类，springboot2.7以前的版本是在<code>META-INF/spring.factories</code>文件中</p></li><li><p>通过自动配置类使用条件注解（如 <code>@ConditionalOnClass、@ConditionalOnBean、@ConditionalOnProperty</code> 等）来确保只有满足特定条件的Bean才能被注册。</p></li></ul><h3 id="使用示例"><a class="markdownIt-Anchor" href="#使用示例"></a> 使用示例</h3><ul><li>编写配置类</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">ThirdPartyConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MyService myService() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">MyService</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编写自动配置类，使用<code>@AutoConfiguration</code>注解，通过<code>@Import</code>导入所需要的自动配置类</li></ul><p><strong>注意</strong>：直接在配置类上使用<code>@AutoConfiguration</code>作为自动配置类，不额外创建一个自动配置类也是可以的</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AutoConfiguration</span><br><span class="hljs-variable">@Import</span>(ThirdPartyConfig.class)<br>public class MyAutoConfiguration &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件中添加自动配置类的全类名</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.config</span>.MyAutoConfiguration<br></code></pre></td></tr></table></figure><ul><li>在pom文件中引入坐标，就可以通过依赖注入使用Bean了</li></ul><h2 id="自定义starter"><a class="markdownIt-Anchor" href="#自定义starter"></a> 自定义starter</h2><h3 id="什么是springboot-starter"><a class="markdownIt-Anchor" href="#什么是springboot-starter"></a> 什么是springboot starter</h3><p>Spring Boot Starter 是 Spring Boot 提供的一系列依赖管理工具，旨在简化 Spring 应用程序的设置和配置。每个 Starter 都是一个预配置的依赖集合，包含了开发特定类型应用程序所需的所有依赖项和配置。</p><h3 id="如何创建自定义starter"><a class="markdownIt-Anchor" href="#如何创建自定义starter"></a> 如何创建自定义starter</h3><p>熟悉自动配置之后，自定义starter的步骤其实很简单，只有两步：</p><ul><li>首先，创建一个模块，提供自动配置功能，即该模块包含自动配置类(定义了自动配置类并在<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>中声明)</li><li>创建另一个模块作为starter，在pom文件中引入上面的自定义自动配置类模块的坐标</li></ul><h2 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h2><h3 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h3><p>定义一个创建对象的接口，但由子类决定实例化哪个类。Spring 使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。<br />两者对比：</p><ul><li>BeanFactory：延迟注入(使用到某个 bean 的时候才会注入),相比于ApplicationContext 来说会占用更少的内存，程序启动速度更快。</li><li>ApplicationContext：容器启动的时候，不管你用没用到，一次性创建所有 bean 。BeanFactory 仅提供了最基本的依赖注入支持，ApplicationContext 扩展了 BeanFactory ,除了有BeanFactory的功能还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。</li></ul><h3 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。<br />使用单例模式的好处 :</p><ul><li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><h3 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h3><p>为其他对象提供一种代理以控制对这个对象的访问。有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，这时候我们可以提供一个代理对象来控制对这个对象的访问。</p><h3 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式"></a> 适配器模式</h3><p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br />主要解决在软件系统中，常常要将一些&quot;现存的对象&quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><h3 id="代理模式和适配器模式的区别"><a class="markdownIt-Anchor" href="#代理模式和适配器模式的区别"></a> 代理模式和适配器模式的区别？</h3><ul><li>目的不同：代理模式主要关注对象的访问，适配器模式主要关注接口的转换，使不兼容的接口可以一起工作。</li><li>结构不同：代理模式一般包含抽象主题、真实主题、代理主题三个角色，适配器模式一般包含目标接口、适配器、被适配者三个角色。</li><li>应用场景不同：代理模式常用于通过代理控制对象的访问，适配器模式用于让不兼容的接口协同工作。</li></ul><h2 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h2><h3 id="什么是redis"><a class="markdownIt-Anchor" href="#什么是redis"></a> 什么是Redis?</h3><p>Redis （REmote DIctionary Server）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p><h3 id="redis为什么快"><a class="markdownIt-Anchor" href="#redis为什么快"></a> Redis为什么快？</h3><ul><li>Redis 内部做了非常多的性能优化，比较重要的有：</li><li>Redis 基于内存，内存的访问速度比磁盘快很多；</li><li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</li><li>Redis 内置了多种优化过后的数据类型/结构实现，性能非常高。</li><li>Redis 通信协议实现简单且解析高效。</li></ul><h2 id="jwt令牌"><a class="markdownIt-Anchor" href="#jwt令牌"></a> JWT令牌</h2><p>JWT全称为Json Web Token，定义了一种简洁的、自包含的格式，用于通信双方以json数据格式安全的传输信息。其形式是一个很长的字符串，中间用点<code>.</code>分隔成三个部分。这些字符串由JSON对象使用Base64URL算法转换得到。<br />分别是：</p><ul><li>头部(Header)，记录令牌类型，加密算法等，如<code>&#123;&quot;alg&quot;: &quot;HS256&quot;,&quot;typ&quot;: &quot;JWT&quot;&#125;</code></li><li>载荷(Payload)，包括默认信息和自定义信息，如可添加自定义信息<code>&#123;&quot;id&quot;:&quot;1&quot;, &quot;name&quot;:&quot;tom&quot;&#125;</code></li><li>签名(Signature)，防止JWT被篡改。需要指定一个密钥(secret)。这个密钥只有服务器才知道，不能泄露给用户。然后，使用Header里面指定的签名算法(默认是 HMAC SHA256)，按照下面的公式产生签名。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">HMACSHA256</span><span class="hljs-params">( base64UrlEncode(header)</span></span> + <span class="hljs-string">&quot;.”&quot;</span>+<span class="hljs-built_in">base64UrlEncode</span>(payload), secret)<br></code></pre></td></tr></table></figure><ul><li>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&quot;点&quot;(.)分隔，就可以返回给用户。</li></ul><p>以下是利用hutool工具封装的创建和解析JWT令牌的类:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtTool</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JWTSigner jwtSigner;<br><br>    <span class="hljs-keyword">public</span> JwtTool(KeyPair keyPair) &#123;<br>        <span class="hljs-built_in">this</span>.jwtSigner = JWTSignerUtil.createSigner(<span class="hljs-string">&quot;rs256&quot;</span>, keyPair);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建 access-token</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param userDTO 用户信息</span><br><span class="hljs-comment">     * @return access-token</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> createToken(Long userId, Duration ttl) &#123;<br>        <span class="hljs-comment">// 1.生成jws</span><br>        <span class="hljs-keyword">return</span> JWT.create()<br>                .setPayload(<span class="hljs-string">&quot;user&quot;</span>, userId)<br>                .setExpiresAt(<span class="hljs-keyword">new</span> <span class="hljs-type">Date</span>(System.currentTimeMillis() + ttl.toMillis()))<br>                .setSigner(jwtSigner)<br>                .sign();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析token</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param token token</span><br><span class="hljs-comment">     * @return 解析刷新token得到的用户信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Long parseToken(<span class="hljs-keyword">String</span> token) &#123;<br>        <span class="hljs-comment">// 1.校验token是否为空</span><br>        <span class="hljs-keyword">if</span> (token == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UnauthorizedException</span>(<span class="hljs-string">&quot;未登录&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 2.校验并解析jwt</span><br>        JWT jwt;<br>        <span class="hljs-keyword">try</span> &#123;<br>            jwt = JWT.of(token).setSigner(jwtSigner);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UnauthorizedException</span>(<span class="hljs-string">&quot;无效的token&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-comment">// 2.校验jwt是否有效</span><br>        <span class="hljs-keyword">if</span> (!jwt.verify()) &#123;<br>            <span class="hljs-comment">// 验证失败</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UnauthorizedException</span>(<span class="hljs-string">&quot;无效的token&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 3.校验是否过期</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            JWTValidator.of(jwt).validateDate();<br>        &#125; <span class="hljs-keyword">catch</span> (ValidateException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UnauthorizedException</span>(<span class="hljs-string">&quot;token已经过期&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 4.数据格式校验</span><br>        Object userPayload = jwt.getPayload(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-keyword">if</span> (userPayload == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 数据为空</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UnauthorizedException</span>(<span class="hljs-string">&quot;无效的token&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 5.数据解析</span><br>        <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">return</span> Long.valueOf(userPayload.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>            <span class="hljs-comment">// 数据格式有误</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UnauthorizedException</span>(<span class="hljs-string">&quot;无效的token&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring 在创建 JwtTool 的实例时(自动注入JwtTool时)，会自动提供一个 KeyPair 实例(KeyPair在配置类中被注册成Bean)，所以使用该工具类时，直接注入，然后调用ceate或者parse方法即可，例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JwtTool jwtTool;<br><span class="hljs-type">String</span> token = jwtTool.<span class="hljs-built_in">createToken</span>(user.<span class="hljs-built_in">getId</span>(), jwtProperties.<span class="hljs-built_in">getTokenTTL</span>());<br></code></pre></td></tr></table></figure><h2 id="threadlocal"><a class="markdownIt-Anchor" href="#threadlocal"></a> ThreadLocal</h2><p>ThreadLoal 变量，线程局部变量<br />ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p><blockquote><p>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。如同一个用户进行不同的请求。</p></blockquote><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><ul><li>线程隔离：每个线程都拥有自己的变量副本，线程之间的变量副本互不影响，从而避免了多线程操作共享资源造成的数据不一致问题。</li><li>线程安全：由于每个线程只能访问自己的变量副本，因此不需要额外的同步机制来保证线程安全。</li><li>减少参数传递：在复杂的业务逻辑中，使用ThreadLocal可以避免在多个方法之间频繁传递参数，从而简化代码。</li></ul><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><p>ThreadLocal的工具类模板：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final ThreadLocal THREAD_LOCAL = <span class="hljs-keyword">new</span> ThreadLocal();<br><br>    <span class="hljs-comment">//    按键获取数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">get</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> (T) THREAD_LOCAL.<span class="hljs-keyword">get</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//    存储数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span>(<span class="hljs-params">Object <span class="hljs-keyword">value</span></span>)</span> &#123;<br>        THREAD_LOCAL.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">value</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//    清除线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span>()</span> &#123;<br>        THREAD_LOCAL.<span class="hljs-keyword">remove</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拦截器"><a class="markdownIt-Anchor" href="#拦截器"></a> 拦截器</h2><p>拦截器（Interceptor）是一种特殊的组件，它可以在请求处理的过程中对请求和响应进行拦截和处理。拦截器可以在请求到达目标处理器之前、处理器处理请求之后以及视图渲染之前执行特定的操作。拦截器的主要目的是在不修改原有代码的情况下，实现对请求和响应的统一处理。</p><h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3><ul><li>权限控制：拦截器可以在请求到达处理器之前进行权限验证，从而实现对不同用户的访问控制。</li><li>日志记录：拦截器可以在请求处理过程中记录请求和响应的详细信息，便于后期分析和调试。</li><li>接口幂等性校验：拦截器可以在请求到达处理器之前进行幂等性校验，防止重复提交。</li><li>数据校验：拦截器可以在请求到达处理器之前对请求数据进行校验，确保数据的合法性。</li><li>缓存处理：拦截器可以在请求处理之后对响应数据进行缓存，提高系统性能。</li></ul><h3 id="拦截器与过滤器的区别"><a class="markdownIt-Anchor" href="#拦截器与过滤器的区别"></a> 拦截器与过滤器的区别</h3><ul><li>执行顺序：过滤器在拦截器之前执行，拦截器在处理器之前执行。</li><li>功能范围：过滤器可以对所有请求进行拦截，而拦截器只能对特定的请求进行拦截。</li><li>生命周期：过滤器由Servlet容器管理，拦截器由Spring容器管理。</li><li>使用场景：过滤器适用于对请求和响应的全局处理，拦截器适用于对特定请求的处理。</li></ul><h3 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h3><ol><li>在SpringBoot中实现拦截器，首先需要创建一个类并实现HandlerInterceptor接口。HandlerInterceptor接口包含以下三个方法：<ul><li>preHandle：在请求到达处理器之前执行，可以用于权限验证、数据校验等操作。如果返回true，则继续执行后续操作；如果返回false，则中断请求处理。</li><li>postHandle：在处理器处理请求之后执行，可以用于日志记录、缓存处理等操作。</li><li>afterCompletion：在视图渲染之后执行，可以用于资源清理等操作。<br />以登录认证为例，代码如下：</li></ul></li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginInterceptor</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">HandlerInterceptor</span></span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;<br>        <span class="hljs-keyword">String</span> token = request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>        <span class="hljs-comment">//        验证token</span><br>        <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//            从redis中获取token</span><br>            ValueOperations&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; ops = redisTemplate.opsForValue();<br>            <span class="hljs-keyword">String</span> redisToken = ops.<span class="hljs-keyword">get</span>(token);<br>            <span class="hljs-keyword">if</span>(redisToken==<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!redisToken.equals(token))&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>();<br>            &#125;<br>            Map&lt;<span class="hljs-keyword">String</span>, Object&gt; claims = JwtUtil.parseToken(token);<br><span class="hljs-comment">//            把用户信息存到threadlocal中</span><br>            ThreadLocalUtil.<span class="hljs-keyword">set</span>(claims);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;<br>        ThreadLocalUtil.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建一个配置类，实现WebMvcConfigurer接口，注册拦截器到InterceptorRegistry，并设置拦截规则<br />以登录认证为例，代码如下：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">LoginInterceptor</span> loginInterceptor;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addInterceptors</span>(<span class="hljs-params">InterceptorRegistry registry</span>) &#123;<br><br><span class="hljs-comment">//        拦截除了登录和注册的其他请求</span><br>        registry.<span class="hljs-title function_">addInterceptor</span>(loginInterceptor).<span class="hljs-title function_">excludePathPatterns</span>(<span class="hljs-string">&quot;/user/login&quot;</span>,<span class="hljs-string">&quot;/user/register&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拦截器的执行顺序"><a class="markdownIt-Anchor" href="#拦截器的执行顺序"></a> 拦截器的执行顺序</h3><p>当有多个拦截器时，它们的执行顺序取决于注册顺序。先注册的拦截器先执行，后注册的拦截器后执行。在请求处理过程中，拦截器的preHandle方法按注册顺序执行，而postHandle和afterCompletion方法按注册顺序的逆序执行。</p><p>当有多个拦截器时，它们的执行流程如下：</p><ul><li>执行所有拦截器的preHandle方法，按注册顺序执行。如果某个拦截器的preHandle方法返回false，则中断请求处理，直接执行已执行拦截器的afterCompletion方法。</li><li>执行处理器的处理方法。</li><li>执行所有拦截器的postHandle方法，按注册顺序的逆序执行。</li><li>渲染视图。</li><li>执行所有拦截器的afterCompletion方法，按注册顺序的逆序执行。</li></ul><h2 id="controller中的方法接收参数注解"><a class="markdownIt-Anchor" href="#controller中的方法接收参数注解"></a> Controller中的方法接收参数注解</h2><h3 id="requestparam"><a class="markdownIt-Anchor" href="#requestparam"></a> @RequestParam</h3><p>用于将HTTP请求参数绑定到控制器的方法参数上。如果请求参数不存在，可以指定一个默认值。这个注解主要用于处理请求中的<strong>查询参数（即URL中<code>?</code>后面的部分）</strong>，使得你可以轻松地从请求中获取这些参数的值。</p><p>示例：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/greeting&quot;</span>)  <br>public String <span class="hljs-built_in">greeting</span>(<span class="hljs-variable">@RequestParam</span>(value = <span class="hljs-string">&quot;name&quot;</span>, defaultValue = <span class="hljs-string">&quot;World&quot;</span>) String name) &#123;  <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">String</span><span class="hljs-selector-class">.format</span>(<span class="hljs-string">&quot;Hello, %s!&quot;</span>, name);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pathvariable"><a class="markdownIt-Anchor" href="#pathvariable"></a> @PathVariable</h3><p>用于将URL模板变量值绑定到控制器处理方法的参数上。<br />这个注解使得你可以<strong>从URL的路径中提取变量值</strong>，这在构建RESTful API时非常有用。</p><p>示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/user/&#123;id&#125;&quot;</span>)</span>  <br><span class="hljs-keyword">public</span> String getUserById(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> id) &#123;  <br>    <span class="hljs-comment">// 根据id获取用户信息  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User ID is: &quot;</span> + id;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="requestbody"><a class="markdownIt-Anchor" href="#requestbody"></a> @RequestBody</h3><p>用于处理HTTP请求的内容体（Body），<strong>将请求体中的数据绑定到Java对象</strong>上。</p><p>这个注解<strong>通常用于处理POST和PUT请求</strong>，特别是当请求的内容类型为application/json或application/xml时。它允许你直接将请求体中的数据映射到Java对象上，便于后续处理</p><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/cookie&quot;</span>)  <br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">readCookie</span>(<span class="hljs-params"><span class="hljs-meta">@CookieValue</span>(name = <span class="hljs-string">&quot;theme&quot;</span>, defaultValue = <span class="hljs-string">&quot;default&quot;</span>) <span class="hljs-built_in">String</span> theme</span>) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Theme is: &quot;</span> + theme;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cookievalue"><a class="markdownIt-Anchor" href="#cookievalue"></a> @CookieValue</h3><p>用于<strong>将请求的Cookie数据绑定到控制器方法的参数</strong>上。</p><p>这个注解允许你访问HTTP请求中的Cookie信息，这在<strong>处理需要身份验证或会话管理的Web应用</strong>时非常有用。</p><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/cookie&quot;</span>)  <br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">readCookie</span>(<span class="hljs-params"><span class="hljs-meta">@CookieValue</span>(name = <span class="hljs-string">&quot;theme&quot;</span>, defaultValue = <span class="hljs-string">&quot;default&quot;</span>) <span class="hljs-built_in">String</span> theme</span>) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Theme is: &quot;</span> + theme;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="requestheader"><a class="markdownIt-Anchor" href="#requestheader"></a> @RequestHeader</h3><p>用于<strong>将HTTP请求头信息绑定到控制器方法的参数</strong>上。</p><p>这个注解<strong>允许你访问HTTP请求中的头部信息</strong>，比如User-Agent、Content-Type等，这对于日志记录、内容协商等场景非常有用。</p><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/header&quot;</span>)  <br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">readHeader</span>(<span class="hljs-params"><span class="hljs-meta">@RequestHeader</span>(name = <span class="hljs-string">&quot;User-Agent&quot;</span>, defaultValue = <span class="hljs-string">&quot;Unknown&quot;</span>) <span class="hljs-built_in">String</span> userAgent</span>) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User-Agent header is: &quot;</span> + userAgent;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="modelattribute"><a class="markdownIt-Anchor" href="#modelattribute"></a> @ModelAttribute</h3><p>用于<strong>将请求参数绑定到JavaBean上</strong>，也可以用在方法上，表示该方法的返回值应该添加到模型（Model）中。</p><p>这个注解主要用于处理表单数据，它可以将请求中的参数自动绑定到一个或多个JavaBean上，便于后续处理。</p><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/addUser&quot;</span>)  <br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">addUser</span>(<span class="hljs-params"><span class="hljs-meta">@ModelAttribute</span> User user</span>) &#123;  <br>    <span class="hljs-comment">// 处理user对象  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User added successfully&quot;</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参数校验"><a class="markdownIt-Anchor" href="#参数校验"></a> 参数校验</h2><p>一般对于提交的表单要进行参数校验，主要步骤如下：</p><h3 id="常用注解"><a class="markdownIt-Anchor" href="#常用注解"></a> 常用注解</h3><p>可以通过注解给对象的每个属性设置校验规则，常见的注解有</p><ul><li>@NotEmpty：检查集合或数组等对象是否为 null 或空。该注解通常用于检查字符串是否为空，集合是否为空等情况。</li><li>@NotBlank：检查字符串是否不为空，并且去除首尾空格后长度大于 0。该注解通常用于检查用户输入的字符串是否为有效值。</li><li>@NotNull：检查对象(包装类：Integer、Boolean等)是否不为 null。该注解通常用于检查对象是否已经被初始化。</li><li>Size(max,min)：检查该字段的size是否在min和max之间，可以是字符串、数组、集合、Map等</li><li>@Pattern(regexp = “[abc]”)：被注释的元素必须符合指定的正则表达式</li><li>@Email：被注释的元素必须是电子邮件地址</li><li>@URL：被注释的元素必须是URL地址</li></ul><p>示例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> jakarta.validation.constraints.*;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author mijiupro</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UserLoginDTO</span> </span>&#123;<br>    <span class="hljs-meta">@NotBlank</span>(message = <span class="hljs-string">&quot;账号不能为空&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> userAccount;<span class="hljs-comment">// 用户账号</span><br>    <span class="hljs-meta">@Size</span>(min = <span class="hljs-number">6</span>, max = <span class="hljs-number">18</span>, message = <span class="hljs-string">&quot;用户密码长度需在6-18位&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> password;<span class="hljs-comment">// 密码</span><br>    <span class="hljs-meta">@NotBlank</span>(message = <span class="hljs-string">&quot;验证码id不能为空&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> captchaId;<span class="hljs-comment">// 验证码id</span><br>    <span class="hljs-meta">@NotBlank</span>(message = <span class="hljs-string">&quot;验证码内容不能为空&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> captcha;<span class="hljs-comment">// 验证码内容</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="开启参数校验"><a class="markdownIt-Anchor" href="#开启参数校验"></a> 开启参数校验</h3><p>通常在控制层进行参数校验，通过对请求参数使用@Validated注解或者@Valid注解来启用校验。</p><p>示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;/user&quot;</span>)</span><br><span class="hljs-meta">@Tag(name = <span class="hljs-string">&quot;用户管理&quot;</span>, description = <span class="hljs-string">&quot;用户管理&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserService userService;<br> <br>    <span class="hljs-keyword">public</span> UserController(UserService userService) &#123;<br>        <span class="hljs-keyword">this</span>.userService = userService;<br>    &#125;<br> <br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/login&quot;</span>)</span><br>    <span class="hljs-meta">@Operation(summary = <span class="hljs-string">&quot;用户登录&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> UserLoginVO login(<span class="hljs-meta">@RequestBody</span> <span class="hljs-meta">@Validated</span> UserLoginDTO userLoginDTO) &#123;<br>        <span class="hljs-keyword">return</span> userService.login(userLoginDTO);<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="validated和valid区别"><a class="markdownIt-Anchor" href="#validated和valid区别"></a> @Validated和@Valid区别</h3><ul><li>@Validated注解是 Spring 框架提供的，主要用于在 Spring MVC 中对控制器的方法参数进行校验。</li><li>@Valid注解是 Java 标准库提供的，用于在任何地方触发参数校验，包括 Spring MVC 的控制器方法、Spring Boot 的 REST 控制器方法、Spring Data JPA 的实体类等。</li></ul><blockquote><p>在spring boot推荐用@Validated注解，因为它能够支持 Spring 提供的校验注解，并且具有更好的集成性。</p></blockquote><h2 id="自定义参数校验"><a class="markdownIt-Anchor" href="#自定义参数校验"></a> 自定义参数校验</h2><p>已有的参数校验注解不能覆盖所有特殊情况，比如发布状态state要求必须是草稿或已发布状态，因此需要自定义校验规则。</p><h3 id="自定义state注解"><a class="markdownIt-Anchor" href="#自定义state注解"></a> 自定义State注解</h3><p>需要实现State接口</p><p>代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Documented</span>//元注解<br><span class="hljs-keyword">@Target</span>(&#123;FIELD&#125;)<span class="hljs-comment">//元注解</span><br><span class="hljs-keyword">@Retention</span>(RUNTIME)//元注解<br><span class="hljs-keyword">@Constraint</span>(validatedBy = &#123;StateValidation<span class="hljs-selector-class">.class</span>&#125;)<span class="hljs-comment">//指定提供校验规则的类</span><br>public <span class="hljs-keyword">@interface</span> State &#123;<br>    <span class="hljs-comment">//提供校验失败后的提示信息</span><br>    String <span class="hljs-built_in">message</span>() default &quot;state参数的值只能是已发布或者草稿&quot;;<br>    <span class="hljs-comment">//指定分组</span><br>    Class&lt;?&gt;<span class="hljs-selector-attr">[]</span> <span class="hljs-built_in">groups</span>() default &#123; &#125;;<br>    <span class="hljs-comment">//负载  获取到State注解的附加信息</span><br>    Class&lt;? extends Payload&gt;<span class="hljs-selector-attr">[]</span> <span class="hljs-built_in">payload</span>() default &#123; &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>@Documented: 这是一个元注解，用于指示该注解应该被包含在文档中</li><li>@Target({FIELD}): 这也是一个元注解，指定了该注解可以应用在字段上</li><li>@Retention(RUNTIME): 这是一个元注解，指定了该注解应该在运行时保留，以便在运行时可以通过反射获取注解信息。</li><li>@Constraint(validatedBy = {StateValidation.class}): 这是一个约束注解，用于指定提供校验规则的类，即 StateValidation 类(自定义的)</li></ul><h3 id="自定义校验规则的类"><a class="markdownIt-Anchor" href="#自定义校验规则的类"></a> 自定义校验规则的类</h3><p>下面实现StateValidation类，该类要实现ConstraintValidator接口：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateValidation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConstraintValidator</span>&lt;<span class="hljs-title class_">State</span>, <span class="hljs-title class_">String</span>&gt;&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> value, ConstraintValidatorContext context</span>) &#123;<br>        <span class="hljs-keyword">if</span>(value==<span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">equals</span>(<span class="hljs-string">&quot;已发布&quot;</span>) || value.<span class="hljs-title function_">equals</span>(<span class="hljs-string">&quot;草稿&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConstraintValidator接口要传入两个参数，一个是提供校验规则的注解(State)，一个是校验的数据类型(String)，然后重写isValid方法。</p><p>经过以上步骤，自定义的@State注解就可以使用了。</p><h2 id="redis实现登陆主动失效"><a class="markdownIt-Anchor" href="#redis实现登陆主动失效"></a> redis实现登陆主动失效</h2><p>在普通的token颁发和校验中 当用户发现自己账号和密码被暴露了时修改了登录密码后，旧的token仍然可以通过系统校验直至token到达失效时间，这肯定是不安全的，所以系统需要利用redis实现token主动失效机制</p><p>实现这个机制的主要步骤如下：</p><ul><li>在每次用户登录后颁发token的同时往redis数据库中存储一份颁发给用户的token，两个token过期时间要相同</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">ValueOperations&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; ops = redisTemplate.opsForValue();<br>ops.set(<span class="hljs-built_in">token</span>, <span class="hljs-built_in">token</span>, <span class="hljs-number">30</span>, TimeUnit.MINUTES);<br></code></pre></td></tr></table></figure><ul><li>每次每次用户请求时除了解析token外还需要查询redis中是否有当前token，有则校验通过，没有则校验失败，校验一般在拦截器执行</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//从redis中获取token</span><br>ValueOperations&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; ops = redisTemplate.opsForValue();<br><span class="hljs-keyword">String</span> redisToken = ops.<span class="hljs-keyword">get</span>(token);<br><span class="hljs-keyword">if</span>(redisToken==<span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每次用户修改密码后删除redis中当前用所携带的token,从而使旧token无法通过token校验</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">userService.updatePwd(Md5Util.getMD5String(<span class="hljs-keyword">new</span><span class="hljs-type">Pwd</span>));<br>ValueOperations&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; ops = redisTemplate.opsForValue();<br>ops.getOperations().delete(token);<br></code></pre></td></tr></table></figure><h2 id="javascript的导入导出"><a class="markdownIt-Anchor" href="#javascript的导入导出"></a> JavaScript的导入导出</h2><h3 id="非默认导出"><a class="markdownIt-Anchor" href="#非默认导出"></a> 非默认导出</h3><p>可以导出多个变量、函数、类等，使用<code>export</code>关键字</p><p>示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">##不带别名<br><span class="hljs-keyword">export</span> &#123;test1, test2&#125;; ##只有一个函数，可以不用&#123;&#125;<br><span class="hljs-keyword">import</span> &#123;test1, test2&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.js&#x27;</span>; <br>##带别名<br><span class="hljs-keyword">export</span> &#123;test1 <span class="hljs-keyword">as</span> t1, test2 <span class="hljs-keyword">as</span> t2&#125;;<br><span class="hljs-keyword">import</span> &#123;t1, t2&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.js&#x27;</span>; <br></code></pre></td></tr></table></figure><h3 id="默认导出"><a class="markdownIt-Anchor" href="#默认导出"></a> 默认导出</h3><p>每个模块只能有一个默认导出，使用<code>export default</code>关键字</p><p>示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">export</span> default &#123;test1, test2&#125;;<br><span class="hljs-keyword">import</span> testMethods <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.js&#x27;</span>; ##不需要&#123;&#125;<br>testMethods.test1();<br>testMethods.test2();<br></code></pre></td></tr></table></figure><blockquote><p>导入非默认导出的模块时，需要使用<code>&#123;&#125;</code>，导入默认导出的模块时，不需要使用<code>&#123;&#125;</code></p></blockquote><h2 id="vue基本概念"><a class="markdownIt-Anchor" href="#vue基本概念"></a> vue基本概念</h2><ul><li><p>一般vue项目目录中，index.html是默认首页，在该文件中引入main.js文件，main.js是<strong>vue项目的入口文件</strong></p></li><li><p>npm下载的包在node_modules文件夹中，一般不需要手动引入，直接在main.js中引入即可</p></li><li><p>main.js中引入App.vue文件，App.vue是根组件，其他组件都是在根组件中引入的</p></li><li><p>App.vue文件中包含三个部分：template、script、style，分别对应html、js、css</p><ul><li>template: 模板，定义页面结构，生成html</li><li>script: 页面逻辑，处理数据和事件</li><li>style: 样式，定义页面样式</li></ul></li></ul><h2 id="vue常用指令"><a class="markdownIt-Anchor" href="#vue常用指令"></a> vue常用指令</h2><h3 id="ref和reactive"><a class="markdownIt-Anchor" href="#ref和reactive"></a> ref和reactive</h3><blockquote><p>响应式数据是指当数据发生变化时，相关的视图会自动更新</p></blockquote><p>ref 可以用来定义所有类型的数据，包括基本数据类型（如字符串、数字、布尔值）和引用类型（如对象、数组等）。ref 会返回一个具有 .value 属性的响应式对象，在模板中可以直接访问，而在脚本中需要通过 .value 来访问和更新其值。</p><p>特点:</p><ul><li>基本数据类型必须使用ref进行修饰</li><li>在template引入响应式数据时，直接引入变量名即可</li><li>修改ref修饰的响应数据的值时，必须使用 &quot;变量.value&quot;才能修改</li></ul><p>reactive 只能用来定义引用类型（如对象、数组等），它将整个对象进行深度代理，使其具有响应式特性。通常用于复杂的对象结构或嵌套对象，便于直接在对象属性上进行修改。</p><p>特点：</p><ul><li>reactive 如果重新进行赋值，那么原来的对象就会失去响应式</li><li>reactive 修改值的内容不需要使用 .value</li></ul><blockquote><p>如何选择：ref 更适合基本类型和简单的变量，而 reactive 更适合对象和结构复杂的数据。</p></blockquote><h3 id="v-for"><a class="markdownIt-Anchor" href="#v-for"></a> v-for</h3><p>常用于列表渲染，用于遍历容器的元素或者对象的属性。</p><p>如渲染多行表格<br />示例：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(article,index) in articleList&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">article.title</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">article.category</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">article.time</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">article.state</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>编辑<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>其中，index可以省略，如<code>v-for=&quot;article in articleList&quot;</code></p><h3 id="v-bind"><a class="markdownIt-Anchor" href="#v-bind"></a> v-bind</h3><p>动态为HTML标签属性绑定属性，即让标签绑定一个变量</p><p>如为herf标签绑定url变量：<br />示例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>我的博客<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>简写： <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>我的博客<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>其中，url可以是博客的网页链接</p><h3 id="v-if-和-v-show"><a class="markdownIt-Anchor" href="#v-if-和-v-show"></a> v-if 和 v-show</h3><p>这两个指令都用来控制元素的显示与隐藏</p><p>v-if 示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">手链价格为: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;customer.level&gt;=0 &amp;&amp; customer.level&lt;=1&quot;</span>&gt;</span>9.9<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;customer.level&gt;1 &amp;&amp; customer.level&lt;=2&quot;</span>&gt;</span>8.8<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else</span>&gt;</span>7.7<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>v-show 示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">手链价格为: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;customer.level&gt;=0 &amp;&amp; customer.level&lt;=1&quot;</span>&gt;</span>9.9<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;customer.level&gt;1 &amp;&amp; customer.level&lt;=2&quot;</span>&gt;</span>8.8<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;customer.level&gt;2&quot;</span>&gt;</span>7.7<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>区别</strong></p><ul><li>v-if 基于条件来创建或移除元素</li><li>v-show 基于css的display属性的切换，控制元素的显示和隐藏</li></ul><h3 id="v-on"><a class="markdownIt-Anchor" href="#v-on"></a> v-on</h3><p>为html元素绑定事件</p><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;oneClick&quot;</span>&gt;</span>点我有惊喜<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-symbol">&amp;nbsp;</span><br><br>简写： <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;twoClick&quot;</span>&gt;</span>再点更惊喜<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-model"><a class="markdownIt-Anchor" href="#v-model"></a> v-model</h3><p>在表单元素上创建双向数据绑定</p><p>如将表单中输入框和代码中的数据变量绑定</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">文章分类: &lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> v-model=<span class="hljs-string">&quot;searchConditions.category&quot;</span> /&gt;<br><br>发布状态: &lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;text&quot;</span> v-model=<span class="hljs-string">&quot;searchConditions.state&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>这样，当表单中填写的值改动，代码中的变量值也会改变，反之亦然</p><h2 id="let和var的区别"><a class="markdownIt-Anchor" href="#let和var的区别"></a> let和var的区别</h2><ul><li>作用域（Scope）：<ul><li>var 声明的变量具有函数作用域，即它在函数内部声明时，作用域限制在该函数内；如果在代码块（如if、for）中声明，它的作用域仍然是该代码块所在的函数或全局作用域。</li><li>let 声明的变量具有块作用域，即它的作用范围仅限于声明它的代码块内。因此在if、for等代码块中使用let，变量只在该代码块内有效。</li></ul></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 函数作用域</span><br>        let b = <span class="hljs-number">2</span>; <span class="hljs-comment">// 块作用域</span><br>    &#125;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// 1</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b); <span class="hljs-comment">// ReferenceError: b is not defined</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>变量提升（Hoisting）：</p><ul><li>var 声明的变量会被提升到当前作用域的顶部，在声明之前可以访问到，但值为undefined。</li><li>let 声明的变量也会提升到作用域顶部，但存在暂时性死区（Temporal Dead Zone），即在变量声明之前访问会<strong>报错</strong>。</li></ul></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b); <span class="hljs-comment">// ReferenceError: Cannot access &#x27;b&#x27; before initialization</span><br>let b = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><ul><li>重复声明：<ul><li>var 允许在同一作用域内重复声明相同变量名，而let不允许重复声明相同变量名。</li></ul></li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>var a <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">; // 不会报错</span><br><br>let b <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>let b <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">; // SyntaxError: Identifier &#x27;b&#x27; has already been declared</span><br></code></pre></td></tr></table></figure><ul><li><p>全局对象属性：</p><ul><li>在全局作用域中用var声明的变量会成为全局对象（如浏览器中的window对象）的属性，而let声明的全局变量不会添加到全局对象上。</li></ul></li></ul><h2 id="vue生命周期"><a class="markdownIt-Anchor" href="#vue生命周期"></a> vue生命周期</h2><p>vue 生命周期一共包含八个阶段，每个阶段会自动执行对应的钩子函数，这些钩子函数可以用来执行一些初始化操作、数据请求、事件监听等操作，具体如下：</p><table><thead><tr><th style="text-align:center">钩子函数</th><th style="text-align:center">阶段</th></tr></thead><tbody><tr><td style="text-align:center">beforeCreate</td><td style="text-align:center">创建前</td></tr><tr><td style="text-align:center">created</td><td style="text-align:center">创建后</td></tr><tr><td style="text-align:center">beforeMount</td><td style="text-align:center">挂载前</td></tr><tr><td style="text-align:center">mounted</td><td style="text-align:center">挂载后</td></tr><tr><td style="text-align:center">beforeUpdate</td><td style="text-align:center">数据更新前</td></tr><tr><td style="text-align:center">updated</td><td style="text-align:center">数据更新后</td></tr><tr><td style="text-align:center">beforeUnmount</td><td style="text-align:center">组件销毁前</td></tr><tr><td style="text-align:center">unmounted</td><td style="text-align:center">组件销毁后</td></tr></tbody></table><h2 id="axios的使用"><a class="markdownIt-Anchor" href="#axios的使用"></a> axios的使用</h2><h3 id="基本用法"><a class="markdownIt-Anchor" href="#基本用法"></a> 基本用法</h3><p>axios 是一个基于 promise 的 异步 ajax 请求库，前端最流行的 ajax 请求库。简单的讲就是可以发送get、post请求，负责与后端交互。</p><p>axios有2种基本使用方式：</p><ol><li>axios({method:‘方法’，url: ‘’, baseURL: ‘’，data:{name: ‘cc’, sex: ‘man’} })</li></ol><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,<br>    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://localhost:8080&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;cc&#x27;</span>,<br>        <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;man&#x27;</span><br>    &#125;<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res)<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(err)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>直接调用axios.get()、axios.post()等方法</li></ol><p>示例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">axios.post(<span class="hljs-string">&#x27;/login&#x27;</span>,&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;man&#x27;</span>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res)<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(err)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="axios响应拦截器"><a class="markdownIt-Anchor" href="#axios响应拦截器"></a> axios响应拦截器</h3><p>在响应被 then 或 catch 处理前拦截它们，可以对响应数据进行处理，如统一处理错误信息、统一处理loading等。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><span class="hljs-keyword">const</span> baseURL = <span class="hljs-string">&#x27;http://localhost:8080&#x27;</span>; <span class="hljs-comment">//后端接口地址</span><br><span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;baseURL&#125;); <span class="hljs-comment">// 定义请求实例</span><br><span class="hljs-comment">// 添加响应拦截器</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<span class="hljs-comment">//http状态码为2xx时触发</span><br>        <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>; <br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<span class="hljs-comment">//http状态码不为2xx时触发</span><br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请求错误&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<span class="hljs-comment">//异步的状态转为失败状态，抛出错误</span><br>    &#125;<br>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> instance;<br></code></pre></td></tr></table></figure><p>axios的拦截器是基于Promise的，use()方法接收两个参数，第一个是成功的回调函数，第二个是失败的回调函数。<br />由于该函数本身就是异步的，所以不需要async和await关键字，js文件调用时也不需要加，只需要在vue文件中调用时加上async和await关键字即可。</p><h3 id="axios请求拦截器"><a class="markdownIt-Anchor" href="#axios请求拦截器"></a> axios请求拦截器</h3><p>在请求被 then 或 catch 处理前拦截它们，可以对请求数据进行处理，如统一添加token、统一添加loading等。</p><p>用法与响应拦截器类似，下面是一个请求拦截器添加token的示例：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">instance.interceptors.request.use(<br>  <span class="hljs-function"><span class="hljs-params">(config)</span> =&gt;</span> &#123;<br>    let tokenStore = useTokenStore();<br>    <span class="hljs-keyword">if</span> (tokenStore.token) &#123;<br>      config.headers.Authorization = tokenStore.token;<br>    &#125;<br>    <span class="hljs-keyword">return</span> config;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">error</span>)</span> =&gt;</span> &#123;<br>    ElMessage(&#123;<br>      <span class="hljs-name">type</span>: <span class="hljs-string">&quot;error&quot;</span>,<br>      <span class="hljs-name">message</span>: <span class="hljs-string">&quot;请求错误！&quot;</span>,<br>      <span class="hljs-name">plain</span>: <span class="hljs-literal">true</span>,<br>    &#125;);<br>    <span class="hljs-keyword">return</span> Promise.reject(<span class="hljs-built_in">error</span>);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><h2 id="浏览器跨域问题"><a class="markdownIt-Anchor" href="#浏览器跨域问题"></a> 浏览器跨域问题</h2><h3 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h3><p>由于浏览器的同源策略，不同源（不同协议、不同域名、不同端口）发送ajax请求时会被浏览器拦截，这就是跨域问题。</p><p>比如，前端页面的地址是 <code>http://localhost:5173</code>，后端接口的地址是 <code>http://localhost:8080</code>，当浏览器启动时，会先发送请求到前端地址，得到注册页面<br />当用户点击注册时，会发送请求到后端地址，这时浏览器会拦截这个请求，因为这是跨域请求。</p><h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3><p>一般是用代理解决跨域问题，即在前端项目中配置代理，将请求转发到后端接口地址。步骤如下：</p><ol><li>在vite.config.js中配置代理</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">server:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    proxy:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-string">&quot;/api&quot;</span>: <span class="hljs-punctuation">&#123;</span><span class="hljs-comment">//获取路径中包含/api的请求，将其代理到http://localhost:8080</span><br><span class="hljs-symbol">        target:</span> <span class="hljs-string">&quot;http://localhost:8080&quot;</span>,<br><span class="hljs-symbol">        changeOrigin:</span> true,<br><span class="hljs-symbol">        rewrite:</span> (path) =&gt; path.replace(/^\<span class="hljs-keyword">/api/</span>, <span class="hljs-string">&quot;&quot;</span>), <span class="hljs-comment">//重写路径，将路径中的/api替换为空</span><br>      <span class="hljs-punctuation">&#125;</span>,<br>    <span class="hljs-punctuation">&#125;</span>,<br>  <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>将axios的baseURL设置为<code>/api</code>，然后定义axios实例</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const baseURL <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/api&quot;</span><span class="hljs-comment">; //前端代理地址</span><br>const instance <span class="hljs-operator">=</span> axios.create(&#123; baseURL &#125;)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="vue的路由"><a class="markdownIt-Anchor" href="#vue的路由"></a> vue的路由</h2><p>路由的含义是根据不同的url地址，返回不同的内容给用户，他的实现原理是监听url地址的变化，然后根据url地址的变化返回不同的内容给用户<br />他的优点是当用户在应用中浏览不同页面时，URL 会随之更新，但页面不需要从服务器重新加载，这样就可以实现单页应用</p><h3 id="vue中路由的使用步骤"><a class="markdownIt-Anchor" href="#vue中路由的使用步骤"></a> vue中路由的使用步骤</h3><ul><li>安装vue-router</li><li>在src/router/index.js中配置路由</li></ul><p>示例:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> &quot;vue-router&quot;;<br><br>//导入组件<br><span class="hljs-keyword">import</span> LoginVue <span class="hljs-keyword">from</span> &quot;@/views/Login.vue&quot;;<br><span class="hljs-keyword">import</span> LayoutVue <span class="hljs-keyword">from</span> &quot;@/views/Layout.vue&quot;;<br><span class="hljs-keyword">import</span> ArticleCategoryVue <span class="hljs-keyword">from</span> &quot;@/views/article/ArticleCategory.vue&quot;;<br><span class="hljs-keyword">import</span> ArticleManageVue <span class="hljs-keyword">from</span> &quot;@/views/article/ArticleManage.vue&quot;;<br><span class="hljs-keyword">import</span> UserAvatarVue <span class="hljs-keyword">from</span> &quot;@/views/user/UserAvatar.vue&quot;;<br><span class="hljs-keyword">import</span> UserInfoVue <span class="hljs-keyword">from</span> &quot;@/views/user/UserInfo.vue&quot;;<br><span class="hljs-keyword">import</span> UserResetPasswordVue <span class="hljs-keyword">from</span> &quot;@/views/user/UserResetPassword.vue&quot;;<br><br>//定义路由关系<br>const routes = [<br>  &#123;<br>    <span class="hljs-type">path</span>: &quot;/login&quot;,<br>    component: LoginVue,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-type">path</span>: &quot;/&quot;,<br>    component: LayoutVue,<br>    redirect: &quot;/article/category&quot;,<br>    //子路由，访问子路由时，父路由的内容会先被渲染，然后子路由的内容会被渲染到父路由的内容上<br>    //子路由的<span class="hljs-type">path</span>不需要加/，会自动拼接到父路由的<span class="hljs-type">path</span>后面<br>    children: [<br>      &#123;<br>        <span class="hljs-type">path</span>: &quot;article/category&quot;,<br>        component: ArticleCategoryVue,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-type">path</span>: &quot;article/manage&quot;,<br>        component: ArticleManageVue,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-type">path</span>: &quot;user/avatar&quot;,<br>        component: UserAvatarVue,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-type">path</span>: &quot;user/info&quot;,<br>        component: UserInfoVue,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-type">path</span>: &quot;user/resetpwd&quot;,<br>        component: UserResetPasswordVue,<br>      &#125;,<br>    ],<br>  &#125;,<br>];<br><br>//创建路由<br>const router = createRouter(&#123; history: createWebHistory(), routes: routes &#125;);<br>export <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><ul><li>在main.js中引入路由</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import router from <span class="hljs-string">&quot;@/router&quot;</span><span class="hljs-comment">;</span><br>app.use(router)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>在App.vue中使用路由</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;template&gt;</span><br>  <span class="hljs-section">&lt;router-view&gt;</span><span class="hljs-section">&lt;/router-view&gt;</span><br><span class="hljs-section">&lt;/template&gt;</span><br></code></pre></td></tr></table></figure><h3 id="路由主动切换组件"><a class="markdownIt-Anchor" href="#路由主动切换组件"></a> 路由主动切换组件</h3><p>实际应用中，vue文件和js文件中路由主动跳转方式是不同的</p><ul><li>vue文件中</li></ul><p>示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import &#123; useRouter &#125; from <span class="hljs-string">&quot;vue-router&quot;</span><span class="hljs-comment">;</span><br>const router <span class="hljs-operator">=</span> useRouter()<span class="hljs-comment">;</span><br>router.push(<span class="hljs-string">&quot;/login&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>js文件中，没有setup，说明js不是vue组件，因此不能用import {useRouter} from 'vue-router’来获取router</li></ul><p>示例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/router&quot;</span>;<br>router.<span class="hljs-keyword">push</span>(<span class="hljs-string">&quot;/login&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="vue中使用pinia及其持久化"><a class="markdownIt-Anchor" href="#vue中使用pinia及其持久化"></a> vue中使用pinia及其持久化</h2><p>pinia是vue的专属状态管理库，它允许跨组件或页面共享状态，比如在登陆页面登陆成功后，可以将用户信息存储在pinia中，然后其他页面从pinia中获取用户信息。</p><h3 id="pinia使用步骤"><a class="markdownIt-Anchor" href="#pinia使用步骤"></a> pinia使用步骤</h3><ul><li>在main.js中引入pinia</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import &#123; createPinia &#125; from <span class="hljs-string">&quot;pinia&quot;</span><span class="hljs-comment">;</span><br>const pinia <span class="hljs-operator">=</span> createPinia()<span class="hljs-comment">;</span><br>app.use(pinia)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>在src/stores/token.js中定义pinia的store</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义关于counter的store</span><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">const</span> useCounter = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&quot;counter&quot;</span>,&#123;<br>    <span class="hljs-attr">state</span>:<span class="hljs-function">() =&gt;</span> (&#123;<br>        <span class="hljs-attr">count</span>:<span class="hljs-number">66</span>,<br>    &#125;),<br>    <br>    <span class="hljs-attr">getters</span>: &#123;<br><br>  &#125;,<br><br>  <span class="hljs-attr">actions</span>: &#123;<br><br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">//导出这个useCounter模块</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useCounter<br></code></pre></td></tr></table></figure><p>defineStore 是需要传参数的，其中第一个参数是id，就是一个唯一的值，简单点说就可以理解成是一个命名空间。<br />第二个参数就是一个对象，里面有三个模块需要处理，第一个是 state，第二个是 getters，第三个是 actions。</p><h3 id="pinia持久化"><a class="markdownIt-Anchor" href="#pinia持久化"></a> pinia持久化</h3><blockquote><p>pinia默认是内存存储，当刷新浏览器时会丢失数据，所以需要利用persist插件实现持久化</p></blockquote><ul><li>引入pinia-persistedstate-plugin插件</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import &#123; createPersistedState &#125; from <span class="hljs-string">&quot;pinia-persistedstate-plugin&quot;</span><span class="hljs-comment">; </span><br>pinia.use(createPersistedState())<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>设置persisted为true</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pf">import &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span>;<br>//defineStore函数接受二个参数，第一个参数是store的名字，第二个参数是一个函数，定义了关于token的一些操作<br>export <span class="hljs-keyword">const</span> useTokenStore = defineStore(<span class="hljs-string">&quot;token&quot;</span>, &#123;<br>  <span class="hljs-keyword">state</span>: () =&gt; (&#123;<br>    //<span class="hljs-keyword">state</span>，一般定义要存储的数据，<span class="hljs-keyword">state</span>的数据本身就是响应式的<br>    token: <span class="hljs-string">&quot;&quot;</span>,<br>  &#125;),<br>  actions: &#123;<br>    //actions，定义一些操作<br>    <span class="hljs-built_in">set</span>Token(newToken) &#123;<br>      this.token = newToken;<br>    &#125;,<br>    removeToken() &#123;<br>      this.token = <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;,<br>  &#125;,<br>  //<span class="hljs-keyword">persist</span>为true，开启持久化<br>  <span class="hljs-keyword">persist</span>: true,<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="微服务部分"><a class="markdownIt-Anchor" href="#微服务部分"></a> 微服务部分</h1><h2 id="注册中心"><a class="markdownIt-Anchor" href="#注册中心"></a> 注册中心</h2><h3 id="服务治理基础知识"><a class="markdownIt-Anchor" href="#服务治理基础知识"></a> 服务治理基础知识</h3><p>服务治理中的三个角色：</p><ul><li>服务提供者：暴露服务接口，供其他服务调用</li><li>服务消费者：调用其他服务提供的接口</li><li>注册中心：记录并监控微服务各实例的状态，推送服务变更信息</li></ul><p>消费者如何知道服务提供者的地址？</p><ul><li>服务提供者启动时向注册中心注册服务信息，消费者从注册中心订阅和拉取服务信息</li></ul><p>消费者如何知道服务状态变更？</p><ul><li>服务提供者通过心跳机制向注册中心报告健康状态，当“心跳”异常时注册中心会剔除异常服务，并通知订阅了该服务的消费者</li></ul><p>当服务提供者有多个实例时，如何选择？</p><ul><li>通过负载均衡算法选择一个服务提供者</li></ul><h3 id="nacos基础知识"><a class="markdownIt-Anchor" href="#nacos基础知识"></a> nacos基础知识</h3><p>Nacos是阿里旗下的一款开源产品，它主要是针对微服务架构中的服务发现、配置管理、服务治理的综合型解决方案；简单来说 Nacos 就是注册中心 + 配置中心的组合，致力于帮助您发现、配置和管理微服务，提供简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>配置方式：<br />一般会把所有微服务的共享的配置，如jdbc、logger、mq等配置放在nacos中，然后由微服务拉取。</p><ul><li>在nacos控制台新建共享配置，如shared-jdbc.yaml</li><li>接下来，要在微服务拉取共享配置。将拉取到的共享配置与本地的application.yaml配置合并，完成项目上下文的初始化。</li></ul><p>需要注意的是，拉取Nacos配置是SpringCloud上下文（ApplicationContext）初始化时处理的。然后才会初始化SpringBoot上下文，去读取application.yaml。</p><p>如果将nacos配置放在application.yaml中，那么在项目引导阶段就无法拉取nacos中的配置了。</p><p>因此，将nacos地址配置到bootstrap.yaml中，那么在项目引导阶段就可以拉取nacos中的共享配置了。</p><p>配置示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">item-service</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.56</span><span class="hljs-number">.101</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># nacos地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br>        <span class="hljs-attr">shared-configs:</span> <span class="hljs-comment"># 共享配置</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-jdbc.yaml</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-log.yaml</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-swagger.yaml</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-seata.yaml</span> <span class="hljs-comment">#</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-mq.yaml</span><br></code></pre></td></tr></table></figure><h3 id="环境隔离"><a class="markdownIt-Anchor" href="#环境隔离"></a> 环境隔离</h3><p>实际开发中，通常会有多个环境，如开发环境、测试环境、发布环境等，不同的环境需要隔离。</p><p>nacos中，主要分为namespace, group, service三级：</p><ul><li>namespace：用于隔离不同环境，默认为空（public）</li><li>group：服务分组，用于区分不同的服务，默认为DEFAULT_GROUP</li><li>service：服务名，用于标识服务</li></ul><p>配置namespace：</p><ul><li>在nacos控制台中创建namespace，如dev、test、prod</li><li>在nacos配置文件中config或discovery字段下指定namespace, 如<code>namespace: &#123;namespaceId&#125;</code></li></ul><h3 id="服务分级模型"><a class="markdownIt-Anchor" href="#服务分级模型"></a> 服务分级模型</h3><p>大厂的服务可能部署在多个机房，物理上被隔离为多个集群，nacos可以实现对集群的划分，实现服务分级模型。</p><p>nacos的分级分为服务，集群，实例三级。<br />比如，某个服务的实例有很多个，分布在全国各地，可以将这些实例划分为多个集群，如华北集群、华南集群、华东集群等，每个集群下有多个实例。</p><p>具体来说，nacos的注册表是一个Map结构<code>Map&lt;String1, Map&lt;String2, Map&lt;String3, Cluster&lt;Set&lt;Instance&gt;&gt;&gt;&gt;&gt;</code></p><ul><li>String1：namespace名称</li><li>String2：服务名称（含分组信息）</li><li>String3：集群名称</li></ul><h2 id="openfeign"><a class="markdownIt-Anchor" href="#openfeign"></a> OpenFeign</h2><p>利用Nacos实现服务治理和发现后，需要利用RestTemplate实现服务的远程调用，步骤如下：</p><ul><li>获取服务名称</li><li>根据服务名称获取服务实例列表</li><li>利用负载均衡算法选择一个服务实例</li><li>重构请求的url，通过RestTemplate发送请求</li></ul><p>但是远程调用的代码太复杂，OpenFeign可以简化远程调用的代码。</p><h3 id="基本用法-2"><a class="markdownIt-Anchor" href="#基本用法-2"></a> 基本用法</h3><p>OpenFeign的使用步骤如下：</p><ul><li>引入OpenFeign依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--openFeign--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--负载均衡器，早期是Ribbon，新版为loadbalancer--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在对应服务的启动类上添加<code>@EnableFeignClients</code>注解</li><li>编写OpenFeign客户端接口</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@FeignClient</span>(value = <span class="hljs-string">&quot;item-service&quot;</span>,fallbackFactory = ItemClientFallbackFactory.class)<br>public interface ItemClient &#123;<br>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/items&quot;</span>)<br>    List&lt;ItemDTO&gt; <span class="hljs-built_in">queryItemByIds</span>(<span class="hljs-variable">@RequestParam</span>(<span class="hljs-string">&quot;ids&quot;</span>) Collection&lt;Long&gt; ids);<br>    <span class="hljs-variable">@PutMapping</span>(<span class="hljs-string">&quot;/items/stock/deduct&quot;</span>)<br>    void <span class="hljs-built_in">deductStock</span>(<span class="hljs-variable">@RequestBody</span> List&lt;OrderDetailDTO&gt; items);<br>    <span class="hljs-variable">@PutMapping</span>(<span class="hljs-string">&quot;/items/stock/restore&quot;</span>)<br>    void <span class="hljs-built_in">restoreStock</span>(<span class="hljs-variable">@RequestBody</span> List&lt;OrderDetailDTO&gt; items);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，接口内的方法和对应的Controller方法的参数、返回值、请求方式、请求路径等要一致</p><ul><li>在需要的地方注入OpenFeign客户端接口，调用接口方法</li></ul><h3 id="连接池"><a class="markdownIt-Anchor" href="#连接池"></a> 连接池</h3><p>Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：</p><ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>支持连接池的优点是可以复用连接，减少连接的创建和销毁，提高性能，一般会使用OKHttp。一般两步即可：</p><ul><li>引入OKHttp依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--OK http 的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在配置文件中配置使用OKHttp</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">okhttp:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启OKHttp功能</span><br></code></pre></td></tr></table></figure><h3 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h3><p>OpenFeign默认的负载均衡策略是轮询策略，在内部维护一个自增的计数器（达到INT最大值时归零），每次调用时，选择一个服务实例。<br />这样的缺点是，当服务实例的数量不均匀时，轮询策略可能会导致某些实例的负载过高，而某些实例的负载过低。</p><p>内置的负载均衡策略有三种：</p><ul><li>RoundRobinLoadBalancer：轮询策略</li><li>RandomLoadBalancer：随机策略</li><li>NacosLoadBalancer：优先在本集群内选择实例（访问快），根据不同实例的权重（nacos控制台设置权重），随机选择实例</li></ul><p>修改默认的负载均衡策略，需要自定义一个返回ReactorLoadBalancer的Bean，具体步骤如下：</p><ul><li>在对应的服务中创建一个配置类，返回ReactorLoadBalancer的Bean</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenFeignConfig</span> </span>&#123;<br>    <span class="hljs-meta">##修改为NacosLoadBalancer</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ReactorLoadBalancer&lt;ServiceInstance&gt; reactorServiceInstanceLoadBalancer(<br>            Environment environment, NacosDiscoveryProperties properties,<br>            LoadBalancerClientFactory loadBalancerClientFactory) &#123;<br>        <span class="hljs-keyword">String</span> name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NacosLoadBalancer</span>(<br>                loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name, properties);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，这个配置类<strong>不要加@Configuration注解</strong>，也不要被SpringBootApplication扫描到。而是在启动类上通过注解来声明这个配置</p><p>全局配置：<code>@LoadBalancerClients(defaultConfiguration = OpenFeignConfig.class)</code>，对所有服务生效<br />局部配置：<code>@LoadBalancerClients(&#123;@LoadBalancerClient(value = &quot;item-service&quot;, configuration = OpenFeignConfig.class)&#125;)</code>，仅对某个服务生效</p><h2 id="网关"><a class="markdownIt-Anchor" href="#网关"></a> 网关</h2><p>网关就是网络的关口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的路由和转发以及数据安全的校验。</p><p>一般单体项目拆分成各种微服务后，每个服务都有自己的端口号，这样会导致前端请求时需要知道每个服务的端口号，这样不利于维护，因此需要一个网关来统一管理请求。</p><p>网关在微服务架构中的作用：</p><ul><li>网关可以做安全控制，也就是<strong>登录身份校验</strong>，校验通过才放行</li><li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li></ul><h3 id="基本用法-3"><a class="markdownIt-Anchor" href="#基本用法-3"></a> 基本用法</h3><p>利用网关实现请求路由。由于网关本身也是一个独立的微服务，因此也需要创建一个模块开发功能。大概步骤如下：</p><ul><li>创建网关微服务，引入依赖</li><li>编写启动类</li><li>在application.yaml中配置网关路由</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">server:</span><br><span class="hljs-symbol">  port:</span> <span class="hljs-number">8080</span><br><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol">  application:</span><br><span class="hljs-symbol">    name:</span> gateway<br><span class="hljs-symbol">  cloud:</span><br><span class="hljs-symbol">    nacos:</span><br>      server-addr: <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span>:<span class="hljs-number">8848</span><br><span class="hljs-symbol">    gateway:</span><br><span class="hljs-symbol">      routes:</span><br>        - id: item <span class="hljs-meta"># 路由规则id，自定义，唯一</span><br><span class="hljs-symbol">          uri:</span> lb:<span class="hljs-comment">//item-service # 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span><br><span class="hljs-symbol">          predicates:</span> <span class="hljs-meta"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span><br>            - P<span class="hljs-attr">ath</span><span class="hljs-operator">=</span><span class="hljs-keyword">/items/</span>**,<span class="hljs-keyword">/search/</span>** <span class="hljs-meta"># 这里是以请求路径作为判断规则</span><br>        - id: cart<br><span class="hljs-symbol">          uri:</span> lb:<span class="hljs-comment">//cart-service</span><br><span class="hljs-symbol">          predicates:</span><br>            - P<span class="hljs-attr">ath</span><span class="hljs-operator">=</span><span class="hljs-keyword">/carts/</span>**<br>        - id: user<br><span class="hljs-symbol">          uri:</span> lb:<span class="hljs-comment">//user-service</span><br><span class="hljs-symbol">          predicates:</span><br>            - P<span class="hljs-attr">ath</span><span class="hljs-operator">=</span><span class="hljs-keyword">/users/</span>**,<span class="hljs-keyword">/addresses/</span>**<br>        - id: trade<br><span class="hljs-symbol">          uri:</span> lb:<span class="hljs-comment">//trade-service</span><br><span class="hljs-symbol">          predicates:</span><br>            - P<span class="hljs-attr">ath</span><span class="hljs-operator">=</span><span class="hljs-keyword">/orders/</span>**<br>        - id: pay<br><span class="hljs-symbol">          uri:</span> lb:<span class="hljs-comment">//pay-service</span><br><span class="hljs-symbol">          predicates:</span><br>            - P<span class="hljs-attr">ath</span><span class="hljs-operator">=</span><span class="hljs-keyword">/pay-orders/</span>**<br></code></pre></td></tr></table></figure><p>四个属性含义如下：</p><ul><li>id：路由的唯一标示</li><li>predicates：路由断言，其实就是匹配条件</li><li>filters：路由过滤器，对请求或响应做特殊处理</li><li>uri：路由目标地址，lb://代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li></ul><h3 id="网关实现登陆校验"><a class="markdownIt-Anchor" href="#网关实现登陆校验"></a> 网关实现登陆校验</h3><p>登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题：</p><ul><li>每个微服务都需要知道JWT的秘钥，不安全</li><li>每个微服务重复编写登录校验代码、权限校验代码，麻烦</li></ul><p>网关是所有微服务的入口，一切请求都需要先经过网关。完全可以把登录校验的工作放到网关去做：</p><ul><li>只需要在网关和用户服务保存秘钥</li><li>只需要在网关开发登录校验功能</li></ul><p>不过，这里存在几个问题：</p><h4 id="如何在转发之前做登录校验"><a class="markdownIt-Anchor" href="#如何在转发之前做登录校验"></a> 如何在转发之前做登录校验？</h4><p>网关处理请求的流程如下：</p><p><img src="/img/gateway.png" alt="" /></p><ol><li>客户端请求进入网关后由HandlerMapping对请求做判断，找到与当前请求匹配的路由规则（Route），然后将请求交给WebHandler去处理。</li><li>WebHandler则会加载当前路由下需要执行的过滤器链（Filter chain），然后按照顺序逐一执行过滤器（后面称为Filter）。</li><li>图中Filter被虚线分为左右两部分，是因为Filter内部的逻辑分为pre和post两部分，分别会在请求路由到微服务之前和之后被执行。</li><li>只有所有Filter的pre逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li><li>微服务返回结果后，再倒序执行Filter的post逻辑。</li><li>最终把响应结果返回。</li></ol><p>最终请求转发是有一个名为NettyRoutingFilter的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。<br />如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到NettyRoutingFilter之前，这就符合我们的需求了！</p><p>网关过滤器链中的过滤器有两种：</p><ul><li>GatewayFilter：路由过滤器，作用范围比较灵活，可以是任意指定的路由Route.</li><li>GlobalFilter：全局过滤器，作用范围是所有路由，不可配置。</li></ul><p>接下来以GlobalFilter为例，实现登录校验功能:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthProperties authProperties;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JwtTool jwtTool;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AntPathMatcher</span> <span class="hljs-variable">antPathMatcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathMatcher</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">//获取request</span><br>        <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>        <span class="hljs-comment">//判断是否需要登录校验</span><br>        <span class="hljs-keyword">if</span> (isExclude(request.getPath().toString())) &#123;<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-comment">//获取token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        List&lt;String&gt; authorizations = request.getHeaders().get(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span> (authorizations != <span class="hljs-literal">null</span> &amp;&amp; !authorizations.isEmpty()) &#123;<br>            token = authorizations.get(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">//校验解析token</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            userId = jwtTool.parseToken(token);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>            response.setStatusCode(HttpStatus.UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> response.setComplete();<br>        &#125;<br>        <span class="hljs-comment">//通过请求头传递用户信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> userId.toString();<br>        <span class="hljs-type">ServerWebExchange</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> exchange.mutate()<br>                .request(builder -&gt; builder.header(<span class="hljs-string">&quot;userInfo&quot;</span>, userInfo))<br>                .build();<br>        <span class="hljs-keyword">return</span> chain.filter(ex);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExclude</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String pathPattern : authProperties.getExcludePaths()) &#123;<br>            <span class="hljs-keyword">if</span> (antPathMatcher.match(pathPattern, string)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//设置优先级，确保该过滤器在NettyRoutingFilter之前执行，越小优先级越高</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="网关登陆校验之后如何将用户信息传递给微服务"><a class="markdownIt-Anchor" href="#网关登陆校验之后如何将用户信息传递给微服务"></a> 网关登陆校验之后，如何将用户信息传递给微服务？</h4><p>由于网关发送请求到微服务依然采用的是Http请求，因此我们可以将用户信息以请求头的方式传递到下游微服务。<br />然后微服务可以从请求头中获取登录用户信息。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用SpringMVC的拦截器来实现登录用户信息获取，并存入ThreadLocal，方便后续使用。<br />具体步骤如下：</p><ul><li>在网关的过滤器中将用户信息放入请求头</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//通过请求头传递用户信息</span><br>        String userInfo = userId.<span class="hljs-keyword">toString</span>();<br>        ServerWebExchange <span class="hljs-keyword">ex</span> = exchange.mutate()<br>                .request(builder -&gt; builder.header(<span class="hljs-string">&quot;userInfo&quot;</span>, userInfo))<br>                .build();<br>        <span class="hljs-keyword">return</span> chain.filter(<span class="hljs-keyword">ex</span>);<br></code></pre></td></tr></table></figure><ul><li>在通用微服务中定义一个拦截器，从请求头中获取用户信息</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object <span class="hljs-keyword">handler</span>)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//获取登录用户信息</span><br>        String userInfo = request.getHeader(<span class="hljs-string">&quot;userInfo&quot;</span>);<br>        <span class="hljs-comment">//判断是否为空，如果不为空存入ThreadLocal</span><br>        <span class="hljs-keyword">if</span>(StrUtil.isNotBlank(userInfo))&#123;<br>            UserContext.setUser(Long.valueOf(userInfo));<br>        &#125;<br>        <span class="hljs-comment">//因为网关已经做过了token校验，所以这里不需要再校验</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object <span class="hljs-keyword">handler</span>, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//清除ThreadLocal中的用户信息</span><br>        UserContext.removeUser();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在通用微服务配置类中，添加拦截器，为了只对微服务生效，仅在SpringMVC中添加拦截器，添加注解<code>@ConditionalOnClass(DispatcherServlet.class)</code></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@ConditionalOnClass</span>(DispatcherServlet.class)<br>public class MvcConfig implements WebMvcConfigurer &#123;<br>    <span class="hljs-variable">@Override</span><br>    public void <span class="hljs-built_in">addInterceptors</span>(InterceptorRegistry registry) &#123;<br>        <span class="hljs-selector-tag">registry</span><span class="hljs-selector-class">.addInterceptor</span>(new <span class="hljs-built_in">UserInfoInterceptor</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>在文件中设置自动配置（参考自动配置原理）</p></li><li><p>其他微服务引入通用微服务的依赖</p></li></ul><h4 id="微服务之间也会相互调用这种调用不经过网关又该如何传递用户信息"><a class="markdownIt-Anchor" href="#微服务之间也会相互调用这种调用不经过网关又该如何传递用户信息"></a> 微服务之间也会相互调用，这种调用不经过网关，又该如何传递用户信息？</h4><p>要想实现微服务之间的用户信息传递，就必须在微服务发起调用时把用户信息存入请求头。</p><p>为了让每一个由OpenFeign发起的请求自动携带登录用户信息，这里要借助Feign中提供的一个拦截器接口：feign.RequestInterceptor</p><p>配置类中添加一个Bean，将用户信息存入请求头：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">RequestInterceptor</span> <span class="hljs-title function_">userInfoRequestInterceptor</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInterceptor</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">apply</span>(<span class="hljs-params">RequestTemplate template</span>) &#123;<br>            <span class="hljs-comment">// 获取登录用户</span><br>            <span class="hljs-title class_">Long</span> userId = <span class="hljs-title class_">UserContext</span>.<span class="hljs-title function_">getUser</span>();<br>            <span class="hljs-keyword">if</span>(userId == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 如果为空则直接跳过</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果不为空则放入请求头中，传递给下游微服务</span><br>            template.<span class="hljs-title function_">header</span>(<span class="hljs-string">&quot;user-info&quot;</span>, userId.<span class="hljs-title function_">toString</span>());<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态路由"><a class="markdownIt-Anchor" href="#动态路由"></a> 动态路由</h3><p>网关的路由配置全部是在项目启动的时候加载，并且一经加载就会缓存到内存中的路由表内（一个Map），不会改变，也不会监听路由变更。要修改路由配置，需要重启网关。</p><p>实现动态路由，需要把路由信息保存到nacos，当路由配置更新时，推送最新路由信息到网关，实现实时更新路由表，步骤如下：</p><ul><li>在nacos控制台中添加路由表，类型为json格式</li><li>在原始网关配置文件application.yml中，删除路由配置</li><li>引入nacos配置管理依赖</li><li>监听nacos配置变更，更新路由表</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicRouteLoader</span> &#123;<br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">RouteDefinitionWriter</span> routeDefinitionWriter;<br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">NacosConfigManager</span> nacosConfigManager;<br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">String</span> dataId = <span class="hljs-string">&quot;gateway-routes.json&quot;</span>;<br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">String</span> group = <span class="hljs-string">&quot;DEFAULT_GROUP&quot;</span>;<br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">String</span>&gt; routeIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@PostConstruct</span> <span class="hljs-comment">// 在构造函数执行完之后执行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">initRouteConfigListener</span>() throws <span class="hljs-title class_">NacosException</span> &#123;<br>        <span class="hljs-comment">//拉取配置，添加监听器</span><br>        <span class="hljs-title class_">String</span> configInfo = nacosConfigManager.<span class="hljs-title function_">getConfigService</span>()<br>                .<span class="hljs-title function_">getConfigAndSignListener</span>(dataId, group, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listener</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Executor</span> <span class="hljs-title function_">getExecutor</span>(<span class="hljs-params"></span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">receiveConfigInfo</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> configInfo</span>) &#123;<br>                        <span class="hljs-comment">//监听到配置变化后，更新路由表</span><br>                        <span class="hljs-title function_">updateRouteConfig</span>(configInfo);<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-comment">//第一次拉取配置后，更新路由表</span><br>        <span class="hljs-title function_">updateRouteConfig</span>(configInfo);<br>    &#125;<br><br>    <span class="hljs-comment">//更新路由表</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">updateRouteConfig</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> configInfo</span>) &#123;<br>        log.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;监听到配置变化，更新路由表&#123;&#125;&quot;</span>, configInfo);<br>        <span class="hljs-comment">//解析配置信息</span><br>        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">RouteDefinition</span>&gt; routeDefinitions = <span class="hljs-title class_">JSON</span>Util.<span class="hljs-title function_">toList</span>(configInfo, <span class="hljs-title class_">RouteDefinition</span>.<span class="hljs-property">class</span>);<br>        <span class="hljs-comment">//清空路由表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> id : routeIds) &#123;<br>            routeDefinitionWriter.<span class="hljs-title function_">delete</span>(<span class="hljs-title class_">Mono</span>.<span class="hljs-title function_">just</span>(id)).<span class="hljs-title function_">subscribe</span>();<br>        &#125;<br>        routeIds.<span class="hljs-title function_">clear</span>();<br>        <span class="hljs-comment">//判断是否需要更新路由表</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">CollUtil</span>.<span class="hljs-title function_">isEmpty</span>(routeDefinitions)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//更新路由表</span><br>        routeDefinitions.<span class="hljs-title function_">forEach</span>(routeDefinition -&gt; &#123;<br>            <span class="hljs-comment">// 3.1.更新路由</span><br>            routeDefinitionWriter.<span class="hljs-title function_">save</span>(<span class="hljs-title class_">Mono</span>.<span class="hljs-title function_">just</span>(routeDefinition)).<span class="hljs-title function_">subscribe</span>();<br>            <span class="hljs-comment">// 3.2.记录路由id，方便将来删除</span><br>            routeIds.<span class="hljs-title function_">add</span>(routeDefinition.<span class="hljs-title function_">getId</span>());<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="微服务保护"><a class="markdownIt-Anchor" href="#微服务保护"></a> 微服务保护</h2><p>雪崩问题：微服务调用链路中某个微服务出现故障，引起整个链路中所有微服务不可用，这就是雪崩<br />雪崩问题出现的原因主要有：</p><ul><li>微服务相互调用，服务提供者出现故障</li><li>服务调用者没有做好异常处理，导致自身故障</li><li>调用链所有服务级联故障，最终整个链路不可用</li></ul><p>微服务保护的方案有很多，比如：</p><ul><li>请求限流</li><li>线程隔离</li><li>服务熔断</li></ul><p>这些方案或多或少都会导致服务的体验上略有下降</p><p>比如请求限流，降低了并发上限；<br />线程隔离，降低了可用资源数量；<br />服务熔断，降低了服务的完整度，部分服务变的不可用或弱可用。<br />因此这些方案都属于服务降级的方案。但通过这些方案，服务的健壮性得到了提升，</p><h3 id="请求限流"><a class="markdownIt-Anchor" href="#请求限流"></a> 请求限流</h3><p>服务故障最重要原因，就是并发太高！当然，接口的并发不是一直很高，而是突发的。因此请求限流，就是<strong>限制或控制接口访问的并发流量</strong>，避免服务因流量激增而出现故障。</p><p>Sentinel是阿里巴巴开源的一款服务保护框架，目前已经加入SpringCloudAlibaba中。</p><p>下面利用Sentinel实现请求限流：</p><ul><li>在相应的微服务中引入Sentinel依赖</li><li>在配置文件中添加Sentinel配置</li></ul><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">spring:<br>  cloud:<br>    sentinel:<br>      transport:<br>        dashboard: localhost:<span class="hljs-number">8090</span><br>      http-<span class="hljs-keyword">method</span>-<span class="hljs-title function_">specify</span>: <span class="hljs-keyword">true</span> # 开启请求方式前缀<br></code></pre></td></tr></table></figure><ul><li>打开Sentinel控制台，查看簇点链路，查看每个接口的访问情况。</li><li>在簇点链路中点击流控，设置流控规则，如QPS为10</li></ul><h3 id="线程隔离"><a class="markdownIt-Anchor" href="#线程隔离"></a> 线程隔离</h3><p>限流可以降低服务器压力，尽量减少因并发流量引起的服务故障的概率，但并不能完全避免服务故障。一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩。</p><p>比如，购物车服务运行中可能涉及到商品服务，商品会占用一些线程资源，为防止商品服务故障导致整个购物车服务不可用，可以限制商品服务可用的线程资源。</p><p>步骤如下：</p><ul><li>开启feign对sentinel的支持</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对sentinel的支持</span><br></code></pre></td></tr></table></figure><ul><li>打开Sentinel控制台,打开簇点链路，点击流控</li><li>设置设置并发线程数，如10</li></ul><h3 id="服务熔断"><a class="markdownIt-Anchor" href="#服务熔断"></a> 服务熔断</h3><p>线程隔离限定了线程数，导致接口吞吐能力有限，会产生以下问题：</p><ol><li>超出的QPS上限的请求就只能抛出异常，从而导致购物车的查询失败。但从业务角度来说，即便没有查询到最新的商品信息，购物车也应该展示给用户，用户体验更好。也就是给查询失败设置一个降级处理逻辑。</li><li>由于查询商品的延迟较高（模拟的500ms），从而导致查询购物车的响应时间也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。对于商品服务这种不太健康的接口，我们应该直接停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口熔断。</li></ol><p>编写降级逻辑一般通过FallbackFactory实现，步骤如下：</p><ul><li>定义降级处理类，实现FallbackFactory接口</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemClientFallbackFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FallbackFactory</span>&lt;<span class="hljs-title class_">ItemClient</span>&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ItemClient</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">Throwable cause</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemClient</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">ItemDTO</span>&gt; <span class="hljs-title function_">queryItemByIds</span>(<span class="hljs-params">Collection&lt;Long&gt; ids</span>) &#123;<br>                log.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;查询商品失败&quot;</span>, cause);<br>                <span class="hljs-keyword">return</span> <span class="hljs-title class_">CollUtils</span>.<span class="hljs-title function_">emptyList</span>();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">deductStock</span>(<span class="hljs-params">List&lt;OrderDetailDTO&gt; items</span>) &#123;<br>                log.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;扣减库存失败&quot;</span>, cause);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(cause);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">restoreStock</span>(<span class="hljs-params">List&lt;OrderDetailDTO&gt; items</span>) &#123;<br>                log.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;恢复库存失败&quot;</span>, cause);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(cause);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在配置类中定义Bean</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ItemClientFallbackFactory</span> <span class="hljs-title function_">itemClientFallbackFactory</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemClientFallbackFactory</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>ItemClient接口中使用ItemClientFallbackFactory</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@FeignClient</span>(value = <span class="hljs-string">&quot;item-service&quot;</span>,fallbackFactory = ItemClientFallbackFactory.class)<br>public interface ItemClient &#123;<br>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/items&quot;</span>)<br>    List&lt;ItemDTO&gt; <span class="hljs-built_in">queryItemByIds</span>(<span class="hljs-variable">@RequestParam</span>(<span class="hljs-string">&quot;ids&quot;</span>) Collection&lt;Long&gt; ids);<br>    <span class="hljs-variable">@PutMapping</span>(<span class="hljs-string">&quot;/items/stock/deduct&quot;</span>)<br>    void <span class="hljs-built_in">deductStock</span>(<span class="hljs-variable">@RequestBody</span> List&lt;OrderDetailDTO&gt; items);<br>    <span class="hljs-variable">@PutMapping</span>(<span class="hljs-string">&quot;/items/stock/restore&quot;</span>)<br>    void <span class="hljs-built_in">restoreStock</span>(<span class="hljs-variable">@RequestBody</span> List&lt;OrderDetailDTO&gt; items);<br>&#125;<br></code></pre></td></tr></table></figure><p>编写完降级逻辑后，还需要在Sentinel控制台中配置熔断规则</p><p>Sentinel中的断路器不仅可以统计某个接口的<strong>慢请求比例</strong>，还可以统计<strong>异常请求</strong>比例。<br />当这些比例超出阈值时，就会熔断该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。<br />具体规则在控制台中簇点链路中进行设置即可。</p><h3 id="不同线程隔离方案对比"><a class="markdownIt-Anchor" href="#不同线程隔离方案对比"></a> 不同线程隔离方案对比</h3><p>线程隔离有两种实现方式：</p><ul><li>线程池隔离（Hystix默认采用）</li><li>信号量隔离（Sentinel默认采用）</li></ul><p>线程池隔离会为每一个被隔离的业务创建一个线程池，从而确保每个业务分配的线程资源不会超出上限，具有更好的隔离性。缺点是带来了额外的CPU开销，性能一般<br />信号量隔离则是通过信号量来限制并发数，性能更好但是隔离性不如线程池隔离。</p><h3 id="计数算法"><a class="markdownIt-Anchor" href="#计数算法"></a> 计数算法</h3><p>在熔断功能中，需要统计异常请求或慢请求比例，也就是计数。在限流的时候，要统计每秒钟的QPS，同样是计数。可见计数算法在熔断限流中的应用非常多。常见的计数算法有以下几种：</p><ul><li>固定窗口计数算法：将时间划分为固定的时间窗口，比如1s，如果某个窗口内的请求超过了阈值则拒绝新加入的请求。但是只能统计当前某1个时间窗的请求数量是否到达阈值，无法结合前后的时间窗的数据做综合统计。<br />所以仍然存在超过QPS的情况。</li><li>滑动窗口计数：滑动时间窗口算法中只包含1个固定跨度的窗口，但窗口是可移动的，窗口内可分为多个区间，每个区间的请求都会被统计，划分的区间越多，这种统计就越准确（否则容易超QPS）。<br />窗口会随着当前请求所在时间currentTime移动，窗口范围从currentTime-Interval时刻之后的第一个时区开始，到currentTime所在时区结束。</li><li>令牌桶算法：-以固定的速率生成令牌，存入令牌桶中，如果令牌桶满了以后，多余令牌丢弃。请求进入后，必须先尝试从桶中获取令牌，获取到令牌后才可以被处理。如果令牌桶中没有令牌，则请求等待或丢弃<br />注意，使用令牌桶算法时，尽量不要将令牌上限设定到服务能承受的QPS上限。而是预留一定的波动空间，这样才能应对突发流量。</li><li>漏桶算法：请求到达后不是直接处理，而是先放入一个队列。而后以固定的速率从队列中取出并处理请求。之所以叫漏桶算法，就是把请求看做水，队列看做是一个漏了的桶。如果桶满了则会拒绝新来的请求。<br />对突发流量的应对能力更好一些。</li></ul><h2 id="分布式事务"><a class="markdownIt-Anchor" href="#分布式事务"></a> 分布式事务</h2><p>整个业务中，各个本地事务是有关联的。因此每个微服务的本地事务，也可以称为分支事务。多个有关联的分支事务一起就组成了全局事务。我们必须保证整个全局事务同时成功或失败。</p><p>比如商品添加购物车后，进入下单界面，此时如果将后台数据库中对应商品库存改为0，那么点击下单会下单失败，但是回到购物车界面，发现购物车中的商品已经清除了，说明购物服务对其他服务的异常没有感知，没有保证事务的一致性。</p><p>解决分布式事务一般采用Seata，Seata中有三个重要的角色：</p><ul><li>TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。</li><li>TM (Transaction Manager) - 事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li><li>RM (Resource Manager) - 资源管理器：管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p>其中，TM和RM可以理解为Seata的客户端部分，引入到参与事务的微服务依赖中即可。将来TM和RM就会协助微服务，实现本地分支事务与TC之间交互，实现事务的提交或回滚。<br />而TC服务则是事务协调中心，是一个独立的微服务，需要单独部署。</p><h3 id="seata的基本用法"><a class="markdownIt-Anchor" href="#seata的基本用法"></a> Seata的基本用法</h3><ul><li>首先，在服务端部署TC</li><li>在微服务中引入Seata的依赖，在配置文件中配置Seata</li><li>seata的客户端在解决分布式事务的时候需要记录一些中间数据，因此还需要准备数据表。</li><li>在对应serviceimpl的方法上添加@GlobalTransactional注解，@GlobalTransactional注解就是在标记事务的起点，将来TM就会基于这个方法判断全局事务范围，初始化全局事务。</li></ul><p>此外Seata支持四种不同的分布式事务解决方案：</p><ul><li>XA</li><li>TCC</li><li>AT</li><li>SAGA</li></ul><p>下面主要介绍XA和AT两种解决方案。</p><h3 id="xa模式"><a class="markdownIt-Anchor" href="#xa模式"></a> XA模式</h3><p>A是一种规范，目前主流数据库都实现了这种规范，实现的原理都是基于两阶段提交。</p><p>一阶段：</p><ul><li>TM发起并注册全局事务到TC</li><li>TM调用分支事务</li><li>RM注册分支事务到TC</li><li>本地事务执行完sql后<strong>不提交</strong>，而是报告事务执行状态给TC，继续持有数据库锁</li></ul><p>二阶段：</p><ul><li>TC基于一阶段的报告检查事务执行状态</li><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li></ul><p><img src="/img/seata1.png" alt="" /></p><p>XA模式的优点是什么？</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p>XA模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，<strong>性能较差</strong></li><li>依赖关系型数据库实现事务，有的数据库不支持XA</li></ul><p>使用XA模式很简单，只需要在在配置文件中设置XA模式，然后添加@GlobalTransactional注解即可(上面已经用过)：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">seata</span>:<br>  <span class="hljs-class"><span class="hljs-keyword">data</span>-source-proxy-mode: <span class="hljs-type">XA</span></span><br></code></pre></td></tr></table></figure><h3 id="at模式"><a class="markdownIt-Anchor" href="#at模式"></a> AT模式</h3><p>AT模式是Seata的默认模式，AT模式是基于数据库的undo-log（数据快照）实现的，流程如下图：</p><p><img src="/img/seata2.png" alt="" /></p><p>与XA模式不同的是，AT模式<strong>执行sql之前要保存数据快照</strong>，然后执行sql，执行完<strong>立刻提交</strong>，并向TC报告状态<br />TC检查各事务状态，如果所有事务都成功则删除undo-log，如果有人失败则根据undo-log回滚事务</p><p>简述AT模式与XA模式最大的区别是什么？</p><ul><li>XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。</li><li>XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。</li><li>XA模式强一致；AT模式最终一致（会有短暂不一致）。</li></ul><h3 id="at模式的脏写问题"><a class="markdownIt-Anchor" href="#at模式的脏写问题"></a> AT模式的脏写问题</h3><p>如果现在有两个事务，事务1保存快照后（此时i为100），修改i=90，然后提交并释放DB锁，此时事务2获取了DB锁，修改i=80，提交并释放DB锁，此时事务1回滚，i=100，那么事务2会<strong>丢失更新</strong>，也就是脏写。简单来说就是事务1回滚前，数据被事务2修改。</p><p>解决方法：<br />通过<strong>全局锁</strong>，在提交事务释放DB锁前，先获取全局锁，保证同一时间只有一个事务能够提交，这样就能避免脏写问题。</p><h3 id="tcc模式"><a class="markdownIt-Anchor" href="#tcc模式"></a> TCC模式</h3><p>TCC模式是Try-Confirm-Cancel的缩写，分为三个阶段：</p><ul><li>Try：检查和预留资源</li><li>Confirm：执行业务和提交</li><li>Cancel：释放预留资源</li></ul><p>事务悬挂和空回滚：<br />假如一个分布式事务中包含两个分支事务，try阶段，一个分支成功执行，另一个分支事务阻塞，如果阻塞时间太长，可能导致全局事务超时而触发二阶段的cancel操作。两个分支事务都会执行cancel操作。</p><p>空回滚：其中一个分支是未执行try操作的，直接执行了cancel操作，反而会导致数据错误。因此，这种情况下，尽管cancel方法要执行，但其中不能做任何回滚操作，这就是空回滚。<br />事务悬挂：对于空回滚的分支事务，将来try方法阻塞结束依然会执行。但是整个全局事务其实已经结束了，因此永远不会再有confirm或cancel，也就是说这个事务执行了一半，处于悬挂状态，这就是业务悬挂问题。</p><p>以上问题都需要我们在编写try、cancel方法时处理。</p><p>TCC的优点是什么？</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能好</li><li>相比AT模型，无需生成快照，无需使用全局锁，性能最强</li><li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li></ul><p>TCC的缺点是什么？</p><ul><li>有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦</li><li>软状态，事务是最终一致</li><li>需要考虑Confirm和Cancel的失败情况，做好幂等处理、事务悬挂和空回滚处理</li></ul><h2 id="消息队列-mq"><a class="markdownIt-Anchor" href="#消息队列-mq"></a> 消息队列 (MQ)</h2><h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3><p>引入MQ之前，微服务之间的调用都是基于OpenFeign的同步调用，存在以下问题：</p><ul><li>拓展性差：每次有新的需求，现有支付逻辑都要跟着变化，拓展性不好</li><li>性能下降：调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和</li><li>级联失败：由于是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。</li></ul><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ul><li>消息发送者：投递消息的人，就是原来的调用方</li><li>消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ul><p>异步调用的优势包括：</p><ul><li>耦合度更低</li><li>性能更好</li><li>业务拓展性强</li><li>故障隔离，避免级联失败</li></ul><p>缺点是：</p><ul><li>完全依赖于Broker的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul><p>几种常见的MQ对比如下：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">RabbitMQ</th><th style="text-align:center">ActiveMQ</th><th style="text-align:center">RocketMQ</th><th style="text-align:center">Kafka</th></tr></thead><tbody><tr><td style="text-align:center">公司/社区</td><td style="text-align:center">Rabbit</td><td style="text-align:center">Apache</td><td style="text-align:center">阿里</td><td style="text-align:center">Apache</td></tr><tr><td style="text-align:center">开发语言</td><td style="text-align:center">Erlang</td><td style="text-align:center">Java</td><td style="text-align:center">Java</td><td style="text-align:center">Scala&amp;Java</td></tr><tr><td style="text-align:center">协议支持</td><td style="text-align:center">AMQP, XMPP, SMTP, STOMP</td><td style="text-align:center">OpenWire,STOMP, REST,XMPP,AMQP</td><td style="text-align:center">自定义协议</td><td style="text-align:center">自定义协议</td></tr><tr><td style="text-align:center">可用性</td><td style="text-align:center">高</td><td style="text-align:center">一般</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">单机吞吐量</td><td style="text-align:center">一般</td><td style="text-align:center">差</td><td style="text-align:center">高</td><td style="text-align:center">非常高</td></tr><tr><td style="text-align:center">消息延迟</td><td style="text-align:center">微秒级</td><td style="text-align:center">毫秒级</td><td style="text-align:center">毫秒级</td><td style="text-align:center">毫秒以内</td></tr><tr><td style="text-align:center">消息可靠性</td><td style="text-align:center">高</td><td style="text-align:center">一般</td><td style="text-align:center">高</td><td style="text-align:center">一般</td></tr></tbody></table><h3 id="rabbitmq基础知识"><a class="markdownIt-Anchor" href="#rabbitmq基础知识"></a> RabbitMQ基础知识</h3><p>RabbitMQ主要有以下几个角色：</p><ul><li>publisher：生产者，也就是发送消息的一方</li><li>consumer：消费者，也就是消费消息的一方</li><li>queue：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>exchange：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li>virtual host：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><p>上述内容都可以在RabbitMQ的管理控制台来管理</p><p>WorkQueues模型：<br />Work queues，任务模型。简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。RabbitMQ<strong>默认会将消息平均分发</strong>给每个消费者。<br />这样的问题是处理消息快的消费者会快速消费完分配给自己所有消息，然后处于空闲状态，而处理慢的消费者则会消费的很慢。因此我们可以通过设置prefetch来限制每个消费者一次性获取的消息数量。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol">  rabbitmq:</span><br><span class="hljs-symbol">    listener:</span><br><span class="hljs-symbol">      simple:</span><br><span class="hljs-symbol">        prefetch:</span> <span class="hljs-number">1</span> <span class="hljs-meta"># 每次只能获取一条消息，处理完成才能获取下一个消息</span><br></code></pre></td></tr></table></figure><p>这样设置以后，处理快的消费者会处理更多消息（能者多劳），总的处理时间会大大缩短。</p><h3 id="rabbitmq交换机类型"><a class="markdownIt-Anchor" href="#rabbitmq交换机类型"></a> RabbitMQ交换机类型</h3><p>交换机的作用是：</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>RabbitMQ的交换机类型有以下几种：</p><ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列。</li><li>Direct：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li>Topic：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li>Headers：头匹配，基于MQ的消息头匹配，用的较少。</li></ul><p>Direct交换机和Topic交换机的区别：</p><ul><li>Direct交换机是<strong>完全匹配</strong>，只有RoutingKey和BindingKey完全一致，才会将消息路由到队列，可以是多个单词、数字、符号等组成的字符串。</li><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>.</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符，<code>#</code>：代表0个或多个词，<code>*</code>：代表1个词</li></ul><p>BindingKey和RoutingKey的区别：</p><ul><li>RoutingKey是<strong>生产者发送消息时指定</strong>的，用于交换机将消息路由到队列</li><li>BindingKey是<strong>消费者绑定队列时指定</strong>的，用于交换机将消息路由到队列</li></ul><h3 id="声明队列和交换机"><a class="markdownIt-Anchor" href="#声明队列和交换机"></a> 声明队列和交换机</h3><p>声明的方式有两种，通过Bean和通过注解。<br />通过Bean的方式比较麻烦，需要手动声明队列和交换机，然后绑定队列和交换机。<br />下面给出通过注解声明的例子：<br />使用前需要引入<code>spring-boot-starter-amqp</code>依赖</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayStatusListener</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IOrderService orderService;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">            value=@Queue(name = <span class="hljs-string">&quot;trade.pay.success.queue&quot;</span>,durable = <span class="hljs-string">&quot;true&quot;</span>),</span><br><span class="hljs-meta">            exchange = @Exchange(name = <span class="hljs-string">&quot;pay.direct&quot;</span>,type = ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">            key = &#123;<span class="hljs-string">&quot;pay.success&quot;</span>&#125;</span><br><span class="hljs-meta">    ))</span><br>    <span class="hljs-keyword">public</span> void listenPaySuccess(<span class="hljs-built_in">Long</span> orderId) &#123;<br>        <span class="hljs-comment">//查询订单</span><br>        Order order = orderService.getById(orderId);<br>        <span class="hljs-comment">//判断订单状态,仅处理未支付订单</span><br>        <span class="hljs-keyword">if</span>(order==<span class="hljs-literal">null</span> || order.getStatus()!=<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//标记订单支付成功</span><br>        orderService.markOrderPaySuccess(orderId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发送消息：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">rabbitTemplate</span><span class="hljs-selector-class">.convertAndSend</span>(<span class="hljs-string">&quot;pay.direct&quot;</span>, <span class="hljs-string">&quot;pay.success&quot;</span>, po.<span class="hljs-built_in">getBizOrderNo</span>());<br></code></pre></td></tr></table></figure><h3 id="消息转换器"><a class="markdownIt-Anchor" href="#消息转换器"></a> 消息转换器</h3><p>SpringAMQP数据传输时，会把发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。<br />默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。步骤如下：</p><ul><li>在publisher和consumer中引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在publisher和consumer的启动类中添加Bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 1.定义消息转换器</span><br>    <span class="hljs-type">Jackson2JsonMessageConverter</span> <span class="hljs-variable">jjmc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>    <span class="hljs-comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span><br>    jjmc.setCreateMessageIds(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> jjmc;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发送者可靠性"><a class="markdownIt-Anchor" href="#发送者可靠性"></a> 发送者可靠性</h3><p>RabbitMQ提供了发送者重连机制和发送者确认机制来保证发送者的可靠性。</p><p>发送者重连：当RabbitTemplate与MQ连接超时后，多次重试，可通过配置yaml文件启用。重试机制是阻塞式的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。<br />如果对于业务性能有要求，建议禁用重试机制。</p><p>发送者确认：生产者消息确认机制，包括Publisher Confirm和Publisher Return两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的回执。包括以下几种情况：</p><ul><li>消息到达交换机，但是路由失败，会通过Publisher Return机制返回ACK，告知投递成功</li><li>临时消息到达交换机，并路由到队列，返回ACK，告知投递成功</li><li>持久消息到达交换机，并路由到队列完成持久化，返回ACK，告知投递成功</li><li>其他情况都会返回NACK，告知投递失败</li></ul><p>总结就是只要消息到了交换机，就会返回ACK，但是不一定会投递到队列中。<br />开启生产者确认比较消耗MQ性能，一般不建议开启。</p><h3 id="mq可靠性"><a class="markdownIt-Anchor" href="#mq可靠性"></a> MQ可靠性</h3><p>默认情况下，MQ接收到的消息保存在内存中，如果MQ宕机，消息会丢失。为了保证可靠性，主要通过数据持久化和懒队列来实现。</p><p>数据持久化包括：</p><ul><li>交换机持久化，默认就是持久化的</li><li>队列持久化，也是默认持久化的</li><li>消息持久化，需要在发送消息时设置</li></ul><p>懒队列：<br />在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为称为PageOut.<br />PageOut会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。</p><p>懒队列的特点是：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>RabbitMQ 3.12版本之后，LazyQueue已经成为所有队列的默认格式。之前版本声明LazyQueue：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RabbitListener</span>(queuesToDeclare = <span class="hljs-variable">@Queue</span>(<br>        name = <span class="hljs-string">&quot;lazy.queue&quot;</span>,<br>        durable = <span class="hljs-string">&quot;true&quot;</span>,<br>        arguments = <span class="hljs-variable">@Argument</span>(name = <span class="hljs-string">&quot;x-queue-mode&quot;</span>, value = <span class="hljs-string">&quot;lazy&quot;</span>)<br>))<br>public void <span class="hljs-built_in">listenLazyQueue</span>(String msg)&#123;<br>    <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消费者可靠性"><a class="markdownIt-Anchor" href="#消费者可靠性"></a> 消费者可靠性</h3><p>消费者确认机制：<br />为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制。当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p>一般reject方式用的较少，除非是消息格式有问题</p><p>SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：</p><ul><li>none：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用</li><li>manual：手动模式。需要自己在业务代码中调用api，发送ack或reject，存在业务入侵，但更灵活</li><li>auto：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回ack. 当业务出现异常时，根据异常类型判断返回不同结果：<ul><li>如果是业务异常，会自动返回nack；</li><li>如果是消息处理或校验异常，自动返回reject;</li></ul></li></ul><p>失败重试机制：<br />当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。<br />极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力</p><p>应对上述情况Spring又提供了消费者失败重试机制：在消费者出现异常时利用<strong>本地重试</strong>，而不是无限制的requeue到mq队列。例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">retry:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启消费者失败重试</span><br>          <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 初识的失败等待时长为1秒</span><br>          <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span><br>          <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 最大重试次数</span><br>          <span class="hljs-attr">stateless:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span><br></code></pre></td></tr></table></figure><ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring会返回reject，消息会被丢弃<br />对于失败的处理一共有三种策略：</li><li>RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</li><li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队</li><li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p>业务幂等性：<br />是指同一个业务，执行一次或多次对业务状态的影响是一致的。<br />数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。<br />保证消息处理的幂等性，这里给出两种方案：</li><li>唯一消息ID<ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li><li>实现方式很简单，在Jackson的消息转换器里即可实现，见上面消息转换器部分</li></ol></li><li>业务状态判断，基于业务本身的逻辑或状态来判断是否是重复的请求或消息</li></ul><h3 id="延迟消息"><a class="markdownIt-Anchor" href="#延迟消息"></a> 延迟消息</h3><p>发送者发送消息后，消费者在指定时间后才收到消息。</p><p>假设现在有以下极端情况，用户下单后，进行支付服务，如果支付服务出现问题，导致支付服务无法通知交易服务修改订单状态，那么支付服务流水为已支付，交易服务的订单为未支付，状态不一致；如果用户没有支付，就会一直占有库存资源，导致其他客户无法正常交易</p><p>解决方法是，设置延迟消息，一段时间后通知交易服务查询支付状态即可。</p><p>实现延迟消息有死信交换机和延迟消息插件两种。</p><p>死信交换机：<br />当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递<br />如果一个队列中的消息已经成为死信，并且这个队列通过dead-letter-exchange属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为死信交换机（Dead Letter Exchange）。</li></ul><p>延迟消息插件：<br />死信交换机的实现较繁琐，DelayExchange插件则更为便捷，步骤如下：</p><ul><li>安装配置插件</li><li>声明延迟交换机，基于注解</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RabbitListener</span>(bindings = <span class="hljs-variable">@QueueBinding</span>(<br>            value = <span class="hljs-variable">@Queue</span>(name = MQConstants.DELAY_EXCHANGE_NAME),<br>            exchange = <span class="hljs-variable">@Exchange</span>(name = MQConstants.DELAY_EXCHANGE_NAME, delayed = <span class="hljs-string">&quot;true&quot;</span>),<br>            key = &#123;MQConstants.DELAY_ORDER_KEY&#125;<br>    ))<br></code></pre></td></tr></table></figure><ul><li>发送延迟消息</li></ul><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sas">rabbitTemplate.convertAndSend(<br>                MQConstants.DELAY_EXCHANGE_NAME,<br>                MQConstants.DELAY_ORDER_KEY,<br>                <span class="hljs-keyword">order</span>.getId(),<br>                <span class="hljs-keyword">message</span> -&gt; &#123;<br>                    <span class="hljs-keyword">message</span>.getMessageProperties().setDelay(1000 <span class="hljs-comment">* 10 * 1);</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">message</span>;<br>                &#125;<br>        );<br></code></pre></td></tr></table></figure><p>综上，支付服务与交易服务之间的订单状态一致性是如何保证的？</p><ul><li>首先，支付服务会正在用户支付成功以后利用MQ消息通知交易服务，完成订单状态同步。</li><li>其次，为了保证MQ消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试等策略，确保消息投递的可靠性</li><li>最后，我们还在交易服务设置了定时任务，定期查询订单支付状态。这样即便MQ通知失败，还可以利用延迟任务作为兜底方案，确保订单支付状态的最终一致性。</li></ul><h2 id="elasticsearch"><a class="markdownIt-Anchor" href="#elasticsearch"></a> ElasticSearch</h2><h3 id="基础知识-2"><a class="markdownIt-Anchor" href="#基础知识-2"></a> 基础知识</h3><p>数据库的模糊搜索存在以下问题：</p><ul><li>数据库模糊查询不走索引，在数据量较大的时候，查询性能很差。</li><li>数据库的模糊搜索功能单一，必须恰好包含用户搜索的关键字。而在搜索引擎中，用户输入出现个别错字，或者用拼音搜索、同义词搜索都能正确匹配到数据。</li></ul><p>Elasticsearch是由elastic公司开发的一套搜索引擎技术，它是elastic技术栈中的一部分。完整的技术栈包括：</p><ul><li>Elasticsearch：用于数据存储、计算和搜索</li><li>Logstash/Beats：用于数据收集</li><li>Kibana：用于数据可视化<br />整套技术栈被称为ELK，经常用来做日志收集、系统监控和状态分析等。</li></ul><p>一般数据库搜索中，当搜索条件为模糊匹配时，由于索引无法生效，导致从索引查询退化为全表扫描，效率很差。<br />因此，正向索引适合于根据索引字段的精确搜索，不适合基于部分词条的模糊匹配。<br />elasticsearch之所以有如此高性能的搜索表现，正是得益于底层的倒排索引技术。</p><p>什么是<em><strong>倒排索引</strong></em>？</p><ul><li>正向索引是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是根据文档找词条的过程。</li><li>而倒排索引则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是根据词条找文档的过程。<br />这里的文档就是数据库中的一行数据，词条就是分词后的词语。</li></ul><p>创建倒排索引的过程：</p><ul><li>分词：将文档中的词语进行分词，形成词条</li><li>建立倒排索引：将词条与文档id进行映射，形成倒排索引表</li></ul><p>有了倒排索引，搜索流程就变成了：</p><ul><li>用户输入搜索词条</li><li>对输入进行分词</li><li>根据分词结果在倒排索引表中查找文档id</li><li>根据文档id获取文档</li></ul><p>一些<strong>基础概念</strong>对比：</p><table><thead><tr><th>MySQL</th><th>Elasticsearch</th><th>说明</th></tr></thead><tbody><tr><td>Table</td><td>Index</td><td>索引(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td>Row</td><td>Document</td><td>文档（Document），就是一条一条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td>Column</td><td>Field</td><td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td>Schema</td><td>Mapping</td><td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td>SQL</td><td>DSL</td><td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><p>Mapping是对索引库中文档的约束，常见的Mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><h3 id="kibana中的增删改查"><a class="markdownIt-Anchor" href="#kibana中的增删改查"></a> Kibana中的增删改查</h3><p>Kibana是一个开源的数据分析和可视化平台，可以让你在Elasticsearch上进行数据分析和搜索。</p><p><strong>索引库的增删改查</strong></p><ul><li>创建索引库</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">PUT</span> /索引库名称<br>&#123;<br>  <span class="hljs-string">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;字段名&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>        <span class="hljs-string">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;字段名2&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span>,<br>        <span class="hljs-string">&quot;index&quot;</span>: <span class="hljs-string">&quot;false&quot;</span><br>      &#125;,<br>      <span class="hljs-string">&quot;字段名3&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;子字段&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>          &#125;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-comment">// ...略</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>查询索引库</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /索引库名<br></code></pre></td></tr></table></figure><ul><li>删除索引库</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">DELETE</span> /索引库名<br></code></pre></td></tr></table></figure><ul><li>修改索引库，索引库一旦创建，无法修改mapping，但可以添加新的字段</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">PUT <span class="hljs-regexp">/索引库名/</span>_mapping<br>&#123;<br>  <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;新字段名&quot;</span>:&#123;<br>      <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>文档的增删改查</strong></p><ul><li>新增文档</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">POST /索引库名/_doc/文档<span class="hljs-built_in">id</span><br>&#123;<br>    <span class="hljs-string">&quot;字段1&quot;</span>: <span class="hljs-string">&quot;值1&quot;</span>,<br>    <span class="hljs-string">&quot;字段2&quot;</span>: <span class="hljs-string">&quot;值2&quot;</span>,<br>    <span class="hljs-string">&quot;字段3&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;子属性1&quot;</span>: <span class="hljs-string">&quot;值3&quot;</span>,<br>        <span class="hljs-string">&quot;子属性2&quot;</span>: <span class="hljs-string">&quot;值4&quot;</span><br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>查询文档</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GET /&#123;索引库名称&#125;/_doc/&#123;<span class="hljs-built_in">id</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>删除文档</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">DELETE</span> <span class="hljs-regexp">/&#123;索引库名&#125;/</span>_doc/id值<br></code></pre></td></tr></table></figure><ul><li>修改文档有两种方式，全量修改直接覆盖原来的文档；局部修改，修改文档中的部分字段，</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">全量修改：与新增文档语法一样<br>局部修改：<br>POST /&#123;索引库名&#125;/_update/文档<span class="hljs-built_in">id</span><br>&#123;<br>    <span class="hljs-string">&quot;doc&quot;</span>: &#123;<br>         <span class="hljs-string">&quot;字段名&quot;</span>: <span class="hljs-string">&quot;新的值&quot;</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dsl查询"><a class="markdownIt-Anchor" href="#dsl查询"></a> DSL查询</h3><p>Elasticsearch提供了基于JSON的DSL（Domain Specific Language）语句来定义<strong>复杂的查询条件</strong><br />Elasticsearch的查询可以分为两大类：</p><ul><li>叶子查询（Leaf query clauses）：一般是在特定的字段里查询特定值，属于简单查询，很少单独使用。</li><li>复合查询（Compound query clauses）：以逻辑方式组合多个叶子查询或者更改叶子查询的行为方式。</li></ul><p><strong>叶子查询</strong></p><ul><li>全文检索查询（Full Text Queries）：利用分词器对用户输入搜索条件先分词，得到词条，然后再利用倒排索引搜索词条。例如：<ul><li>match：</li><li>multi_match</li></ul></li><li>精确查询（Term-level queries）：不对用户输入搜索条件分词，根据字段内容精确值匹配。但只能查找keyword、数值、日期、boolean类型的字段。例如：<ul><li>ids：根据文档id查询</li><li>term：精确匹配某个字段的值</li><li>range：范围查询</li></ul></li><li>地理坐标查询：用于搜索地理位置，搜索方式很多，例如：<ul><li>geo_bounding_box：按矩形搜索</li><li>geo_distance：按点和半径搜索</li></ul></li></ul><p><strong>全文检索查询</strong></p><ul><li>match查询，例如模糊搜索商品名称为苹果手机的商品</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /&#123;索引库名&#125;/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;苹果手机&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>multi_match查询：可以指定多个字段进行搜索。例如模糊搜索商品名称和品牌中包含苹果手机的商品</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /&#123;索引库名&#125;/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;multi_match&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;苹果手机&quot;</span>,<br>      <span class="hljs-string">&quot;fields&quot;</span>: [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;brand&quot;</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>精确查询</strong></p><ul><li>term查询：精确匹配某个字段的值，例如查询品牌为苹果的商品</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /&#123;索引库名&#125;/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;term&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;brand&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;苹果&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>range查询：范围查询，例如查询价格在100-500之间的商品</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /&#123;索引库名&#125;/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;range&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;price&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;gte&quot;</span>: 100,<br>        <span class="hljs-string">&quot;lte&quot;</span>: 500<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复合查询</strong><br />复合查询大致可以分为两类：</p><ul><li>第一类：基于逻辑运算组合叶子查询，实现组合条件，例如<ul><li>bool</li></ul></li><li>第二类：基于某种算法修改查询时的文档相关性算分，从而改变文档排名。例如：<ul><li>function_score</li><li>dis_max</li></ul></li></ul><p><strong>bool查询</strong><br />bool查询是最常用的复合查询，利用逻辑运算来组合一个或多个查询子句的组合。bool查询支持的逻辑运算有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”，满足相关项即可提升匹配分数</li><li>must_not：必须不匹配，不参与算分，类似“非”</li><li>filter：必须匹配，不参与算分</li></ul><p>例如查询商品名称中包含手机，品牌最好为vivo或小米，价格大于等于1000且小于2500的商品</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">GET</span> /items/<span class="hljs-symbol">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;bool&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;must&quot;</span>: [<br>        &#123;<span class="hljs-string">&quot;match&quot;</span>: &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;手机&quot;</span>&#125;&#125;<br>      ],<br>      <span class="hljs-string">&quot;should&quot;</span>: [<br>        &#123;<span class="hljs-string">&quot;term&quot;</span>: &#123;<span class="hljs-string">&quot;brand&quot;</span>: &#123; <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;vivo&quot;</span> &#125;&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;term&quot;</span>: &#123;<span class="hljs-string">&quot;brand&quot;</span>: &#123; <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;小米&quot;</span> &#125;&#125;&#125;<br>      ],<br>      <span class="hljs-string">&quot;must_not&quot;</span>: [<br>        &#123;<span class="hljs-string">&quot;range&quot;</span>: &#123;<span class="hljs-string">&quot;price&quot;</span>: &#123;<span class="hljs-string">&quot;gte&quot;</span>: <span class="hljs-number">2500</span>&#125;&#125;&#125;<br>      ],<br>      <span class="hljs-string">&quot;filter&quot;</span>: [<br>        &#123;<span class="hljs-string">&quot;range&quot;</span>: &#123;<span class="hljs-string">&quot;price&quot;</span>: &#123;<span class="hljs-string">&quot;gte&quot;</span>: <span class="hljs-number">1000</span>&#125;&#125;&#125;<br>      ]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>排序</strong><br />elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索结果排序。不过分词字段无法排序，能参与排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。<br />例如按商品价格降序排序</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">GET</span> /<span class="hljs-built_in">items</span>/<span class="hljs-variable">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;price&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分页</strong><br />elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。<br />基础分页通过修改from和size参数来实现，from表示从第几条开始，size表示返回多少条数据。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">GET</span> /<span class="hljs-built_in">items</span>/<span class="hljs-variable">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match_all&quot;</span>: &#123;&#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 分页开始的位置，默认为0</span><br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">10</span>,  <span class="hljs-comment">// 每页文档数量，默认10</span><br>  <span class="hljs-string">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;price&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;order&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>深度分页问题</strong><br />elasticsearch的数据一般会采用分片存储，也就是把一个索引中的数据分成N份，存储到不同节点上。这种存储方式比较有利于数据扩展，但给分页带来了一些麻烦。<br />比如要查找所有数据中最小的前1000条数据，需要在每个分片上查找前1000条数据，然后再在所有分片上合并排序，最后返回前1000条数据。这个过程会消耗大量的时间和资源。</p><p>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力。<br />在ES中，<code>from+ size</code> 超过10000的请求会被拒绝。</p><p>针对深度分页，elasticsearch提供了两种解决方案：</p><ul><li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li>scroll：原理将排序后的文档id形成快照，保存下来，基于快照做分页。官方已经不推荐使用。</li></ul><p>search after的优点是支持深度分页，但是必须依赖排序字段，而且排序字段的值必须是全局唯一的，不支持跳页。</p><p><strong>高亮</strong><br />我们在百度搜索时，关键字会变成红色，比较醒目，这叫高亮显示，实现如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /&#123;索引库名&#125;/_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;搜索字段&quot;</span>: <span class="hljs-string">&quot;搜索关键字&quot;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;highlight&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;fields&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;高亮字段名称&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;pre_tags&quot;</span>: <span class="hljs-string">&quot;&lt;em&gt;&quot;</span>,<br>        <span class="hljs-string">&quot;post_tags&quot;</span>: <span class="hljs-string">&quot;&lt;/em&gt;&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>聚合</strong><br />聚合（aggregations）可以让我们极其方便的实现对数据的统计、分析、运算。<br />聚合常见的有三类：</p><ul><li>桶（Bucket）聚合：用来对文档做分组</li><li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li><li>度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等</li><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小值</li><li>Stats：同时求max、min、avg、sum等</li><li>管道（pipeline）聚合：其它聚合的结果为基础做进一步运算</li></ul><blockquote><p>注意：参加聚合的字段必须是keyword、日期、数值、布尔类型</p></blockquote><p>Bucket聚合语法，查询商品按照品牌分组</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">GET</span> /<span class="hljs-built_in">items</span>/<span class="hljs-variable">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">//size为0表示不返回文档，只返回聚合结果</span><br>  <span class="hljs-string">&quot;aggs&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;brand_agg&quot;</span>: &#123; <span class="hljs-comment">//聚合名称</span><br>      <span class="hljs-string">&quot;terms&quot;</span>: &#123; <span class="hljs-comment">//桶聚合用terms</span><br>        <span class="hljs-string">&quot;field&quot;</span>: <span class="hljs-string">&quot;brand&quot;</span>,<br>        <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">20</span> <span class="hljs-comment">//返回几个桶</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Metric聚合语法，比如查询商品按品牌分组后，查看价格的统计数据</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">GET</span> /<span class="hljs-built_in">items</span>/<span class="hljs-variable">_search</span><br>&#123;<br>  <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-string">&quot;aggs&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;brand_agg&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;terms&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;field&quot;</span>: <span class="hljs-string">&quot;brand&quot;</span>,<br>        <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">20</span><br>      &#125;,<br>      <span class="hljs-string">&quot;aggs&quot;</span>: &#123; <span class="hljs-comment">//子聚合</span><br>        <span class="hljs-string">&quot;stats_agg&quot;</span>: &#123; <span class="hljs-comment">//聚合名称</span><br>          <span class="hljs-string">&quot;stats&quot;</span>: &#123; <span class="hljs-comment">//Metric聚合用stats</span><br>            <span class="hljs-string">&quot;field&quot;</span>: <span class="hljs-string">&quot;price&quot;</span> <br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="restclient基础操作"><a class="markdownIt-Anchor" href="#restclient基础操作"></a> RestClient基础操作</h3><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。<br />一些基本操作如下：</p><ul><li>初始化RestHighLevelClient：</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@BeforeEach</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>&#123;<br>    client = <span class="hljs-keyword">new</span> RestHighLevelClient(RestClient.builder(<br>            HttpHost.create(<span class="hljs-string">&quot;http://192.168.56.101:9200&quot;</span>)<br><span class="hljs-comment">//                HttpHost.create(&quot;http://192.168.56.101:9200&quot;),</span><br><span class="hljs-comment">//                HttpHost.create(&quot;http://192.168.56.101:9200&quot;)</span><br>    ));<br>&#125;<br><br><span class="hljs-meta">@AfterEach</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tearDown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">if</span> (client != <span class="hljs-keyword">null</span>) &#123;<br>        client.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建索引库</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs swift">void createIndex() <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br>        <span class="hljs-comment">// 创建索引</span><br>        <span class="hljs-type">CreateIndexRequest</span> request <span class="hljs-operator">=</span> new <span class="hljs-type">CreateIndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>        request.source(<span class="hljs-type">MAPPING_TEMPLATE</span>, <span class="hljs-type">XContentType</span>.<span class="hljs-type">JSON</span>);<br>        client.indices().create(request, <span class="hljs-type">RequestOptions</span>.<span class="hljs-type">DEFAULT</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-type">MAPPING_TEMPLATE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;  <span class="hljs-subst">\&quot;</span>mappings<span class="hljs-subst">\&quot;</span>: &#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;    <span class="hljs-subst">\&quot;</span>properties<span class="hljs-subst">\&quot;</span>: &#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>id<span class="hljs-subst">\&quot;</span>: &#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>keyword<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>name<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>text<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>analyzer<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>ik_max_word<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>price<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>integer<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>image<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>keyword<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>index<span class="hljs-subst">\&quot;</span>: false<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>category<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>keyword<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>brand<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>keyword<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>sold<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>integer<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>commentCount<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>integer<span class="hljs-subst">\&quot;</span>,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>index<span class="hljs-subst">\&quot;</span>: false<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>isAD<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>boolean<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;,<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      <span class="hljs-subst">\&quot;</span>updateTime<span class="hljs-subst">\&quot;</span>:&#123;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;        <span class="hljs-subst">\&quot;</span>type<span class="hljs-subst">\&quot;</span>: <span class="hljs-subst">\&quot;</span>date<span class="hljs-subst">\&quot;</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;      &#125;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;    &#125;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;  &#125;<span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;&#125;&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>删除索引库</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">void</span> deleteIndex() <span class="hljs-keyword">throws</span> IOException &#123;<br>        DeleteIndexRequest request = <span class="hljs-keyword">new</span> DeleteIndexRequest(<span class="hljs-string">&quot;items&quot;</span>);<br>        client.indices().<span class="hljs-keyword">delete</span>(request, RequestOptions.<span class="hljs-keyword">DEFAULT</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>新增文档</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createDoc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//准备数据</span><br>        <span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> itemService.getById(<span class="hljs-number">317578L</span>);<br>        <span class="hljs-type">ItemDoc</span> <span class="hljs-variable">itemDoc</span> <span class="hljs-operator">=</span> BeanUtils.copyProperties(item, ItemDoc.class);<br>        <span class="hljs-comment">//准备request,IndexRequest即能创建文档，也能全量更新文档</span><br>        <span class="hljs-type">IndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>).id(item.getId().toString());<br>        <span class="hljs-comment">//准备请求参数</span><br>        request.source(JSONUtil.toJsonStr(itemDoc), XContentType.JSON);<br>        <span class="hljs-comment">//发送请求</span><br>        client.index(request, RequestOptions.DEFAULT);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>查询文档</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">void</span> getDoc() <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//准备request</span><br>        GetRequest request = <span class="hljs-keyword">new</span> GetRequest(<span class="hljs-string">&quot;items&quot;</span>).id(<span class="hljs-string">&quot;317578&quot;</span>);<br>        <span class="hljs-comment">//发送请求</span><br>        GetResponse response = client.get(request, RequestOptions.<span class="hljs-keyword">DEFAULT</span>);<br>        <span class="hljs-comment">//解析结果</span><br>        String <span class="hljs-keyword">source</span> = response.getSourceAsString();<br>        ItemDoc doc = JSONUtil.toBean(<span class="hljs-keyword">source</span>, ItemDoc.<span class="hljs-keyword">class</span>);<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;doc = &quot;</span> + doc);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>删除文档</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">void</span> deleteDoc() <span class="hljs-keyword">throws</span> IOException &#123;<br>        DeleteRequest request = <span class="hljs-keyword">new</span> DeleteRequest(<span class="hljs-string">&quot;items&quot;</span>).id(<span class="hljs-string">&quot;317578&quot;</span>);<br>        client.<span class="hljs-keyword">delete</span>(request, RequestOptions.<span class="hljs-keyword">DEFAULT</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>修改文档</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">updateDoc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//局部更新</span><br>        <span class="hljs-type">UpdateRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateRequest</span>(<span class="hljs-string">&quot;items&quot;</span>, <span class="hljs-string">&quot;317578&quot;</span>);<br>        request.doc(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">9999</span>);<br>        client.update(request, RequestOptions.DEFAULT);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>批量新增文档</li></ul><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-literal">void</span> testBulkDoc() throws IOException &#123;<br>        int pageNo = <span class="hljs-number">1</span>, pageSize = <span class="hljs-number">500</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//准备数据</span><br>            Page&lt;Item&gt; page = itemService.lambdaQuery()<br>                    .<span class="hljs-literal">eq</span>(Item<span class="hljs-type">::getStatus</span>, <span class="hljs-number">1</span>)<br>                    .page(<span class="hljs-literal">new</span> Page&lt;&gt;(pageNo, pageSize));<br>            <span class="hljs-built_in">List</span>&lt;Item&gt; <span class="hljs-keyword">records</span> = page.getRecords();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">records</span> == <span class="hljs-built_in">null</span> || <span class="hljs-keyword">records</span>.isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            BulkRequest request = <span class="hljs-literal">new</span> BulkRequest();<br>            <span class="hljs-comment">//批量插入</span><br>            for (Item item : <span class="hljs-keyword">records</span>) &#123;<br>                request.add(<span class="hljs-literal">new</span> IndexRequest(<span class="hljs-string">&quot;items&quot;</span>)<br>                        .id(item.getId().toString())<br>                        .source(JSONUtil.toJsonStr(BeanUtils.copyProperties(item, ItemDoc.class)), XContentType.JSON));<br>            &#125;<br>            <span class="hljs-comment">//发送请求</span><br>            client.bulk(request, RequestOptions.DEFAULT);<br>            pageNo++;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>DSL match查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    request.source().query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;脱脂牛奶&quot;</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>DSL multi_match查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMultiMatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    request.source().query(QueryBuilders.multiMatchQuery(<span class="hljs-string">&quot;脱脂牛奶&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;category&quot;</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>DSL bool查询，查询商品名称包含脱脂牛奶，品牌为德亚，价格在5000-30000之间的商品</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSearch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 1.创建Request</span><br>        <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>        <span class="hljs-comment">// 2.组织请求参数</span><br>        request.source().query(QueryBuilders.boolQuery()<br>                .must(QueryBuilders.matchQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;脱脂牛奶&quot;</span>))<br>                .must(QueryBuilders.termQuery(<span class="hljs-string">&quot;brand&quot;</span>, <span class="hljs-string">&quot;德亚&quot;</span>))<br>                .filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).gte(<span class="hljs-number">5000</span>).lte(<span class="hljs-number">30000</span>))<br>        );<br>        <span class="hljs-comment">// 3.发送请求</span><br>        <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>        <span class="hljs-comment">// 4.解析响应</span><br>        parseDocResponse(response);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>DSL 排序和分页查询</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">void</span> testPageAndSort() <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">int</span> pageNo = <span class="hljs-number">1</span>, pageSize = <span class="hljs-number">5</span>;<br>        <span class="hljs-comment">// 1.创建Request</span><br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;items&quot;</span>);<br>        <span class="hljs-comment">// 2.组织请求参数</span><br>        request.<span class="hljs-keyword">source</span>().query(QueryBuilders.matchAllQuery())<br>                .<span class="hljs-keyword">from</span>((pageNo - <span class="hljs-number">1</span>) * pageSize)<br>                .<span class="hljs-keyword">size</span>(pageSize)<br>                .<span class="hljs-keyword">sort</span>(<span class="hljs-string">&quot;sold&quot;</span>, SortOrder.DESC)<br>                .<span class="hljs-keyword">sort</span>(<span class="hljs-string">&quot;price&quot;</span>, SortOrder.ASC);<br>        <span class="hljs-comment">// 3.发送请求</span><br>        SearchResponse response = client.search(request, RequestOptions.<span class="hljs-keyword">DEFAULT</span>);<br>        <span class="hljs-comment">// 4.解析响应</span><br>        parseDocResponse(response);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>DSL 高亮查询</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">testHighlight</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 1.创建Request</span><br>        <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>        <span class="hljs-comment">// 2.组织请求参数</span><br>        request.source().query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;脱脂牛奶&quot;</span>))<br>                .highlighter(SearchSourceBuilder.highlight()<br>                        .field(<span class="hljs-string">&quot;name&quot;</span>)<br>                        .preTags(<span class="hljs-string">&quot;&lt;em&gt;&quot;</span>)<br>                        .postTags(<span class="hljs-string">&quot;&lt;/em&gt;&quot;</span>)<br>                );<br>        <span class="hljs-comment">// 3.发送请求</span><br>        <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>        <span class="hljs-comment">// 4.解析响应</span><br>        parseDocResponse(response);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>DSL 聚合查询</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">void</span> testAggs() <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//查询价格大于等于3000的手机，按品牌聚合，然后按每个品牌的数量升序</span><br>        <span class="hljs-comment">// 1.创建Request</span><br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(<span class="hljs-string">&quot;items&quot;</span>);<br>        <span class="hljs-comment">// 2.组织请求参数</span><br>        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()<br>                .filter(QueryBuilders.termQuery(<span class="hljs-string">&quot;category&quot;</span>, <span class="hljs-string">&quot;手机&quot;</span>))<br>                .filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).gte(<span class="hljs-number">300000</span>));<br>        request.<span class="hljs-keyword">source</span>().query(boolQuery).<span class="hljs-keyword">size</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//size=0表示不查询doc</span><br><br>        String brandAggName = <span class="hljs-string">&quot;brands_agg&quot;</span>;<br>        request.<span class="hljs-keyword">source</span>().aggregation(AggregationBuilders.terms(brandAggName)<br>                .field(<span class="hljs-string">&quot;brand&quot;</span>)<br>                .<span class="hljs-keyword">size</span>(<span class="hljs-number">10</span>)<br>                .order(BucketOrder.<span class="hljs-keyword">count</span>(<span class="hljs-keyword">true</span>))<br>        );<br>        <span class="hljs-comment">// 3.发送请求</span><br>        SearchResponse response = client.search(request, RequestOptions.<span class="hljs-keyword">DEFAULT</span>);<br>        <span class="hljs-comment">// 4.解析响应</span><br>        parseAggsResponse(response, brandAggName);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>解析响应</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> parseDocResponse(SearchResponse response) &#123;<br>        SearchHits searchHits = response.getHits();<br>        <span class="hljs-comment">// 1.获取总条数</span><br>        <span class="hljs-keyword">long</span> total = searchHits.getTotalHits().value;<br>        System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;共搜索到&quot;</span> + total + <span class="hljs-string">&quot;条数据&quot;</span>);<br>        <span class="hljs-comment">// 2.遍历结果数组</span><br>        SearchHit[] hits = searchHits.getHits();<br>        <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>            <span class="hljs-comment">// 3.得到_source，也就是原始json文档</span><br>            String <span class="hljs-keyword">source</span> = hit.getSourceAsString();<br>            <span class="hljs-comment">// 4.反序列化并打印</span><br>            ItemDoc item = JSONUtil.toBean(<span class="hljs-keyword">source</span>, ItemDoc.<span class="hljs-keyword">class</span>);<br>            <span class="hljs-comment">// 5.获取高亮字段</span><br>            Map&lt;String, HighlightField&gt; hfs = hit.getHighlightFields();<br>            <span class="hljs-keyword">if</span> (CollUtils.isNotEmpty(hfs)) &#123;<br>                HighlightField hf = hfs.get(<span class="hljs-string">&quot;name&quot;</span>);<br>                <span class="hljs-keyword">if</span> (hf != <span class="hljs-keyword">null</span>) &#123;<br>                    Text[] fragments = hf.fragments();<br>                    <span class="hljs-comment">//拼接高亮字段</span><br>                    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>                    <span class="hljs-keyword">for</span> (Text fragment : fragments)<br>                        sb.<span class="hljs-keyword">append</span>(fragment);<br>                    item.setName(sb.toString());<br>                &#125;<br>            &#125;<br>            System.out.<span class="hljs-keyword">println</span>(item);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>解析聚合查询响应</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseAggsResponse</span><span class="hljs-params">(SearchResponse response, String aggName)</span> &#123;<br>        <span class="hljs-type">Aggregations</span> <span class="hljs-variable">aggregations</span> <span class="hljs-operator">=</span> response.getAggregations();<br>        <span class="hljs-comment">//根据聚合名称获取聚合</span><br>        <span class="hljs-type">Terms</span> <span class="hljs-variable">terms</span> <span class="hljs-operator">=</span> aggregations.get(aggName);<br>        <span class="hljs-comment">//获取桶</span><br>        List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Terms</span>.Bucket&gt; buckets = terms.getBuckets();<br>        <span class="hljs-keyword">for</span> (Terms.Bucket bucket : buckets) &#123;<br>            System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + bucket.getKeyAsString() + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-string">&quot;cnt:&quot;</span> + bucket.getDocCount());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="redis主从"><a class="markdownIt-Anchor" href="#redis主从"></a> Redis主从</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><p>假如集群中有一个master节点、两个slave节点（现在叫replica）。当我们通过Redis的Java客户端访问主从集群时，应该做好路由：</p><ul><li>如果是写操作，应该访问master节点，master会自动将数据同步给两个slave节点</li><li>如果是读操作，建议访问各个slave节点，从而分担并发压力</li><li>启动不同redis实例后，配置主从关系如下</li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment"># Redis5.0以前</span><br>slaveof <span class="hljs-variable">&lt;masterip&gt;</span> <span class="hljs-variable">&lt;masterport&gt;</span><br><span class="hljs-comment"># Redis5.0以后</span><br>replicaof <span class="hljs-variable">&lt;masterip&gt;</span> <span class="hljs-variable">&lt;masterport&gt;</span><br></code></pre></td></tr></table></figure><p>两个重要的概念：</p><ul><li>Replication Id：简称replid，是数据集的标记，replid一致则是同一数据集。<em>每个master都有唯一的replid，slave则会继承master节点的replid</em></li><li>offset：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li><li>RDB: Redis Database Backup，Redis数据库备份文件，是一个二进制文件，保存了某个时间点的Redis数据库的数据。</li></ul><p>全量同步：主从第一次建立连接时，执行全量同步，将master节点的所有数据都拷贝给slave节点<br />增量同步：全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高。因此除了第一次做全量同步，其它大多数时候slave与master都是做增量同步。</p><p>主从同步步骤：</p><ul><li>slave节点请求增量同步</li><li>master节点判断replid，发现不一致，拒绝增量同步，返回master的replid和offset</li><li>master将完整内存数据生成RDB，发送RDB到slave</li><li>slave清空本地数据，加载master的RDB</li><li>master将slave加载RDB期间的命令记录在repl_baklog，并将命令发送给slave</li><li>slave执行接收到的命令，保持与master之间的同步</li></ul><p>repl_baklog原理：<br />该文件是一个固定大小的数组，只不过数组是环形，也就是说角标到达数组末尾后，会再次从0开始读写，这样数组头部的数据就会被覆盖。该文件记录了redis处理过的命令，以及master和slave的offset，他们之间offset的差异，就是slave要增量拷贝的数据<br />随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset<br />如果slave出现网络阻塞，导致还没有同步的数据被覆盖，repl_baklog找不到slave的offset，那么只能再次做全量同步</p><p>什么时候执行增量同步？</p><ul><li>slave节点断开又恢复，并且在repl_baklog中能找到offset时</li></ul><p>可以从以下几个方面来优化Redis主从就集群：</p><ul><li>在master中配置<code>repl-diskless-sync  yes</code>启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul><h2 id="redis哨兵"><a class="markdownIt-Anchor" href="#redis哨兵"></a> Redis哨兵</h2><p>Redis提供了哨兵（Sentinel）机制来监控主从集群监控状态，确保集群的高可用性。<br />哨兵的作用如下：</p><ul><li>状态监控：Sentinel 会不断检查您的master和slave是否按预期工作</li><li>故障恢复（failover）：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后会成为slave</li><li>状态通知：Sentinel充当Redis客户端的服务发现来源，当集群发生failover时，会将最新集群信息推送给Redis的客户端</li></ul><p>sentinel如何监控？<br />Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个节点发送ping命令，并通过实例的响应结果来做出判断：</p><ul><li>主观下线（sdown）：如果某sentinel节点发现某Redis节点未在规定时间响应，则认为该节点主观下线。</li><li>客观下线(odown)：若超过指定数量（通过quorum设置）的sentinel都认为该节点主观下线，则该节点客观下线。quorum值最好超过Sentinel节点数量的一半，Sentinel节点数量至少3台。</li></ul><p>master出现故障如何处理？</p><ul><li>首先要在sentinel中选出一个leader，由leader执行failover(下面3步)</li><li>leader选定一个slave作为新的master，执行slaveof noone，切换到master模式</li><li>然后让所有节点都执行slaveof 新master</li><li>修改故障节点配置，添加slaveof 新master</li></ul><p>sentinel选举leader的依据是什么？</p><ul><li>票数超过sentinel节点数量1半</li><li>票数超过quorum数量</li><li>一般情况下最先发起failover的节点会当选</li></ul><p>leader从slave中选取master的依据是什么？</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过down-after-milliseconds * 10则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举（默认都是1）。</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的run_id大小，越小优先级越高（通过info server可以查看run_id）。</li></ul><h2 id="redis分片集群"><a class="markdownIt-Anchor" href="#redis分片集群"></a> Redis分片集群</h2><p>主从模式可以解决高可用、高并发读的问题。但依然有两个问题没有解决：</p><ul><li>海量数据存储</li><li>高并发写</li></ul><p>分片集群特征：</p><ul><li>集群中有多个master，每个master保存不同分片数据 ，解决海量数据存储问题</li><li>每个master都可以有多个slave节点 ，确保高可用</li><li>master之间通过ping监测彼此健康状态 ，类似哨兵作用</li><li>客户端请求可以访问集群任意节点，最终都会被转发到数据所在节点</li></ul><h3 id="散列插槽"><a class="markdownIt-Anchor" href="#散列插槽"></a> 散列插槽</h3><p>数据要分片存储到不同的Redis节点，肯定需要有分片的依据，这样下次查询的时候才能知道去哪个节点查询。<br />很多数据分片都会采用一致性hash算法。而Redis则是利用散列插槽（hash slot）的方式实现数据分片。</p><p>在Redis集群中，共有16384个hash slots，集群中的每一个master节点都会分配一定数量的hash slots。<br />当我们读写数据时，Redis基于<code>CRC16</code> 算法对key做hash运算，得到的结果与16384取余，就计算出了这个key的slot值。然后到slot所在的Redis节点执行读写操作。<br />不过hash slot的计算也分两种情况：</p><ul><li>当key中包含{}时，根据{}之间的字符串计算hash slot (key是user，则根据user来计算hash slot)</li><li>当key中不包含{}时，则根据整个key字符串计算hash slot (key是user:{age}，则根据age来计算hash slot)</li></ul><p>分片集群进行故障恢复时，互相通过ping的方式做心跳检测，超时未回应的节点会被标记为下线状态。当发现master下线时，会将这个master的某个slave提升为master。</p><p>Redis分片集群如何判断某个key应该在哪个实例？</p><ul><li>将16384个插槽分配到不同的实例</li><li>根据key计算哈希值，对16384取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul><p>如何将同一类数据固定的保存在同一个Redis实例？</p><ul><li>Redis计算key的插槽值时会判断key中是否包含{}，如果有则基于{}内的字符计算插槽</li><li>数据的key中可以加入{类型}，例如key都以{typeId}为前缀，这样同类型数据计算的插槽一定相同</li></ul><h2 id="redis数据结构"><a class="markdownIt-Anchor" href="#redis数据结构"></a> Redis数据结构</h2><p>常用的Redis数据类型有5种，分别是：String、List、Set、SortedSet、Hash<br />不管是任何一种数据类型，最终都会封装为RedisObject格式，它是一种结构体，包含了对象类型、编码方式、指向真实数据的指针等信息。</p><h3 id="skiplist"><a class="markdownIt-Anchor" href="#skiplist"></a> SkipList</h3><p>跳表的特点：</p><ul><li>跳表是一个有序的双向链表</li><li>每个节点可以包含多层指针,层数是1到32之间的随机数</li><li>不同层指针到下一个节点的跨度不同,层级越高,跨度越大</li><li>增删改查效率与红黑树基本一致,实现却更简单。但空间复杂度更高</li></ul><p>传统链表只有指向前后元素的指针，因此只能顺序依次访问。如果查找的元素在链表中间，查询的效率会比较低。而SkipList则不同，它内部包含跨度不同的多级指针，可以让我们跳跃查找链表中间的元素，效率非常高。<br />比如，某些元素含3个指针，每个指针跨度分别为4,5,6<br />多级指针的查询方式就避免了传统链表的逐个遍历导致的查询效率下降问题。在对有序数据做随机查询和排序时效率非常高。</p><p>跳表的结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplist</span> &#123;<br>    <span class="hljs-comment">// 头尾节点指针</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *header, *tail;<br>    <span class="hljs-comment">// 节点数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-comment">// 最大的索引层级</span><br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><p>跳表节点的数据机构:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> &#123;<br>    sds ele; <span class="hljs-comment">// 节点存储的字符串</span><br>    <span class="hljs-type">double</span> score;<span class="hljs-comment">// 节点分数，排序、查找用</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *backward; <span class="hljs-comment">// 前一个节点指针</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistLevel</span> &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *forward; <span class="hljs-comment">// 下一个节点指针</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span; <span class="hljs-comment">// 索引跨度</span><br>    &#125; level[]; <span class="hljs-comment">// 多级索引数组</span><br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><h3 id="sortedset"><a class="markdownIt-Anchor" href="#sortedset"></a> SortedSet</h3><p>SortedSet 数据结构的特点是：</p><ul><li>每组数据都包含 score 和 member</li><li>member 唯一</li><li>可根据 score 排序</li></ul><p>SortedSet的底层数据结构是怎样的？</p><ul><li>首先SortedSet需要能存储score和member值，而且要快捷的根据member查询score，因此底层有一个哈希表，以member为键，以score为value</li><li>其次SortedSet还需要能根据score排序，因此底层还维护了一个跳表。</li><li>当需要根据member查询score时，就去哈希表中查询；</li><li>当需要根据score排序查询时，则基于跳表查询</li></ul><p>因为SortedSet底层需要用到两种数据结构，对内存占用比较高。因此Redis底层会对SortedSet中的元素大小做判断，如果满足以下条件，则会采用ZipList(压缩列表)来代替：</p><ul><li>SortSet 保存的键值对数量少于 128 个；</li><li>每个元素的长度小于 64 字节。</li></ul><h3 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> Bitmap</h3><p>Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p><p>应用场景：<br />需要保存状态信息（0/1 即可表示）的场景，如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</p><p>使用 Bitmap 统计活跃用户怎么做？</p><ul><li>想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</li></ul><h2 id="redis内存回收"><a class="markdownIt-Anchor" href="#redis内存回收"></a> Redis内存回收</h2><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。<br />Redis内部会有两套内存回收的策略：</p><ul><li>内存过期策略</li><li>内存淘汰策略</li></ul><h3 id="内存过期策略"><a class="markdownIt-Anchor" href="#内存过期策略"></a> 内存过期策略</h3><p>Redis通过expire命令给Key设置TTL（Time To Live），当过期时间到了以后，再去查询数据，会发现数据已经不存在了。</p><p>Redis如何判断KEY是否过期呢？<br />Redis的本身是键值型数据库，其所有数据都存在一个redisDB的结构体中，其中包含两个哈希表：</p><ul><li>dict：保存Redis中所有的键值对</li><li>expires：保存Redis中所有的设置了过期时间的KEY及其到期时间（写入时间+TTL）<br />所以可以去expires查询过期时间即可</li></ul><p>TTL到期就会立即删除Key吗？<br />Redis并不会实时监测key的过期时间，在key过期后立刻删除。而是采用两种延迟删除的策略：<br />惰性删除：当有命令需要操作一个key的时候，检查该key的存活时间，如果已经过期才执行删除。<br />周期删除：通过一个定时任务，周期性的抽样部分有TTL的key，如果过期则执行删除。</p><p>周期删除的定时任务执行周期有两种：<br />SLOW模式：默认执行频率为每秒10次，但每次执行时长不能超过25ms，受server.hz参数影响。<br />FAST模式：频率不固定，跟随Redis内部IO事件循环执行。两次任务之间间隔不低于2ms，执行时长不超过1ms。</p><h3 id="内存淘汰策略"><a class="markdownIt-Anchor" href="#内存淘汰策略"></a> 内存淘汰策略</h3><p>仅仅依靠过期KEY清理是不够的，内存可能很快就达到上限。因此Redis允许设置内存告警阈值，当内存使用达到阈值时就会主动挑选部分KEY删除以释放更多内存。这叫做内存淘汰机制。<br />内存淘汰的策略有：<br />Redis支持8种不同的内存淘汰策略：</p><ul><li><p>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</p></li><li><p>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</p></li><li><p>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</p></li><li><p>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</p></li><li><p>allkeys-lru： 对全体key，基于LRU算法进行淘汰</p></li><li><p>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</p></li><li><p>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</p></li><li><p>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰</p></li><li><p>LRU（Least Recently Used），最近最久未使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p></li><li><p>LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</p></li></ul><p>RedisObject中有lru属性，用于记录最后一次访问时间或者访问频率，选择LRU和LFU时这个属性的意义不同</p><ul><li>LRU：以秒为单位记录最近一次访问时间，长度24bit</li><li>LFU：高16位以分钟为单位记录最近一次访问时间，低8位记录逻辑访问次数</li></ul><p>之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：</p><ul><li>① 生成<code>[0,1)</code>之间的随机数R</li><li>② 计算 <code>1/(旧次数 * lfu_log_factor + 1)</code>，记录为P， lfu_log_factor默认为10</li><li>③ 如果 <code>R &lt; P</code> ，则计数器 +1，且最大不超过255</li><li>④ 访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟(默认1) ，计数器-1<br />逻辑访问次数越大，说明单位时间内访问次数越多，所以更能<strong>反应Key的重要性</strong></li></ul><h2 id="redis缓存"><a class="markdownIt-Anchor" href="#redis缓存"></a> Redis缓存</h2><h3 id="缓存一致性"><a class="markdownIt-Anchor" href="#缓存一致性"></a> 缓存一致性</h3><p>缓存的通用模型有三种：</p><ul><li>Cache Aside（用的最多）：有缓存调用者自己维护数据库与缓存的一致性。即：<ul><li>查询时：命中则直接返回，未命中则查询数据库并写入缓存</li><li>更新时：更新数据库并直接删除缓存，有查询时再更新缓存</li></ul></li><li>Read/Write Through：数据库自己维护一份缓存，底层实现对调用者透明。底层实现：<ul><li>查询时：命中则直接返回，未命中则查询数据库并写入缓存</li><li>更新时：判断缓存是否存在，不存在直接更新数据库。存在则更新缓存，同步更新数据库</li></ul></li><li>Write Behind Cahing：读写操作都直接操作缓存，由线程异步的将缓存数据同步到数据库</li></ul><p>更新时先更新数据库再删除缓存还是先删除缓存再更新数据库？</p><ul><li>如果先删除缓存再更新数据库，假如刚删除缓存，来了一个查询请求，那么查询请求会发现缓存不存在，就会去数据库查询，这时数据库还没有更新，查询到的数据是旧数据，然后将旧数据写入缓存，然后此时数据库更新了，缓存还是旧数据。就会导致不一致。</li><li>如果先更新数据库再删除缓存，也有异常情况，比如线程1查询缓存未命中，于是去查询数据库，查询到旧数据，线程1将数据写入缓存之前，线程2来了，更新数据库，删除缓存，线程1执行写入缓存的操作，写入旧数据。这样也会不一致。</li></ul><p>但是先更新数据库再删除缓存异常情况发生的条件极为苛刻，需要线程1写入缓存之前，线程2完成更新数据库和删除缓存两个操作，所以很难触发不一致的情况。</p><p>缓存一致性策略的最佳实践方案：</p><ol><li>低一致性需求：使用Redis的key过期清理方案</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案<ul><li>读操作：<ul><li>缓存命中则直接返回</li><li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li></ul></li><li>写操作：<ul><li>先写数据库，然后再删除缓存</li><li>要确保数据库与缓存操作的原子性</li></ul></li></ul></li></ol><h3 id="缓存穿透"><a class="markdownIt-Anchor" href="#缓存穿透"></a> 缓存穿透</h3><p>缓存穿透是指客户端请求的数据在数据库中也不存在，从而导致请求穿透缓存，无法建立缓存，永远直接请求数据库的问题。<br />假如有不怀好意的人，开启很多线程频繁的访问一个数据库中也不存在的数据。由于缓存不可能生效，那么所有的请求都访问数据库，可能就会导致数据库因过高的压力而宕机。</p><p>解决方案有两种：</p><p><strong>缓存空对象</strong><br />当数据库也不存在数据时，将空值缓存到Redis，避免频繁查询数据库。优点是实现简单，维护方便，缺点是额外的内存消耗</p><p><strong>布隆过滤器</strong><br />布隆过滤是一种数据统计的算法，用于检索一个元素是否存在一个集合中。但是布隆过滤无需存储元素到集合，而是把元素映射到一个很长的二进制数位上。</p><ul><li>首先需要一个很长很长的二进制数，默认每一位都是0</li><li>然后需要N个不同算法的哈希函数</li><li>将集合中的元素根据N个哈希函数做运算，得到N个数字，然后将每个数字对应的bit位标记为1</li><li>要判断某个元素是否存在，只需要把元素按照上述方式运算，判断对应的bit位是否是1即可</li></ul><p>布隆过滤器的特点</p><ul><li>当布隆过滤器认为元素不存在时，它肯定不存在</li><li>当布隆过滤器认为元素存在时，它可能存在，也可能不存在（存在哈希碰撞）</li></ul><h3 id="缓存雪崩"><a class="markdownIt-Anchor" href="#缓存雪崩"></a> 缓存雪崩</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>常见的解决方案有：</p><ul><li>给不同的Key的TTL添加随机值，这样KEY的过期时间不同，不会大量KEY同时过期</li><li>利用Redis集群提高服务的可用性，避免缓存服务宕机</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存（如浏览器级别缓存、nginx级别缓存、jvm本地缓存等），比如先查询本地缓存，本地缓存未命中再查询Redis，Redis未命中再查询数据库。即便Redis宕机，也还有本地缓存可以抗压力</li></ul><h3 id="缓存击穿"><a class="markdownIt-Anchor" href="#缓存击穿"></a> 缓存击穿</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁：给重建缓存逻辑加锁，避免多线程同时指向</li><li>逻辑过期：热点key不要设置过期时间，在活动结束后手动删除。</li></ul><p>如何保证缓存的双写一致性？<br />答：缓存的双写一致性很难保证强一致，只能尽可能降低不一致的概率，确保最终一致。我们项目中采用的是Cache Aside模式。简单来说，就是在更新数据库之后删除缓存；在查询时先查询缓存，如果未命中则查询数据库并写入缓存。同时我们会给缓存设置过期时间作为兜底方案，如果真的出现了不一致的情况，也可以通过缓存过期来保证最终一致。</p><p>追问：为什么不采用延迟双删机制？<br />答：延迟双删的第一次删除并没有实际意义，第二次采用延迟删除主要是解决数据库主从同步的延迟问题，我认为这是数据库主从的一致性问题，与缓存同步无关。既然主节点数据已经更新，Redis的缓存理应更新。而且延迟双删会增加缓存业务复杂度，也没能完全避免缓存一致性问题，投入回报比太低。</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>删除链表中的重复元素</title>
    <link href="/2024/10/12/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/2024/10/12/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="删除链表中的重复元素"><a class="markdownIt-Anchor" href="#删除链表中的重复元素"></a> 删除链表中的重复元素</h2><!-- TOC --><ul><li><a href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">删除链表中的重复元素</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2,3,3,4,4,5]</span><br>输出：<span class="hljs-comment">[1,2,5]</span><br><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>创建一个哨兵节点dummy,然后使得<code>dummy-&gt;next</code>指向<code>head</code>，<code>cur</code>指向<code>dummy</code>，当<code>cur-&gt;next</code>和<code>cur-&gt;next-&gt;next</code>不为空时：</p><ul><li>如果<code>cur-&gt;next-&gt;val</code>和<code>cur-&gt;next-&gt;next-&gt;val</code>相等，记录这个值为x,当<code>cur-&gt;next-&gt;val</code>等于x时，<code>cur-&gt;next=cur-&gt;next-&gt;next</code>，跳过重复的元素</li><li>否则,<code>cur=cur-&gt;next</code></li><li>最后返回<code>dummy-&gt;next</code>即可</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xl">class Solution &#123;<br>public:<br>    ListNode* deleteDuplicates(ListNode* head) &#123;<br>        <span class="hljs-keyword">if</span>(head==nullptr)<br>            return head;<br>        ListNode* dummy=new ListNode(-<span class="hljs-number">1</span>,head);<br>        ListNode* cur=dummy;<br>        <span class="hljs-function"><span class="hljs-title">while</span>(cur-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>&amp;&amp;cur-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>next)&#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span>(cur-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">val</span>==cur-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>val)&#123;<br>                <span class="hljs-function"><span class="hljs-title">int</span> x=cur-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>val;<br>                <span class="hljs-function"><span class="hljs-title">while</span>(cur-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>&amp;&amp;cur-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>val==x)&#123;<br>                    <span class="hljs-function"><span class="hljs-title">cur</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=cur-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>next;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-function"><span class="hljs-title">cur</span>=cur-&gt;</span>next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">return</span> dummy-&gt;</span>next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最小覆盖子串</title>
    <link href="/2024/10/05/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <url>/2024/10/05/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="最小覆盖子串"><a class="markdownIt-Anchor" href="#最小覆盖子串"></a> 最小覆盖子串</h2><!-- TOC --><ul><li><a href="#%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2">最小覆盖子串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：</p><p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br />如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>e.g.</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题主要思路是滑动窗口。创建两个哈希表用来统计s某区间内的子串是否能覆盖t。然后开始滑动窗口，不断扩充右边界，每当能覆盖时，收缩左边界，并更新答案即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=s.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; sp,tp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:t)&#123;<br>            ++tp[c];<br>        &#125; <br>        function&lt;<span class="hljs-type">bool</span>()&gt; check=[&amp;]()&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> m:tp)&#123;<br>                <span class="hljs-keyword">if</span>(m.second&gt;sp[m.first])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res=INT_MAX,resl=<span class="hljs-number">-1</span>,resr=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(r&lt;n)&#123;<br>            ++sp[s[r]];<br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">check</span>()&amp;&amp;l&lt;=r)&#123;<br>                <span class="hljs-type">int</span> len=r-l+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(len&lt;res)&#123;<br>                    res=len;<br>                    resl=l;<br>                    resr=r;<br>                &#125;<br>                --sp[s[l]];<br>                ++l;<br>            &#125;<br>            ++r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resl==<span class="hljs-number">-1</span>? <span class="hljs-string">&quot;&quot;</span>:s.<span class="hljs-built_in">substr</span>(resl,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>克隆图</title>
    <link href="/2024/09/29/%E5%85%8B%E9%9A%86%E5%9B%BE/"/>
    <url>/2024/09/29/%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="克隆图"><a class="markdownIt-Anchor" href="#克隆图"></a> 克隆图</h2><!-- TOC --><ul><li><a href="#%E5%85%8B%E9%9A%86%E5%9B%BE">克隆图</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/clone-graph/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p><p>图中的每个节点都包含它的值 val（int） 和其邻居的列表</p><p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。</p><p>邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p><p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题主要是实现深拷贝，主要思路是递归。首先用一个哈希表记录节点是否访问过，然后克隆当前节点(new一个新内存)，并在哈希表中记录该节点，然后遍历所有邻居，将当前节点的邻居拷贝给克隆节点。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class Solution &#123;<br>public:<br>    unordered_map<span class="hljs-tag">&lt;Node*, Node*&gt;</span> mp;<br>    <span class="hljs-keyword">Node</span><span class="hljs-title">* cloneGraph</span>(<span class="hljs-keyword">Node</span><span class="hljs-title">* node</span>) &#123;<br>        if(<span class="hljs-keyword">node</span><span class="hljs-title">==nullptr</span>)<br>            return <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">        if</span>(mp.count(<span class="hljs-keyword">node</span><span class="hljs-title">))</span><br><span class="hljs-title">            return</span> mp[<span class="hljs-keyword">node</span><span class="hljs-title">];</span><br><span class="hljs-title">        Node</span>* <span class="hljs-attr">clone=</span>new <span class="hljs-keyword">Node</span><span class="hljs-title">(node-</span>&gt;val);<br>        mp[<span class="hljs-keyword">node</span><span class="hljs-title">]=clone</span>;<br>        for(auto t:<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;neighbors</span>)&#123;<br>            clone-&gt;neighbors.push_back(cloneGraph(t));<br>        &#125;<br>        return clone;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分隔链表</title>
    <link href="/2024/09/28/%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/09/28/%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="分隔链表"><a class="markdownIt-Anchor" href="#分隔链表"></a> 分隔链表</h2><!-- TOC --><ul><li><a href="#%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8">分隔链表</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/partition-list/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。<br />e.g.</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,4,3,2,5,2]</span>, x = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[1,2,2,4,3,5]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题思路还是比较简单的。创建两个链表，一个用来存储小于x的节点，一个用来存储大于x的节点，遍历完head后，将两个链表连接在一起即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    ListNode* partition(ListNode* head, int x) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-attribute">head</span>==nullptr)<br>            return head;<br>        ListNode* <span class="hljs-attribute">l</span>=new ListNode(0);<br>        ListNode* <span class="hljs-attribute">lh</span>=l;<br>        ListNode* <span class="hljs-attribute">r</span>=new ListNode(0);<br>        ListNode* <span class="hljs-attribute">rh</span>=r;<br>        <span class="hljs-keyword">while</span>(head!=nullptr)&#123;<br>            <span class="hljs-keyword">if</span>(head-&gt;val&gt;=x)&#123;<br>                r-&gt;<span class="hljs-attribute">next</span>=head;<br>                <span class="hljs-attribute">r</span>=r-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l-&gt;<span class="hljs-attribute">next</span>=head;<br>                <span class="hljs-attribute">l</span>=l-&gt;next;<br>            &#125;<br>            <span class="hljs-attribute">head</span>=head-&gt;next;<br>        &#125;<br>        r-&gt;<span class="hljs-attribute">next</span>=nullptr;<br>        l-&gt;<span class="hljs-attribute">next</span>=rh-&gt;next;<br>        return lh-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最长重复子串</title>
    <link href="/2024/09/27/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/"/>
    <url>/2024/09/27/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="最长重复子串"><a class="markdownIt-Anchor" href="#最长重复子串"></a> 最长重复子串</h2><!-- TOC --><ul><li><a href="#%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2">最长重复子串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#tips">tips</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/longest-duplicate-substring/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个字符串 s ，考虑其所有 重复子串 ：即 s 的（连续）子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。</p><p>返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 “” 。</p><p>e.g.</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;banana&quot;</span><br>输出：<span class="hljs-string">&quot;ana&quot;</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>参考大佬的题解，主要思路是字符串哈希 + 二分。用二分搜索数组的长度，然后check长度为len的子串是否重复出现，如果是，返回该子串，否则，返回空串。二分过程中如果返回空串，缩短长度继续二分，否则扩大长度继续二分。</p><p>现在难点在于如何在O(n)复杂度内执行check,这里用到字符串哈希：<br />创建数组h和p，P是一个质数(一般要尽可能大一点)<br />h：用于存储前缀哈希值的数组。<br />p：存储每个位置的幂次的数组，方便计算哈希值。<br />初始化:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">for (int i = 0; i &lt; n; i++) &#123;<br>            p<span class="hljs-comment">[i + 1]</span> = p<span class="hljs-comment">[i]</span> * P;<br>            h<span class="hljs-comment">[i + 1]</span> = h<span class="hljs-comment">[i]</span> * P + s<span class="hljs-comment">[i]</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p><code>h[i]</code>是子串从 第一个位置 到 第 i 个 的哈希值<br />从位置 i 到 j 的子串的哈希值的表达式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">h<span class="hljs-selector-attr">[j]</span> - h<span class="hljs-selector-attr">[i - 1]</span> * <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j - i + 1]</span><br></code></pre></td></tr></table></figure><p>把这些哈希值存在set里，可以判断子串是否重复出现</p><p>PS:大佬的java代码long long就能过，我写的c++用long long都会爆，必须用unsigned long long</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    typedef unsigned long long ULL;<br>    <span class="hljs-built_in">int</span> P=<span class="hljs-number">1313131</span>;<br>    vector&lt;ULL&gt; h,p;<br>    string check(string &amp;s,<span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span>)&#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>=s.size();<br>        unordered_set&lt;ULL&gt; st;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i+<span class="hljs-built_in">len</span>-<span class="hljs-number">1</span>&lt;=<span class="hljs-built_in">n</span>;++i)&#123;<br>            <span class="hljs-built_in">int</span> j=i+<span class="hljs-built_in">len</span>-<span class="hljs-number">1</span>;<br>            ULL <span class="hljs-built_in">t</span>=h[j]-h[i-<span class="hljs-number">1</span>]*p[j-i+<span class="hljs-number">1</span>];//i~j子串的哈希值<br>            <span class="hljs-built_in">if</span>(st.count(<span class="hljs-built_in">t</span>))<br>                return s.substr(i-<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>);<br>            st.insert(<span class="hljs-built_in">t</span>);<br>        &#125;<br>        return <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    string longestDupSubstring(string s) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>=s.size();<br>        h.resize(<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>);<br>        p.resize(<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>);<br>        p[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">n</span>;++i)&#123;<br>            p[i+<span class="hljs-number">1</span>]=p[i]*P;<br>            h[i+<span class="hljs-number">1</span>]=h[i]*P+s[i];<br>        &#125;<br>        <span class="hljs-built_in">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-built_in">n</span>;<br>        string ans;<br>        while(l&lt;r)&#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span>=l+(r-l)/<span class="hljs-number">2</span>;<br>            string <span class="hljs-built_in">t</span>=check(s,<span class="hljs-built_in">mid</span>);<br>            <span class="hljs-built_in">int</span> tlen=t.size();<br>            <span class="hljs-built_in">if</span>(tlen==<span class="hljs-number">0</span>)<br>                r=<span class="hljs-built_in">mid</span>;<br>            else<br>                l=<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>;<br>            ans=tlen&gt;ans.size()?<span class="hljs-symbol">t:an</span>s;<br>        &#125;<br>        return ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> tips</h3><p>最长公共子序列和最长公共子串的区别是：后者是连续的，当前字符不相等时<code>dp[i][j]=0</code></p>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>被围绕的区域</title>
    <link href="/2024/09/26/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/"/>
    <url>/2024/09/26/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="被围绕的区域"><a class="markdownIt-Anchor" href="#被围绕的区域"></a> 被围绕的区域</h2><!-- TOC --><ul><li><a href="#%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F">被围绕的区域</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/surrounded-regions/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ 组成，捕获 所有 被围绕的区域：</p><p>连接：一个单元格与水平或垂直方向上相邻的单元格连接。<br />区域：连接所有 ‘O’ 的单元格来形成一个区域。<br />围绕：如果您可以用 ‘X’ 单元格 连接这个区域，并且区域中没有任何单元格位于 board 边缘，则该区域被 ‘X’ 单元格围绕。<br />通过将输入矩阵 board 中的所有 ‘O’ 替换为 ‘X’ 来 捕获被围绕的区域。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>]]<br><br>输出：[[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>]]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>对边缘的所有<code>O</code>进行DFS，将其修改为<code>B</code>，然后遍历整个矩阵，将<code>O</code>改为<code>X</code>，<code>B</code>改为<code>O</code>即可</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs prolog">class <span class="hljs-symbol">Solution</span> &#123;<br>public:<br>    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;<br>        int m=board.size(),n=board[<span class="hljs-number">0</span>].size();<br>        function&lt;void(int,int)&gt; dfs=[&amp;](int x,int y)&#123;<br>            board[x][y]=<span class="hljs-string">&#x27;B&#x27;</span>;<br>            if(x+<span class="hljs-number">1</span>&lt;m&amp;&amp;board[x+<span class="hljs-number">1</span>][y]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                dfs(x+<span class="hljs-number">1</span>,y);<br>            if(y<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;board[x][y<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                dfs(x,y<span class="hljs-number">-1</span>);<br>            if(x<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;board[x<span class="hljs-number">-1</span>][y]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                dfs(x<span class="hljs-number">-1</span>,y);<br>            if(y+<span class="hljs-number">1</span>&lt;n&amp;&amp;board[x][y+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                dfs(x,y+<span class="hljs-number">1</span>);<br>        &#125;;<br>        for(int i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br>            if(board[i][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                dfs(i,<span class="hljs-number">0</span>);<br>            if(board[i][n<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                dfs(i,n<span class="hljs-number">-1</span>);<br>        &#125;<br>        for(int j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>            if(board[<span class="hljs-number">0</span>][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                dfs(<span class="hljs-number">0</span>,j);<br>            if(board[m<span class="hljs-number">-1</span>][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                dfs(m<span class="hljs-number">-1</span>,j);<br>        &#125;<br>        for(int i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;<br>            for(int j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                if(board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;X&#x27;</span>;<br>                else if(board[i][j]==<span class="hljs-string">&#x27;B&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;O&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>引爆气球</title>
    <link href="/2024/09/25/%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/"/>
    <url>/2024/09/25/%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</url>
    
    <content type="html"><![CDATA[<h2 id="引爆气球"><a class="markdownIt-Anchor" href="#引爆气球"></a> 引爆气球</h2><!-- TOC --><ul><li><a href="#%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83">引爆气球</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[10,16]</span>,<span class="hljs-comment">[2,8]</span>,<span class="hljs-comment">[1,6]</span>,<span class="hljs-comment">[7,12]</span>]</span><br>输出：2<br>解释：气球可以用2支箭来爆破:<br>-在x = 6处射出箭，击破气球<span class="hljs-comment">[2,8]</span>和<span class="hljs-comment">[1,6]</span>。<br>-在x = 11处发射箭，击破气球<span class="hljs-comment">[10,16]</span>和<span class="hljs-comment">[7,12]</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这题一眼排序，但可惜我排成左端点了😅。先对所有区间按右端点升序排序，然后每当有左端点大于上一个右端点tmp是，更新答案，更新tmp。<br />按左端点排序的话<code>[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]</code>过不了。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=points.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(),points.<span class="hljs-built_in">end</span>(),[&amp;](vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&lt;b[<span class="hljs-number">0</span>];<br>        &#125;);<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> tmp=points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>]&gt;tmp)&#123;<br>                ++res;<br>                tmp=points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>除法求值</title>
    <link href="/2024/09/24/%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
    <url>/2024/09/24/%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="除法求值"><a class="markdownIt-Anchor" href="#除法求值"></a> 除法求值</h2><!-- TOC --><ul><li><a href="#%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC">除法求值</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/evaluate-division/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p><p>另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。</p><p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。</p><p>注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p><p>注意：未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：equations = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]], values = [<span class="hljs-number">2.0</span>,<span class="hljs-number">3.0</span>], queries = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>],[<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>],[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>],[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>],[<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>]]<br>输出：[<span class="hljs-number">6.00000</span>,<span class="hljs-number">0.50000</span>,<span class="hljs-number">-1.00000</span>,<span class="hljs-number">1.00000</span>,<span class="hljs-number">-1.00000</span>]<br>解释：<br>条件：a / b = <span class="hljs-number">2.0</span>, b / c = <span class="hljs-number">3.0</span><br>问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?<br>结果：[<span class="hljs-number">6.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">-1.0</span> ]<br>注意：x 是未定义的 =&gt; <span class="hljs-number">-1.0</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题参考了评论区大佬的思路，非常简洁清晰。用一个set记录所有出现过的字符串，然后用一个map保存两个字符串间的运算结果，如字符串a除以b可表示为mp[a][b]。<br />接下来，对于字符串之间的运算，采用Floyd算法，遍历set中的字符串，如果<code>mp[i][k] &amp;&amp; mp[k][j]</code>，那么可以计算得到<code>mp[i][j]=mp[i][k]*mp[k][j];</code>，对于query中的字符串<code>(a,b)</code>，若<code>mp[a][b]</code>不为0,则返回对应的值，若为0则返回-1。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">calcEquation</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="hljs-type">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=equations.<span class="hljs-built_in">size</span>();<br>        unordered_set&lt;string&gt; s;<br>        unordered_map&lt;string, unordered_map&lt;string, <span class="hljs-type">double</span>&gt;&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            string a=equations[i][<span class="hljs-number">0</span>],b=equations[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">double</span> c=values[i];<br>            mp[a][b]=c;<br>            mp[b][a]=<span class="hljs-number">1.0</span>/c;<br>            s.<span class="hljs-built_in">insert</span>(a);<br>            s.<span class="hljs-built_in">insert</span>(b);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(string k:s)&#123;<br>            <span class="hljs-keyword">for</span>(string i:s)&#123;<br>                <span class="hljs-keyword">for</span>(string j:s)&#123;<br>                    <span class="hljs-keyword">if</span>(mp[i][k] &amp;&amp; mp[k][j])&#123;<br>                        mp[i][j]=mp[i][k]*mp[k][j];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">double</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;t:queries)&#123;<br>            string a=t[<span class="hljs-number">0</span>],b=t[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(mp[a][b])<br>                res.<span class="hljs-built_in">push_back</span>(mp[a][b]);<br>            <span class="hljs-keyword">else</span><br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1.0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>寻找旋转排序数组中的最小值</title>
    <link href="/2024/09/23/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <url>/2024/09/23/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="寻找旋转排序数组中的最小值"><a class="markdownIt-Anchor" href="#寻找旋转排序数组中的最小值"></a> 寻找旋转排序数组中的最小值</h2><!-- TOC --><ul><li><a href="#%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC">寻找旋转排序数组中的最小值</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br />若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br />若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br />注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p><p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><p>e.g.</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要思路是二分查找，数组经过旋转之后左右两部分是升序的，当mid比r大时收缩左边界，当mid比r小时收缩右边界即可。</p><p>这里顺便记录一下二分查找的模板:</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment">//找出数组中第一个大于等于target的下标，左闭右开[l,r)</span><br><span class="hljs-type">int</span> lower_bound(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> taget)&#123;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>, r=nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid]&lt;<span class="hljs-built_in">target</span>)<br>            l=mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            r=mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    int findMin(vector&lt;int&gt;&amp; nums) &#123;<br>        int <span class="hljs-attribute">n</span>=nums.size();<br>        int <span class="hljs-attribute">l</span>=0;<br>        int <span class="hljs-attribute">r</span>=n-1;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            int <span class="hljs-attribute">mid</span>=l+(r-l)/2;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[r])<br>                <span class="hljs-attribute">l</span>=mid+1;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-attribute">r</span>=mid;<br>        &#125;<br>        return nums[l];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树构造</title>
    <link href="/2024/09/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9E%84%E9%80%A0/"/>
    <url>/2024/09/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9E%84%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">前序中序构造二叉树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E5%90%8E%E5%BA%8F%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">后序中序构造二叉树</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="前序中序构造二叉树"><a class="markdownIt-Anchor" href="#前序中序构造二叉树"></a> 前序中序构造二叉树</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: preorder = <span class="hljs-string">[3,9,20,15,7]</span>, inorder = <span class="hljs-string">[9,3,15,20,7]</span><br>输出: <span class="hljs-string">[3,9,20,null,null,15,7]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>首先用一个全局的哈希表记录inorder中各元素的下标，用idx表示在preorder中根节点的下标，idx初始为0。定义builder函数递归构建二叉树：</p><ul><li>根据idx获取根节点的值rootVal</li><li>根据rootVal在哈希表中获取inoder中的下标index</li><li>++idx</li><li>构建左子树，builder(l,index-1,preorder,inorder);</li><li>构建右子树，builder(index+1,r,preorder,inorder);</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-type">int</span> idx;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">builder</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(l&gt;r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> rootVal=preorder[idx];<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootVal);<br>        <span class="hljs-type">int</span> index=mp[rootVal];<br>        idx++;<br>        root-&gt;left=<span class="hljs-built_in">builder</span>(l,index<span class="hljs-number">-1</span>,preorder,inorder);<br>        root-&gt;right=<span class="hljs-built_in">builder</span>(index+<span class="hljs-number">1</span>,r,preorder,inorder);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=preorder.<span class="hljs-built_in">size</span>();<br>        idx=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>            mp[inorder[i]]=i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">builder</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,preorder,inorder);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="后序中序构造二叉树"><a class="markdownIt-Anchor" href="#后序中序构造二叉树"></a> 后序中序构造二叉树</h2><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>整体思路与上面相同，注意idx初始化值(n-1)与构建顺序</p><ul><li>根据idx获取根节点的值rootVal</li><li>根据rootVal在哈希表中获取inoder中的下标index</li><li>–idx</li><li>构建右子树，builder(index+1,r,postorder,inorder);</li><li>构建左子树，builder(l,index-1,postorder,inorder);</li></ul><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-type">int</span> idx;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">builder</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(l&gt;r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> rootVal=postorder[idx];<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootVal);<br>        <span class="hljs-type">int</span> index=mp[rootVal];<br>        idx--;<br>        root-&gt;right=<span class="hljs-built_in">builder</span>(index+<span class="hljs-number">1</span>,r,postorder,inorder);<br>        root-&gt;left=<span class="hljs-built_in">builder</span>(l,index<span class="hljs-number">-1</span>,postorder,inorder);<br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=postorder.<span class="hljs-built_in">size</span>();<br>        idx=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>            mp[inorder[i]]=i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">builder</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,postorder,inorder);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>简化路径</title>
    <link href="/2024/09/21/%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/09/21/%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="简化路径"><a class="markdownIt-Anchor" href="#简化路径"></a> 简化路径</h2><!-- TOC --><ul><li><a href="#%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84">简化路径</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/simplify-path/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘/’ 开头），请你将其转化为 更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中规则如下：</p><p>一个点 ‘.’ 表示当前目录本身。<br />此外，两个点 ‘…’ 表示将目录切换到上一级（指向父目录）。<br />任意多个连续的斜杠（即，‘//’ 或 ‘///’）都被视为单个斜杠 ‘/’。<br />任何其他格式的点（例如，‘…’ 或 ‘…’）均被视为有效的文件/目录名称。<br />返回的 简化路径 必须遵循下述格式：</p><p>始终以斜杠 ‘/’ 开头。<br />两个目录名之间必须只有一个斜杠 ‘/’ 。<br />最后一个目录名（如果存在）不能 以 ‘/’ 结尾。<br />此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘…’）。<br />返回简化后得到的 规范路径 。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/home//foo/&quot;</span><br><br>输出：<span class="hljs-string">&quot;/home/foo&quot;</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>先按<code>/</code>分割字符串，这个python一行就搞定了。然后将分割后的数组按规则入栈：</p><ul><li>如果为<code>..</code>，则弹出栈顶字符串</li><li>如果为空或者为<code>.</code>，则跳过</li><li>其他情况入栈</li></ul><p>最后遍历栈内字符串元素，将他们拼接。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">string</span> simplifyPath(<span class="hljs-keyword">string</span> path) &#123;<br>        auto split=[&amp;](<span class="hljs-keyword">string</span>&amp; s, <span class="hljs-keyword">char</span> c)-&gt;vector&lt;<span class="hljs-keyword">string</span>&gt;&#123;<br>            vector&lt;<span class="hljs-keyword">string</span>&gt; res;<br>            <span class="hljs-keyword">string</span> cur;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> t:s)&#123;<br>                <span class="hljs-keyword">if</span>(t==c)&#123;<br>                    res.push_back(cur);<br>                    cur.clear();<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    cur+=t;<br>                &#125;<br>            &#125;<br>            res.push_back(cur);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        vector&lt;<span class="hljs-keyword">string</span>&gt; sr=split(path,<span class="hljs-string">&#x27;/&#x27;</span>);<br>        vector&lt;<span class="hljs-keyword">string</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">string</span>&amp; t: sr)&#123;<br>            <span class="hljs-keyword">if</span>(t==<span class="hljs-string">&quot;..&quot;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(!st.<span class="hljs-keyword">empty</span>())<br>                    st.pop_back();<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!t.<span class="hljs-keyword">empty</span>()&amp;&amp;t!=<span class="hljs-string">&quot;.&quot;</span>)<br>                st.push_back(t);<br>        &#125;<br>        <span class="hljs-keyword">string</span> ans;<br>        <span class="hljs-keyword">if</span>(st.<span class="hljs-keyword">empty</span>())<br>            ans+=<span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">string</span> t: st)<br>                ans+=<span class="hljs-string">&#x27;/&#x27;</span>+t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>有效的数独</title>
    <link href="/2024/09/20/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    <url>/2024/09/20/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="有效的数独"><a class="markdownIt-Anchor" href="#有效的数独"></a> 有效的数独</h2><!-- TOC --><ul><li><a href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC">有效的数独</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/valid-sudoku/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。<br />数字 1-9 在每一列只能出现一次。<br />数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = <br>[[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>,[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>,[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br>输出：true<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用三个数组分别表示每行每列，每个九宫格的数字摆放情况：</p><ul><li>row[i][num]，第i行数字num+1出现的次数</li><li>col[j][num]，第j列数字num+1出现的次数</li><li>box[i/3][j/3][num]，对应小九宫格内的数字num+1出现的次数</li></ul><p>每次填入数字后，若出现次数大于2,则返回false即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs prolog">class <span class="hljs-symbol">Solution</span> &#123;<br>public:<br>    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;<br>        int rows[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>        int cols[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>        int box[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">9</span>];<br>        memset(rows,<span class="hljs-number">0</span>,sizeof(rows));<br>        memset(cols,<span class="hljs-number">0</span>,sizeof(cols));<br>        memset(box,<span class="hljs-number">0</span>,sizeof(box));<br>        char c;<br>        int t;<br>        for(int i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;++i)&#123;<br>            for(int j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j)&#123;<br>                c=board[i][j];<br>                if(c!=<span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                    t=c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                    ++rows[i][t<span class="hljs-number">-1</span>];<br>                    ++cols[j][t<span class="hljs-number">-1</span>];<br>                    ++box[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][t<span class="hljs-number">-1</span>];<br>                    if(rows[i][t<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">1</span>||cols[j][t<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">1</span>||box[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][t<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">1</span>)<br>                        return false;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return true;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最长连续序列</title>
    <link href="/2024/09/18/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <url>/2024/09/18/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="最长连续序列"><a class="markdownIt-Anchor" href="#最长连续序列"></a> 最长连续序列</h2><!-- TOC --><ul><li><a href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97">最长连续序列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[100,4,200,1,3,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 <span class="hljs-string">[1, 2, 3, 4]</span>。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>之前做过，不过用的是暴力排序的方法，能过但是不是O(n)时间复杂度。这道题可以先用一个哈希表保存所有数字，对于数字n，如果n-1不存在，那么n可以作为一个连续数组的起点，于是当n+1存在时，可以遍历下去，求出n为起点的最长连续序列长度。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;t:nums)<br>            st.<span class="hljs-built_in">insert</span>(t);<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>, len=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;t:nums)&#123;<br>            <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">count</span>(t<span class="hljs-number">-1</span>))&#123;<br>                tmp=t;<br>                len=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">count</span>(tmp+<span class="hljs-number">1</span>))&#123;<br>                    ++tmp;<br>                    ++len;<br>                &#125;<br>                ans=<span class="hljs-built_in">max</span>(ans,len);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最小编辑距离</title>
    <link href="/2024/09/17/%E6%9C%80%E5%B0%8F%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2024/09/17/%E6%9C%80%E5%B0%8F%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="最小编辑距离"><a class="markdownIt-Anchor" href="#最小编辑距离"></a> 最小编辑距离</h2><!-- TOC --><ul><li><a href="#%E6%9C%80%E5%B0%8F%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">最小编辑距离</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/edit-distance/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br />删除一个字符<br />替换一个字符</p><p>e.g.</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">horse</span> -&gt;</span> rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rorse</span> -&gt;</span> rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rose</span> -&gt;</span> ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>经典的动态规划问题。dp[i][j]表示s1的前i个字符和s2的前j个字符的最小编辑距离。当前字符不相等时，考虑插入、删除、替换3种情况，需要的次数分别是<code>dp[i][j-1]+1, dp[i-1][j]+1, dp[i-1][j-1]+1</code>，所以状态方程为：<br /><code>dp[i][j]=min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1])+1;</code><br />当前字符不相等时，替换操作无需增加操作数，因此状态方程为<br /><code>dp[i][j]=min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]-1)+1;</code></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int minDistance(string word1, string word2) &#123;<br>        int m=word1.size(),n=word2.size();<br>        if(m==0||n==0)<br>            return n+m;<br>        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt; (n+1));<br>        for(int i=0;i&lt;=m;++i)<br>            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>=i;<br>        for(int j=0;j&lt;=n;++j)<br>            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span>=j;<br>        for(int i=1;i&lt;=m;++i)&#123;<br>            for(int j=1;j&lt;=n;++j)&#123;<br>                if(word1<span class="hljs-comment">[i-1]</span>==word2<span class="hljs-comment">[j-1]</span>)<br>                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=min(min(dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>,dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>),dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>-1)+1;<br>                else<br>                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=min(min(dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>,dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>),dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>)+1;<br>            &#125;<br>        &#125;<br>        return dp<span class="hljs-comment">[m]</span><span class="hljs-comment">[n]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>找到所有字母异位词</title>
    <link href="/2024/09/16/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <url>/2024/09/16/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="找到所有字母异位词"><a class="markdownIt-Anchor" href="#找到所有字母异位词"></a> 找到所有字母异位词</h2><!-- TOC --><ul><li><a href="#%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D">找到所有字母异位词</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p>e.g.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>一道滑动窗口的题。首先要判断s中是否存在字母异位词，只需要保证s的子串<code>s1.size()==p.size()</code>且两个字符串中字母出现次数相等即可</p><p>所以，可以用两个数组vs和vp记录字母的出现情况</p><p>下来开始滑窗，枚举s的左端点，然后向右扩展右端点，当子串长度不超过<code>p.size()</code>且<code>vs!=vp</code>时，++r，并且更新vs数组，每当<code>vs==vp</code>，将当前左端点l加入ans</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vs</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vp</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:p)<br>            vp[c-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-type">int</span> slen=s.<span class="hljs-built_in">size</span>(), plen=p.<span class="hljs-built_in">size</span>(), r=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;l&lt;slen&amp;&amp;r&lt;slen;++l)&#123;<br>            <span class="hljs-keyword">if</span>(l!=<span class="hljs-number">0</span>)<br>                --vs[s[l<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]; <br>            <span class="hljs-keyword">while</span>(r&lt;slen &amp;&amp; r-l+<span class="hljs-number">1</span>&lt;=plen)&#123;<br>                ++vs[s[r]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>                ++r;<br>                <span class="hljs-keyword">if</span>(vs==vp)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(l);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LRU缓存</title>
    <link href="/2024/09/16/LRU%E7%BC%93%E5%AD%98/"/>
    <url>/2024/09/16/LRU%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="lru缓存"><a class="markdownIt-Anchor" href="#lru缓存"></a> LRU缓存</h2><!-- TOC --><ul><li><a href="#lru%E7%BC%93%E5%AD%98">LRU缓存</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/lru-cache/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br />实现 LRUCache 类：<br />LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br />int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br />void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br />函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[null, null, null, <span class="hljs-number">1</span>, null, <span class="hljs-number">-1</span>, null, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>一开始看到以O(1)时间复杂度运行，想到用一个数组和一个队列解决，但是实际上想得太简单了，忽略了一些复杂情况。官方题解用哈系表和双向队列解决，写的很复杂，我主要参考了评论区的大佬的思路。</p><p>首先定义一个结构体Node，包括Key, value, prev指针, next指针，用来代表一个双向链表中的节点。</p><p>对该结构体的操作有remove, push_front, get_node等<br /><strong>remove</strong><br />移除节点，更新首尾指针</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xl">void remove(Node *x)&#123;<br>        <span class="hljs-function"><span class="hljs-title">x</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=x-&gt;</span>next;<br>        <span class="hljs-function"><span class="hljs-title">x</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prev</span>=x-&gt;</span>prev;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>push_front</strong><br />队列头插入新节点</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">void push_front(Node *x)&#123;<br>        <span class="hljs-function"><span class="hljs-title">x</span>-&gt;</span>prev=dummy;<br>        <span class="hljs-function"><span class="hljs-title">x</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=dummy-&gt;</span>next;<br>        <span class="hljs-function"><span class="hljs-title">x</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">prev</span>-&gt;</span>next=x;<br>        <span class="hljs-function"><span class="hljs-title">x</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>prev=x;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>get_node</strong><br />模拟LRU中访问某个元素的操作，每当访问一个元素，若不存在返回空，存在则重新将它插入到头部</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">void push_front(Node *x)&#123;<br>        auto it<span class="hljs-operator">=</span>mp.find(key)<span class="hljs-comment">;</span><br>        if(it<span class="hljs-operator">=</span><span class="hljs-operator">=</span>mp.end())<br>            return nullptr<span class="hljs-comment">;</span><br>        Node *t<span class="hljs-operator">=</span>it-&gt;second<span class="hljs-comment">;</span><br>        remove(t)<span class="hljs-comment">;</span><br>        push_front(t)<span class="hljs-comment">;</span><br>        return t<span class="hljs-comment">;</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>定义一个哈系表<code>unordered_map&lt;int,Node*&gt;</code>保存每个key对应的Node，方便查询</p><p>定义一个哨兵节点dummy，<code>dummy-&gt;next</code>指向队列头，<code>dummy-&gt;prev</code>指向队列尾，初始化<code>dummy-&gt;next=dummy，dummy-&gt;prev=dummy</code></p><p>在get时，调用get_node，如果为空则返回-1,否则就返回对应value</p><p>在put时，同样调用get_node，若已存在则修改<code>node-&gt;value</code>即可;否则使用push_front插入新节点，然后若超出容量，删除<code>dummy-&gt;prev</code>指向的队列尾元素。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Node&#123;<br>public:<br>    int key,value;<br>    Node *prev,*next;<br>    Node(int <span class="hljs-attribute">k</span>=0, int <span class="hljs-attribute">v</span>=0) : key(k),value(v)&#123;&#125;<br>&#125;;<br><br>class LRUCache &#123;<br>private:    <br>    unordered_map&lt;int,Node*&gt; mp;<br>    Node <span class="hljs-number">*d</span>ummy;<br>    int sz;<br><br>    void <span class="hljs-built_in">remove</span>(Node *x)&#123;<br>        x-&gt;prev-&gt;<span class="hljs-attribute">next</span>=x-&gt;next;<br>        x-&gt;next-&gt;<span class="hljs-attribute">prev</span>=x-&gt;prev;<br>    &#125;<br><br>    void push_front(Node *x)&#123;<br>        x-&gt;<span class="hljs-attribute">prev</span>=dummy;<br>        x-&gt;<span class="hljs-attribute">next</span>=dummy-&gt;next;<br>        x-&gt;prev-&gt;<span class="hljs-attribute">next</span>=x;<br>        x-&gt;next-&gt;<span class="hljs-attribute">prev</span>=x;<br>    &#125;<br><br>    Node *get_node(int key)&#123;<br>        auto <span class="hljs-attribute">it</span>=mp.find(key);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-attribute">it</span>==mp.end())<br>            return nullptr;<br>        Node *<span class="hljs-attribute">t</span>=it-&gt;second;<br>        <span class="hljs-built_in">remove</span>(t);<br>        push_front(t);<br>        return t;<br>    &#125;<br><br>public:<br>    <br>    LRUCache(int capacity):sz(capacity)&#123;<br>        <span class="hljs-attribute">dummy</span>=new Node();<br>        dummy-&gt;<span class="hljs-attribute">prev</span>=dummy;<br>        dummy-&gt;<span class="hljs-attribute">next</span>=dummy;<br>    &#125;<br>    <br>    int <span class="hljs-built_in">get</span>(int key) &#123;<br>        Node *<span class="hljs-attribute">node</span>=get_node(key);<br>        return node ? node-&gt;value:-1; <br>    &#125;<br>    <br>    void put(int key, int value) &#123;<br>        Node *<span class="hljs-attribute">node</span>=get_node(key);<br>        <span class="hljs-keyword">if</span>(node)&#123;<br>            node-&gt;<span class="hljs-attribute">value</span>=value;<br>            return;<br>        &#125;<br>        node =new Node(key,value);<br>        mp[key]=node;<br>        push_front(node);<br>        <span class="hljs-keyword">if</span>(mp.size()&gt;sz)&#123;<br>            Node <span class="hljs-number">*bac</span><span class="hljs-attribute">k</span>=dummy-&gt;prev;<br>            mp.erase(back-&gt;key);<br>            <span class="hljs-built_in">remove</span>(back);<br>            delete back;<br>        &#125;<br>            <br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最小栈</title>
    <link href="/2024/09/15/%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2024/09/15/%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="最小栈"><a class="markdownIt-Anchor" href="#最小栈"></a> 最小栈</h2><!-- TOC --><ul><li><a href="#%E6%9C%80%E5%B0%8F%E6%A0%88">最小栈</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/min-stack/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 MinStack 类:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">MinStack</span>() 初始化堆栈对象。<br>void <span class="hljs-built_in">push</span>(int val) 将元素val推入堆栈。<br>void <span class="hljs-built_in">pop</span>() 删除堆栈顶部的元素。<br>int <span class="hljs-attribute">top</span>() 获取堆栈顶部的元素。<br>int <span class="hljs-built_in">getMin</span>() 获取堆栈中的最小元素。<br></code></pre></td></tr></table></figure><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MinStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;top&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>]<br>[[],[<span class="hljs-number">-2</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">-3</span>],[],[],[],[]]<br><br>输出：<br>[null,null,null,null,<span class="hljs-number">-3</span>,null,<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>]<br><br>解释：<br><span class="hljs-symbol">MinStack</span> minStack = new <span class="hljs-symbol">MinStack</span>();<br>minStack.push(<span class="hljs-number">-2</span>);<br>minStack.push(<span class="hljs-number">0</span>);<br>minStack.push(<span class="hljs-number">-3</span>);<br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-3.</span><br>minStack.pop();<br>minStack.top();      --&gt; 返回 <span class="hljs-number">0.</span><br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-2.</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题主要难点在于如何在常数时间内检索到最小元素。解决方法有点类似单调栈，重新开一个辅助栈，其栈顶元素为当前主栈内所有元素的最小值。每当push操作时，主栈直接插入，辅助栈将栈顶元素与要插入的元素进行对比，然后插入其中的较小的一个。pop操作时，两个栈同时pop，top操作主栈返回顶部元素，getMin()时辅助栈返回顶部元素。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    stack&lt;<span class="hljs-type">int</span>&gt; aux_st;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        aux_st.<span class="hljs-built_in">push</span>(INT_MAX);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        st.<span class="hljs-built_in">push</span>(val);<br>        aux_st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">min</span>(aux_st.<span class="hljs-built_in">top</span>(),val));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>        aux_st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> aux_st.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单词拆分</title>
    <link href="/2024/09/14/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
    <url>/2024/09/14/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="单词拆分"><a class="markdownIt-Anchor" href="#单词拆分"></a> 单词拆分</h2><!-- TOC --><ul><li><a href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">单词拆分</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/word-break/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>e.g.</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以由 <span class="hljs-string">&quot;leet&quot;</span> 和 <span class="hljs-string">&quot;code&quot;</span> 拼接成。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要思路是dp。dp[i]表示<code>0～i-1</code>的子串是否可以用dict中的词组成，对于<code>0&lt;j&lt;i</code>，状态方程可以写为<code>dp[i]=dp[j] &amp;&amp; check(j,i-1)</code></p><p>对于<code>check(j,i-1)</code>，可以用一个哈系表st来保存dict中的所有单词，如果满足：</p><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mizar"><span class="hljs-keyword">st</span>.find(s.substr(j,i-j))!=<span class="hljs-keyword">st</span>.<span class="hljs-keyword">end</span>()<br></code></pre></td></tr></table></figure><p>说明<code>j~i-1</code>的部分可以与dict中的单词匹配成功</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=s.<span class="hljs-built_in">size</span>();<br>        unordered_set&lt;string&gt; st;<br>        <span class="hljs-keyword">for</span>(string &amp;t:wordDict)&#123;<br>            st.<span class="hljs-built_in">insert</span>(t);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j)&#123;<br>                <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; st.<span class="hljs-built_in">find</span>(s.<span class="hljs-built_in">substr</span>(j,i-j))!=st.<span class="hljs-built_in">end</span>())&#123;<br>                    dp[i]=<span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>长度最小子数组</title>
    <link href="/2024/09/14/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2024/09/14/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="长度最小子数组"><a class="markdownIt-Anchor" href="#长度最小子数组"></a> 长度最小子数组</h2><!-- TOC --><ul><li><a href="#%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84">长度最小子数组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其总和大于等于 target 的长度最小的<br />子数组<br /><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：target = 7, nums = <span class="hljs-comment">[2,3,1,2,4,3]</span><br>输出：2<br>解释：子数组 <span class="hljs-comment">[4,3]</span> 是该条件下的长度最小的子数组。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>好久没刷题了，今天做道滑动窗口练练，结果直接超时了 😅，偷偷看了题解 😁，题目不难，右边界扩张，左边界收缩即可，具体见代码。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> minSubArrayLen(<span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">int</span> res=INT_MAX;<br>        <span class="hljs-built_in">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(r&lt;n)&#123;<br>            <span class="hljs-built_in">sum</span>+=nums[r];<br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">sum</span>&gt;=<span class="hljs-keyword">target</span>)&#123;<br>                res=<span class="hljs-built_in">min</span>(res,r-l+<span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">sum</span>-=nums[l];<br>                ++l;<br>            &#125;<br>            ++r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res==INT_MAX ? <span class="hljs-number">0</span>:res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>下一个排列</title>
    <link href="/2024/05/30/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <url>/2024/05/30/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="下一个排列"><a class="markdownIt-Anchor" href="#下一个排列"></a> 下一个排列</h2><!-- TOC --><ul><li><a href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97">下一个排列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/next-permutation/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br />整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。<br />类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。<br />而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br />给你一个整数数组 nums ，找出 nums 的下一个排列。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>很久之前做过这道题(当时直接next_permutation了😁)，现在重新写一遍。<br />主要分三步:</p><ul><li>从后往前遍历，找到<code>nums[i]</code>满足<code>nums[i]&lt;nums[i+1]</code></li><li>从后往前遍历，找到<code>nums[j]</code>满足<code>nums[i]&lt;nums[j]</code>，然后swap</li><li>将i以后的部分(i+1～end) reverse</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;</span><br><span class="hljs-class">public:</span><br><span class="hljs-class">    void nextPermutation(<span class="hljs-title">vector</span>&lt;<span class="hljs-title">int</span>&gt;&amp; <span class="hljs-title">nums</span>) &#123;</span><br><span class="hljs-class">        // next_permutation(<span class="hljs-title">nums</span>.<span class="hljs-title">begin</span>(),nums.end());</span><br><span class="hljs-class">        int n=nums.size();</span><br><span class="hljs-class">        int i=n-2,j=n-1;</span><br><span class="hljs-class">        while(<span class="hljs-title">i</span>&gt;=0&amp;&amp;<span class="hljs-title">nums</span>[<span class="hljs-title">i</span>]&gt;=<span class="hljs-title">nums</span>[<span class="hljs-title">i</span>+1])</span><br><span class="hljs-class">            <span class="hljs-comment">--i;</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">        if(<span class="hljs-title">i</span>&gt;=0)&#123;</span><br><span class="hljs-class">            while(<span class="hljs-title">j</span>&gt;=0&amp;&amp;<span class="hljs-title">nums</span>[<span class="hljs-title">j</span>]&lt;=<span class="hljs-title">nums</span>[<span class="hljs-title">i</span>])</span><br><span class="hljs-class">                <span class="hljs-comment">--j;</span></span><br><span class="hljs-class">            swap(<span class="hljs-title">nums</span>[<span class="hljs-title">i</span>],<span class="hljs-title">nums</span>[<span class="hljs-title">j</span>]);</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        reverse(<span class="hljs-title">nums</span>.<span class="hljs-title">begin</span>()+i+1,nums.end());</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">&#125;;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>预测赢家</title>
    <link href="/2024/05/25/%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/"/>
    <url>/2024/05/25/%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="预测赢家"><a class="markdownIt-Anchor" href="#预测赢家"></a> 预测赢家</h2><!-- TOC --><ul><li><a href="#%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6">预测赢家</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/predict-the-winner/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。</p><p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 0 。每一回合，玩家从数组的任意一端取一个数字（即，nums[0] 或 nums[nums.length - 1]），取到的数字将会从数组中移除（数组长度减 1 ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。</p><p>如果玩家 1 能成为赢家，返回 true 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 true 。你可以假设每个玩家的玩法都会使他的分数最大化。</p><p>e.g.</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,5,2]<br>输出：false<br>解释：一开始，玩家<span class="hljs-number"> 1 </span>可以从<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>中进行选择。<br>如果他选择 2（或者<span class="hljs-number"> 1 </span>），那么玩家<span class="hljs-number"> 2 </span>可以从 1（或者<span class="hljs-number"> 2 </span>）和<span class="hljs-number"> 5 </span>中进行选择。如果玩家<span class="hljs-number"> 2 </span>选择了<span class="hljs-number"> 5 </span>，那么玩家<span class="hljs-number"> 1 </span>则只剩下 1（或者<span class="hljs-number"> 2 </span>）可选。 <br>所以，玩家<span class="hljs-number"> 1 </span>的最终分数为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>= 3，而玩家<span class="hljs-number"> 2 </span>为<span class="hljs-number"> 5 </span>。<br>因此，玩家<span class="hljs-number"> 1 </span>永远不会成为赢家，返回 false 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>两个玩家轮流取数字，用dp[i][j]表示在数字i~j之间，玩家1对于玩家2的最大分数差，显然，如果玩家1取nums[i]，那么dp[i+1][j]为玩家2对玩家1的最大分数差;如果玩家1取nums[j]，那么dp[i][j-1]为玩家2对玩家1的最大分数差，状态方程为：<code>dp[i][j]=max(nums[i]-dp[i+1][j],nums[j]-dp[i][j-1])</code>。如果i==j，那么玩家1先取，dp[i][i]=nums[i]。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">predictTheWinner</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>            dp[i][i]=nums[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;++j)<br>            &#123;<br>                dp[i][j]=<span class="hljs-built_in">max</span>(nums[i]-dp[i+<span class="hljs-number">1</span>][j],nums[j]-dp[i][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]&gt;=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最小区间</title>
    <link href="/2024/05/23/%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/"/>
    <url>/2024/05/23/%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="最小区间"><a class="markdownIt-Anchor" href="#最小区间"></a> 最小区间</h2><!-- TOC --><ul><li><a href="#%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4">最小区间</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/description">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你有 k 个 非递减排列 的整数列表。找到一个 最小 区间，使得 k 个列表中的每个列表至少有一个数包含在其中。</p><p>我们定义如果 b-a &lt; d-c 或者在 b-a == d-c 时 a &lt; c，则区间 [a,b] 比 [c,d] 小</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[<span class="hljs-comment">[4,10,15,24,26]</span>, <span class="hljs-comment">[0,9,12,20]</span>, <span class="hljs-comment">[5,18,22,30]</span>]</span><br>输出：<span class="hljs-comment">[20,24]</span><br>解释： <br>列表 1：<span class="hljs-comment">[4, 10, 15, 24, 26]</span>，24 在区间 <span class="hljs-comment">[20,24]</span> 中。<br>列表 2：<span class="hljs-comment">[0, 9, 12, 20]</span>，20 在区间 <span class="hljs-comment">[20,24]</span> 中。<br>列表 3：<span class="hljs-comment">[5, 18, 22, 30]</span>，22 在区间 <span class="hljs-comment">[20,24]</span> 中。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题自己看的时候没什么头绪，看了官方题解才明白。主要思路就是滑动窗口和哈系表。首先，创建一个哈系表来储存每个数字各自属于哪个数组，如 mp[i]=[0,1,2] 表示数字 i 在第 [0,1,2] 个数组中都出现过，遍历过程中确定出所有数字的最大值和最小值，作为初始答案。接下来，用一个数组freq统计每个数组的出现次数，cnt表示覆盖的数组个数, 初始化滑窗左端点 l=min，右端点r=l-1，首先扩张右端点，当r存在于mp中，将r出现过的所有数组 freq+1，如果freq为1,说明该数组第一次出现，cnt+1。然后，当cnt==n时，已经满足题目要求，先更新最小区间，然后开始收缩左端点，同理，当l存在于mp中，将l出现过的所有数组 freq-1，如果freq为 0,说明该数组没有被覆盖，cnt-1，开始新的扩张阶段，直到r达到所有数字最大值。具体细节参考代码。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs perl">class Solution &#123;<br>public:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; smallestRange(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">int</span> n=nums.size();<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; mp;<span class="hljs-regexp">//</span>记录某元素都在哪些数组出现过<br>        <span class="hljs-keyword">int</span> xmin=INT_MAX,xmax=INT_MIN;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> &amp; t:nums[i])<br>            &#123;<br>                mp[t].push_back(i);<br>                xmin=min(xmin,t);<br>                xmax=max(xmax,t);<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; fre<span class="hljs-string">q(n)</span>;<span class="hljs-regexp">//</span>统计每个数组的统计次数<br>        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>; <span class="hljs-regexp">//</span>cnt==n时视为满足条件<br>        <span class="hljs-keyword">int</span> l=xmin,r=xmin-<span class="hljs-number">1</span>,res_l=xmin,res_r=xmax;<br>        <span class="hljs-keyword">while</span>(r&lt;xmax) //开始滑窗，先向右扩张，再向左收缩<br>        &#123;<br>            ++r;<br>            <span class="hljs-keyword">if</span>(mp.count(r))<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> &amp;t:mp[r]) //统计当前数在哪些数组出现过，如果在某数组出现则freq++<br>                &#123;<br>                    ++fre<span class="hljs-string">q[t]</span>;<br>                    <span class="hljs-keyword">if</span>(fre<span class="hljs-string">q[t]</span>==<span class="hljs-number">1</span>) //至少出现一次cnt+<span class="hljs-number">1</span><br>                        ++cnt;<br>                &#125;<br>                <span class="hljs-keyword">while</span>(cnt==n)//满足条件时更新答案，收缩左区间<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(r-l&lt;res_r-res_l) <br>                    &#123;<br>                        res_r=r;<br>                        res_l=l;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(mp.count(l))<br>                    &#123;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> &amp;t:mp[l])<br>                        &#123;<br>                            --fre<span class="hljs-string">q[t]</span>;<br>                            <span class="hljs-keyword">if</span>(fre<span class="hljs-string">q[t]</span>==<span class="hljs-number">0</span>)//如果某数组没有数在当前区间出现，退出收缩阶段，继续扩张<br>                                --cnt;<br>                        &#125;<br>                    &#125;<br>                    ++l;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;res_l,res_r&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>丑数</title>
    <link href="/2024/05/20/%E4%B8%91%E6%95%B0/"/>
    <url>/2024/05/20/%E4%B8%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="丑数"><a class="markdownIt-Anchor" href="#丑数"></a> 丑数</h2><!-- TOC --><ul><li><a href="#%E4%B8%91%E6%95%B0">丑数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/ugly-number-ii/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数 n ，请你找出并返回第 n 个 丑数 。</p><p>丑数 就是质因子只包含 2、3 和 5 的正整数。</p><p>e.g.</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">12</span><br>解释：<span class="hljs-string">[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]</span> 是由前 <span class="hljs-number">10</span> 个丑数组成的序列。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要用堆的思想，从小到达将最小的丑数1分别乘以2,3,5加入最小堆中，并且注意不能加入相同的数，然后加入的第n个数就是答案。一开始没想到堆，想得是用试除法一步步算，太久没刷题感觉脑子都转不动了😢</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; a=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br>        unordered_set&lt;<span class="hljs-type">long</span>&gt; s;<br>        priority_queue&lt;<span class="hljs-type">long</span>,vector&lt;<span class="hljs-type">long</span>&gt;,greater&lt;<span class="hljs-type">long</span>&gt;&gt; pq;<br>        pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>        s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">long</span> tmp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;   <br>            tmp=pq.<span class="hljs-built_in">top</span>();<br>            ans=(<span class="hljs-type">int</span>)tmp;<br>            pq.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t:a)<br>            &#123;<br>                <span class="hljs-type">long</span> tt=tmp*t;<br>                <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">count</span>(tt))<br>                &#123;<br>                    s.<span class="hljs-built_in">insert</span>(tt);<br>                    pq.<span class="hljs-built_in">push</span>(tt);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最近公共祖先</title>
    <link href="/2024/05/17/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2024/05/17/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h2 id="最近公共祖先"><a class="markdownIt-Anchor" href="#最近公共祖先"></a> 最近公共祖先</h2><!-- TOC --><ul><li><a href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">最近公共祖先</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</p><p>e.g.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：root = <span class="hljs-selector-attr">[3,5,1,6,2,0,8,null,null,7,4]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">5</span>, <span class="hljs-selector-tag">q</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>之前统计过最近公共祖先的模板(<a href="https://lqz2.github.io/2023/06/13/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88LCA/">https://lqz2.github.io/2023/06/13/最近公共祖先LCA/</a>)，但是比较繁琐。一种简洁的思路是，分别从左右子树搜索p和q，当前节点为空或者当前节点等于p或q时返回当前节点，如果p和q分别在左右子树中(左右子树返回均不为空)，那么当前节点就是LCA，如果p和q在左右子树其中一棵上(左右子树返回有一个为空)，那么直接返回非空的子树。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xquery">class Solution &#123;<br>public:<br>    TreeNode* lowestCommonAncestor(TreeNode*<span class="hljs-built_in"> root</span>, TreeNode* p, TreeNode* q) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">!root</span>|<span class="hljs-built_in">|root</span>==p|<span class="hljs-built_in">|root</span>==q)<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>        TreeNode* l=lowestCommonAncestor<span class="hljs-built_in">(root</span>-&gt;left,p,q);<br>        TreeNode* r=lowestCommonAncestor<span class="hljs-built_in">(root</span>-&gt;right,p,q);<br>        <span class="hljs-keyword">if</span>(l&amp;&amp;r)<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span>;<br>        <span class="hljs-keyword">return</span> l?l:r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子集中元素的最大数量</title>
    <link href="/2024/01/28/%E5%AD%90%E9%9B%86%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/"/>
    <url>/2024/01/28/%E5%AD%90%E9%9B%86%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="子集中元素的最大数量"><a class="markdownIt-Anchor" href="#子集中元素的最大数量"></a> 子集中元素的最大数量</h2><p><a href="https://leetcode.cn/problems/find-the-maximum-number-of-elements-in-subset/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个 正整数 数组 nums 。</p><p>你需要从数组中选出一个满足下述条件的子集：</p><p>你可以将选中的元素放置在一个下标从 0 开始的数组中，并使其遵循以下模式：<code>[x, x^2, x^4, ..., x^k/2, x^k, x^k/2, ..., x^4, x^2, x]</code>（注意，k 可以是任何非负的2的幂）。例如，[2, 4, 16, 4, 2] 和 [3, 9, 3] 都符合这一模式，而 [2, 4, 8, 4, 2] 则不符合。<br />返回满足这些条件的子集中，元素数量的 最大值 。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要思路就是统计出现2次以上的数字，然后遍历他们，统计子集的最大数量，具体实现看代码即可理解，注意1的特殊情况。</p><p>周赛第二题，思路和答案一样，甚至数据结构都用的一样，但是就差一点点没实现好，感觉代码实现能力还需要好好提升。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : nums)<br>            m[a]++;<br>        <span class="hljs-type">int</span> ans = m[<span class="hljs-number">1</span>] - (m[<span class="hljs-number">1</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>        m.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : m)<br>        &#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> t = x.first;<br>            <span class="hljs-keyword">while</span> (m.<span class="hljs-built_in">count</span>(t) &amp;&amp; m[t] &gt; <span class="hljs-number">1</span>)<br>            &#123;<br>                cnt += <span class="hljs-number">2</span>;<br>                t *= t;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, cnt + (m.<span class="hljs-built_in">count</span>(t) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>输入单词需要的最少按键次数</title>
    <link href="/2024/01/21/%E8%BE%93%E5%85%A5%E5%8D%95%E8%AF%8D%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E6%8C%89%E9%94%AE%E6%AC%A1%E6%95%B0/"/>
    <url>/2024/01/21/%E8%BE%93%E5%85%A5%E5%8D%95%E8%AF%8D%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E6%8C%89%E9%94%AE%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%BE%93%E5%85%A5%E5%8D%95%E8%AF%8D%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E6%8C%89%E9%94%AE%E6%AC%A1%E6%95%B0">输入单词需要的最少按键次数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="输入单词需要的最少按键次数"><a class="markdownIt-Anchor" href="#输入单词需要的最少按键次数"></a> 输入单词需要的最少按键次数</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-pushes-to-type-word-ii/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个字符串 word，由 不同 小写英文字母组成。</p><p>电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 2 对应 [“a”,“b”,“c”]，我们需要按一次键来输入 “a”，按两次键来输入 “b”，按三次键来输入 “c”。</p><p>现在允许你将编号为 2 到 9 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 word 所需的 最少 按键次数。</p><p>返回重新映射按键后输入 word 所需的 最少 按键次数。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：word = &quot;xyzxyzxyzxyz&quot;<br>输出：12<br>解释：图片中给出的重新映射方案的输入成本最小。<br>&quot;x&quot; -&gt; 在按键<span class="hljs-number"> 2 </span>上按一次<br>&quot;y&quot; -&gt; 在按键<span class="hljs-number"> 3 </span>上按一次<br>&quot;z&quot; -&gt; 在按键<span class="hljs-number"> 4 </span>上按一次<br>总成本为<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 12 </span>。<br>可以证明不存在其他成本更低的映射方案。<br>注意按键<span class="hljs-number"> 9 </span>没有映射到任何字母：不必让每个按键都存在与之映射的字母，但是每个字母都必须映射到按键上。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>周赛第三题，思路其实很简单，但是比赛时想复杂了。首先统计所有字符出现的次数，然后按出现频率从大小排序，然后对于出现次数前8大的字符，只需1次，9到16大的字符，只需2次，以此类推</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumPushes</span><span class="hljs-params">(string <span class="hljs-type">word</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-type">word</span>.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            cnt[<span class="hljs-type">word</span>[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(cnt.<span class="hljs-built_in">begin</span>(), cnt.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>            ans += cnt[i] * ((i / <span class="hljs-number">8</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>价值和小于等于k的最大数字</title>
    <link href="/2024/01/15/%E4%BB%B7%E5%80%BC%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ek%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/"/>
    <url>/2024/01/15/%E4%BB%B7%E5%80%BC%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ek%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BB%B7%E5%80%BC%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8Ek%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97">价值和小于等于k的最大数字</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="价值和小于等于k的最大数字"><a class="markdownIt-Anchor" href="#价值和小于等于k的最大数字"></a> 价值和小于等于k的最大数字</h2><p><a href="https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数 k 和一个整数 x 。</p><p>令 s 为整数 num 的下标从 1 开始的二进制表示。我们说一个整数 num 的 价值 是满足 i % x == 0 且 s[i] 是 设置位 的 i 的数目。</p><p>请你返回 最大 整数 num ，满足从 1 到 num 的所有整数的 价值 和小于等于 k 。</p><p>注意：</p><p>一个整数二进制表示下 设置位 是值为 1 的数位。<br />一个整数的二进制表示下标从右到左编号，比方说如果 s == 11100 ，那么 s[4] == 1 且 s[2] == 0 。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：k <span class="hljs-operator">=</span> <span class="hljs-number">9</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">6</span><br>解释：数字 <span class="hljs-number">1</span> ，<span class="hljs-number">2</span> ，<span class="hljs-number">3</span> ，<span class="hljs-number">4</span> ，<span class="hljs-number">5</span> 和 <span class="hljs-number">6</span> 二进制表示分别为 <span class="hljs-string">&quot;1&quot;</span> ，<span class="hljs-string">&quot;10&quot;</span> ，<span class="hljs-string">&quot;11&quot;</span> ，<span class="hljs-string">&quot;100&quot;</span> ，<span class="hljs-string">&quot;101&quot;</span> 和 <span class="hljs-string">&quot;110&quot;</span> 。<br>由于 <span class="hljs-keyword">x</span> 等于 <span class="hljs-number">1</span> ，每个数字的价值分别为所有设置位的数目。<br>这些数字的所有设置位数目总数是 <span class="hljs-number">9</span> ，所以前 <span class="hljs-number">6</span> 个数字的价值和为 <span class="hljs-number">9</span> 。<br>所以答案为 <span class="hljs-number">6</span> 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>周赛的第3题，做的时候时间复杂度优化不下来，一直超时。整体思路是数学加二分。</p><p>首先，求1～n的所有数每个位置上1的数量。这里可以用数位DP，也可以直接用数学公式推导：<br />对于1～n的所有数，第i(从右到左递增，从0开始)个位置的1的数量为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup></mfrac><mo>×</mo><msup><mn>2</mn><mi>i</mi></msup><mo>+</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><msup><mn>2</mn><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><msup><mn>2</mn><mi>i</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{n+1}{2^{i+1}} \times 2^{i} + max(0,(n+1) \% 2^{i+1}-2^i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.750664em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9579939999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.124664em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">%</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.874664em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1246639999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>可以通过位运算完成上面的计算，比如<code>n mod 2^i</code>即<code>n &amp; ((1 &lt;&lt; i) - 1)</code></p><p>所以上面的式子可表示为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(((<span class="hljs-name">n</span> + <span class="hljs-number">1</span>LL) &gt;&gt; (<span class="hljs-name">i</span> + <span class="hljs-number">1</span>LL)) &lt;&lt; i) + max(<span class="hljs-number">0</span>LL, ((<span class="hljs-name">n</span> + <span class="hljs-number">1</span>LL) &amp; ((<span class="hljs-number">1</span>LL &lt;&lt; (<span class="hljs-name">i</span> + <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>LL)) - (<span class="hljs-number">1</span>LL &lt;&lt; i))<br></code></pre></td></tr></table></figure><p>这样我们可以快速计算1～n的价值和，得到价值和后需要用二分查找得到价值和小于等于K的最大的n，因为价值和是递增的，所以也就是找到价值和大于K的n再减去1，也就是价值和大于等于K+1的n减去1，下面进行二分查找即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 判断1~n的价值和是否超过了k</span><br>    bool <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">int</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span><br>    &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span> - __builtin_clzll(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((i + <span class="hljs-number">1</span>) % x == <span class="hljs-number">0</span>)<br>            &#123;<br>                res += (((n + 1LL) &gt;&gt; (i + 1LL)) &lt;&lt; i) + max(0LL, ((n + 1LL) &amp; ((1LL &lt;&lt; (i + <span class="hljs-number">1</span>)) - 1LL)) - (1LL &lt;&lt; i));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res &lt; k + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">findMaximumNumber</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> k, <span class="hljs-type">int</span> x)</span><br>    &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, r = (k + <span class="hljs-number">1</span>) &lt;&lt; x;<br>        <span class="hljs-keyword">while</span> (l &lt;= r)<br>        &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (check(mid, x, k))<br>                l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>移除后集合的最多元素数</title>
    <link href="/2024/01/07/%E7%A7%BB%E9%99%A4%E5%90%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%9C%80%E5%A4%9A%E5%85%83%E7%B4%A0%E6%95%B0/"/>
    <url>/2024/01/07/%E7%A7%BB%E9%99%A4%E5%90%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%9C%80%E5%A4%9A%E5%85%83%E7%B4%A0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%A7%BB%E9%99%A4%E5%90%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%9C%80%E5%A4%9A%E5%85%83%E7%B4%A0%E6%95%B0">移除后集合的最多元素数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="移除后集合的最多元素数"><a class="markdownIt-Anchor" href="#移除后集合的最多元素数"></a> 移除后集合的最多元素数</h2><p><a href="https://leetcode.cn/problems/maximum-size-of-a-set-after-removals/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，它们的长度都是偶数 n 。</p><p>你必须从 nums1 中移除 n / 2 个元素，同时从 nums2 中也移除 n / 2 个元素。移除之后，你将 nums1 和 nums2 中剩下的元素插入到集合 s 中。</p><p>返回集合 s可能的 最多 包含多少元素。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">示例 <span class="hljs-number">1</span>：<br>输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">2</span><br>解释：从 <span class="hljs-symbol">nums1</span> 和 <span class="hljs-symbol">nums2</span> 中移除两个 <span class="hljs-number">1</span> 。移除后，数组变为 <span class="hljs-symbol">nums1</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] 和 <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] 。因此，s = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125; 。<br>可以证明，在移除之后，集合 s 最多可以包含 <span class="hljs-number">2</span> 个元素。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>周赛第3题，思路很巧妙，自己没有想到。题目希望s中的不同元素尽可能多，也就是说应该尽可能从两个数组的交集移除元素，换句话说就是尽可能保留两个数组自身独有的不同元素，如果数组长度为n，两个数组独有的不同元素个数为cnt1,cnt2，应当优先添加两个数组独有的元素到s，再添加交集的元素到s。</p><ul><li>首先两个数组因为要移除n/2个元素，所以cnt1，cnt2都应满足小于等于n/2</li><li>然后s中的最大元素个数为n，在添加了cnt1,cnt2后，最多还能添加n-cnt1-cnt2个不同元素，这部分元素需要从交集中获取，因此总的答案为<code>cnt1+cnt2+min(n-cnt1-cnt2,cnt3)</code>，其中cnt3为交集中的元素个数。</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumSetSize</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums1, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s1</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s2</span><span class="hljs-params">(nums2.begin(), nums2.end())</span></span>;<br>        <span class="hljs-type">int</span> cnt1 = s1.<span class="hljs-built_in">size</span>(), cnt2 = s2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cnt3 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : s1)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s2.<span class="hljs-built_in">find</span>(x) != s2.<span class="hljs-built_in">end</span>())<br>                cnt3++;<br>        &#125;<br>        cnt1 -= cnt3;<br>        cnt2 -= cnt3;<br>        cnt1 = <span class="hljs-built_in">min</span>(cnt1, n / <span class="hljs-number">2</span>);<br>        cnt2 = <span class="hljs-built_in">min</span>(cnt2, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> cnt1 + cnt2 + <span class="hljs-built_in">min</span>(n - cnt1 - cnt2, cnt3);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>至少出现三次的特殊子字符串</title>
    <link href="/2023/12/31/%E8%87%B3%E5%B0%91%E5%87%BA%E7%8E%B0%E4%B8%89%E6%AC%A1%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/12/31/%E8%87%B3%E5%B0%91%E5%87%BA%E7%8E%B0%E4%B8%89%E6%AC%A1%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%87%B3%E5%B0%91%E5%87%BA%E7%8E%B0%E4%B8%89%E6%AC%A1%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2">至少出现三次的特殊子字符串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="至少出现三次的特殊子字符串"><a class="markdownIt-Anchor" href="#至少出现三次的特殊子字符串"></a> 至少出现三次的特殊子字符串</h2><p><a href="https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-ii/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个仅由小写英文字母组成的字符串 s 。</p><p>如果一个字符串仅由单一字符组成，那么它被称为 特殊 字符串。例如，字符串 “abc” 不是特殊字符串，而字符串 “ddd”、“zz” 和 “f” 是特殊字符串。</p><p>返回在 s 中出现 至少三次 的 最长特殊子字符串 的长度，如果不存在出现至少三次的特殊子字符串，则返回 -1 。</p><p>子字符串 是字符串中的一个连续 非空 字符序列。</p><p>e.g.</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aaaa&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：出现三次的最长特殊子字符串是 <span class="hljs-string">&quot;aa&quot;</span> ：子字符串 <span class="hljs-string">&quot;aaaa&quot;</span>、<span class="hljs-string">&quot;aaaa&quot;</span> 和 <span class="hljs-string">&quot;aaaa&quot;</span>。<br>可以证明最大长度是 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>周赛第三题，和第二题一样，但是数据规模大了很多，时间复杂度我只能到O(n^2)，但是看了大佬的思路觉得很好，所以学习学习。</p><p>首先，统计26个字母构成的子串长度，如aaaabbbabb中a为{4,1}，b为{3,2}<br />接下来对每个字母对应的数组降序排序，然后分类讨论：</p><ul><li>如果在a[0]，也就是最长的字符串中取3个子字符串，则可以取三个长为a[0]-2的子串</li><li>如果在a[0],a[1]中取3个子字符串，则取的长度为min(a[0]-1,a[1])</li><li>如果在a[0],a[1],a[2]中取3个子字符串，则直接取长度为a[2]即可</li></ul><p>综上，取得长度为<code>max(a[0]−2,min(a[0]−1,a[1]),a[2])</code>，非常简洁</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumLength</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(<span class="hljs-number">26</span>);<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            ++cnt;<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> == n || s[i] != s[i + <span class="hljs-number">1</span>])<br>            &#123;<br>                g[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">push_back</span>(cnt);<br>                cnt = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; t : g)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">empty</span>())<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>            t.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            t.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            ans = <span class="hljs-built_in">max</span>(&#123;ans, t[<span class="hljs-number">0</span>] - <span class="hljs-number">2</span>, <span class="hljs-built_in">min</span>(t[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, t[<span class="hljs-number">1</span>]), t[<span class="hljs-number">2</span>]&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>转换字符串的最小成本</title>
    <link href="/2023/12/24/%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC/"/>
    <url>/2023/12/24/%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="移除栅栏得到的最大正方形"><a class="markdownIt-Anchor" href="#移除栅栏得到的最大正方形"></a> 移除栅栏得到的最大正方形</h2><p><a href="https://leetcode.cn/problems/maximum-square-area-by-removing-fences-from-a-field/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有一个大型的 (m - 1) x (n - 1) 矩形田地，其两个对角分别是 (1, 1) 和 (m, n) ，田地内部有一些水平栅栏和垂直栅栏，分别由数组 hFences 和 vFences 给出。</p><p>水平栅栏为坐标 (hFences[i], 1) 到 (hFences[i], n)，垂直栅栏为坐标 (1, vFences[i]) 到 (m, vFences[i]) 。</p><p>返回通过 移除 一些栅栏（可能不移除）所能形成的最大面积的 正方形 田地的面积，或者如果无法形成正方形田地则返回 -1。</p><p>由于答案可能很大，所以请返回结果对 109 + 7 取余 后的值。</p><p>注意：田地外围两个水平栅栏（坐标 (1, 1) 到 (1, n) 和坐标 (m, 1) 到 (m, n) ）以及两个垂直栅栏（坐标 (1, 1) 到 (m, 1) 和坐标 (1, n) 到 (m, n) ）所包围。这些栅栏 不能 被移除。</p><p>e.g.</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：m = 4, n = 3, hFences = [2,3], vFences = [2]<br>输出：4<br>解释：移除位于<span class="hljs-number"> 2 </span>的水平栅栏和位于<span class="hljs-number"> 2 </span>的垂直栅栏将得到一个面积为<span class="hljs-number"> 4 </span>的正方形田地。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>周赛第二题，当时以为很复杂，暴力会超时，以为有什么特殊做法，结束一看确实是暴力做的。<br />主要思路是用一个哈系表存储水平/垂直方向的栅栏之间的差值，这里以存储水平栅栏的差值为例，下来遍历垂直方向的栅栏的差值，如果有差值x在水平和垂直方向都存在，那么用x更新正方形最大边长e即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">maximizeSquareArea</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt; &amp;hFences, vector&lt;<span class="hljs-type">int</span>&gt; &amp;vFences)</span><br>    &#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; h;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        hFences.push_back(<span class="hljs-number">1</span>);<br>        hFences.push_back(m);<br>        vFences.push_back(<span class="hljs-number">1</span>);<br>        vFences.push_back(n);<br>        sort(hFences.begin(), hFences.end());<br>        sort(vFences.begin(), vFences.end());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; hFences.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; hFences.size(); j++)<br>                ++h[hFences[j] - hFences[i]];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vFences.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; vFences.size(); j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (h[vFences[j] - vFences[i]])<br>                    e = max(e, vFences[j] - vFences[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> e==<span class="hljs-number">0</span> ? -<span class="hljs-number">1</span>:(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)e * (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)e % mod;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="转换字符串的最小成本"><a class="markdownIt-Anchor" href="#转换字符串的最小成本"></a> 转换字符串的最小成本</h2><p><a href="https://leetcode.cn/problems/minimum-cost-to-convert-string-i/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>给你两个下标从 0 开始的字符串 source 和 target ，它们的长度均为 n 并且由 小写 英文字母组成。</p><p>另给你两个下标从 0 开始的字符数组 original 和 changed ，以及一个整数数组 cost ，其中 cost[i] 代表将字符 original[i] 更改为字符 changed[i] 的成本。</p><p>你从字符串 source 开始。在一次操作中，如果 存在 任意 下标 j 满足 cost[j] == z  、original[j] == x 以及 changed[j] == y 。你就可以选择字符串中的一个字符 x 并以 z 的成本将其更改为字符 y 。</p><p>返回将字符串 source 转换为字符串 target 所需的 最小 成本。如果不可能完成转换，则返回 -1 。</p><p>注意，可能存在下标 i 、j 使得 original[j] == original[i] 且 changed[j] == changed[i] 。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：source = <span class="hljs-string">&quot;abcd&quot;</span>, target = <span class="hljs-string">&quot;acbe&quot;</span>, original = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>], changed = [<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>], cost = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">20</span>]<br>输出：<span class="hljs-number">28</span><br>解释：将字符串 <span class="hljs-string">&quot;abcd&quot;</span> 转换为字符串 <span class="hljs-string">&quot;acbe&quot;</span> ：<br>- 更改下标 <span class="hljs-number">1</span> 处的值 <span class="hljs-string">&#x27;b&#x27;</span> 为 <span class="hljs-string">&#x27;c&#x27;</span> ，成本为 <span class="hljs-number">5</span> 。<br>- 更改下标 <span class="hljs-number">2</span> 处的值 <span class="hljs-string">&#x27;c&#x27;</span> 为 <span class="hljs-string">&#x27;e&#x27;</span> ，成本为 <span class="hljs-number">1</span> 。<br>- 更改下标 <span class="hljs-number">2</span> 处的值 <span class="hljs-string">&#x27;e&#x27;</span> 为 <span class="hljs-string">&#x27;b&#x27;</span> ，成本为 <span class="hljs-number">2</span> 。<br>- 更改下标 <span class="hljs-number">3</span> 处的值 <span class="hljs-string">&#x27;d&#x27;</span> 为 <span class="hljs-string">&#x27;e&#x27;</span> ，成本为 <span class="hljs-number">20</span> 。<br>产生的总成本是 <span class="hljs-number">5</span> + <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">20</span> = <span class="hljs-number">28</span> 。<br>可以证明这是可能的最小成本。<br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>周赛第三题，本质上是求26个字母间的多源最短路，使用Floyd求得每两个字母互换的最小代价，然后遍历两个字符串，计算转换的最小代价，周赛第四题是这道题的升级版，<a href="https://leetcode.cn/problems/minimum-cost-to-convert-string-ii/description/">链接</a></p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs prolog">class <span class="hljs-symbol">Solution</span><br>&#123;<br>public:<br>    long long minimumCost(string source, string target, vector&lt;char&gt; &amp;original, vector&lt;char&gt; &amp;changed, vector&lt;int&gt; &amp;cost)<br>    &#123;<br>        int n = source.size();<br>        long long ans = <span class="hljs-number">0</span>;<br>        int costmp[<span class="hljs-number">26</span>][<span class="hljs-number">26</span>];<br>        memset(costmp, <span class="hljs-number">0x3f</span>, sizeof(costmp));<br>        for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i)<br>            costmp[i][i] = <span class="hljs-number">0</span>;<br>        for (int i = <span class="hljs-number">0</span>; i &lt; original.size(); ++i)<br>        &#123;<br>            int u = original[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            int v = changed[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            costmp[u][v] = min(costmp[u][v], cost[i]);<br>        &#125;<br>        for (int k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">26</span>; ++k)<br>        &#123;<br>            for (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i)<br>            &#123;<br>                for (int j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; ++j)<br>                &#123;<br>                    if (costmp[i][k] + costmp[k][j] &lt; costmp[i][j])<br>                        costmp[i][j] = costmp[i][k] + costmp[k][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        for (int i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            int u = source[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            int v = target[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            if (costmp[u][v] == <span class="hljs-number">0x3f3f3f3f</span>)<br>                return <span class="hljs-number">-1</span>;<br>            ans += costmp[u][v];<br>        &#125;<br>        return ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>执行操作使频率分数最大</title>
    <link href="/2023/12/17/%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E9%A2%91%E7%8E%87%E5%88%86%E6%95%B0%E6%9C%80%E5%A4%A7/"/>
    <url>/2023/12/17/%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E9%A2%91%E7%8E%87%E5%88%86%E6%95%B0%E6%9C%80%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="执行操作使频率分数最大"><a class="markdownIt-Anchor" href="#执行操作使频率分数最大"></a> 执行操作使频率分数最大</h2><p><a href="https://leetcode.cn/problems/apply-operations-to-maximize-frequency-score/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。</p><p>你可以对数组执行 至多 k 次操作：</p><p>从数组中选择一个下标 i ，将 nums[i] 增加 或者 减少 1 。<br />最终数组的频率分数定义为数组中众数的 频率 。</p><p>请你返回你可以得到的 最大 频率分数。</p><p>众数指的是数组中出现次数最多的数。一个元素的频率指的是数组中这个元素的出现次数。</p><p>e.g.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[1,2,6,4]</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：我们可以对数组执行以下操作：<br>- 选择 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span> ，将 nums<span class="hljs-selector-attr">[0]</span> 增加 <span class="hljs-number">1</span> 。得到数组 <span class="hljs-selector-attr">[2,2,6,4]</span> 。<br>- 选择 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">3</span> ，将 nums<span class="hljs-selector-attr">[3]</span> 减少 <span class="hljs-number">1</span> ，得到数组 <span class="hljs-selector-attr">[2,2,6,3]</span> 。<br>- 选择 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">3</span> ，将 nums<span class="hljs-selector-attr">[3]</span> 减少 <span class="hljs-number">1</span> ，得到数组 <span class="hljs-selector-attr">[2,2,6,2]</span> 。<br>元素 <span class="hljs-number">2</span> 是最终数组中的众数，出现了 <span class="hljs-number">3</span> 次，所以频率分数为 <span class="hljs-number">3</span> 。<br><span class="hljs-number">3</span> 是所有可行方案里的最大频率分数。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>周赛第四题，思路是前缀和滑动窗口，想到了中位数和排序，但只想到二分没想到滑动窗口。<br />可以看作是将一个子区间内的所有数变成同一个值的曼哈顿距离之和，如升序子数组a1,a2,a3,a4,a5，如果要使得改动距离和最小应全部改为中位数，将这5个数全部变成a3，实际改动的距离和是：<br />d=a4-a3+a3-a2+a5-a3+a3-a1=a4+a5-(a1+a2)，也就是说，改动距离和等于中位数左边的数之和减去右边的数之和。<br />可以预处理成前缀和数组sum减小求和的复杂度。<br />对于子区间l~r</p><ul><li>如果区间长为奇数，<code>d = sum[r + 1] - sum[mid + 1] - sum[mid] + sum[l]</code>;</li><li>如果区间长为偶数，<code>d = sum[r + 1] - 2 * sum[mid + 1] + sum[l]</code></li></ul><p>接下来遍历右端点，如果子区间距离和大于k，则缩小子数组长度(++l)，每次更新子区间最大长度即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> maxFrequencyScore(vector&lt;<span class="hljs-built_in">int</span>&gt; &amp;nums, <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> k)<br>    &#123;<br>        <span class="hljs-built_in">int</span> n = nums.size();<br>        sort(nums.begin(), nums.end());<br>        vector&lt;<span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span>&gt; <span class="hljs-keyword">sum</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">sum</span>[i + <span class="hljs-number">1</span>] = <span class="hljs-keyword">sum</span>[i] + nums[i];<br>        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        function&lt;<span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>)&gt; f = [&amp;](<span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> mid, <span class="hljs-built_in">int</span> r)<br>        &#123;<br>            <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> res = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">int</span> len = r - l + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (len &amp; <span class="hljs-number">1</span>)<br>                res = <span class="hljs-keyword">sum</span>[r + <span class="hljs-number">1</span>] - <span class="hljs-keyword">sum</span>[mid + <span class="hljs-number">1</span>] - <span class="hljs-keyword">sum</span>[mid] + <span class="hljs-keyword">sum</span>[l];<br>            <span class="hljs-keyword">else</span><br>                res = <span class="hljs-keyword">sum</span>[r + <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> * <span class="hljs-keyword">sum</span>[mid + <span class="hljs-number">1</span>] + <span class="hljs-keyword">sum</span>[l];<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> r = <span class="hljs-number">0</span>; r &lt; n; ++r)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (f(l, (l + r) / <span class="hljs-number">2</span>, r) &gt; k)<br>                ++l;<br>            ans = max(ans, r - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分图匹配</title>
    <link href="/2023/12/15/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
    <url>/2023/12/15/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="二分图匹配"><a class="markdownIt-Anchor" href="#二分图匹配"></a> 二分图匹配</h2><p><a href="">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个二分图，其左部点的个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，右部点的个数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>，边数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span>，求其最大匹配的边数。</p><p>左部点从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 编号，右部点从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 编号。</p><h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h4><p>输入的第一行是三个整数，分别代表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> 行，每行两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u, v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，表示存在一条连接左部点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> 和右部点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 的边。</p><h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h4><p>输出一行一个整数，代表二分图最大匹配的边数。</p><h4 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1"></a> 样例输入 #1</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1"></a> 样例输出 #1</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h4 id="样例输入-2"><a class="markdownIt-Anchor" href="#样例输入-2"></a> 样例输入 #2</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-2"><a class="markdownIt-Anchor" href="#样例输出-2"></a> 样例输出 #2</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><h4 id="数据规模与约定"><a class="markdownIt-Anchor" href="#数据规模与约定"></a> 数据规模与约定</h4><p>对于全部的测试点，保证：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>500</mn></mrow><annotation encoding="application/x-tex">1 \leq n, m \leq 500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>e</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq e \leq 5 \times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>u</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \leq u \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>v</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1 \leq v \leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>。</li></ul><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要用到匈牙利算法的思路，每次通过dfs尝试为左部分的点找一个匹配对象，找到则返回true，++ans。在二分图匹配中，匈牙利算法的主要思想是：</p><ul><li>如果u要匹配的目标v还没有cp，那么直接匹配即match[v]=u</li><li>如果u发现v已经匹配了，则match[v]能找到新的就把v让给u(match[v]=u)，找不到就不让。</li><li>如果以前的不让步，u就去寻找下一个匹配。</li><li>如果u谁也匹配不上了，那就匹配失败，返回false。</li></ul><p>dfs过程中，为了防止访问过的点循环访问，用一个数组vistime[]来记录访问状态，tag表示轮次，vistime[u]=tag，表示u节点在第tag轮已经被访问，已被访问的状态下直接返回false即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000</span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(N);<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vistime</span><span class="hljs-params">(N)</span>, <span class="hljs-title">match</span><span class="hljs-params">(N)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, e;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; e;<br>    <span class="hljs-type">int</span> u, v;<br>    <span class="hljs-keyword">while</span> (e--)<br>    &#123;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        g[u].<span class="hljs-built_in">push_back</span>(v);<br>    &#125;<br>    function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> tag)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (vistime[u] == tag)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        vistime[u] = tag;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : g[u])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (match[v] == <span class="hljs-number">0</span> || <span class="hljs-built_in">dfs</span>(match[v], tag))<br>            &#123;<br>                match[v] = u;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i, i))<br>            ++ans;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法作业4</title>
    <link href="/2023/12/11/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A4/"/>
    <url>/2023/12/11/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A4/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%8C%9C%E7%96%91%E9%93%BE">猜疑链</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E5%86%9C%E5%9C%BA%E7%81%8C%E6%BA%89">农场灌溉</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li><li><a href="#%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5">社交网络连接</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-2">代码</a></li></ul></li><li><a href="#%E7%89%A9%E6%B5%81%E8%A7%84%E5%88%92%E5%B8%88">物流规划师</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-3">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-3">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="猜疑链"><a class="markdownIt-Anchor" href="#猜疑链"></a> 猜疑链</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>假设有n个文明，每个文明都有一个编号，从1到n。有一种传言，称这些文明中有一个掌握了强大的毁灭力量，被称为“黑暗森林之王”。</p><p>按照黑暗森林法则：</p><p>黑暗森林之王不相信任何其他文明。</p><p>每个文明（除了黑暗森林之王）都信任黑暗森林之王。</p><p>只有一个文明同时满足属性1和属性2。</p><p>如果黑暗森林之王存在并且可以确定其身份，请返回该黑暗森林之王的编号；否则，返回-1。</p><p>input:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>-&gt;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>统计每个节点的入度和出度，满足入度为n-1，出度为0的点就是黑暗之王</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(s)</span></span>;<br>    string t;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-type">int</span> a, b, mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, t, <span class="hljs-string">&#x27;,&#x27;</span>))<br>    &#123;<br>        <span class="hljs-type">int</span> idx = t.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        a = <span class="hljs-built_in">stoi</span>(t.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, idx));<br>        b = <span class="hljs-built_in">stoi</span>(t.<span class="hljs-built_in">substr</span>(idx + <span class="hljs-number">2</span>, t.<span class="hljs-built_in">size</span>() - idx - <span class="hljs-number">2</span>));<br>        mx = <span class="hljs-built_in">max</span>(mx, <span class="hljs-built_in">max</span>(a, b));<br>        in[b]++;<br>        out[a]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= mx; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (out[i] == <span class="hljs-number">0</span> &amp;&amp; in[i] == mx - <span class="hljs-number">1</span>)<br>        &#123;<br>            ans = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="农场灌溉"><a class="markdownIt-Anchor" href="#农场灌溉"></a> 农场灌溉</h2><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>题目描述：在一个包含n个节点的农场中，节点之间通过水渠相连。给定一个整数n和一个数组pipes，其中pipes[i] = [ai, bi]表示农场中ai和bi之间有一条水渠。请返回农场中已连接水渠的数目。</p><p>e.g.</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bnf">输入：0<span class="hljs-attribute">&lt;-&gt;</span>1,1<span class="hljs-attribute">&lt;-&gt;</span>2,3<span class="hljs-attribute">&lt;-&gt;</span>4<br><br>输出：2<br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>深度优先搜索(dfs)，标记访问过的节点，统计连通子图数量。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(s)</span></span>;<br>    string t;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-type">int</span> a, b, mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, t, <span class="hljs-string">&#x27;,&#x27;</span>))<br>    &#123;<br>        <span class="hljs-type">int</span> idx = t.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        a = <span class="hljs-built_in">stoi</span>(t.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, idx - <span class="hljs-number">1</span>));<br>        b = <span class="hljs-built_in">stoi</span>(t.<span class="hljs-built_in">substr</span>(idx + <span class="hljs-number">2</span>, t.<span class="hljs-built_in">size</span>() - idx));<br>        mx = <span class="hljs-built_in">max</span>(mx, <span class="hljs-built_in">max</span>(a, b));<br>        g[a].<span class="hljs-built_in">push_back</span>(b);<br>        g[b].<span class="hljs-built_in">push_back</span>(a);<br>    &#125;<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> p)<br>    &#123;<br>        vis[x] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : g[x])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i == p)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (vis[i] == <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">dfs</span>(i, x);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= mx; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (vis[i] == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">-1</span>);<br>            ans++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="社交网络连接"><a class="markdownIt-Anchor" href="#社交网络连接"></a> 社交网络连接</h2><h3 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h3><p>假设你是一位社交网络平台的技术总监，有 n 个用户在你的平台上注册。给定用户之间建立连接的成本，以及每个用户的编号，你的任务是设计算法找到以最低成本连接所有用户的方法。连接是双向的，每对用户之间至少有一条路径。如果无法连接所有用户，返回 -1。最小成本应该是所用全部连接成本的总和。</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bnf">输入：1<span class="hljs-attribute">&lt;-&gt;</span>2 5,1<span class="hljs-attribute">&lt;-&gt;</span>3 6,2<span class="hljs-attribute">&lt;-&gt;</span>3 1<br><br>输出：6<br></code></pre></td></tr></table></figure><h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3><p>求解最小生成树，使用并查集，主要是定义find函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; find = [&amp;](<span class="hljs-type">int</span> x)<br>&#123;<br>    <span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后排序，不断加边，最后统计一下连通子图的个数，判断是否连通。</p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br>struct e<br>&#123;<br>    <span class="hljs-type">int</span> u, v, w;<br>    e(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w) : u(u), v(v), w(w) &#123;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(const e &amp;o) const<br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; o.w;<br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> main()<br>&#123;<br>    string s;<br>    getline(cin, s);<br>    stringstream ss(s);<br>    string t;<br>    vector&lt;e&gt; edge;<br>    <span class="hljs-type">int</span> a, b, c, mx = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (getline(ss, t, <span class="hljs-string">&#x27;,&#x27;</span>))<br>    &#123;<br>        <span class="hljs-type">int</span> idx1 = t.find_first_of(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        <span class="hljs-type">int</span> idx2 = t.find_first_of(<span class="hljs-string">&#x27; &#x27;</span>);<br>        a = stoi(t.substr(<span class="hljs-number">0</span>, idx1 - <span class="hljs-number">1</span>));<br>        b = stoi(t.substr(idx1 + <span class="hljs-number">2</span>, idx2 - idx1 - <span class="hljs-number">2</span>));<br>        c = stoi(t.substr(idx2 + <span class="hljs-number">1</span>, t.size() - idx2 - <span class="hljs-number">1</span>));<br>        mx = max(mx, max(a, b));<br>        edge.emplace_back(e(a, b, c));<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; fa(mx + <span class="hljs-number">1</span>);<br>    iota(fa.<span class="hljs-keyword">begin</span>(), fa.<span class="hljs-keyword">end</span>(), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">function</span>&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; find = [&amp;](<span class="hljs-type">int</span> x)<br>    &#123;<br>        <span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);<br>    &#125;;<br>    sort(edge.<span class="hljs-keyword">begin</span>(), edge.<span class="hljs-keyword">end</span>());<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (e &amp;t : edge)<br>    &#123;<br>        <span class="hljs-type">int</span> x = find(t.u), y = find(t.v);<br>        <span class="hljs-keyword">if</span> (x != y)<br>        &#123;<br>            fa[x] = y;<br>            ans += t.w;<br>            ++cnt;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt == mx - <span class="hljs-number">1</span>)<br>            break;<br>    &#125;<br>    cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= mx; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (fa[i] == i)<br>            ++cnt;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">1</span>)<br>        cout &lt;&lt; <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="物流规划师"><a class="markdownIt-Anchor" href="#物流规划师"></a> 物流规划师</h2><h3 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4"></a> 题目描述</h3><p>假设你是一家货运公司的物流规划师，有 n 个城市作为货物的发货和收货点。给定城市之间的运输路径和每条路径的成功运输概率，以及每个城市的编号，你的任务是设计算法找到从发货城市到收货城市成功运输概率最大的路径。给定一个由 n 个城市和它们之间的运输路径组成的图，以及每条路径的成功运输概率。指定两个城市分别作为货物的发货点和收货点，你需要找到从发货城市到收货城市成功运输概率最大的路径，并返回该概率。如果不存在从发货城市到收货城市的路径，请返回 0。</p><p>起点为0，数字最大为终点。</p><p>e.g.</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bnf">输入：0<span class="hljs-attribute">&lt;-&gt;</span>1 0.5,1<span class="hljs-attribute">&lt;-&gt;</span>2 0.5,0<span class="hljs-attribute">&lt;-&gt;</span>2 0.2<br><br>输出：0.25000(保留5位小数，其余直接舍掉)<br><br>解释：从起点0到终点2有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25<br></code></pre></td></tr></table></figure><h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3><p>单源最短路，使用最朴素的dijkstra，求最长路径即可。</p><h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#include &lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>double mp[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br>double <span class="hljs-keyword">dis[100];</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bool </span>vis[<span class="hljs-number">100</span>];<br>int main()<br>&#123;<br>    string s;<br>    getline(cin, s);<br>    stringstream ss(s);<br>    string t;<br>    int a, <span class="hljs-keyword">b, </span>mx = <span class="hljs-number">0</span>;<br>    double c;<br>    while (getline(ss, t, <span class="hljs-string">&#x27;,&#x27;</span>))<br>    &#123;<br>        int idx1 = t.find_first_of(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        int idx2 = t.find_first_of(<span class="hljs-string">&#x27; &#x27;</span>);<br>        a = stoi(t.<span class="hljs-keyword">substr(0, </span>idx1 - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">b </span>= stoi(t.<span class="hljs-keyword">substr(idx1 </span>+ <span class="hljs-number">2</span>, idx2 - idx1 - <span class="hljs-number">2</span>));<br>        c = stod(t.<span class="hljs-keyword">substr(idx2 </span>+ <span class="hljs-number">1</span>, t.size() - idx2 - <span class="hljs-number">1</span>));<br>        mx = max(mx, max(a, <span class="hljs-keyword">b));</span><br><span class="hljs-keyword"></span>        mp[a][<span class="hljs-keyword">b] </span>= c;<br>        mp[<span class="hljs-keyword">b][a] </span>= c;<br>    &#125;<br>    memset(<span class="hljs-keyword">dis, </span>-<span class="hljs-number">0x3f</span>, sizeof(<span class="hljs-keyword">dis));</span><br><span class="hljs-keyword"></span>    <span class="hljs-keyword">dis[0] </span>= <span class="hljs-number">1</span>.<span class="hljs-number">0</span>;<br>    for (int i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt;= mx; ++i)</span><br>    &#123;<br>        int t = -<span class="hljs-number">1</span>;<br>        for (int <span class="hljs-keyword">j </span>= <span class="hljs-number">0</span><span class="hljs-comment">; j &lt;= mx; ++j)</span><br>        &#123;<br>            if (!vis[<span class="hljs-keyword">j] </span>&amp;&amp; (t == -<span class="hljs-number">1</span> <span class="hljs-title">||</span> <span class="hljs-keyword">dis[j] </span>&gt; <span class="hljs-keyword">dis[t]))</span><br><span class="hljs-keyword"></span>                t = <span class="hljs-keyword">j;</span><br><span class="hljs-keyword"></span>        &#125;<br>        vis[t] = true;<br>        for (int <span class="hljs-keyword">j </span>= <span class="hljs-number">0</span><span class="hljs-comment">; j &lt;= mx; ++j)</span><br>        &#123;<br>            <span class="hljs-keyword">dis[j] </span>= max(<span class="hljs-keyword">dis[j], </span><span class="hljs-keyword">dis[t] </span>* mp[t][<span class="hljs-keyword">j]);</span><br><span class="hljs-keyword"></span>        &#125;<br>    &#125;<br>    printf(<span class="hljs-string">&quot;%.5lf&quot;</span>, <span class="hljs-keyword">dis[mx]);</span><br><span class="hljs-keyword"></span>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>添加硬币的最小数量</title>
    <link href="/2023/12/03/%E6%B7%BB%E5%8A%A0%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E9%87%8F/"/>
    <url>/2023/12/03/%E6%B7%BB%E5%8A%A0%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%B7%BB%E5%8A%A0%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E9%87%8F">添加硬币的最小数量</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E7%BB%9F%E8%AE%A1%E5%AE%8C%E5%85%A8%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2">统计完全子字符串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="添加硬币的最小数量"><a class="markdownIt-Anchor" href="#添加硬币的最小数量"></a> 添加硬币的最小数量</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个下标从 0 开始的整数数组 coins，表示可用的硬币的面值，以及一个整数 target 。</p><p>如果存在某个 coins 的子序列总和为 x，那么整数 x 就是一个 可取得的金额 。</p><p>返回需要添加到数组中的 任意面值 硬币的 最小数量 ，使范围 [1, target] 内的每个整数都属于 可取得的金额 。</p><p>数组的 子序列 是通过删除原始数组的一些（可能不删除）元素而形成的新的 非空 数组，删除过程不会改变剩余元素的相对位置。</p><p>e.g.</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：coins = [1,4,10,5,7,19], target = 19<br>输出：1<br>解释：只需要添加一枚面值为<span class="hljs-number"> 2 </span>的硬币，得到硬币数组 [1,2,4,5,7,10,19] 。<br>可以证明从<span class="hljs-number"> 1 </span>到<span class="hljs-number"> 19 </span>的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>周赛的第二题，自己没想到，靠gpt给了思路(<s>tcl😢</s>)</p><p>首先对所有coins升序排序，设当前可取得的最大值是maxnum(初始为0)。接下来遍历coins，下一个要取得的值应为maxnum+1，如果当前coin&gt;maxnum+1，说明需要添加新的硬币，且新硬币的面值应当为maxnum+1，而maxnum也要更新：maxnum+=maxnum+1（原本已有硬币可以取得0~maxnum之间任意值，加入面值为maxnum+1的硬币后，上界也应当扩大maxnum+1），直到当前coin &lt;= maxnum+1，此时说明不算当前coin已有硬币最大可以取到maxnum+1，那么算上coin后，maxnum更新为maxnum+=maxnum+coin。每次更新maxnum时都应检查maxnum&gt;=target，如果满足那么直接返回加入的硬币数量，如果遍历完coins，maxnum依然小于target，那么继续maxnum+=maxnum+1，++ans。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">minimumAddedCoins</span>(<span class="hljs-params">vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; coins, <span class="hljs-built_in">int</span> target</span>)</span> &#123;<br>        sort(coins.begin(), coins.end());<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">add</span> = <span class="hljs-number">0</span>, max_num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> c : coins)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (c &gt; max_num + <span class="hljs-number">1</span>)<br>            &#123;<br>                ++<span class="hljs-keyword">add</span>;<br>                max_num += max_num + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (max_num &gt;= target)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">add</span>;<br>            &#125;<br>            max_num += c;<br>            <span class="hljs-keyword">if</span> (max_num &gt;= target)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">add</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (max_num &lt; target)<br>        &#123;<br>            ++<span class="hljs-keyword">add</span>;<br>            max_num += max_num + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">add</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="统计完全子字符串"><a class="markdownIt-Anchor" href="#统计完全子字符串"></a> 统计完全子字符串</h2><p><a href="https://leetcode.cn/problems/count-complete-substrings/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>给你一个字符串 word 和一个整数 k 。</p><p>如果 word 的一个子字符串 s 满足以下条件，我们称它是 完全字符串：</p><p>s 中每个字符 恰好 出现 k 次。<br />相邻字符在字母表中的顺序 至多 相差 2 。也就是说，s 中两个相邻字符 c1 和 c2 ，它们在字母表中的位置相差 至多 为 2 。<br />请你返回 word 中 完全 子字符串的数目。</p><p>子字符串 指的是一个字符串中一段连续 非空 的字符序列。</p><p>e.g.</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">word</span> = <span class="hljs-string">&quot;igigee&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：完全子字符串需要满足每个字符恰好出现 <span class="hljs-number">2</span> 次，且相邻字符相差至多为 <span class="hljs-number">2</span> ：igigee, igigee, igigee 。<br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>周赛第三题，主要思路是分组加滑动窗口。</p><p>要求相邻字符差不大于2，那么当两个字符间大于2时，就可以在中间进行分割，这样将原始字符串划分成许多段，段内进行处理。</p><p>对于每一段，需要统计满足k次要求的子串个数，可以固定滑动窗口的大小为m*k，m是子串中字符种类，然后维护一个cnt数组记录每个字符出现次数，遍历所有滑窗，统计出滑窗内每个字符都出现k次的子串个数。</p><p>这道题时间复杂度要求比较高，检查函数定义在外部就超时了。。。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs perl">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> <span class="hljs-function"><span class="hljs-keyword">sub</span>(<span class="hljs-title">string</span> <span class="hljs-title">s</span>,<span class="hljs-title">int</span> <span class="hljs-title">k</span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n=s.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m=<span class="hljs-number">1</span>;m&lt;=<span class="hljs-number">26</span> &amp;&amp; m*k&lt;=n;++m)<br>        &#123;<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; cnt(<span class="hljs-number">26</span>);<br>            function&lt;bool()&gt; check=[&amp;]()<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;++i)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(cnt[i]&amp;&amp;cnt[i]!=k)<br>                        <span class="hljs-keyword">return</span> false;<br>                &#125;<br>                <span class="hljs-keyword">return</span> true;<br>            &#125;;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r=<span class="hljs-number">0</span>;r&lt;n;++r)<br>            &#123;<br>                ++cnt[s[r]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>                <span class="hljs-keyword">int</span> l=r-m*k+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(l&gt;=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(check()) ++res;<br>                    --cnt[s[l]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">int</span> countCompleteSubstrings(string word, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">int</span> n=word.size();<br>        <span class="hljs-keyword">int</span> pre_pos=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">abs</span>(word[i]-word[i-<span class="hljs-number">1</span>])&gt;<span class="hljs-number">2</span>)<br>            &#123;<br>                ans+=<span class="hljs-function"><span class="hljs-keyword">sub</span></span>(word.substr(pre_pos,i-pre_pos),k);<br>                pre_pos=i;<br>            &#125;<br>        &#125;<br>        ans+=<span class="hljs-function"><span class="hljs-keyword">sub</span></span>(word.substr(pre_pos,n-pre_pos),k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>四种位置编码实现</title>
    <link href="/2023/12/02/%E5%9B%9B%E7%A7%8D%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/12/02/%E5%9B%9B%E7%A7%8D%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#transformer--vit--swin-transformer--mae%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0">Transformer / VIT / Swin Transformer / MAE中的位置编码实现</a><ul><li><a href="#transformer">Transformer</a></li><li><a href="#vit%E4%B8%AD%E7%9A%84%E7%BB%9D%E5%AF%B9%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81">VIT中的绝对位置编码</a></li><li><a href="#swin-transformer%E7%9A%84%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81">Swin Transformer的相对位置编码</a></li><li><a href="#mae">MAE</a></li></ul></li></ul><!-- /TOC --><h2 id="transformer-vit-swin-transformer-mae中的位置编码实现"><a class="markdownIt-Anchor" href="#transformer-vit-swin-transformer-mae中的位置编码实现"></a> Transformer / VIT / Swin Transformer / MAE中的位置编码实现</h2><h3 id="transformer"><a class="markdownIt-Anchor" href="#transformer"></a> Transformer</h3><p>Transformer中的位置编码是这样定义的：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>P</mi><msub><mi>E</mi><mrow><mo stretchy="false">(</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi><mo stretchy="false">)</mo></mrow></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>p</mi><mi>o</mi><mi>s</mi><mi mathvariant="normal">/</mi><mn>1000</mn><msup><mn>0</mn><mrow><mn>2</mn><mi>i</mi><mi mathvariant="normal">/</mi><msub><mi>d</mi><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi></mrow></msub></mrow></msup><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>P</mi><msub><mi>E</mi><mrow><mo stretchy="false">(</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>p</mi><mi>o</mi><mi>s</mi><mi mathvariant="normal">/</mi><mn>1000</mn><msup><mn>0</mn><mrow><mn>2</mn><mi>i</mi><mi mathvariant="normal">/</mi><msub><mi>d</mi><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi></mrow></msub></mrow></msup><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}PE_{(pos,2i)}&amp;=sin(pos/10000^{2i/d_{\mathrm{model}}})\\PE_{(pos,2i+1)}&amp;=cos(pos/10000^{2i/d_{\mathrm{model}}})\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.196em;vertical-align:-1.348em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.848em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.3120000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.348em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.848em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">m</span><span class="mord mathrm mtight">o</span><span class="mord mathrm mtight">d</span><span class="mord mathrm mtight">e</span><span class="mord mathrm mtight">l</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.3120000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">m</span><span class="mord mathrm mtight">o</span><span class="mord mathrm mtight">d</span><span class="mord mathrm mtight">e</span><span class="mord mathrm mtight">l</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.348em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_1d_absolute_sincos_pe</span>(<span class="hljs-params">n_pos_vec, dim</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param n_pos_vec: (tensor)torch.arrge(n_pos,dtype=torch.float32)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">assert</span> dim % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;dim must be even&#x27;</span><br>    position_embedding = torch.zeros((n_pos_vec.numel(), dim), dtype=torch.float32)  <span class="hljs-comment"># [n_pos,dim]</span><br>    omega = torch.arange(dim // <span class="hljs-number">2</span>, dtype=torch.float32)  <span class="hljs-comment"># i</span><br>    omega /= dim / <span class="hljs-number">2</span><br>    omega = <span class="hljs-number">1</span> / (<span class="hljs-number">1e4</span>**omega)<br>    out = n_pos_vec.unsqueeze(<span class="hljs-number">1</span>) @ omega.unsqueeze(<span class="hljs-number">0</span>)  <span class="hljs-comment"># [n_pos,dim//2]</span><br>    position_embedding[:, <span class="hljs-number">0</span>::<span class="hljs-number">2</span>] = torch.sin(out)<br>    position_embedding[:, <span class="hljs-number">1</span>::<span class="hljs-number">2</span>] = torch.cos(out)<br>    <span class="hljs-keyword">return</span> position_embedding<br></code></pre></td></tr></table></figure><h3 id="vit中的绝对位置编码"><a class="markdownIt-Anchor" href="#vit中的绝对位置编码"></a> VIT中的绝对位置编码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_1d_absolute_trainable_pe</span>(<span class="hljs-params">n_pos_vec, dim</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param n_pos_vec: (tensor)torch.arrge(n_pos,dtype=torch.float32)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    position_embedding = nn.Embedding(n_pos_vec.numel(), dim)<br>    <span class="hljs-comment"># initialize the position embedding</span><br>    nn.init.constant_(position_embedding.weight, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> position_embedding<br></code></pre></td></tr></table></figure><h3 id="swin-transformer的相对位置编码"><a class="markdownIt-Anchor" href="#swin-transformer的相对位置编码"></a> Swin Transformer的相对位置编码</h3><p>在Swin中，相对位置编码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>用于计算注意力时：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Attention</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">SoftMax</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup><mi mathvariant="normal">/</mi><msqrt><mi>d</mi></msqrt><mo>+</mo><mi>B</mi><mo stretchy="false">)</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\operatorname{Attention}(Q,K,V)=\operatorname{SoftMax}(QK^T/\sqrt d+B)V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">A</span><span class="mord mathrm">t</span><span class="mord mathrm">t</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">o</span><span class="mord mathrm">n</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.231095em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">S</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mord mathrm">t</span><span class="mord mathrm">M</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981095em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="padding-left:0.833em;">d</span></span><span style="top:-2.941095em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.058904999999999985em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> get_2d_relative_position_index(height, width):<br>    <span class="hljs-attribute">m1</span>, m2 = torch.meshgrid(torch.arange(height), torch.arange(width))  # m1每一行相等，m2每一列相等<br>    <span class="hljs-attribute">coords</span> = torch.stack((m1, m2), dim=<span class="hljs-number">0</span>)  #<span class="hljs-meta"> [2,h,w]</span><br>    <span class="hljs-attribute">coords_f</span> = torch.flatten(coords, <span class="hljs-number">1</span>)  #<span class="hljs-meta"> [2,h*w]</span><br>    <span class="hljs-attribute">relative_coords_bias</span> = coords_f[:, :, None] - coords_f[:, None, :]  #<span class="hljs-meta"> [2,h*w,h*w]</span><br>    <span class="hljs-attribute">relative_coords_bias</span>[<span class="hljs-number">0</span>, :, :] += height - <span class="hljs-number">1</span><br>    <span class="hljs-attribute">relative_coords_bias</span>[<span class="hljs-number">1</span>, :, :] += width - <span class="hljs-number">1</span><br>    <span class="hljs-attribute">relative_coords_bias</span>[<span class="hljs-number">0</span>, :, :] *= relative_coords_bias[<span class="hljs-number">1</span>, :, :].max() + <span class="hljs-number">1</span><br>    <span class="hljs-attribute">return</span> relative_coords_bias[<span class="hljs-number">0</span>, :, :] + relative_coords_bias[<span class="hljs-number">1</span>, :, :]<br><br><br><span class="hljs-attribute">def</span> create_2d_relative_bias_trainable_pe(n_head, height, width, dim):<br>    <span class="hljs-attribute">position_embedding</span> = nn.Embedding((<span class="hljs-number">2</span> * height - <span class="hljs-number">1</span>) * (<span class="hljs-number">2</span> * width - <span class="hljs-number">1</span>), n_head)  # bias[-h+<span class="hljs-number">1</span>,h-<span class="hljs-number">1</span>],bias[-w+<span class="hljs-number">1</span>,w-<span class="hljs-number">1</span>]<br>    <span class="hljs-attribute">nn</span>.init.constant_(position_embedding.weight, <span class="hljs-number">0</span>)<br>    <span class="hljs-attribute">relative_position_index</span> = get_2d_relative_position_index(height, width)  #<span class="hljs-meta"> [h*w,h*w],获得相对位置索引</span><br><span class="hljs-meta">    bias_embedding = position_embedding(torch.flatten(relative_position_index)).reshape(height * width, height * width, n_head)  # [h*w,h*w,n_head]</span><br>    <span class="hljs-attribute">bias_embedding</span> = bias_embedding.permute(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>).unsqueeze(<span class="hljs-number">0</span>)  #<span class="hljs-meta"> [1,n_head,h*w,h*w]</span><br>    <span class="hljs-attribute">return</span> position_embedding<br></code></pre></td></tr></table></figure><p>因为每个patch与其他所有patch之间的位置关系都需要被编码，因此输出后两维是h*w</p><h3 id="mae"><a class="markdownIt-Anchor" href="#mae"></a> MAE</h3><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs hsp">def create_2d_absolute_sincos_pe(height, <span class="hljs-keyword">width</span>, <span class="hljs-keyword">dim</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">dim</span> % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;dim must be divisible by 4&#x27;</span><br>    position_embedding = torch.zeros((height * <span class="hljs-keyword">width</span>, <span class="hljs-keyword">dim</span>), dtype=torch.float32)  <span class="hljs-meta"># [h*w,dim]</span><br>    coords = torch.stack(torch.meshgrid(torch.arange(height, dtype=torch.float32), torch.arange(<span class="hljs-keyword">width</span>, dtype=torch.float32)), <span class="hljs-keyword">dim</span>=<span class="hljs-number">0</span>)  <span class="hljs-meta"># [<span class="hljs-number">2</span>,h,w]</span><br>    height_embedding = create_1d_absolute_sincos_pe(coords[<span class="hljs-number">0</span>].flatten(), <span class="hljs-keyword">dim</span> <span class="hljs-comment">// 2)  # [h*w,dim//2]</span><br>    width_embedding = create_1d_absolute_sincos_pe(coords[<span class="hljs-number">1</span>].flatten(), <span class="hljs-keyword">dim</span> <span class="hljs-comment">// 2)  # [h*w,dim//2]</span><br>    position_embedding[:, : <span class="hljs-keyword">dim</span> <span class="hljs-comment">// 2] = height_embedding  # [h*w,dim//2]</span><br>    position_embedding[:, <span class="hljs-keyword">dim</span> <span class="hljs-comment">// 2 :] = width_embedding  # [h*w,dim//2]</span><br>    <span class="hljs-keyword">return</span> position_embedding<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>资料</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子数组的最小值之和</title>
    <link href="/2023/11/28/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/"/>
    <url>/2023/11/28/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C">子数组的最小值之和</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="子数组的最小值之和"><a class="markdownIt-Anchor" href="#子数组的最小值之和"></a> 子数组的最小值之和</h2><p><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。</p><p>由于答案可能很大，因此 返回答案模 10^9 + 7 。</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[3,1,2,4]</span><br>输出：17<br>解释：<br>子数组为 <span class="hljs-comment">[3]</span>，<span class="hljs-comment">[1]</span>，<span class="hljs-comment">[2]</span>，<span class="hljs-comment">[4]</span>，<span class="hljs-comment">[3,1]</span>，<span class="hljs-comment">[1,2]</span>，<span class="hljs-comment">[2,4]</span>，<span class="hljs-comment">[3,1,2]</span>，<span class="hljs-comment">[1,2,4]</span>，<span class="hljs-comment">[3,1,2,4]</span>。 <br>最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题主要还是用到单调栈的思想。我们需要计算每个以arr[i]为最小值的子数组最小值之和，例如 arr=[1,4,2,3,1]，其中2是子数组[2],[4,2],[2,3],[4,2,3]的最小值，那么2对答案的贡献就是8。因此，需要利用单调栈找到arr[i]左边第一个比他小的数的下标L，和右边第一个比他小的数的下标R，因为子数组要包括arr[i]，因此左端点可以是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>L</mi><mo>+</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">L+1, L+2, ... i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathnormal">i</span></span></span></span>共i-L个，右端点可以是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mtext>，</mtext><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>L</mi><mo>+</mo><mn>2</mn><mtext>，</mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>R</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i，i+1, L+2，... R-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>共R-i个，因此以arr[i]为最小值的子数组对答案的贡献为(i-L)*(R-i)*arr[i]。</p><p>要注意的是，由于可能存在重复的数，因此每个arr[i]对应的左右边界不能重叠，否则会导致重复计算，所以左右边界要满足<strong>左闭右开（左开右闭）</strong></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;</span><br><span class="hljs-class">public:</span><br><span class="hljs-class">    int sumSubarrayMins(<span class="hljs-title">vector</span>&lt;<span class="hljs-title">int</span>&gt;&amp; <span class="hljs-title">arr</span>) &#123;</span><br><span class="hljs-class">        int n=arr.size();</span><br><span class="hljs-class">        stack&lt;int&gt; ls,rs;</span><br><span class="hljs-class">        vector&lt;int&gt; left(<span class="hljs-title">n</span>),right(<span class="hljs-title">n</span>);</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            while(!<span class="hljs-title">ls</span>.<span class="hljs-title">empty</span>()&amp;&amp;arr[ls.top()]&gt;=arr[i])</span><br><span class="hljs-class">                ls.pop();</span><br><span class="hljs-class">            left[i]=ls.empty() ? -1:ls.top();</span><br><span class="hljs-class">            ls.push(<span class="hljs-title">i</span>);</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=<span class="hljs-title">n</span>-1;<span class="hljs-title">i</span>&gt;=0;<span class="hljs-comment">--i)</span></span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            <span class="hljs-title">while</span>(!<span class="hljs-title">rs</span>.<span class="hljs-title">empty</span>()&amp;&amp;arr[rs.top()]&gt;arr[i])</span><br><span class="hljs-class">                rs.pop();</span><br><span class="hljs-class">            right[i]=rs.empty() ? n:rs.top();</span><br><span class="hljs-class">            rs.push(<span class="hljs-title">i</span>);</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        int mod=1e9+7;</span><br><span class="hljs-class">        long long ans=0;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">            ans+=((<span class="hljs-title">long</span> <span class="hljs-title">long</span>)(<span class="hljs-title">i</span>-<span class="hljs-title">left</span>[<span class="hljs-title">i</span>])*(<span class="hljs-title">right</span>[<span class="hljs-title">i</span>]-<span class="hljs-title">i</span>)*arr[i])%mod;</span><br><span class="hljs-class">        return ans%mod;</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">&#125;;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>交换得到字典序最小的数组</title>
    <link href="/2023/11/26/%E4%BA%A4%E6%8D%A2%E5%BE%97%E5%88%B0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <url>/2023/11/26/%E4%BA%A4%E6%8D%A2%E5%BE%97%E5%88%B0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BA%A4%E6%8D%A2%E5%BE%97%E5%88%B0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E7%BB%84">交换得到字典序最小的数组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="交换得到字典序最小的数组"><a class="markdownIt-Anchor" href="#交换得到字典序最小的数组"></a> 交换得到字典序最小的数组</h2><p><a href="https://leetcode.cn/problems/make-lexicographically-smallest-array-by-swapping-elements/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个下标从 0 开始的 正整数 数组 nums 和一个 正整数 limit 。</p><p>在一次操作中，你可以选择任意两个下标 i 和 j，如果 满足 |nums[i] - nums[j]| &lt;= limit ，则交换 nums[i] 和 nums[j] 。</p><p>返回执行任意次操作后能得到的 字典序最小的数组 。</p><p>如果在数组 a 和数组 b 第一个不同的位置上，数组 a 中的对应字符比数组 b 中的对应字符的字典序更小，则认为数组 a 就比数组 b 字典序更小。例如，数组 [2,10,3] 比数组 [10,2,3] 字典序更小，下标 0 处是两个数组第一个不同的位置，且 2 &lt; 10 。</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,5,3,9,8]</span>, limit = 2<br>输出：<span class="hljs-comment">[1,3,5,8,9]</span><br>解释：执行 2 次操作：<br>- 交换 nums<span class="hljs-comment">[1]</span> 和 nums<span class="hljs-comment">[2]</span> 。数组变为 <span class="hljs-comment">[1,3,5,9,8]</span> 。<br>- 交换 nums<span class="hljs-comment">[3]</span> 和 nums<span class="hljs-comment">[4]</span> 。数组变为 <span class="hljs-comment">[1,3,5,8,9]</span> 。<br>即便执行更多次操作，也无法得到字典序更小的数组。<br>注意，执行不同的操作也可能会得到相同的结果。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要思路是分组排序和二分。首先需要对数组进行排序，接下来将他们分组，分组的原则是组内升序且各个组之间，不存在任何一对可以交换的元素<code>(tmp[j]-tmp[i]&gt;limit,j&gt;i)</code>，然后用数组idx[]记录每个组的第一个元素在有序数组中的下标，offset[]记录偏移量。接下来遍历nums数组，每个元素先二分查找在有序数组中的下标j，然后再二分查找j属于哪个组，然后根据组内起始下标和组内偏移确定在有序数组中的下标，然后添加到ans中。总的来说，每次遍历元素放置的是元素所在组内能交换的较小值，因此保证了字典序较小。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lexicographicallySmallestArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; tmp=nums;<br>        <span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; idx;<br>        idx.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tmp[i]-tmp[t]&gt;limit)<br>            &#123;<br>                idx.<span class="hljs-built_in">push_back</span>(i);<br>                t=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> m=idx.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">offset</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> j=<span class="hljs-built_in">upper_bound</span>(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>(),nums[i])-tmp.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-type">int</span> k=<span class="hljs-built_in">lower_bound</span>(idx.<span class="hljs-built_in">begin</span>(),idx.<span class="hljs-built_in">end</span>(),j)-idx.<span class="hljs-built_in">begin</span>();<br>            ans[i]=tmp[idx[k<span class="hljs-number">-1</span>]+offset[k<span class="hljs-number">-1</span>]];<br>            ++offset[k<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网格中最小路径代价</title>
    <link href="/2023/11/22/%E7%BD%91%E6%A0%BC%E4%B8%AD%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%BB%A3%E4%BB%B7/"/>
    <url>/2023/11/22/%E7%BD%91%E6%A0%BC%E4%B8%AD%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BD%91%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%BB%A3%E4%BB%B7">网格中的最小路径代价</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="网格中的最小路径代价"><a class="markdownIt-Anchor" href="#网格中的最小路径代价"></a> 网格中的最小路径代价</h2><p><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个下标从 0 开始的整数矩阵 grid ，矩阵大小为 m x n ，由从 0 到 m * n - 1 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 下一行 的任何其他单元格。如果你位于单元格 (x, y) ，且满足 x &lt; m - 1 ，你可以移动到 (x + 1, 0), (x + 1, 1), …, (x + 1, n - 1) 中的任何一个单元格。注意： 在最后一行中的单元格不能触发移动。</p><p>每次可能的移动都需要付出对应的代价，代价用一个下标从 0 开始的二维数组 moveCost 表示，该数组大小为 (m * n) x n ，其中 moveCost[i][j] 是从值为 i 的单元格移动到下一行第 j 列单元格的代价。从 grid 最后一行的单元格移动的代价可以忽略。</p><p>grid 一条路径的代价是：所有路径经过的单元格的 值之和 加上 所有移动的 代价之和 。从 第一行 任意单元格出发，返回到达 最后一行 任意单元格的最小路径代价。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题关键在于理解moveCost的意思。可以用dp[i][j]表示从第0行某元素到第i行第j列元素的代价，状态方程可以表示为：<code> dp[i][j]=min(dp[i][j],dp[i-1][k]+grid[i][j]+moveCost[grid[i-1][k]][j]);</code>，注意这里moveCost的行索引是元素的值。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> minPathCost(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-keyword">grid</span>, <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; moveCost) &#123;<br>        <span class="hljs-keyword">int</span> m=<span class="hljs-keyword">grid</span>.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">int</span> n=<span class="hljs-keyword">grid</span>[<span class="hljs-number">0</span>].<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp(m,<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n,INT_MAX));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            dp[<span class="hljs-number">0</span>][j]=<span class="hljs-keyword">grid</span>[<span class="hljs-number">0</span>][j];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k)<br>                    dp[i][j]=<span class="hljs-keyword">min</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][k]+<span class="hljs-keyword">grid</span>[i][j]+moveCost[<span class="hljs-keyword">grid</span>[i<span class="hljs-number">-1</span>][k]][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *min_element(dp[m<span class="hljs-number">-1</span>].begin(),dp[m<span class="hljs-number">-1</span>].end());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法作业3</title>
    <link href="/2023/11/15/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A3/"/>
    <url>/2023/11/15/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A3/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B9%A6%E7%B1%8D%E5%BD%92%E6%A1%A3">书籍归档</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E5%81%9C%E8%BD%A6%E5%9C%BA%E7%AE%A1%E7%90%86%E5%91%98">停车场管理员</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E5%AF%B9">服务器配对</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-2">代码</a></li></ul></li><li><a href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">哈夫曼编码</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-3">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-3">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="书籍归档"><a class="markdownIt-Anchor" href="#书籍归档"></a> 书籍归档</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你是一名图书馆管理员，负责归档书籍。你有一个书架，它能承载一定量的重量。给定一个整数数组 books，其中 books[i] 表示第 i 本书的重量。书架的承重限制为 5000 单位。返回你最多可以归档的书籍数量。<br />input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">900 </span><span class="hljs-number">950</span> <span class="hljs-number">800</span> <span class="hljs-number">1000</span> <span class="hljs-number">700</span> <span class="hljs-number">800</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>比较简单，排序然后统计一下…</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a) != EOF)<br>        v.<span class="hljs-built_in">push_back</span>(a);<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> w = <span class="hljs-number">5000</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (w &gt;= v[i])<br>        &#123;<br>            w -= v[i];<br>            ++ans;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="停车场管理员"><a class="markdownIt-Anchor" href="#停车场管理员"></a> 停车场管理员</h2><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>你是一家购物中心的停车场管理员，需要安排各辆车的停车时段。每辆车的停车时段可以用一个时间数组来表示，数组中包括车辆进入和离开的时间 ，你的任务是确定购物中心所需的最小停车位数量。</p><p>e.g.</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<span class="hljs-number">0,30 5,10</span> <span class="hljs-number">15</span>,<span class="hljs-number">20</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>定义一个数组，用每个时间段对数组进行填充，统计数组的最大值即可，注意填充是要左闭右开。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">int</span> d[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; v;<br>    string s;<br>    <span class="hljs-type">int</span> a, b;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-built_in">getline</span>(cin, s);<br>    <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(s)</span></span>;<br>    <span class="hljs-keyword">while</span> (ss &gt;&gt; a &gt;&gt; c &gt;&gt; b)<br>        v.<span class="hljs-built_in">push_back</span>(&#123;a, b&#125;);<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (PII p : v)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p.first; i &lt; p.second; ++i)<br>        &#123;<br>            ++d[i];<br>            ans = <span class="hljs-built_in">max</span>(ans, d[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="服务器配对"><a class="markdownIt-Anchor" href="#服务器配对"></a> 服务器配对</h2><h3 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h3><p>在一个大型的数据中心，服务器是成对安置的，以便进行数据镜像和冗余备份。每对服务器由一对连续的整数表示，如第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。由于配置错误，服务器的配对顺序被打乱了。现在，需要通过网络中的虚拟交换，重新配置服务器，使得每对服务器可以重新成对工作。虚拟交换可以在任意两台服务器之间进行，而不管它们的位置如何。返回最少交换次数，以便每对服务器可以重新配对工作。<br />e.g.</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：1<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 0 </span>2 5<br>输出：2<br></code></pre></td></tr></table></figure><h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3><p>用一个数组pos来记录每个元素的位置，然后遍历数组，对于每个元素a，和他配对的元素是a^1，如1配对0，2配对3，3配对2。遍历时只用遍历偶数下标i的元素，如果i+1元素无法配对，那么交换i+1位置的元素和配对元素，同时交换他们在pos数组中的位置。</p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; a)<br>        v.<span class="hljs-built_in">push_back</span>(a);<br>    <span class="hljs-type">int</span> n = v.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pos</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        pos[v[i]] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> match = v[i] ^ <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (v[i + <span class="hljs-number">1</span>] != match)<br>        &#123;<br>            ++ans;<br>            <span class="hljs-built_in">swap</span>(v[i + <span class="hljs-number">1</span>], v[pos[match]]);<br>            <span class="hljs-built_in">swap</span>(pos[v[i + <span class="hljs-number">1</span>]], pos[v[pos[match]]]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈夫曼编码"><a class="markdownIt-Anchor" href="#哈夫曼编码"></a> 哈夫曼编码</h2><h3 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4"></a> 题目描述</h3><p>请以霍夫曼编码方式压缩《傲慢与偏见》，为了将编码文本写入文件（以&quot;wb&quot;二进制模式写入文件）。</p><h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3><p>用优先级队列模拟元素插入的过程，辅助建树，注意代码中文件读写的实现和建树过程。</p><h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-type">int</span> freq;<br>    Node *left, *right;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">char</span> c, <span class="hljs-type">int</span> f, Node *l = <span class="hljs-literal">nullptr</span>, Node *r = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">ch</span>(c), <span class="hljs-built_in">freq</span>(f), <span class="hljs-built_in">left</span>(l), <span class="hljs-built_in">right</span>(r) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 定义排序规则(小顶堆)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">compare</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Node *l, Node *r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> l-&gt;freq &gt; r-&gt;freq;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 递归获取哈夫曼编码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Node *root, string str, map&lt;<span class="hljs-type">char</span>, string&gt; &amp;huffmanCode)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)<br>        huffmanCode[root-&gt;ch] = str;<br>    <span class="hljs-built_in">encode</span>(root-&gt;left, str + <span class="hljs-string">&quot;0&quot;</span>, huffmanCode);<br>    <span class="hljs-built_in">encode</span>(root-&gt;right, str + <span class="hljs-string">&quot;1&quot;</span>, huffmanCode);<br>&#125;<br><br><span class="hljs-comment">// 哈夫曼编码压缩，返回平均编码长度</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">huffmanCompress</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;filename)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">file</span><span class="hljs-params">(filename, ios::in)</span></span>;<br>    map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; freq;<br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 统计出现频率</span><br>    <span class="hljs-keyword">while</span> (file.<span class="hljs-built_in">get</span>(ch))<br>    &#123;<br>        freq[ch]++;<br>        ++cnt;<br>    &#125;<br><br>    priority_queue&lt;Node *, vector&lt;Node *&gt;, compare&gt; pq;<br>    <span class="hljs-comment">// 初始化叶子节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : freq)<br>        pq.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(it.first, it.second));<br>    <span class="hljs-comment">// 构建哈夫曼树</span><br>    <span class="hljs-keyword">while</span> (pq.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>)<br>    &#123;<br>        Node *left = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        Node *right = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> sum = left-&gt;freq + right-&gt;freq;<br>        pq.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-string">&#x27;\0&#x27;</span>, sum, left, right));<br>    &#125;<br><br>    Node *root = pq.<span class="hljs-built_in">top</span>();<br>    map&lt;<span class="hljs-type">char</span>, string&gt; huffmanCode; <span class="hljs-comment">// 保存每个字符对应的哈夫曼编码</span><br>    <span class="hljs-built_in">encode</span>(root, <span class="hljs-string">&quot;&quot;</span>, huffmanCode);<br><br>    <span class="hljs-comment">// 计算平均编码长度</span><br>    <span class="hljs-type">double</span> avgLen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : huffmanCode)<br>        avgLen += it.second.<span class="hljs-built_in">size</span>() * freq[it.first];<br>    avgLen /= cnt;<br><br>    file.<span class="hljs-built_in">clear</span>();<br>    file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-function">ofstream <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-string">&quot;text.huff&quot;</span>, ios::out | ios::binary)</span></span>;<br>    <span class="hljs-comment">// 写入二进制文件</span><br>    <span class="hljs-type">char</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (file.<span class="hljs-built_in">get</span>(ch))<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : huffmanCode[ch])<br>        &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                buffer |= (<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">7</span> - index));<br>            index++;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">8</span>)<br>            &#123;<br>                output &lt;&lt; buffer;<br>                index = <span class="hljs-number">0</span>;<br>                buffer = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    file.<span class="hljs-built_in">close</span>();<br>    output.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> avgLen;<br>&#125;<br><span class="hljs-comment">// 计算压缩比率</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getCompressRate</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;filename)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">file</span><span class="hljs-params">(filename, ios::in)</span></span>;<br>    file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::end);<br>    <span class="hljs-type">double</span> originSize = file.<span class="hljs-built_in">tellg</span>(); <span class="hljs-comment">// 返回文件字节数</span><br>    file.<span class="hljs-built_in">close</span>();<br>    file.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;text.huff&quot;</span>, ios::in);<br>    file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::end);<br>    <span class="hljs-type">double</span> compressSize = file.<span class="hljs-built_in">tellg</span>();<br>    file.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> compressSize / originSize;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">huffmanCompress</span>(<span class="hljs-string">&quot;Pride and Prejudice.txt&quot;</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Compress Rate: &quot;</span> &lt;&lt; <span class="hljs-built_in">getCompressRate</span>(<span class="hljs-string">&quot;Pride and Prejudice.txt&quot;</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文本左右对齐</title>
    <link href="/2023/11/13/%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90/"/>
    <url>/2023/11/13/%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90">文本左右对齐</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="文本左右对齐"><a class="markdownIt-Anchor" href="#文本左右对齐"></a> 文本左右对齐</h2><p><a href="https://leetcode.cn/problems/text-justification/description/?envType=study-plan-v2&amp;envId=top-interview-150">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。</p><p>你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ’ ’ 填充，使得每行恰好有 maxWidth 个字符。</p><p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p><p>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</p><p>注意:</p><p>单词是指由非空格字符组成的字符序列。<br />每个单词的长度大于 0，小于等于 maxWidth。<br />输入单词数组 words 至少包含一个单词。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: words = [<span class="hljs-string">&quot;This&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;of&quot;</span>, <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-string">&quot;justification.&quot;</span>], maxWidth = <span class="hljs-number">16</span><br>输出:<br>[<br>   <span class="hljs-string">&quot;This    is    an&quot;</span>,<br>   <span class="hljs-string">&quot;example  of text&quot;</span>,<br>   <span class="hljs-string">&quot;justification.  &quot;</span><br>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题不涉及什么算法，主要考察字符串处理能力。可以按行来处理，首先记录要加入每行的单词有哪些，可以遍历单词，累加遍历过的单词长度，如果加入下一个单词后总长度大于maxWidth，或者下一个单词是最后一个单词，那么就将现有区间的所有单词生成一行并返回。</p><p>对于空格，我们可以先统计每行总的空格数量spnum，然后计算每个字符串后跟的基本空格数<code>base_space=(wordnum==1)? spnum:spnum/(wordnum-1)</code>，还需额外的空格数为<code>extra_space=(wordnum==1)? 0:spnum%(wordnum-1);</code>，每个单词后面补的空格数为<code>string(base_space+((i-start)&lt;extra_space),' ')</code>。在处理时要注意，如果是处理最后一行，则每个单词后面加一个空格就行，然后每行最后一个单词根据当前行的长度在后面补上对应数量的空格。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">getline</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end, <span class="hljs-type">int</span> width,<span class="hljs-type">bool</span> last)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> wordnum= end-start+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;=end;++i)<br>            sum+=words[i].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> spnum=width-sum;<br>        <span class="hljs-type">int</span> base_space=(wordnum==<span class="hljs-number">1</span>)? spnum:spnum/(wordnum<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> extra_space=(wordnum==<span class="hljs-number">1</span>)? <span class="hljs-number">0</span>:spnum%(wordnum<span class="hljs-number">-1</span>);<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;end;++i)<br>        &#123;<br>            res+=words[i];<br>            <span class="hljs-keyword">if</span>(last)<br>            &#123;<br>                res+=<span class="hljs-string">&#x27; &#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            res+=<span class="hljs-built_in">string</span>(base_space+((i-start)&lt;extra_space),<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>        res+=words[end];<br>        res+=<span class="hljs-built_in">string</span>(width-res.<span class="hljs-built_in">size</span>(),<span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">fullJustify</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> maxWidth)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=words.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            sum+=words[i].<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>==n||sum+words[i+<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()&gt;maxWidth)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">getline</span>(words,start,i,maxWidth,i+<span class="hljs-number">1</span>==n));<br>                start=i+<span class="hljs-number">1</span>;<br>                sum=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;      <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分发糖果</title>
    <link href="/2023/11/08/%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
    <url>/2023/11/08/%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C">分发糖果</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="分发糖果"><a class="markdownIt-Anchor" href="#分发糖果"></a> 分发糖果</h2><p><a href="https://leetcode.cn/problems/candy/description/?envType=study-plan-v2&amp;envId=top-interview-150">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br />相邻两个孩子评分更高的孩子会获得更多的糖果。<br />请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p><p>e.g.</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：ratings </span>=<span class="hljs-string"> [1,0,2]</span><br><span class="hljs-string">输出：5</span><br><span class="hljs-string">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>可以分别从左右两边开始遍历，当满足顺序要求时，糖果数加1，当不满足时糖果数为1，然后统计每个人左右两种顺序下的最大值累加到答案中即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    <span class="hljs-built_in">int</span> candy(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; ratings) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>=ratings.size();<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">left</span>(<span class="hljs-built_in">n</span>);<br>        <span class="hljs-built_in">left</span>[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">n</span>;++i)<br>        &#123;<br>            <span class="hljs-built_in">if</span>(ratings[i]&gt;ratings[i-<span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">left</span>[i]=<span class="hljs-built_in">left</span>[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            else<br>                <span class="hljs-built_in">left</span>[i]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">int</span> r=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-built_in">if</span>(i+<span class="hljs-number">1</span>&lt;<span class="hljs-built_in">n</span>&amp;&amp;ratings[i]&gt;ratings[i+<span class="hljs-number">1</span>])<br>                ++r;<br>            else<br>                r=<span class="hljs-number">1</span>;<br>            res+=<span class="hljs-built_in">max</span>(r,<span class="hljs-built_in">left</span>[i]);            <br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加油站</title>
    <link href="/2023/11/06/%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
    <url>/2023/11/06/%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h2 id="加油站"><a class="markdownIt-Anchor" href="#加油站"></a> 加油站</h2><p><a href="https://leetcode.cn/problems/gas-station/description/?envType=study-plan-v2&amp;envId=top-interview-150">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i]升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则保证它是唯一的。</p><p>e.g.</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]<br>输出: 3<br>解释:<br>从<span class="hljs-number"> 3 </span>号加油站(索引为<span class="hljs-number"> 3 </span>处)出发，可获得<span class="hljs-number"> 4 </span>升汽油。此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 4 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 8 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 8 </span>-<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 7 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>升汽油<br>开往<span class="hljs-number"> 2 </span>号加油站，此时油箱有<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>升汽油<br>开往<span class="hljs-number"> 3 </span>号加油站，你需要消耗<span class="hljs-number"> 5 </span>升汽油，正好足够你返回到<span class="hljs-number"> 3 </span>号加油站。<br>因此，3 可为起始索引。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>首先根据题意，一次只能到达相邻的加油站，而且当总的gas小于总cost，则无论如何都不能绕行一周。因此我们可以遍历所有起点，用cos和rest分别保存某起点开始的剩余油量和总的剩余油量，当cos &lt; 0时，说明当前i位置无法到达i+1位置，因此把i+1设置为start起点，并把cos置为0，遍历完成之后，如果rest &lt; 0，说明总的gas小于总cost，返回-1，否则返回start。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>, cos=<span class="hljs-number">0</span>,rest=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;gas.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            cos+=gas[i]-cost[i];<br>            rest+=gas[i]-cost[i];<br>            <span class="hljs-keyword">if</span>(cos&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                start=i+<span class="hljs-number">1</span>;<br>                cos=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rest&lt;<span class="hljs-number">0</span>?<span class="hljs-number">-1</span>:start;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>矩阵链乘法</title>
    <link href="/2023/11/03/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/"/>
    <url>/2023/11/03/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵链乘法"><a class="markdownIt-Anchor" href="#矩阵链乘法"></a> 矩阵链乘法</h2><h3 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h3><p>矩阵乘法的计算复杂度与相乘顺序有关，可以通过适当的结合降低计算复杂度。<br />给你一系列的矩阵A1,A2,A3,…,An和一系列的整数P0,P1,P2…,Pn，每个矩阵 Ai 的规模为Pi-1 * Pi, 1 &lt;=i &lt; n。<br />现在，请你计算这些矩阵连乘所需要的最少的计算次数是多少？</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用d[i][j]表示相乘后矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的计算次数，对于i~j(1 &lt;=i &lt; j &lt; n)的矩阵，可以在中间找到第k个矩阵进行切割，此时所需计算次数为d[i][k]+d[k+1][j]+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>p</mi><mi>k</mi></msub><msub><mi>p</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">p_{i-1}p_{k}p_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，可以遍历i~j之间所有k，找到使计算次数最小的k。递推关系如下：</p><ul><li>若 i== j，d[i][j]==0</li><li>若i &lt; j, d[i][j]=din(d[i][k]+d[k+1][j]+p(i-1)p(k)p(j))， i &lt;= k &lt; j</li></ul><p>经过以上步骤，可以找出i～j个矩阵相乘的子问题的最优解，该子问题包含j-i+1个矩阵，因此矩阵链的长度为l=j-i+1，为了求出总体的最优解，还需要遍历所有子链的长度l(1~n)</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs prolog">void <span class="hljs-symbol">MATRIX_CHAIN_ORDER</span>(int *p,int <span class="hljs-symbol">Length</span>,int d[][<span class="hljs-symbol">M</span>],int s[][<span class="hljs-symbol">M</span>])<br>&#123;<br>    //d保存最少计算次数，s保存划分位置(跟踪矩阵)<br>int q,n=<span class="hljs-symbol">Length</span><span class="hljs-number">-1</span>;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++) d[i][i]=<span class="hljs-number">0</span>;<br>for(int l=<span class="hljs-number">2</span>;l&lt;=n;l++) <span class="hljs-comment">/* 矩阵链的长度 */</span><br>&#123;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n-l+<span class="hljs-number">1</span>;i++) <br>&#123;<br>int j=i+l<span class="hljs-number">-1</span>;         <span class="hljs-comment">/* 等价于 l=j-i+1 */</span><br>d[i][j]=<span class="hljs-symbol">INT_MAX</span>;<br>for(int k=i;k&lt;=j<span class="hljs-number">-1</span>;k++)<br>&#123;<br>q=d[i][k]+d[k+<span class="hljs-number">1</span>][j]+p[i<span class="hljs-number">-1</span>]*p[k]*p[j];<br>if(q&lt;d[i][j])<br>&#123;<br>d[i][j]=q;<br>s[i][j]=k;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法作业2</title>
    <link href="/2023/10/20/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A2/"/>
    <url>/2023/10/20/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%95%B0%E4%B8%80%E6%95%B0">数“一”数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2">最大矩形</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li><li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D">正则表达式匹配</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-2">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="数一数"><a class="markdownIt-Anchor" href="#数一数"></a> 数“一”数</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>编写一个函数，输入一个整数 n，返回一个长度为 n + 1 的数组，其中每个元素表示对应整数二进制中 “1” 的数量。</p><p>input:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[0, 1, 1, 2, 1, 2]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>可以用数组res保存每个数字的二进制表示的1的数量</p><ul><li>对于偶数<code>a</code>，他的二进制表示中1的数量和<code>a/2</code>相同</li><li>对于奇数<code>a</code>,他的二进制表示中1的数量比<code>a/2</code>多1</li></ul><p>因此有递推式：<code>res[i]=res[i&gt;&gt;1]+(i&amp;1)</code></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        res[i] = res[i &gt;&gt; <span class="hljs-number">1</span>] + i &amp; <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;[&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i != n)<br>            cout &lt;&lt; res[i] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; res[i];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;]&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最大矩形"><a class="markdownIt-Anchor" href="#最大矩形"></a> 最大矩形</h2><p><a href="https://leetcode.cn/problems/maximal-rectangle/description/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]<br>输出：<span class="hljs-number">6</span><br>解释：最大矩形如上图所示。<br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>这道题需要用到单调栈，在<a href="https://lqz2.github.io/2022/09/13/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a>中，通过单调栈，可以求得柱状图中的最大矩形。对于这道题，需要先把矩阵按每一行连续的1处理成柱状图，例如一行是<code>1 0 1 1 1</code>，处理后变成<code>1 0 1 2 3</code>。接下来，将每一列视为一个柱状图，这道题可以视为寻找所有列对应的柱状图中的最大子矩形，因此，需要遍历每列柱状图的最大子矩形，然后求得最大值后返回。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;</span><br><span class="hljs-class">public:</span><br><span class="hljs-class">    int maximalRectangle(<span class="hljs-title">vector</span>&lt;<span class="hljs-title">vector</span>&lt;<span class="hljs-title">char</span>&gt;&gt;&amp; <span class="hljs-title">matrix</span>) &#123;</span><br><span class="hljs-class">        int m=matrix.size(),n=matrix[0].size();</span><br><span class="hljs-class">        vector&lt;vector&lt;int&gt;&gt; a(<span class="hljs-title">m</span>,<span class="hljs-title">vector</span>&lt;<span class="hljs-title">int</span>&gt;(<span class="hljs-title">n</span>));</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                if(<span class="hljs-title">matrix</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>]==&#x27;1&#x27;)</span><br><span class="hljs-class">                    a[i][j]=(<span class="hljs-title">j</span>==0?0:<span class="hljs-title">a</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>-1])+1;</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        int res=0,area=0;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            vector&lt;int&gt; up(<span class="hljs-title">m</span>),down(<span class="hljs-title">m</span>);</span><br><span class="hljs-class">            stack&lt;int&gt; ust,dst;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                while(!<span class="hljs-title">ust</span>.<span class="hljs-title">empty</span>()&amp;&amp;a[ust.top()][j]&gt;=a[i][j])</span><br><span class="hljs-class">                    ust.pop();</span><br><span class="hljs-class">                up[i]=ust.empty()?-1:ust.top();</span><br><span class="hljs-class">                ust.push(<span class="hljs-title">i</span>);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=<span class="hljs-title">m</span>-1;<span class="hljs-title">i</span>&gt;=0;<span class="hljs-comment">--i)</span></span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                <span class="hljs-title">while</span>(!<span class="hljs-title">dst</span>.<span class="hljs-title">empty</span>()&amp;&amp;a[dst.top()][j]&gt;=a[i][j])</span><br><span class="hljs-class">                    dst.pop();</span><br><span class="hljs-class">                down[i]=dst.empty()?m:dst.top();</span><br><span class="hljs-class">                dst.push(<span class="hljs-title">i</span>);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                area=a[i][j]*(<span class="hljs-title">down</span>[<span class="hljs-title">i</span>]-<span class="hljs-title">up</span>[<span class="hljs-title">i</span>]-1);</span><br><span class="hljs-class">                res=max(<span class="hljs-title">res</span>,<span class="hljs-title">area</span>);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        return res;</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">&#125;;</span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure><h2 id="正则表达式匹配"><a class="markdownIt-Anchor" href="#正则表达式匹配"></a> 正则表达式匹配</h2><p><a href="https://leetcode.cn/problems/regular-expression-matching/">原题</a></p><h3 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><p>‘.’ 匹配任意单个字符<br />‘*’ 匹配零个或多个前面的那一个元素<br />所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p>e.g.</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;aa&quot;</span>, p = <span class="hljs-string">&quot;a*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-string">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。<br><br>输入：s = <span class="hljs-string">&quot;ab&quot;</span>, p = <span class="hljs-string">&quot;.*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="hljs-string">&#x27;*&#x27;</span>）任意字符（<span class="hljs-string">&#x27;.&#x27;</span>）。<br></code></pre></td></tr></table></figure><h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3><p>用到动态规划的思想。用dp[i][j]表示s中前i个字符和p中前j个字符是否匹配,接下来分情况讨论</p><ul><li>当s[i]和p[j]匹配时<code>(s[i-1]=p[j-1]或者p[j-1]=='.')</code>，<code>dp[i][j]=dp[i-1][j-1]</code></li><li>否则，如果p[j]当前字符p[j-1]==‘*’<ul><li>如果s[i]和p[j]的前一个字符匹配<code>(s[i-1]=p[j-2]或者p[j-2]=='.')</code>，此时可以匹配一个或多个s[i]，也可以不匹配s[i]，状态方程为<code>dp[i][j]=dp[i][j-2]||dp[i-1][j]</code></li><li>如果s[i]和p[j]的前一个字符不匹配，那么不匹配s[i]，<code>dp[i][j]=dp[i][j-2]</code></li></ul></li></ul><p>总的状态方程如下：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi></mrow><msup><mrow><mo fence="true">(</mo><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo></mrow><mo lspace="0em" rspace="0em">∗</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>s</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mrow><mtext> </mtext><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mtext> </mtext></mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>s</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f[i][j]=\begin{cases}\mathrm{if}\left(p[j]\neq\right.^{*})=\begin{cases}f[i-1][j-1],&amp;matches(s[i],p[j])\\\mathrm{false},&amp;\mathrm{otherwise}&amp;\end{cases}\\\mathrm{otherwise}=\begin{cases}f[i-1][j]\mathrm{~or~}f[i][j-2],&amp;matches(s[i],p[j-1])\\f[i][j-2],&amp;\mathrm{otherwise}&amp;\end{cases}\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:6.0000599999999995em;vertical-align:-2.7500299999999998em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2500200000000006em;"><span style="top:-1.2999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.2949899999999999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.58999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.8849900000000002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.17999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.2049900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.29501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.59001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.885010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.180010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.205010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.50002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2500299999999998em;"><span style="top:-5.25003em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mclose nulldelimiter"></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.828596em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">o</span><span class="mord mathrm">t</span><span class="mord mathrm">h</span><span class="mord mathrm">e</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="mord mathrm">i</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">o</span><span class="mord mathrm">t</span><span class="mord mathrm">h</span><span class="mord mathrm">e</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="mord mathrm">i</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord"><span class="mspace nobreak"> </span><span class="mord mathrm">o</span><span class="mord mathrm">r</span><span class="mspace nobreak"> </span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">o</span><span class="mord mathrm">t</span><span class="mord mathrm">h</span><span class="mord mathrm">e</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="mord mathrm">i</span><span class="mord mathrm">s</span><span class="mord mathrm">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7500299999999998em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs prolog">class <span class="hljs-symbol">Solution</span> &#123;<br>public:<br>    bool isMatch(string s, string p) &#123;<br>        int m = s.size();<br>        int n = p.size(); <br>        vector&lt;vector&lt;bool&gt;&gt; dp(m+<span class="hljs-number">1</span>,vector&lt;bool&gt;(n+<span class="hljs-number">1</span>,false));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = true;<br>        //初始化dp,匹配空串时,*可以消除前一个字符，因此状态与前前一个状态相等<br>        for(int j =<span class="hljs-number">2</span>;j &lt;=n ;j++)<br>        &#123;<br>            if(p[j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;*&#x27;</span>)<br>                dp[<span class="hljs-number">0</span>][j]=dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-2</span>];<br>        &#125;<br>        function&lt;bool(int,int)&gt; match=[&amp;](int i,int j)&#123;<br>            if(s[i<span class="hljs-number">-1</span>]==p[j<span class="hljs-number">-1</span>]||p[j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>                return true;<br>            return false;<br>        &#125;;<br>        for (int i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        &#123;<br>            for (int j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            &#123;<br>                //如果当前s[i]和p[j]匹配,则与上一个状态相等<br>                if (match(i,j))<br>                        dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]; <br>                else if (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)//如果当前p[j]为*<br>                &#123;<br>                    if(match(i,j<span class="hljs-number">-1</span>))//如果*前面的字符可以匹配s[i]<br>                        //匹配<span class="hljs-number">0</span>次：dp[i][j<span class="hljs-number">-2</span>],相当于删除*前面的字符<br>                        //匹配<span class="hljs-number">1</span>次或以上：dp[i<span class="hljs-number">-1</span>][j]<br>                        dp[i][j]=dp[i][j<span class="hljs-number">-2</span>]||dp[i<span class="hljs-number">-1</span>][j];<br>                    else//相当于匹配了<span class="hljs-number">0</span>次<br>                        dp[i][j]=dp[i][j<span class="hljs-number">-2</span>];<br>                &#125;      <br>            &#125;<br>        &#125;<br>        return dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>矩阵打印问题</title>
    <link href="/2023/10/19/%E7%9F%A9%E9%98%B5%E6%89%93%E5%8D%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/19/%E7%9F%A9%E9%98%B5%E6%89%93%E5%8D%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%9F%A9%E9%98%B5%E6%89%93%E5%8D%B0%E9%97%AE%E9%A2%98">矩阵打印问题</a><ul><li><a href="#%E4%B8%8A%E4%B8%89%E8%A7%92%E9%98%B5">上三角阵</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E4%B8%80">螺旋矩阵一</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li><li><a href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E4%BA%8C">螺旋矩阵二</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-2">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-2">代码</a></li></ul></li><li><a href="#z%E5%AD%97%E5%9E%8B%E8%9B%87%E5%9E%8B">Z字型(蛇型)</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-3">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-3">代码</a></li></ul></li></ul></li></ul><!-- /TOC --><h2 id="矩阵打印问题"><a class="markdownIt-Anchor" href="#矩阵打印问题"></a> 矩阵打印问题</h2><h3 id="上三角阵"><a class="markdownIt-Anchor" href="#上三角阵"></a> 上三角阵</h3><p><a href="https://www.nowcoder.com/practice/649b210ef44446e3b1cd1be6fa4cab5e?tpId=37&amp;tqId=21258&amp;ru=/exam/oj">原题</a></p><h4 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h4><p>输入描述：<br />输入正整数N（N不大于100）</p><p>输出描述：<br />输出一个N行的上三角矩阵</p><p>input</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><p>output</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">8</span><br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><p>根据题目描述，输出上三角阵只用考虑右上方向，因此每输出一个数就<code>--i,++j</code>，超出上边界(i&lt;0)时，将j置为0，然后更新i的起始点即可。</p><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>int a[101][101];<br>int main()<br>&#123;<br>    int n;<br>    cin&gt;&gt;n;<br>    int num=(n+1)*n/2;<br>    int <span class="hljs-attribute">cnt</span>=0,i=0,j=0,pre=0,k=1;<br>    <br>    <span class="hljs-keyword">while</span>(cnt&lt;num)<br>    &#123;<br>        a[i][j]=k++;<br>        ++cnt;<br>        --i;++j;<br>        <span class="hljs-keyword">if</span>(i&lt;0)<br>        &#123;<br>            <span class="hljs-attribute">j</span>=0;<br>            <span class="hljs-attribute">i</span>=pre+1;<br>            <span class="hljs-attribute">pre</span>=i;<br>        &#125;<br>    &#125;<br>    int <span class="hljs-attribute">nn</span>=n;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=0;j&lt;nn;++j)<br>            cout&lt;&lt;a[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        --nn;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="螺旋矩阵一"><a class="markdownIt-Anchor" href="#螺旋矩阵一"></a> 螺旋矩阵一</h3><p><a href="https://leetcode.cn/problems/spiral-matrix/description/">原题</a></p><h4 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h4><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[4,5,6]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br></code></pre></td></tr></table></figure><h4 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h4><p>这道题首先要设置上下左右四个边界，然后按照上，右，下，左，四个边界打印，每便利完一个边界判断一下边界有没有越界<br />例如</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(int i=l;i&lt;=r;++i)<br>    cout&lt;&lt;<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[u]</span><span class="hljs-selector-attr">[i]</span>;<br><span class="hljs-built_in">if</span>(++u&gt;d) break;<br></code></pre></td></tr></table></figure><h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; spiralOrder(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-keyword">matrix</span>) &#123;<br>        <span class="hljs-keyword">int</span> m=<span class="hljs-keyword">matrix</span>.<span class="hljs-keyword">size</span>(),n=<span class="hljs-keyword">matrix</span>[<span class="hljs-number">0</span>].<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>,u=<span class="hljs-number">0</span>,d=m<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span>(true)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;++i)<br>                ans.push_back(<span class="hljs-keyword">matrix</span>[u][i]);<br>            <span class="hljs-keyword">if</span>(++u&gt;d) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=u;i&lt;=d;++i)<br>                ans.push_back(<span class="hljs-keyword">matrix</span>[i][r]);<br>            <span class="hljs-keyword">if</span>(--r&lt;l) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=r;i&gt;=l;--i)<br>                ans.push_back(<span class="hljs-keyword">matrix</span>[d][i]);<br>            <span class="hljs-keyword">if</span>(--d&lt;u) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=d;i&gt;=u;--i)<br>                ans.push_back(<span class="hljs-keyword">matrix</span>[i][l]);<br>            <span class="hljs-keyword">if</span>(++l&gt;r) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="螺旋矩阵二"><a class="markdownIt-Anchor" href="#螺旋矩阵二"></a> 螺旋矩阵二</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-iii/description/">原题</a></p><h4 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h4><p>在 rows x cols 的网格上，你从单元格 (rStart, cStart) 面朝东面开始。网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p><p>你需要以顺时针按螺旋状行走，访问此网格中的每个位置。每当移动到网格的边界之外时，需要继续在网格之外行走（但稍后可能会返回到网格边界）。</p><p>最终，我们到过网格的所有 rows x cols 个空间。</p><p>按照访问顺序返回表示网格位置的坐标列表。<br />e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：rows = 5, cols = 6, rStart = 1, cStart = 4<br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[1,5]</span>,<span class="hljs-comment">[2,5]</span>,<span class="hljs-comment">[2,4]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[0,3]</span>,<span class="hljs-comment">[0,4]</span>,<span class="hljs-comment">[0,5]</span>,<span class="hljs-comment">[3,5]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[3,3]</span>,<span class="hljs-comment">[3,2]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[0,2]</span>,<span class="hljs-comment">[4,5]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[4,3]</span>,<span class="hljs-comment">[4,2]</span>,<span class="hljs-comment">[4,1]</span>,<span class="hljs-comment">[3,1]</span>,<span class="hljs-comment">[2,1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[4,0]</span>,<span class="hljs-comment">[3,0]</span>,<span class="hljs-comment">[2,0]</span>,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[0,0]</span>]</span><br></code></pre></td></tr></table></figure><h4 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h4><p>这道题实际上是从中心向四周遍历螺旋方阵，然后输出在矩阵内的数。<br />首先根据起始点的坐标，初始化上下左右四个边界(起始点周围第一层数)，并初始化方向为右(0,1,2,3四个方向)<br />接下来分情况讨论：</p><ul><li>如果方向向右且已经到达右边界，右边界+1，方向转为向下</li><li>如果方向向下且已经到达下边界，下边界+1，方向转为向左</li><li>如果方向向左且已经到达左边界，左边界-1，方向转为向上</li><li>如果方向向上且已经到达上边界，上边界-1，方向转为向右</li><li>根据当前方向更新坐标</li></ul><p>打印时只需要判断当前坐标在矩阵内即可打印</p><h4 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">spiralMatrixIII</span>(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> rStart, <span class="hljs-type">int</span> cStart) &#123;<br>        <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,di=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i=rStart,j=cStart,l=cStart<span class="hljs-number">-1</span>,r=cStart+<span class="hljs-number">1</span>,u=rStart<span class="hljs-number">-1</span>,d=rStart+<span class="hljs-number">1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">while</span>(cnt&lt;rows*cols)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;i&lt;rows&amp;&amp;j&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;cols)<br>            &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;i,j&#125;);<br>                ++cnt;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(di==<span class="hljs-number">0</span>&amp;&amp;j==r)<br>            &#123;<br>                di=(di+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;<br>                ++r;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(di==<span class="hljs-number">1</span>&amp;&amp;i==d)<br>            &#123;<br>                di=(di+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;<br>                ++d;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(di==<span class="hljs-number">2</span>&amp;&amp;j==l)<br>            &#123;<br>                di=(di+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;<br>                --l;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(di==<span class="hljs-number">3</span>&amp;&amp;i==u)<br>            &#123;<br>                di=(di+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;<br>                --u;<br>            &#125;<br>            i+=dir[di][<span class="hljs-number">0</span>];<br>            j+=dir[di][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="z字型蛇型"><a class="markdownIt-Anchor" href="#z字型蛇型"></a> Z字型(蛇型)</h3><p><a href="https://www.acwing.com/problem/content/description/3211/">原题</a></p><h4 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4"></a> 题目描述</h4><p>对于下面的 4×4的矩阵，</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>对其进行 Z字形扫描后得到长度为16的序列：1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3。<br />请实现一个Z字形扫描的程序，给定一个 n×n的矩阵，输出对这个矩阵进行 Z字形扫描的结果。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">9</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h4><p>一共有两种方向，右上或者左下，因此需要设置一个flag，当flag为true时表示右上，否则表示左下，初始化方向为右上。</p><ul><li>每当坐标i,j在矩阵范围内，就打印该位置的值</li><li>每打印一个值，根据方向更改坐标i,j的值</li><li>如果i&lt;0，i置为0，方向取反，如果j&lt;0，j置为0，方向取反。</li></ul><p>重复以上步骤，直到打印出所有元素</p><h4 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">501</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            cin&gt;&gt;a[i][j];<br>    &#125;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//true 右上，false左下</span><br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(cnt&lt;n*n)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;j&lt;n)<br>        &#123;<br>            cout&lt;&lt;a[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>            ++cnt;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag)<br>        &#123;<br>            --i;++j;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ++i;--j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            i=<span class="hljs-number">0</span>;<br>            flag=!flag;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            j=<span class="hljs-number">0</span>;<br>            flag=!flag;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动机器人</title>
    <link href="/2023/10/17/%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <url>/2023/10/17/%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="移动机器人"><a class="markdownIt-Anchor" href="#移动机器人"></a> 移动机器人</h2><p><a href="https://leetcode.cn/problems/movement-of-robots/?envType=daily-question&amp;envId=2023-10-10">原题</a></p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>有一些机器人分布在一条无限长的数轴上，他们初始坐标用一个下标从 0 开始的整数数组 nums 表示。当你给机器人下达命令时，它们以每秒钟一单位的速度开始移动。</p><p>给你一个字符串 s ，每个字符按顺序分别表示每个机器人移动的方向。‘L’ 表示机器人往左或者数轴的负方向移动，‘R’ 表示机器人往右或者数轴的正方向移动。</p><p>当两个机器人相撞时，它们开始沿着原本相反的方向移动。</p><p>请你返回指令重复执行 d 秒后，所有机器人之间两两距离之和。由于答案可能很大，请你将答案对 109 + 7 取余后返回。</p><p>注意：</p><p>对于坐标在 i 和 j 的两个机器人，(i,j) 和 (j,i) 视为相同的坐标对。也就是说，机器人视为无差别的。<br />当机器人相撞时，它们 立即改变 它们的前进方向，这个过程不消耗任何时间。<br />当两个机器人在同一时刻占据相同的位置时，就会相撞。</p><p>例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 2 并往左移动，下一秒，它们都将占据位置 1，并改变方向。再下一秒钟后，第一个机器人位于位置 0 并往左移动，而另一个机器人位于位置 2 并往右移动。</p><p>例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 1 并往左移动，下一秒，第一个机器人位于位置 0 并往左行驶，而另一个机器人位于位置 1 并往右移动。</p><p>e.g.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[1,0]</span>, s = <span class="hljs-string">&quot;RL&quot;</span>, d = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span><br>解释：<br><span class="hljs-number">1</span> 秒后，机器人的位置为 <span class="hljs-selector-attr">[2,-1]</span> 。<br><span class="hljs-number">2</span> 秒后，机器人的位置为 <span class="hljs-selector-attr">[3,-2]</span> 。<br>两个机器人的距离为 <span class="hljs-built_in">abs</span>(-<span class="hljs-number">2</span> - <span class="hljs-number">3</span>) = <span class="hljs-number">5</span> 。<br></code></pre></td></tr></table></figure><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>可以看作机器人相撞后穿透了对方，然后可以直接计算出每个机器人d秒后的位置pos[]，接下来计算两两之和。</p><p>对于第i个机器人，他的左边有i个机器人，右边有n-i个机器人，在计算左右两边的距离和时，<code>pos[i]-pos[i-1]</code>这段距离被计算了<code>i*(n-i)</code>次，因此将所有的距离累加即可。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumDistance</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, string s, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>        <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">pos</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;R&#x27;</span>)<br>                pos[i]=(ll)nums[i]+d;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;L&#x27;</span>)<br>                pos[i]=(ll)nums[i]-d;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(pos.<span class="hljs-built_in">begin</span>(),pos.<span class="hljs-built_in">end</span>());<br>        ll ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)<br>        &#123;<br>            ans+=(pos[i]-pos[i<span class="hljs-number">-1</span>])*i%mod*(n-i)%mod;<br>            ans%=mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最短且字典序最小的美丽字符串</title>
    <link href="/2023/10/16/%E6%9C%80%E7%9F%AD%E4%B8%94%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E7%BE%8E%E4%B8%BD%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/10/16/%E6%9C%80%E7%9F%AD%E4%B8%94%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E7%BE%8E%E4%B8%BD%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E7%9F%AD%E4%B8%94%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E7%BE%8E%E4%B8%BD%E5%AD%97%E7%AC%A6%E4%B8%B2">最短且字典序最小的美丽字符串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><strong>题目描述</strong></a></li><li><a href="#%E6%80%9D%E8%B7%AF"><strong>思路</strong></a></li><li><a href="#%E4%BB%A3%E7%A0%81"><strong>代码</strong></a></li></ul></li><li><a href="#%E6%89%BE%E5%87%BA%E6%BB%A1%E8%B6%B3%E5%B7%AE%E5%80%BC%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%B8%8B%E6%A0%87">找出满足差值条件的下标</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><strong>题目描述</strong></a></li><li><a href="#%E6%80%9D%E8%B7%AF-1"><strong>思路</strong></a></li></ul></li></ul><!-- /TOC --><h2 id="最短且字典序最小的美丽字符串"><a class="markdownIt-Anchor" href="#最短且字典序最小的美丽字符串"></a> 最短且字典序最小的美丽字符串</h2><p><a href="https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> <strong>题目描述</strong></h3><p>给你一个二进制字符串 s 和一个正整数 k 。</p><p>如果 s 的某个子字符串中 1 的个数恰好等于 k ，则称这个子字符串是一个 美丽子字符串 。</p><p>令 len 等于 最短 美丽子字符串的长度。</p><p>返回长度等于 len 且字典序 最小 的美丽子字符串。如果 s 中不含美丽子字符串，则返回一个 空 字符串。</p><p>对于相同长度的两个字符串 a 和 b ，如果在 a 和 b 出现不同的第一个位置上，a 中该位置上的字符严格大于 b 中的对应字符，则认为字符串 a 字典序 大于 字符串 b 。</p><p>例如，“abcd” 的字典序大于 “abcc” ，因为两个字符串出现不同的第一个位置对应第四个字符，而 d 大于 c 。</p><p>e.g.</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;1011&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">&quot;11&quot;</span><br>解释：示例中共有 <span class="hljs-number">3</span> 个美丽子字符串：<br><span class="hljs-number">1</span>. 子字符串 <span class="hljs-string">&quot;1011&quot;</span> 。<br><span class="hljs-number">2</span>. 子字符串 <span class="hljs-string">&quot;1011&quot;</span> 。<br><span class="hljs-number">3</span>. 子字符串 <span class="hljs-string">&quot;1011&quot;</span> 。<br>最短美丽子字符串的长度是 <span class="hljs-number">2</span> 。<br>长度为 <span class="hljs-number">2</span> 且字典序最小的美丽子字符串是子字符串 <span class="hljs-string">&quot;11&quot;</span> 。 <br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> <strong>思路</strong></h3><p>此题主要使用双指针加滑动窗口解决，定义两个指针<code>l,r</code>，然后用cnt统计<code>1</code>的个数，用r遍历字符串，如果当前元素是<code>1</code>那么<code>cnt++</code>，然后开始缩小窗口，当<code>cnt&gt;k||s[l]=='0'</code>时，<code>--l</code>，此时如果<code>cnt==k</code>，如果当前子串<code>l~r</code>之间的子串小于res的长度，或者长度相等字典序小于res，那么更新res为当前子串。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> <strong>代码</strong></h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    string shortestBeautifulSubstring(string s, int k) &#123;<br>        <span class="hljs-keyword">if</span>(count(s.begin(),s.end(),<span class="hljs-string">&#x27;1&#x27;</span>)&lt;k)<br>            return <span class="hljs-string">&quot;&quot;</span>;<br>        int <span class="hljs-attribute">n</span>=s.size();<br>        int <span class="hljs-attribute">l</span>=0,r=0;<br>        string <span class="hljs-attribute">res</span>=s;<br>        int <span class="hljs-attribute">cnt</span>=0;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-attribute">r</span>=0;r&lt;n;++r)<br>        &#123;   <br>            cnt+=s[r]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">while</span>(cnt&gt;k||s[l]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            &#123;<br>                <span class="hljs-attribute">cnt-</span>=s[l]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                ++l;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-attribute">cnt</span>==k)<br>            &#123;<br>                string <span class="hljs-attribute">t</span>=s.substr(l,r-l+1);<br>                <span class="hljs-keyword">if</span>(t.size()&lt;res.size()||t.size()==res.size()&amp;&amp;t&lt;res)<br>                    <span class="hljs-attribute">res</span>=t;<br>            &#125;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="找出满足差值条件的下标"><a class="markdownIt-Anchor" href="#找出满足差值条件的下标"></a> 找出满足差值条件的下标</h2><p><a href="https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/description/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> <strong>题目描述</strong></h3><p>给你一个下标从 0 开始、长度为 n 的整数数组 nums ，以及整数 indexDifference 和整数 valueDifference 。</p><p>你的任务是从范围 [0, n - 1] 内找出  2 个满足下述所有条件的下标 i 和 j ：</p><p>abs(i - j) &gt;= indexDifference 且<br />abs(nums[i] - nums[j]) &gt;= valueDifference<br />返回整数数组 answer。如果存在满足题目要求的两个下标，则 answer = [i, j] ；否则，answer = [-1, -1] 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。</p><p>注意：i 和 j 可能 相等，请实现O(n)时间复杂度的算法。</p><p>e.g.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[5,1,4,1]</span>, indexDifference = <span class="hljs-number">2</span>, valueDifference = <span class="hljs-number">4</span><br>输出：<span class="hljs-selector-attr">[0,3]</span><br>解释：在示例中，可以选择 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span> 和 j = <span class="hljs-number">3</span> 。<br><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-number">0</span> - <span class="hljs-number">3</span>)</span></span> &gt;= <span class="hljs-number">2</span> 且 <span class="hljs-built_in">abs</span>(nums<span class="hljs-selector-attr">[0]</span> - nums<span class="hljs-selector-attr">[3]</span>) &gt;= <span class="hljs-number">4</span> 。<br>因此，<span class="hljs-selector-attr">[0,3]</span> 是一个符合题目要求的答案。<br><span class="hljs-selector-attr">[3,0]</span> 也是符合题目要求的答案。<br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> <strong>思路</strong></h3><p>这道题要求用O(n)时间复杂度实现，自己没有想到，参考大佬的解法恍然大悟。<br />可以记录<strong>之前的间隔index_gap的元素中最大值和最小值下标</strong>，然后与当前值nums[j]对比如果<code>max-nums[j]&gt;=valueDifference</code>或者<code>nums[j]-min&gt;=valueDifference</code>，那么即可返回对应的最大/最小值下标和当前下标j<br /><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findIndices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> indexDifference, <span class="hljs-type">int</span> valueDifference)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> mx_idx=<span class="hljs-number">0</span>,mn_idx=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=indexDifference;j&lt;n;++j)<br>        &#123;<br>            i=j-indexDifference;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;nums[mx_idx])<br>                mx_idx=i;<br>            <span class="hljs-keyword">if</span>(nums[i]&lt;nums[mn_idx])<br>                mn_idx=i;<br>            <span class="hljs-keyword">if</span>(nums[mx_idx]-nums[j]&gt;=valueDifference)<br>                <span class="hljs-keyword">return</span> &#123;mx_idx,j&#125;;<br>            <span class="hljs-keyword">if</span>(nums[j]-nums[mn_idx]&gt;=valueDifference)<br>                <span class="hljs-keyword">return</span> &#123;mn_idx,j&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法作业1</title>
    <link href="/2023/09/25/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A1/"/>
    <url>/2023/09/25/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A1/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%85%83%E7%B4%A0">出现最多的元素</a></li><li><a href="#%E5%AF%84%E5%8C%85%E8%A3%B9">寄包裹</a></li><li><a href="#%E7%BF%BB%E8%BD%AC%E5%AF%B9">翻转对</a></li></ul><!-- /TOC --><h2 id="出现最多的元素"><a class="markdownIt-Anchor" href="#出现最多的元素"></a> 出现最多的元素</h2><p><strong>题目描述</strong><br />提供一个包含 n 个元素的数组，要求返回其中出现次数大于半数（大于 ⌊n/2⌋）的元素。假设数组中一定存在这样的元素。</p><p>Input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p><strong>思路</strong><br />这道题要求找出现次数大于半数的数，例如数组有<code>n</code>个数，那么就返回唯一的出现次数大于<code>n/2</code>的数，也就是出现次数最多的数。</p><p>首先想到的思路是用哈系表记录每个出现次数，然后遍历找到出现次数最多的数。</p><p>这里还可以用投票法，因为由题目已知这里的出现次数最多的数，它所出现的次数是大于<code>n/2</code>的，也就是说其他数的出现次数之和也小于它的出现次数。因此，可以维护两个变量cnt和candidate(初始都为0)，然后遍历数组，当cnt为0时更新candidate，然后如果<code>num==candidate</code>，则cnt加1，否则减1。这样，最后的candidate即出现最多的数。由于这道题输出是唯一的(出现次数大于<code>n/2</code>)，所以可以用投票法解决。</p><p>代码(附哈系表解法)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a) != EOF)<br>        v.<span class="hljs-built_in">push_back</span>(a);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, cand = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : v)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>)<br>            cand = c;<br>        cnt += c == cand ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>    &#125;<br>    cout &lt;&lt; cand &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> cand;<br>&#125;<br><span class="hljs-comment">// int main()</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//     vector&lt;int&gt; v;</span><br><span class="hljs-comment">//     int a;</span><br><span class="hljs-comment">//     while (scanf(&quot;%d&quot;, &amp;a) != EOF)</span><br><span class="hljs-comment">//         v.push_back(a);</span><br><span class="hljs-comment">//     int n = v.size();</span><br><span class="hljs-comment">//     unordered_map&lt;int, int&gt; m;</span><br><span class="hljs-comment">//     for (int i = 0; i &lt; n; i++)</span><br><span class="hljs-comment">//         ++m[v[i]];</span><br><br><span class="hljs-comment">//     int max = 0, res = 0;</span><br><br><span class="hljs-comment">//     for (auto it = m.begin(); it != m.end(); it++)</span><br><span class="hljs-comment">//     &#123;</span><br><span class="hljs-comment">//         if (it-&gt;second &gt; max)</span><br><span class="hljs-comment">//         &#123;</span><br><span class="hljs-comment">//             max = it-&gt;second;</span><br><span class="hljs-comment">//             res = it-&gt;first;</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//     cout &lt;&lt; res;</span><br><span class="hljs-comment">//     return res;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h2 id="寄包裹"><a class="markdownIt-Anchor" href="#寄包裹"></a> 寄包裹</h2><p><strong>题目描述</strong><br />现在有 n 个不同的包裹，需要寄给 n 个不同的地址，请编程求出每个包裹都送错地址的情况共有多少种。</p><p>Input:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">44<br></code></pre></td></tr></table></figure><p><strong>思路</strong><br />这道题属于错排问题，关于错排问题，有公式$D(n)=(n-1)(D(n-1)+D(n-2)) $，参考<a href="https://zhuanlan.zhihu.com/p/466098489">这里</a></p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// int f(int a)</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//     if (a == 1)</span><br><span class="hljs-comment">//         return 0;</span><br><span class="hljs-comment">//     else if (a == 2)</span><br><span class="hljs-comment">//         return 1;</span><br><span class="hljs-comment">//     else</span><br><span class="hljs-comment">//         return (a - 1) * (f(a - 1) + f(a - 2));</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; ++i)<br>        dp[i] = (i - <span class="hljs-number">1</span>) * (dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]);<br>    cout &lt;&lt; dp[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="翻转对"><a class="markdownIt-Anchor" href="#翻转对"></a> 翻转对</h2><p><strong>题目描述</strong><br />现在有 n 个不同的包裹，需要寄给 n 个不同的地址，请编程求出每个包裹都送错地址的情况共有多少种。<br />给定一个数组nums，如果 i &lt; j 且 nums[i] &gt; 3*nums[j] 我们就将 (i, j) 称作一个重要翻转对。</p><p>你需要返回给定数组中的重要翻转对的数量。</p><p><strong>思路</strong><br />这道题是求逆序对数的小变形，求逆序对的主要思想是归并排序，对于已经有序的区间<code>[l,mid]</code>和<code>[mid+1,r]</code>，当<code>nums[i]&gt;3*nums[j]</code>，说明<code>[i,mid]</code>区间的元素都大于<code>3*nums[j]</code>，因此逆序对数增加<code>mid-i+1</code>，其余部分进行归并排序即可。</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> cnt;<br>vector&lt;<span class="hljs-type">int</span>&gt; num;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> nl = mid - l + <span class="hljs-number">1</span>, nr = r - mid;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">al</span><span class="hljs-params">(nl)</span>, <span class="hljs-title">ar</span><span class="hljs-params">(nr)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nl; ++i)<br>        al[i] = num[l + i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nr; ++i)<br>        ar[i] = num[mid + <span class="hljs-number">1</span> + i];<br>    <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (num[i] &gt; <span class="hljs-number">3</span> * num[j])<br>        &#123;<br>            cnt += mid - i + <span class="hljs-number">1</span>;<br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            ++i;<br>    &#125;<br>    i = <span class="hljs-number">0</span>;<br>    j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; nl &amp;&amp; j &lt; nr)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (al[i] &lt;= ar[j])<br>            num[l++] = al[i++];<br>        <span class="hljs-keyword">else</span><br>            num[l++] = ar[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt; nl)<br>        num[l++] = al[i++];<br>    <span class="hljs-keyword">while</span> (j &lt; nr)<br>        num[l++] = ar[j++];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">mergesort</span>(l, mid);<br>        <span class="hljs-built_in">mergesort</span>(mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">merge</span>(l, mid, r);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a) != EOF)<br>        num.<span class="hljs-built_in">push_back</span>(a);<br>    <span class="hljs-type">int</span> n = num.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">mergesort</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>相关问题及解决方法</title>
    <link href="/2023/08/11/%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2023/08/11/%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0rainbowrainbowrainbow">遇到的一些问题和解决方法（持续更新！）🌈🌈🌈</a><ul><li><a href="#%E7%AC%AC1%E5%91%A8rainbow">第1周🌈</a></li><li><a href="#%E7%AC%AC2%E5%91%A8rainbow">第2周🌈</a></li><li><a href="#%E7%AC%AC3%E5%91%A8rainbow">第3周🌈</a></li><li><a href="#%E7%AC%AC4%E5%91%A8rainbow">第4周🌈</a></li><li><a href="#%E7%AC%AC5%E5%91%A8rainbow">第5周🌈</a></li><li><a href="#%E7%AC%AC6%E5%91%A8rainbow">第6周🌈</a></li><li><a href="#%E7%AC%AC7%E5%91%A8rainbow">第7周🌈</a></li><li><a href="#%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0rainbow">持续更新🌈</a></li></ul></li></ul><!-- /TOC --><h2 id="遇到的一些问题和解决方法持续更新"><a class="markdownIt-Anchor" href="#遇到的一些问题和解决方法持续更新"></a> 遇到的一些问题和解决方法（持续更新！）🌈🌈🌈</h2><h3 id="第1周"><a class="markdownIt-Anchor" href="#第1周"></a> 第1周🌈</h3><ol><li>windows环境下安装pycocotools报错：ERROR: Could not build wheels for pycocotools, which is required to install pyproject.toml-based projects，解决方法：<a href="https://blog.csdn.net/weixin_45775136/article/details/130248372?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=ERROR:%20Could%20not%20build%20wheels%20&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-130248372.nonecase&amp;spm=1018.2226.3001.4187">1</a></li><li>windows环境下安装mmcv库报错：ERROR:Could not build wheels for mmcv, which is required to install pyproject.toml-based projects，解决方法：先pip install openmim，然后mim install mmcv</li><li>训练时出现OSError: [WinError 1455] 页面文件太小,无法完成操作，原因是dataloader的num_worker设置的太大，CPU线程不支持，解决方法：num_worker设置小一些即可</li><li>TarDAL代码中，检测部分yolov5s网络输出的结果shape不一致，解决办法：调试之后发现yolov5源码中会根据当前模式(train or eval)选择输出</li><li>MetaFusion论文并未提供详细代码，只提供了测试代码，因此无法得知网络具体的训练策略以及损失计算的详细过程。</li><li>训练TarDAL时，自己训练的子模型无法加载到下一个子模型中，而论文提供的预训练模型却可以。解决方法：该篇论文提供的源码存在诸多问题，经过多番调试发现，自己训练的模型无法加载的原因是因为判别器模型linear层参数的size与当前判别器模型对应层参数size不匹配，而提供的预训练权重可以正常加载的原因是预训练权重只包含了生成器的权重，因此代码在加载预训练权重时没有加载判别器权重。进一步调试后发现，linear层参数size不匹配的原因是不同子模型训练时输入图片的大小不一致，导致后续子模型无法加载权重。</li><li>训练时梯度回传时出现nan。解决方法：先检查数据有没有问题，没有问题则尝试将对应的学习率调低。</li></ol><h3 id="第2周"><a class="markdownIt-Anchor" href="#第2周"></a> 第2周🌈</h3><ol><li>执行sh脚本文件时出现找不到目录。解决方法：windows默认换行符是\r\n，linux下是\n，我在windows环境下使用vscode连接远程服务器时，使用的换行符依旧是\r\n，所以在执行cd时找不到目录，这时可以使用dos2unix命令来转换脚本文件。</li><li>OSError: cannot write mode F as PNG。解决方法：这里的 mode F 意思是图像中浮点类型的像素值，原因是代码中的 img 数组是 float 类型的，而图像中每个像素的值应该是 0-255(uint8 类型)。使用astype(np.uint8)转换数据类型即可。</li><li>使用wandb时出错，wandb: ERROR Internal wandb error: file data was not synced。解决方法：该错误与protobuf库有关，卸载后重新安装即可解决。</li><li>detfusion在使用bash compile.sh编译mmdet时报错。解决方法：原因是因为python. cuda. pytorch版本过高导致的，安装python3.7. 切换cuda版本安装pytorch低版本1.3.1后解决。</li><li>尝试运行detfusion时出现ModuleNotFoundError: No module named ‘DOTA_devkit’。解决方法：安装swig，然后git下DOTA_devkit远程仓库，然后编译c++扩展。具体参考：(<a href="https://zhuanlan.zhihu.com/p/355862906">https://zhuanlan.zhihu.com/p/355862906</a>)</li><li>运行时报错ImportError: urllib3 v2.0 only supports OpenSSL 1.1.1+, currently the ‘ssl’ module is compiled with 'OpenSSL 1.0.2u。解决方法：urllib版本过高导致，安装对应版本的urllib即可。</li><li>使用faster rcnn对detfusion的融合结果进行检测时，边界框回归损失出现nan。解决方法：起初认为是学习率过高导致，后来降低学习率无果后，怀疑是作者给的annotations存在问题，编写简单脚本进行检查后发现，有5张图片的gt存在问题，具体问题是xmin==xmax导致边界框回归计算出错，将出错的gt删除即可。</li><li>部署模型时出现timm.layers未找到，timm更新后路径改变导致。解决方法：改为timm.models.layers</li><li>使用lyngor编译模型时出现AttributeError: module ‘torch’ has no attribute ‘get_autocast_gpu_dtype’。解决方法：这是因为pytorch版本过低导致，可以升级pytorch或者手动更改代码中的dtype，我通过本地高版本pytorch打印出该函数返回值，然后手动改为torch.half和torch.bfloat16</li><li>AttributeError: ‘str’ object has no attribute ‘fromat’，解决方法：改成f-string形式。</li><li>ValueError: only one element tensors can be converted to Python scalars，解决方法：<a href="https://blog.csdn.net/Vertira/article/details/127814093?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169372428616800225573433%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169372428616800225573433&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-2-127814093-null-null.142%5Ev93%5Econtrol&amp;utm_term=ValueError%3A%20only%20one%20element%20tensors%20can%20be%20converted%20to%20Python%20scalars&amp;spm=1018.2226.3001.4187">1</a></li></ol><h3 id="第3周"><a class="markdownIt-Anchor" href="#第3周"></a> 第3周🌈</h3><ol><li>python导入另一个文件夹下的包时提示找不到模块，如/a/aa.py的aa.py文件需要导入/b/bb.py文件，aa.py文件提示找不到bb模块。解决方法：需要在/b/文件夹下创建__init__.py，然后再aa.py中加入import sys,sys.path.append(‘…’)，将上级目录添加到工作路径中。</li><li>ImportError: attempted relative import with no known parent package。解决方法：这个错误通常是由于相对导入的模块没有正确的父级包导致的，使用绝对导入即可解决。</li><li>使用thop计算模型参数量时出现RuntimeError: module must have its parameters and buffers on device cuda:0 (device_ids[0]) but found one of them on device: cpu。解决方法：原因是nn.DataParallel()导致部分模型没有在同一张GPU上，使用单卡计算参数量和计算量即可。</li><li>在改动CDDFuse代码时，使用params_group为不同参数设置学习率后，出现梯度为0，loss不变的情况。解决方法：经过排查是学习率太大导致，降低学习率即可。</li><li>在使用FFT计算频谱的时候，使用torch.fft.ifftn将频谱逆变换回来，然后保存为图像时报错。解决办法：图像的数据需要转换为np.uint8类型，所以逆变换后需要将数据转换成np.uint8才能正常保存。</li><li>将频域信息输入到卷积层时报错。解决方法：nn.Linear，nn.Conv2d等默认输入数据类型是torch.float32，频域数据是复数，所以需要将dtype改成torch.complex64即可解决。</li><li>使用切片操作得到预测的滤波器时报错：RuntimeError: “div_floor_cuda” not implemented for ‘ComplexFloat’。解决方法：该错误和数据类型有关，需要使用torch.abs将数据类型为torch.complex的数据转换一下。</li></ol><h3 id="第4周"><a class="markdownIt-Anchor" href="#第4周"></a> 第4周🌈</h3><ol><li>自己搭建的融合网络进行推理测试时报错：IndexError: invalid index of a 0-dim tensor. Use <code>tensor.item()</code> in Python or <code>tensor.item&lt;T&gt;()</code> in C++ to convert a 0-dim tensor to a number。解决方法：因为在推理时，batchsize为1，所以计算时出现了维度错误，将相应的和batch有关的计算进行更改即可。</li><li>将ycbcr进行拼接转为rgb图像时，图像显示时色彩异常。解决方法：出现此情况的原因时读取ycbcr图像时，先分别读取出y，cbcr，然后在分别进行归一化，因为rgb2ycbcr的过程中涉及其他计算，所以应当先对整张图像归一化，再分别读取出y，cbcr。</li><li>推理时报错TypeError: conv2d() received an invalid combination of arguments - got (tuple, Parameter, NoneType, tuple, tuple, tuple, int), but expected one of: * (Tensor input, Tensor weight, Tensor bias, tuple of ints stride, tuple of ints padding, tuple of ints dilation, int groups)didn’t match because some of the arguments have invalid types: (tuple of (Tensor, Tensor), Parameter, NoneType, tuple of (int, int), tuple of (int, int), tuple of (int, int), int)。解决方法：原因是输入模型的数据有误，误把某个tuple类型的数据输入到一个本该为tensor的数据中。</li></ol><h3 id="第5周"><a class="markdownIt-Anchor" href="#第5周"></a> 第5周🌈</h3><ol><li>使用git push出现<br />error: 对象文件 .git/objects/f2/22d3b7ccb69f6a75af88129fa8ebc652a6d349 为空<br />error: 对象文件 .git/objects/f2/22d3b7ccb69f6a75af88129fa8ebc652a6d349 为空<br />fatal: 松散对象 f222d3b7ccb69f6a75af88129fa8ebc652a6d349（保存在 .git/objects/f2/22d3b7ccb69f6a75af88129fa8ebc652a6d349）已损坏<br />解决方法：是因为虚拟机强制退出引起的，按照网上的方法要find .git/objects/ -size 0 -exec rm -f {} ;<br />git fetch origin，但没有解决，应该将备份分支的.git文件夹复制到主目录，部署分支的.git放在.deploy_git</li><li>error: 源引用规格 main 没有匹配，解决方法，本地分支与远程分支名称不匹配，指定推送的远程分支名称即可。</li><li>vscode终端运行c++文件输出中文乱码，解决方法：原因是vscode文件编码为utf8而终端编码为gbk，因此需要把终端编码改为utf8，对于powershell，需要按ctrl+,然后在命令行后面加powershell.exe -NoExit chcp 65001，对于cmd，需要在注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor新建字符串值，然后输入chcp 65001。或者在代码中，包含#include &lt;windows.h&gt;，然后在输出前加一行SetConsoleOutputCP(CP_UTF8);这样就可以正常输出中文了。</li></ol><h3 id="第6周"><a class="markdownIt-Anchor" href="#第6周"></a> 第6周🌈</h3><ol><li>linux下运行sh脚本，命令行参数间自动增加\r，解决方法：dos2unix <a href="http://a.sh">a.sh</a> 或者 sed -i “s/\r//” <a href="http://a.sh">a.sh</a>，参考(<a href="https://blog.csdn.net/qq_25112523/article/details/109279059">https://blog.csdn.net/qq_25112523/article/details/109279059</a>)</li><li>安装tinycudann时报错ERROR: Could not build wheels for tinycudann, which is required to install pyproject.toml-based projects，此时还发现其他报错信息，The detected CUDA version (12.2) mismatches the version that was used to compile PyTorch (11.7). Please make sure to use the same CUDA versions.因此因该是版本不一致导致的，解决方法：切换cuda版本</li><li>UnboundLocalError: local variable ‘dir’ referenced before assignment。解决方法，我在使用if语句时，每个分支内定义了dir变量，然后函数返回dir时如果都不满足可能不认识，因此应在if语句前初始化一下dir变量</li><li>pip安装requirements失败，解决方法：不知道什么原因，需要先安装一个torch，继续安装requirements就正常了。</li><li>装环境报错error in gym setup command: ‘extras_require’ must be a dictionary whose values are strings or lists of strings containing valid project/version requirement specifiers.。解决办法：pip install setuptools== 65.5.0<br />pip install --user wheel==0.38.0</li><li>安装环境时报错，Caused by SSLError(SSLZeroReturnError(6, ‘TLS/SSL connection has been closed (EOF) (_ssl.c:1131)’))) - skipping解决方法：关闭系统代理</li><li>TypeError: Cannot handle this data type: (1, 1), &lt; i8，解决方法，需要将图像数组转换成np.uint8</li></ol><h3 id="第7周"><a class="markdownIt-Anchor" href="#第7周"></a> 第7周🌈</h3><ol><li>cannot import name ‘greycomatrix’ from ‘skimage.feature’，解决方法，由于skimage版本问题，旧版本为greycomatrix，新版本为graycomatrix，更正即可</li><li>fft后频域融合的结果不理想，解决方法：仔细检查后发现幅值和相位的处理有问题，一些损失函数如relu，sigmoid会对结果有很大影响，需要重新分析，分析时要考虑值域以及相应的几何意义。</li></ol><h3 id="持续更新"><a class="markdownIt-Anchor" href="#持续更新"></a> 持续更新🌈</h3><ol><li>训练网络时报错，RuntimeError: one of the variables needed for gradient computation has been modified by an inplace operation: [torch.cuda.FloatTensor [4, 32, 320, 320]], which is output 0 of ReluBackward0, is at version 1; expected version 0 instead. Hint: enable anomaly detection to find the operation that failed to compute its gradient, with torch.autograd.set_detect_anomaly(True). 原因：利用a变量进行一次网络运算后，使用修改后的a变量又进行一次网络运算，而网络在后向传播时，发现第一次网络运算的梯度溯源失败，a变量被修改了。解决方法，在出错的地方将x换成x.clone()，例如<code>x = self.dhsa(x.clone())</code>即可</li></ol>]]></content>
    
    
    <categories>
      
      <category>资料</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>参考资料合集</title>
    <link href="/2023/08/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E5%90%88%E9%9B%86/"/>
    <url>/2023/08/11/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B8%80%E4%BA%9B%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0rainbowrainbowrainbow">一些有价值的参考资料（持续更新!）🌈🌈🌈</a><ul><li><a href="#%E7%AC%AC1%E5%91%A8rainbow">第1周🌈</a></li><li><a href="#%E7%AC%AC2%E5%91%A8rainbow">第2周🌈</a></li><li><a href="#%E7%AC%AC3%E5%91%A8rainbow">第3周🌈</a></li><li><a href="#%E7%AC%AC4%E5%91%A8rainbow">第4周🌈</a></li><li><a href="#%E7%AC%AC5%E5%91%A8rainbow">第5周🌈</a></li><li><a href="#%E7%AC%AC6%E5%91%A8rainbow">第6周🌈</a></li><li><a href="#%E7%AC%AC7%E5%91%A8rainbow">第7周🌈</a></li><li><a href="#%E7%AC%AC8%E5%91%A8rainbow">第8周🌈</a></li><li><a href="#%E7%AC%AC9%E5%91%A8rainbow">第9周🌈</a></li><li><a href="#%E7%AC%AC10%E5%91%A8rainbow">第10周🌈</a></li><li><a href="#%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0rainbow">持续更新🌈</a></li></ul></li></ul><!-- /TOC --><h2 id="一些有价值的参考资料持续更新"><a class="markdownIt-Anchor" href="#一些有价值的参考资料持续更新"></a> 一些有价值的参考资料（持续更新!）🌈🌈🌈</h2><h3 id="第1周"><a class="markdownIt-Anchor" href="#第1周"></a> 第1周🌈</h3><ol><li>了解了在线深度学习可视化辅助工具wandb</li><li>关于结构性相似度（SSIM）的论文，《Image quality assessment: from error visibility to structural similarity》</li><li>在TarDAL中使用显著性检测从红外图像中生成mask的网络，《R3Net: Recurrent Residual Refinement Network for Saliency Detection》</li><li>GAN网络中为什么判别器训练的越好，生成器梯度消失越严重，参考<a href="https://blog.csdn.net/qq_42693593/article/details/127365516?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169372361316800182792093%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169372361316800182792093&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127365516-null-null.142%5Ev93%5Econtrol&amp;utm_term=%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%A4%E5%88%AB%E5%99%A8%E8%AE%AD%E7%BB%83%E7%9A%84%E8%B6%8A%E5%A5%BD%EF%BC%8C%E7%94%9F%E6%88%90%E5%99%A8%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E8%B6%8A%E4%B8%A5%E9%87%8D&amp;spm=1018.2226.3001.4187">1</a></li><li>在TarDAL论文中，判别器损失函数使用了WGAN-div损失函数，即引入了Wasserstein散度，具体参考(<a href="https://zhuanlan.zhihu.com/p/25071913">https://zhuanlan.zhihu.com/p/25071913</a>)，<a href="https://blog.csdn.net/qq_39237205/article/details/123718856?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169372388816800182120614%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169372388816800182120614&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-123718856-null-null.142%5Ev93%5Econtrol&amp;utm_term=wgan-div&amp;spm=1018.2226.3001.4187">1</a>，总的来说WGAN可以帮助GAN网络的训练变的更加稳定。</li><li>关于图像融合评价指标的计算：<a href="https://blog.csdn.net/fovever_/article/details/129332278?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169372348316800188584429%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169372348316800188584429&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129332278-null-null.142%5Ev93%5Econtrol&amp;utm_term=%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87python&amp;spm=1018.2226.3001.4187">1</a></li></ol><h3 id="第2周"><a class="markdownIt-Anchor" href="#第2周"></a> 第2周🌈</h3><ol><li>linux下通过软连接切换cuda版本，首先 ls /usr/local | grep cuda查看已安装的cuda版本，然后sudo ln -snf /usr/local/cuda-10.0 /usr/local/cuda建立软连接即可，-s表示创建软连接，-n表示软连接已存在则删除，-f表示强制覆盖，具体可参考<a href="https://blog.csdn.net/fxmtb/article/details/130573696?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169371218816800213030057%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169371218816800213030057&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130573696-null-null.142%5Ev93%5Econtrol&amp;utm_term=linux%E4%B8%8B%E5%88%87%E6%8D%A2cuda%E7%89%88%E6%9C%AC%E8%BD%AF%E8%BF%9E%E6%8E%A5&amp;spm=1018.2226.3001.4187">1</a>，如果没有root权限，可通过修改~/.bashrc文件的方法切换，具体参考<a href="https://blog.csdn.net/Marquis_Z/article/details/129683777?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169371196516800211516194%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169371196516800211516194&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-129683777-null-null.142%5Ev93%5Econtrol&amp;utm_term=linux%E4%B8%8B%E5%88%87%E6%8D%A2cuda%E7%89%88%E6%9C%AC&amp;spm=1018.2226.3001.4187">2</a>,<a href="https://blog.csdn.net/deersonglzx/article/details/132103228?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169371204116800188517144%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169371204116800188517144&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-1-132103228-null-null.142%5Ev93%5Econtrol&amp;utm_term=linux%E4%B8%8B%E5%88%87%E6%8D%A2cuda%E7%89%88%E6%9C%AC&amp;spm=1018.2226.3001.4187">3</a></li><li>vscode远程调试中文件路径无法找到时，可以将launch.json中pargram设置为运行文件，cwd设置为运行目录，这样即可正常调试。</li><li>调试过程查看梯度：在vscode调试时，尝试在调试控制台查看模型的梯度，但是只能在变量中看到nn.module.parameters()函数，要具体查看参数需要通过代码将梯度打印出来，如for name, param in self.detect.net.named_parameters(): print(name, param.grad)，经过调试得出，在优化器更新参数时，只有模型的loss经过backward()回传才会计算梯度，比如gloss=a * floss+b * dloss，如果a=0，那么gloss.backward()后，会计算模型d梯度而不会计算模型f的梯度。</li><li>pytorch中permute函数和view()/reshape()函数的区别，前者是在维度上互换或者重新排列，后者相当于将所有元素重新取出再排列。详细参考<a href="https://blog.csdn.net/Dust_Evc/article/details/128565263?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=permute%E5%92%8Cview/reshape%E5%8C%BA%E5%88%AB&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128565263.142%5Ev93%5Econtrol&amp;spm=1018.2226.3001.4187">1</a>,<a href="https://blog.csdn.net/ODIMAYA/article/details/123898732?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169371133116800226577302%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169371133116800226577302&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-11-123898732-null-null.142%5Ev93%5Econtrol&amp;utm_term=permute%E5%92%8Cview%2Freshape%E5%8C%BA%E5%88%AB&amp;spm=1018.2226.3001.4187">2</a>，同时torch.nn.Flatten与torch.flatten也有点小区别，即前者默认从维度1开始，后者默认从维度0开始。</li><li>einops库中的矩阵操作与einsum矩阵乘法，参考：<a href="https://blog.csdn.net/a486259/article/details/126966772?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169370823316800182774809%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169370823316800182774809&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-126966772-null-null.142%5Ev93%5Econtrol&amp;utm_term=einops%E4%B8%8Eeinsum&amp;spm=1018.2226.3001.4187">1</a></li><li>关于dataloader中的collate_fn函数，他的作用是手动调整1个batch中的数据的组织方式，其传入参数为batch(1个大小为batchsize的list)，具体参考<a href="https://blog.csdn.net/dong_liuqi/article/details/114521240">1</a>，如果__getitem__函数中出现标签为空的情况，可以通过collate_fn进行改动，参考<a href="https://blog.csdn.net/guyuealian/article/details/91129367###">2</a></li><li>pytorch中torchvision.transform.Resize()和torch.nn.functions.interpolate的区别：前者是基于插值实现的，用于调整图像的大小，后者常用于对特征图进行上采样等操作。更多关于图像预处理的方法，参考torchvision官方文档(<a href="https://pytorch.org/vision/0.15/transforms.html#transforms-scriptability">https://pytorch.org/vision/0.15/transforms.html#transforms-scriptability</a>)</li><li>IEEE Conference latex模板使用注意事项，参考<a href="https://blog.csdn.net/Hsin96/article/details/121133441">1</a>，latex列表的使用，参考<a href="https://blog.csdn.net/xovee/article/details/106365532?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169372332716800188537784%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169372332716800188537784&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-106365532-null-null.142%5Ev93%5Econtrol&amp;utm_term=latex%E5%88%97%E8%A1%A8&amp;spm=1018.2226.3001.4187">2</a></li><li>ppt绘图后使用vba宏1键导出为pdf并裁剪，参考<a href="https://blog.csdn.net/leida_wt/article/details/114326133?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169372340516800180676210%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169372340516800180676210&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-114326133-null-null.142%5Ev93%5Econtrol&amp;utm_term=ppt%E4%BD%BF%E7%94%A8vba%E5%AF%BC%E5%87%BApdf&amp;spm=1018.2226.3001.4187">1</a>，这里vba代码中使用pdfcrop在我的电脑中失效，可以shell代码改为Shell &quot;pdfcrop &quot; &amp; strNotes &amp; sExt &amp; &quot; &quot; &amp; strNotes &amp; sExt，然后在前面加上ChDir sPath更改工作路径，或者手动使用pdfcrop进行pdf裁剪</li><li>科研作图和表格参考：(<a href="https://zhuanlan.zhihu.com/p/603088040">https://zhuanlan.zhihu.com/p/603088040</a>)</li><li>统计模型参数量和计算量，参考<a href="https://blog.csdn.net/qq_43426908/article/details/130338449?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169370415016800182723428%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169370415016800182723428&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-4-130338449-null-null.142%5Ev93%5Econtrol&amp;utm_term=torchstat&amp;spm=1018.2226.3001.4187">1</a></li><li>etc.，et al.，i.e.，e.g.的区别，参考(<a href="https://zhuanlan.zhihu.com/p/85630819">https://zhuanlan.zhihu.com/p/85630819</a>)</li><li>图像的相关系数计算，参考<a href="https://blog.csdn.net/weixin_30394333/article/details/95754064?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%9B%BE%E5%83%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0%E8%AE%A1%E7%AE%97&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-95754064.142%5Ev93%5Econtrol&amp;spm=1018.2226.3001.4187">1</a></li><li>关于范数，0范数表示非零元素个数，1范数表示所有元素绝对值之和，2范数表示所有元素间平方和，无穷范数表示所有元素最大值，对于两个向量，L1范数又叫曼哈顿距离，是元素间的绝对误差和(差的绝对值求和)，而L2范数是欧氏距离，是元素间的平方差和。</li><li>梯度裁剪nn.utils.clip_grad_norm_的使用，参考<a href="https://blog.csdn.net/Mikeyboi/article/details/119522689">1</a>，<a href="https://blog.csdn.net/zhaohongfei_358/article/details/122820992?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169365178316800213092562%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169365178316800213092562&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-122820992-null-null.142%5Ev93%5Econtrol&amp;utm_term=nn.utils.clip_grad_norm_&amp;spm=1018.2226.3001.4187">2</a></li><li>本地文件传输到远程服务器，远程服务器文件互相传输，参考：(<a href="https://cloud.tencent.com/developer/article/2092491">https://cloud.tencent.com/developer/article/2092491</a>)</li><li>服务器防火墙设置，参考<a href="https://blog.csdn.net/lu962820662/article/details/129340504?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169365169716800211535651%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169365169716800211535651&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-3-129340504-null-null.142%5Ev93%5Econtrol&amp;utm_term=linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%B2%E7%81%AB%E5%A2%99%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8&amp;spm=1018.2226.3001.4187">1</a></li><li>关于自注意力的意义的详细解析，参考(<a href="https://zhuanlan.zhihu.com/p/410776234">https://zhuanlan.zhihu.com/p/410776234</a>)</li><li>BatchNorm，LayerNorm，GroupNorm的区别，参考：<a href="https://blog.csdn.net/qq_43426908/article/details/123119919?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169365115016800225577832%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169365115016800225577832&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-123119919-null-null.142%5Ev93%5Econtrol&amp;utm_term=batchnorm%20layernorm%20%20groupnorm&amp;spm=1018.2226.3001.4187">1</a></li><li>python广播机制的用法，参考：(<a href="https://zhuanlan.zhihu.com/p/86997775">https://zhuanlan.zhihu.com/p/86997775</a>)</li><li>h5py库的用法，参考<a href="https://blog.csdn.net/csdn15698845876/article/details/73278120?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%2273278120%22%2C%22source%22%3A%22qq_45909764%22%7D&amp;fromshare=blogdetail">1</a></li></ol><h3 id="第3周"><a class="markdownIt-Anchor" href="#第3周"></a> 第3周🌈</h3><ol><li>两台服务器之间传输文件的方法，参考<a href="https://blog.csdn.net/Black_8/article/details/122925549?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22122925549%22%2C%22source%22%3A%22qq_45909764%22%7D&amp;fromshare=blogdetail">1</a></li><li>关于python中文件路径的介绍，参考<a href="https://blog.csdn.net/The_Time_Runner/article/details/84147220?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%2284147220%22%2C%22source%22%3A%22qq_45909764%22%7D&amp;fromshare=blogdetail">1</a></li><li>关于python中super()函数，有时候看到在super函数中传递当前类的实例如super(AttentionBase, self).<strong>init</strong>()，又是则不传递，如super().<strong>init</strong>()，在Python 3中，如果super()不传递任何参数，则函数将自动使用当前类和实例作为参数。因此直接super().<strong>init</strong>()与前者是等效的。</li><li>list，numpy，tensor互相转换及常用操作，参考：<a href="https://blog.csdn.net/onion_rain/article/details/107460601?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22107460601%22%2C%22source%22%3A%22qq_45909764%22%7D&amp;fromshare=blogdetail">1</a></li><li>对list进行[:None]和[None:]的作用，参考：(<a href="https://zhuanlan.zhihu.com/p/598562546">https://zhuanlan.zhihu.com/p/598562546</a>)</li><li>关于使用np.percentile计算百分位数的用法，参考<a href="https://blog.csdn.net/yxf771hotmail/article/details/131849484?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22131849484%22%2C%22source%22%3A%22qq_45909764%22%7D&amp;fromshare=blogdetail">1</a></li><li>python导入上级目录. 同级目录. 下级目录的包，参考<a href="https://blog.csdn.net/gaifuxi9518/article/details/81038818?ops_request_misc=%7B%22request%5Fid%22%3A%22169382667516800197050835%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169382667516800197050835&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-81038818-null-null.142%5Ev93%5Econtrol&amp;utm_term=python%E5%AF%BC%E5%85%A5%E5%8C%85%E7%9A%84%E5%8E%9F%E7%90%86&amp;spm=1018.2226.3001.4187">1</a>，<a href="https://blog.csdn.net/anshiquanshu/article/details/116174774?ops_request_misc=%7B%22request%5Fid%22%3A%22169381126916800225545986%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169381126916800225545986&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-5-116174774-null-null.142%5Ev93%5Econtrol&amp;utm_term=python%E6%89%BE%E4%B8%8D%E5%88%B0%E4%B8%8A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9&amp;spm=1018.2226.3001.4187">2</a>，为了减少导入包时候的错误，导入同一包(目录)中的模块应使用相对导入(.)，导入其他包中模块应使用绝对导入。</li><li>关于python中的解包和打包，<em>通常用于解包，如<code>a=[[1,2],[3,4]]</code>，则使用</em>a返回两个List，<code>[1,2]</code>和<code>[3,4]</code>，使用zip进行打包，它会将两个可迭代对象相同位置的元素打包成一个元组，然后返回一个迭代器，例如<code>a=[1,2]</code>，<code>b=[3,4]</code>，zip(a,b)会得到两个元组<code>(1,3)，(2,4)</code>，可以用for来进行迭代。通常在__collate_fn__中，使用zip(*batch)重新组织一批数据，例如get_item函数返回了两个列表a,b，假设batchsize为8，传入到__collate_fn__中的batch是一个包含8个元素的list，其中每个元素都为元组(a,b)，*batch会将list解包，然后zip会将8个元组中的a打包成一个新的元组，然后将8个元组中的b打包成一个新的元组，也就是说得到了两个新元组x(由8个a组成)和y(由8个b组成)，然后分别返回x，y即可。</li><li>关于params_group，以及如何为不同层设置不同学习率，参考<a href="https://blog.csdn.net/weixin_45464524/article/details/130456843?ops_request_misc=%7B%22request%5Fid%22%3A%22169390449016800192272047%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169390449016800192272047&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-2-130456843-null-null.142%5Ev93%5Econtrol&amp;utm_term=pytorch%E7%9A%84params_group&amp;spm=1018.2226.3001.4187">1</a>，<a href="https://zhuanlan.zhihu.com/p/347929433">2</a>，<a href="https://blog.csdn.net/weixin_45464524/article/details/130477798?ops_request_misc=%7B%22request%5Fid%22%3A%22169407405916800184146887%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169407405916800184146887&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130477798-null-null.142%5Ev93%5Econtrol&amp;utm_term=%E4%BD%BF%E7%94%A8params_group%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E5%AD%A6%E4%B9%A0%E7%8E%87&amp;spm=1018.2226.3001.4187">3</a>。</li><li>关于python中矩阵乘法multiply(). dot().  matmul(). ’ * '. '@'的区别，参考:<a href="https://blog.csdn.net/u011851421/article/details/83783826?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=@,dot,multiply%E7%9A%84%E5%8C%BA%E5%88%AB&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-83783826.142%5Ev93%5Econtrol&amp;spm=1018.2226.3001.4187">1</a></li><li>optimizer.zero_grad和model.zero_grad的区别，参考<a href="https://blog.csdn.net/qq_32614873/article/details/128626028?ops_request_misc=%7B%22request%5Fid%22%3A%22169400319916777224491083%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169400319916777224491083&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-128626028-null-null.142%5Ev93%5Econtrol&amp;utm_term=model.zero_grad()%E5%92%8Coptimizer.zero_grad()&amp;spm=1018.2226.3001.4187">1</a>。</li><li>pytorch的显存分配机制，参考(<a href="https://zhuanlan.zhihu.com/p/424512257">https://zhuanlan.zhihu.com/p/424512257</a>)</li><li>哪些部分需要to(device)? 损失函数需不需要to(device)? 参考<a href="https://blog.csdn.net/virus111222/article/details/129773728?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=pytorch%E5%93%AA%E4%BA%9B%E9%9C%80%E8%A6%81to(device)&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-129773728.142%5Ev93%5Econtrol&amp;spm=1018.2226.3001.4187">1</a></li><li>关于分组卷积，即conv2d中groups参数，每个卷积核的通道数为in_channel / groups，然后共有out_channels个卷积核，每个组内有out_channels / groups个卷积核，深度可分离卷积的输入输出通道数以及groups都相同，具体例子参考<a href="https://blog.csdn.net/u012633319/article/details/109171775?ops_request_misc=%7B%22request%5Fid%22%3A%22169443420016800180671495%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169443420016800180671495&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109171775-null-null.142%5Ev93%5Econtrol&amp;utm_term=conv2d%E7%9A%84groups%E5%8F%82%E6%95%B0&amp;spm=1018.2226.3001.4187">1</a></li><li>关于全局平均池化(GAP)的原理以及实现。参考<a href="https://blog.csdn.net/qq_41990294/article/details/128930017?ops_request_misc=%7B%22request%5Fid%22%3A%22169466072616800185863464%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169466072616800185863464&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-128930017-null-null.142%5Ev94%5Econtrol&amp;utm_term=globalaveragepooling&amp;spm=1018.2226.3001.4187">1</a>，pytorch中主要通过自适应池化实现，参考<a href="https://blog.csdn.net/weixin_45928096/article/details/122506640?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169926028516777224462932%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169926028516777224462932&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-122506640-null-null.142%5Ev96%5Epc_search_result_base5&amp;utm_term=adaptive%20avg%20pool&amp;spm=1018.2226.3001.4187">2</a></li></ol><h3 id="第4周"><a class="markdownIt-Anchor" href="#第4周"></a> 第4周🌈</h3><ol><li>关于模型断点继续训练，参考(<a href="https://zhuanlan.zhihu.com/p/611485709">https://zhuanlan.zhihu.com/p/611485709</a>),                           (<a href="https://zhuanlan.zhihu.com/p/647349640">https://zhuanlan.zhihu.com/p/647349640</a>)</li><li>关于进度条tqdm的使用，参考(<a href="https://blog.csdn.net/wxd1233/article/details/118371404">https://blog.csdn.net/wxd1233/article/details/118371404</a>)</li><li>关于词嵌入向量torch.nn.Embedding，参考<a href="https://blog.csdn.net/athrunsunny/article/details/123068113?spm=1001.2014.3001.5501">1</a></li><li>匈牙利算法常用来解决最优指派问题，在DETR里它的作用是为每一个gt匹配到唯一的query，从而使代价矩阵的匹配成功的query和gt的代价和最小，关于匈牙利算法的简单理解，参考<a href="https://blog.csdn.net/athrunsunny/article/details/123504015?spm=1001.2014.3001.5502">1</a></li><li>各种IOU的介绍，参考<a href="https://blog.csdn.net/weixin_43694096/article/details/126455488?ops_request_misc=%7B%22request%5Fid%22%3A%22169544548316800180675276%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169544548316800180675276&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-17-126455488-null-null.142%5Ev94%5Econtrol&amp;utm_term=ciou,diou,giou&amp;spm=1018.2226.3001.4187">1</a></li><li>latex配置c和python代码块风格，参考<a href="https://blog.csdn.net/Aldielshala/article/details/89840206">1</a>，<a href="https://zhuanlan.zhihu.com/p/464141424">2</a></li><li>latex写伪代码，参考(<a href="https://zhuanlan.zhihu.com/p/599142563">https://zhuanlan.zhihu.com/p/599142563</a>)，(<a href="https://zhuanlan.zhihu.com/p/572285214">https://zhuanlan.zhihu.com/p/572285214</a>)</li><li>plt.subplots的使用,参考<a href="https://blog.csdn.net/weixin_39258979/article/details/126039763">1</a></li></ol><h3 id="第5周"><a class="markdownIt-Anchor" href="#第5周"></a> 第5周🌈</h3><ol><li>使用algorithmic宏包编写伪代码时的分页问题，参考(<a href="https://blog.csdn.net/Yiigel/article/details/53840888">https://blog.csdn.net/Yiigel/article/details/53840888</a>)</li><li>cv中的绝对位置编码和相对位置编码，绝对位置编码：一般是可学习的，实现非常简洁，初始化一个形状和经过patch_embedding后的输出x相同的参数，然后直接加到x上，在训练阶段一起训练，有点像加了一个可学习的bias，VIT中使用的就是这种方式。对于相对位置编码：绝对位置编码是在patch_embedding之后，计算自注意力(Q,K,V)之前，而相对位置编码是在计算自注意力的时候加入的，在swin transformer中，将二维位置信息转换为一维位置信息，然后去根据相对位置偏移表查询具体的值，位置偏移表的值是训练出来的，在文章中，相对位置编码效果好于绝对位置编码。具体参考<a href="https://blog.csdn.net/qq_43733107/article/details/127077056">这里</a>。</li><li>dense block，每一层将之前所有层的输入进行拼接，之后将输出的特征图传递给之后的所有层，可以可以减轻梯度消失现象，加强特征的融合。参考(<a href="https://www.jianshu.com/p/0b8fc900abef">https://www.jianshu.com/p/0b8fc900abef</a>)</li><li>关于变异系数CV(coefficient of variation)，需要比较两组数据离散程度大小的时候，如果两组数据的测量尺度相差太大，或者数据量纲的不同，直接使用标准差来进行比较不合适，此时就应当消除测量尺度和量纲的影响，而变异系数可以做到这一点，它是原始数据标准差与原始数据平均数的比。CV没有量纲，这样就可以进行客观比较了。事实上，可以认为变异系数和极差. 标准差和方差一样，都是反映数据离散程度的绝对值。其数据大小不仅受变量值离散程度的影响，而且还受变量值平均水平大小的影响。参考<a href="https://blog.csdn.net/m0_64799907/article/details/130041485?ops_request_misc=%7B%22request%5Fid%22%3A%22169745656316800225536260%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169745656316800225536260&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-130041485-null-null.142%5Ev96%5Econtrol&amp;utm_term=coefficientofvariation&amp;spm=1018.2226.3001.4187">1</a></li><li>git fetch 和git pull的区别，git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</li><li>转置卷积的计算详解，参考<a href="https://blog.csdn.net/ZhaoDongyu_AK47/article/details/130602195">1</a></li></ol><h3 id="第6周"><a class="markdownIt-Anchor" href="#第6周"></a> 第6周🌈</h3><ol><li>新设备配置git时，验证是否成功ssh -T <a href="mailto:git@github.com">git@github.com</a>，启智平台同理，参考<a href="https://blog.csdn.net/m0_72983118/article/details/130546429">1</a></li><li>vbox的虚拟环境的复制，只需要复制.vbox, .vdi, vbox-prev文件到相同路径，然后在vbox中注册即可</li><li>vscode终端支持conda命令，参考<a href="https://blog.csdn.net/takedachia/article/details/124694616">1</a></li><li>list的extend和append的区别：append（）用于在列表末尾添加新的对象，输入参数为对象；extend（）用于在列表末尾追加另一个序列中的多个值，输入对象为元素队列；</li><li>numpy的ravel和flatten函数的区别：参考<a href="https://blog.csdn.net/liuweiyuxiang/article/details/78220080?ops_request_misc=%7B%22request%5Fid%22%3A%22169830186016800186578235%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169830186016800186578235&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-78220080-null-null.142%5Ev96%5Epc_search_result_base5&amp;utm_term=ravel%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">1</a></li><li>delctype和auto的区别，二者都用于自动推导类型，但delctype更为灵活，auto所修饰的变量必须被初始化，编译器需要通过初始化来确定auto所代表的类型，即必须要定义变量。若仅希望得到类型，则可以用delctype，如一些排序规则需要使用仿函数，可以用lambda表达式定义比较函数，然后用decltype自动推导。参考(<a href="https://zhuanlan.zhihu.com/p/152154499">https://zhuanlan.zhihu.com/p/152154499</a>)</li></ol><h3 id="第7周"><a class="markdownIt-Anchor" href="#第7周"></a> 第7周🌈</h3><ol><li>python中函数命名时下划线的作用，单前置下划线作为类名或者函数名时，表示会阻止其他python脚本通过【from module import *】语句导入该名字，即该名字不会被星号匹配；前后均带有双下划线的名字，一般用于特殊方法的命名，用来实现对象的一些行为或者功能，如__new__()方法用来创建实例，<strong>init</strong>()方法用来初始化对象，x + y操作被映射为方法x.<strong>add</strong>(y)，序列或者字典的索引操作x[k]映射为x.<strong>getitem</strong>(k), <strong>len</strong>(), <strong>str</strong>()分别被内置函数len(). str()调用等等；仅开头带双下划线的命名，表示，以此命名的属性或者方法为类的私有属性或者私有方法。</li><li>linux终端命令中&amp;&amp;和&amp;的区别，&amp;&amp; 用于顺序执行两个命令，并且第二个命令仅在第一个成功时才执行，而 &amp; 用于将命令置于后台运行，允许你同时执行其他任务。</li><li>余弦退火调整学习率，一般训练时梯度下降算法可能陷入局部最小值，此时可以通过突然提高学习率，来“跳出”局部最小值并找到通向全局最小值的路径。这种方式称为带重启的随机梯度下降方法。参考(<a href="https://blog.csdn.net/weixin_35848967/article/details/108493217">https://blog.csdn.net/weixin_35848967/article/details/108493217</a>)</li><li>关于torch.backends.cudnn.benchmark，该选项设置为true时，会自动选择最优卷积算子，但是这个过程是随机的，也就是说即使固定了随机种子，如果这一项为true，训练的结果依然会不同。</li><li>windows终端查看编码格式，chcp，切换编码chcp 65001(utf-8) chcp 936(简体中文gbk) chcp 437(英语)</li></ol><h3 id="第8周"><a class="markdownIt-Anchor" href="#第8周"></a> 第8周🌈</h3><ol><li>colab中命令前加！就可以执行linux命令，但是cd前需要加%</li><li>linux下使用代理，终端输入export https_proxy=https://proxy_ip:prot或者export https_proxy=<a href="https://username">https://username</a>:password@proxy_ip:port</li><li>python中的functools.partial的用法，partial可以为函数固定一个参数，如函数f(a,b)-&gt;a+b，那么ff=partial(f,3)就将f的第一个参数固定为3，ff(3)的结果为3+3=6，参考(<a href="https://blog.csdn.net/qsloony/article/details/123802110">https://blog.csdn.net/qsloony/article/details/123802110</a>)</li><li>git clone和git fetch的区别，git clone用于首次获取整个远程仓库到本地。git fetch用于检查远程仓库的更新并将这些更新拉取到本地，但不会自动合并这些更新。在使用git fetch后，可能需要使用git merge或git rebase来将获取的更新合并到你的当前分支。如果想同时获取并合并，可以使用git pull，它实际上是git fetch和git merge的组合。</li><li>upstream和origin的区别：git remote add upstream 用于添加原始仓库的引用，通常用于同步你 fork 的仓库。git remote add origin 用于添加你自己的远程仓库的引用，通常是你 fork 的仓库或你自己创建的新仓库。删除当前添加的远程仓库：git remote rm origin(仓库别名)</li><li>添加自己代码到别人仓库的方法，先fork别人的仓库，然后clone到本地，然后git remote add upstream url添加别人的原始仓库作为上游，然后依据需要决定是否创建新分支(git checkout -b branch)，然后add commit，在push之前，一般可以先从upstream获取代码更新(git pull upstream 分支名)，然后push到自己的仓库git push origin 分支名，然后在自己的仓库提交PR即可，通过后原始仓库会把自己的代码修改更新过去。</li><li>软连接的注意事项，参考(<a href="https://blog.csdn.net/liu16659/article/details/83714066">https://blog.csdn.net/liu16659/article/details/83714066</a>)</li></ol><h3 id="第9周"><a class="markdownIt-Anchor" href="#第9周"></a> 第9周🌈</h3><ol><li>terminal中使用pdb调试代码，在代码中import pdb;然后使用pdb.set_trace()加入断点，可以使用命令p varname来查看变量varname的值，使用命令c来执行程序到下一个断点，使用命令q来退出调试模式，n表示执行下一行不进入子程序，s表示执行下一行进入子程序，cl表示清除所有断点，在调试完成后，需要将import pdb; pdb.set_trace()这行代码从程序中删除，否则程序每次执行到这个位置都会进入调试模式，影响程序的执行效率。</li><li>nn.Conv2d和F.conv2d的区别，前者是卷积层（类接口），通过forward函数运算，只需定义in_c，out_c，kernel_size等参数，后者是卷积操作（函数接口），需要手动定义kernel和bias，如kernel=(16,3,5,5)表示输出通道数16，输入通道数3，bias设置为和输出通道数相等，参考(<a href="https://blog.csdn.net/SHU15121856/article/details/88956545">https://blog.csdn.net/SHU15121856/article/details/88956545</a>)</li><li>pytorch批量矩阵乘法torch.bmm用法，参考(<a href="https://blog.csdn.net/AdamCY888/article/details/131269958">https://blog.csdn.net/AdamCY888/article/details/131269958</a>)</li><li>几种归一化的区别，batchnorm：[n,c,h,w]-&gt;[c]，layernorm：[n,c,h,w]-&gt;[n]，instancenorm：[n,c,h,w]-&gt;[n,c]，groupnorm：[n,g,c//g,h,w]-&gt;[n,g]，weightnorm：主要思想是将权重向量分解为两个因子：方向和大小。然后，对方向进行归一化，使其具有单位范数，而大小则作为一个可训练的参数。这样做的好处是，它可以减少梯度下降中的路径依赖性，从而避免局部最优和鞍点。</li><li>windows终端使用代理(需安装相关代理软件)，cmd:set https_proxy=“xxxx”,powershell: $env:https_proxy=“xxxx”</li></ol><h3 id="第10周"><a class="markdownIt-Anchor" href="#第10周"></a> 第10周🌈</h3><ol><li>如果要冻结部分模型的参数更新，设置required_grad为false和with torch.no_grad()都可以，通常前者效率更高</li><li>关于GLCM的资料，参考(<a href="https://cloud.tencent.com/developer/article/2219407?areaId=106001">https://cloud.tencent.com/developer/article/2219407?areaId=106001</a>)</li><li>对齐版本的FLIR数据集，参考<a href="https://github.com/DocF/multispectral-object-detection">https://github.com/DocF/multispectral-object-detection</a></li><li>解压以.tar.001,.tar.002,…结尾的压缩文件：linux端先<code>cat file.tar.001 file.tar.002 file.tar.003 &gt; file.tar</code>合并文件，然后<code>tar -xvf file.tar</code>解压，windows端先<code>copy /b file.tar.001 + file.tar.002 + file.tar.003 file.tar</code>，再用压缩软件解压。</li><li>linux服务器设置huggingface镜像，首先<code>pip install huggingface_hub</code>，然后<code>export HF_ENDPOINT=https://hf-mirror.com</code></li></ol><h3 id="持续更新"><a class="markdownIt-Anchor" href="#持续更新"></a> 持续更新🌈</h3>]]></content>
    
    
    <categories>
      
      <category>资料</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最近公共祖先LCA</title>
    <link href="/2023/06/13/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88LCA/"/>
    <url>/2023/06/13/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88LCA/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%A5%96%E5%85%88">树节点的第K个祖先</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="树节点的第k个祖先"><a class="markdownIt-Anchor" href="#树节点的第k个祖先"></a> 树节点的第K个祖先</h2><p><a href="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。</p><p>树节点的第 k 个祖先节点是从该节点到根节点路径上的第 k 个节点。</p><p>实现 TreeAncestor 类：</p><p>TreeAncestor（int n， int[] parent） 对树和父数组中的节点数初始化对象。<br />getKthAncestor(int node, int k) 返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;TreeAncestor&quot;</span>,<span class="hljs-string">&quot;getKthAncestor&quot;</span>,<span class="hljs-string">&quot;getKthAncestor&quot;</span>,<span class="hljs-string">&quot;getKthAncestor&quot;</span>]<br>[[<span class="hljs-number">7</span>,[<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]],[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">3</span>]]<br><br>输出：<br>[null,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>]<br><br>解释：<br><span class="hljs-symbol">TreeAncestor</span> treeAncestor = new <span class="hljs-symbol">TreeAncestor</span>(<span class="hljs-number">7</span>, [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]);<br>treeAncestor.getKthAncestor(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);  // 返回 <span class="hljs-number">1</span> ，它是 <span class="hljs-number">3</span> 的父节点<br>treeAncestor.getKthAncestor(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>);  // 返回 <span class="hljs-number">0</span> ，它是 <span class="hljs-number">5</span> 的祖父节点<br>treeAncestor.getKthAncestor(<span class="hljs-number">6</span>, <span class="hljs-number">3</span>);  // 返回 <span class="hljs-number">-1</span> 因为不存在满足要求的祖先节点<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要用到树上倍增算法，需要用二维数组<code>pa[x][i]</code>表示节点<code>x</code>的第<code>2^i</code>祖先节点，则满足<code>pa[x][i+1]=pa[pa[x][i]][i]</code>，然后获取第k个祖先节点时，将k转换成二进制然后按位计算即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">TreeAncestor</span> &#123;<br>    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; pa;<br><span class="hljs-keyword">public</span>:<br>    TreeAncestor(<span class="hljs-built_in">int</span> n, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; parent) &#123;<br>        <span class="hljs-built_in">int</span> m=<span class="hljs-number">32</span>-__builtin_clz(n);<br>        pa.resize(n,vector&lt;<span class="hljs-built_in">int</span>&gt;(m,<span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>            pa[i][<span class="hljs-number">0</span>]=parent[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;m<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> x=<span class="hljs-number">0</span>;x&lt;n;++x)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">int</span> p=pa[x][i];p!=<span class="hljs-number">-1</span>)<br>                    pa[x][i+<span class="hljs-number">1</span>]=pa[p][i];<br>            &#125;<br>        &#125;<br>    &#125;  <br>    <span class="hljs-built_in">int</span> getKthAncestor(<span class="hljs-built_in">int</span> node, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> l=<span class="hljs-number">32</span>-__builtin_clz(k);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;l;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((k&gt;&gt;i)&amp;<span class="hljs-number">1</span>)<br>            &#123;<br>                node=pa[node][i];<br>                <span class="hljs-keyword">if</span>(node&lt;<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;    <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最近公共祖先lca"><a class="markdownIt-Anchor" href="#最近公共祖先lca"></a> 最近公共祖先LCA</h2><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>关于两个点x和y的lca，可以先预处理出每个节点的深度数组<code>depth[i]</code>，由于x和y的深度可能不同，所以需要现将深度较深的一个如<code>y</code>转换成它和x同一深度的祖先<code>y'</code>，然后x和y同时往上跳，在x到根节点的这条路径上猜一个点z当作lca，且x与z相距<code>2^i</code>步。把x和y同时向上跳<code>2^i</code>步，如果<code>x≠y</code>，就说明lca在z的上面，否则lca要么是z，要么在z的下面。</p><p>下面是模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeAncestor</span> &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; depth;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; pa;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TreeAncestor</span>(vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; &amp;edges) &#123;<br>        <span class="hljs-type">int</span> n = edges.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">32</span> - __builtin_clz(n); <span class="hljs-comment">// n 的二进制长度</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, y]: edges) &#123; <span class="hljs-comment">// 节点编号从 0 开始</span><br>            g[x].<span class="hljs-built_in">push_back</span>(y);<br>            g[y].<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br><br>        depth.<span class="hljs-built_in">resize</span>(n);<br>        pa.<span class="hljs-built_in">resize</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">-1</span>));<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa) &#123;<br>            pa[x][<span class="hljs-number">0</span>] = fa;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y: g[x]) &#123;<br>                <span class="hljs-keyword">if</span> (y != fa) &#123;<br>                    depth[y] = depth[x] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">dfs</span>(y, x);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; n; x++)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-type">int</span> p = pa[x][i]; p != <span class="hljs-number">-1</span>)<br>                    pa[x][i + <span class="hljs-number">1</span>] = pa[p][i];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_kth_ancestor</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (; k; k &amp;= k - <span class="hljs-number">1</span>)<br>            node = pa[node][__builtin_ctz(k)];<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回 x 和 y 的最近公共祖先（节点编号从 0 开始）</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (depth[x] &gt; depth[y])<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        <span class="hljs-comment">// 使 y 和 x 在同一深度</span><br>        y = <span class="hljs-built_in">get_kth_ancestor</span>(y, depth[y] - depth[x]);<br>        <span class="hljs-keyword">if</span> (y == x)<br>            <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pa[x].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> px = pa[x][i], py = pa[y][i];<br>            <span class="hljs-keyword">if</span> (px != py) &#123;<br>                x = px;<br>                y = py;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pa[x][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>活字印刷</title>
    <link href="/2023/05/19/%E6%B4%BB%E5%AD%97%E5%8D%B0%E5%88%B7/"/>
    <url>/2023/05/19/%E6%B4%BB%E5%AD%97%E5%8D%B0%E5%88%B7/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%B4%BB%E5%AD%97%E5%8D%B0%E5%88%B7">活字印刷</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="活字印刷"><a class="markdownIt-Anchor" href="#活字印刷"></a> 活字印刷</h2><p><a href="https://leetcode.cn/problems/letter-tile-possibilities/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。</p><p>注意：本题中，每个活字字模只能使用一次。</p><p>e.g.</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-string">&quot;AAB&quot;</span><br>输出：<span class="hljs-number">8</span><br>解释：可能的序列为 <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-string">&quot;AB&quot;</span>, <span class="hljs-string">&quot;BA&quot;</span>, <span class="hljs-string">&quot;AAB&quot;</span>, <span class="hljs-string">&quot;ABA&quot;</span>, <span class="hljs-string">&quot;BAA&quot;</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>计数dp，用<code>dp[i][j]</code>表示前i种字符生成长度为j的字符串时，能得到的方案数，用二位数组v预处理组合数，用哈系表统计字符出现频率，当不选第i种字符时，<code>dp[i][j]=dp[i-1][j]</code>，当选中k个i字符时，需要从j中选出k个位置放置这些字符，其余位置就是用前<code>i-1</code>种字符构造长为<code>j-k</code>的字符串，即<code>dp[i][j]=dp[i-1][j-k]*v[j][k]</code>，最后把所有不同长度的方案数加起来即最终答案。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTilePossibilities</span><span class="hljs-params">(string tiles)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> &amp;c:tiles)<br>            ++mp[c];<br>        <span class="hljs-type">int</span> n=tiles.<span class="hljs-built_in">size</span>(),m=mp.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">v</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)<br>        &#123;<br>            v[i][<span class="hljs-number">0</span>]=v[i][i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j)<br>                v[i][j]=v[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+v[i<span class="hljs-number">-1</span>][j];<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; it:mp)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;++j)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=j&amp;&amp;k&lt;=it.second;++k)<br>                    dp[i][j]+=dp[i<span class="hljs-number">-1</span>][j-k]*v[j][k];<br>            &#125;<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(dp[m].<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,dp[m].<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>按列翻转得到最大值等行数</title>
    <link href="/2023/05/15/%E6%8C%89%E5%88%97%E7%BF%BB%E8%BD%AC%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%AD%89%E8%A1%8C%E6%95%B0/"/>
    <url>/2023/05/15/%E6%8C%89%E5%88%97%E7%BF%BB%E8%BD%AC%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%AD%89%E8%A1%8C%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8C%89%E5%88%97%E7%BF%BB%E8%BD%AC%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%AD%89%E8%A1%8C%E6%95%B0">按列翻转得到最大值等行数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="按列翻转得到最大值等行数"><a class="markdownIt-Anchor" href="#按列翻转得到最大值等行数"></a> 按列翻转得到最大值等行数</h2><p><a href="https://leetcode.cn/problems/flip-columns-for-maximum-number-of-equal-rows/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定 m x n 矩阵 matrix 。</p><p>你可以从中选出任意数量的列并翻转其上的 每个 单元格。（即翻转后，单元格的值从 0 变成 1，或者从 1 变为 0 。）</p><p>返回 经过一些翻转后，行与行之间所有值都相等的最大行数 。</p><p>e.g.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[0,1],[1,1]]</span><br>输出：<span class="hljs-number">1</span><br>解释：不进行翻转，有 <span class="hljs-number">1</span> 行所有值都相等。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>因为最终统计的行都是全0或者全1，所以这道题的最终目的是找到互补的行数，所以对各行中首个元素为1的行取反，然后将每行转换成字符串，用哈系表统计相同行的最大数量即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> maxEqualRowsAfterFlips(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; <span class="hljs-keyword">matrix</span>) &#123;<br>        <span class="hljs-keyword">int</span> n=<span class="hljs-keyword">matrix</span>[<span class="hljs-number">0</span>].<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-keyword">string</span>,<span class="hljs-keyword">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; t:<span class="hljs-keyword">matrix</span>)<br>        &#123;<br>            <span class="hljs-keyword">string</span> s(n,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>                s[i]=t[i]^t[<span class="hljs-number">0</span>];<br>            ++mp[s];<br>            ans=<span class="hljs-keyword">max</span>(ans,mp[s]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>推箱子</title>
    <link href="/2023/05/08/%E6%8E%A8%E7%AE%B1%E5%AD%90/"/>
    <url>/2023/05/08/%E6%8E%A8%E7%AE%B1%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8E%A8%E7%AE%B1%E5%AD%90">推箱子</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="推箱子"><a class="markdownIt-Anchor" href="#推箱子"></a> 推箱子</h2><p><a href="https://leetcode.cn/problems/minimum-moves-to-move-a-box-to-their-target-location/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。</p><p>游戏地图用大小为 m x n 的网格 grid 表示，其中每个元素可以是墙、地板或者是箱子。</p><p>现在你将作为玩家参与游戏，按规则将箱子 ‘B’ 移动到目标位置 ‘T’ ：</p><p>玩家用字符 ‘S’ 表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。<br />地板用字符 ‘.’ 表示，意味着可以自由行走。<br />墙用字符 ‘#’ 表示，意味着障碍物，不能通行。<br />箱子仅有一个，用字符 ‘B’ 表示。相应地，网格上有一个目标位置 ‘T’。<br />玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。<br />玩家无法越过箱子。<br />返回将箱子推到目标位置的最小 推动 次数，如果无法做到，请返回 -1。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [[<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>],<br>             [<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>],<br>             [<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>],<br>             [<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>],<br>             [<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>],<br>             [<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>]]<br>输出：<span class="hljs-number">3</span><br>解释：我们只需要返回推箱子的次数。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>深度优先搜索(BFS)，通过<code>vis[px][py][bx][by]</code>记录当前箱子和人的位置是否被访问过，然后定义一个双端队列<code>deque&lt;tuple&lt;int,int,int,int&gt;&gt;</code>，每个元素记录人的位置、箱子的位置和当前推动距离，然后进行bfs，每次取出队首元素，如果箱子到达目的地则返回推动距离，否则先让人移动，当人移动到箱子位置时推动箱子(更新箱子位置)，如果推动后人和箱子当前位置未被访问，则将该状态加入队尾，如果人未移动到箱子位置并且当前二者位置未被访问，则将当前状态加入队首，重复上述步骤知道队列为空为止。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs prolog">class <span class="hljs-symbol">Solution</span> &#123;<br>int dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br>bool vis[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>][<span class="hljs-number">20</span>][<span class="hljs-number">20</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>public:<br>    int minPushBox(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;<br>        int m=grid.size(),n=grid[<span class="hljs-number">0</span>].size();<br>        auto isvalid=[&amp;](int x,int y)-&gt;bool&#123;<br>            return x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="hljs-number">0</span>&amp;&amp;y&lt;n&amp;&amp;grid[x][y]!=<span class="hljs-string">&#x27;#&#x27;</span>;<br>        &#125;;<br>        int startx,starty,boxx,boxy,endx,endy;<br>        for(int i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            for(int j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                if(grid[i][j]==<span class="hljs-string">&#x27;S&#x27;</span>)<br>                &#123;<br>                    startx=i;starty=j;<br>                &#125;<br>                else if(grid[i][j]==<span class="hljs-string">&#x27;B&#x27;</span>)<br>                &#123;<br>                    boxx=i;boxy=j;<br>                &#125;<br>                else if(grid[i][j]==<span class="hljs-string">&#x27;T&#x27;</span>)<br>                &#123;<br>                    endx=i;endy=j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        deque&lt;tuple&lt;int,int,int,int,int&gt;&gt; q;<br>        q.emplace_front(startx,starty,boxx,boxy,<span class="hljs-number">0</span>);<br>        vis[startx][starty][boxx][boxy]=true;<br>        while(!q.empty())<br>        &#123;<br>            auto [px,py,bx,by,d]=q.front();<br>            q.pop_front();<br>            if(bx==endx&amp;&amp;by==endy)<br>                return d;<br>            for(auto [dx,dy]:dir)<br>            &#123;<br>                int npx=px+dx,npy=py+dy;<br>                if(!isvalid(npx,npy))<br>                    continue;<br>                if(npx==bx&amp;&amp;npy==by)<br>                &#123;<br>                    int nbx=bx+dx,nby=by+dy;<br>                    if(!isvalid(nbx,nby)||vis[npx][npy][nbx][nby])<br>                        continue;<br>                    q.emplace_back(npx,npy,nbx,nby,d+<span class="hljs-number">1</span>);<br>                    vis[npx][npy][nbx][nby]=true;<br>                &#125;<br>                else if(!vis[npx][npy][bx][by])<br>                &#123;<br>                    q.emplace_front(npx,npy,bx,by,d);<br>                    vis[npx][npy][bx][by]=true;<br>                &#125;  <br>            &#125;<br>        &#125;<br>        return <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>摘水果</title>
    <link href="/2023/05/04/%E6%91%98%E6%B0%B4%E6%9E%9C/"/>
    <url>/2023/05/04/%E6%91%98%E6%B0%B4%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%91%98%E6%B0%B4%E6%9E%9C">摘水果</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="摘水果"><a class="markdownIt-Anchor" href="#摘水果"></a> 摘水果</h2><p><a href="https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 fruits ，其中 fruits[i] = [positioni, amounti] 表示共有 amounti 个水果放置在 positioni 上。fruits 已经按 positioni 升序排列 ，每个 positioni 互不相同 。</p><p>另给你两个整数 startPos 和 k 。最初，你位于 startPos 。从任何位置，你可以选择 向左或者向右 走。在 x 轴上每移动 一个单位 ，就记作 一步 。你总共可以走 最多 k 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。</p><p>返回你可以摘到水果的 最大总数 。<br />e.g.</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4<br>输出：9<br>解释：<br>最佳路线为：<br>- 向右移动到位置<span class="hljs-number"> 6 </span>，摘到<span class="hljs-number"> 3 </span>个水果<br>- 向右移动到位置<span class="hljs-number"> 8 </span>，摘到<span class="hljs-number"> 6 </span>个水果<br>移动<span class="hljs-number"> 3 </span>步，共摘到<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 9 </span>个水果<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>枚举移动的区间<code>[left,right]</code>，用二分查找来确定移动区间，实际移动时，要么先向左移动<code>x</code>步，再向右移动<code>k-x</code>，要么先向右移动<code>x</code>步，再向左移动<code>k-x</code>步，通过前缀和来快速计算区间的水果数量，通过二分查找枚举移动区间的时候，要注意边界，最后更新最大值即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    <span class="hljs-built_in">int</span> maxTotalFruits(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; fruits, <span class="hljs-built_in">int</span> startPos, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>=fruits.size();<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>);<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; idx(<span class="hljs-built_in">n</span>);<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">n</span>;++i)<br>        &#123;<br>            <span class="hljs-built_in">sum</span>[i+<span class="hljs-number">1</span>]=<span class="hljs-built_in">sum</span>[i]+fruits[i][<span class="hljs-number">1</span>];<br>            idx[i]=fruits[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>=k/<span class="hljs-number">2</span>;<br>        for(<span class="hljs-built_in">int</span> x=<span class="hljs-number">0</span>;x&lt;=<span class="hljs-built_in">t</span>;++x)<br>        &#123;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">offset</span>=k-<span class="hljs-number">2</span>*x;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=startPos-x;<br>            <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>=startPos+<span class="hljs-built_in">offset</span>;<br>            <span class="hljs-built_in">int</span> l=lower_bound(idx.begin(),idx.end(),<span class="hljs-built_in">left</span>)-idx.begin();<br>            <span class="hljs-built_in">int</span> r=upper_bound(idx.begin(),idx.end(),<span class="hljs-built_in">right</span>)-idx.begin();<br>            res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">sum</span>[r]-<span class="hljs-built_in">sum</span>[l]);<br>            <span class="hljs-built_in">right</span>=startPos+x;<br>            <span class="hljs-built_in">left</span>=startPos-<span class="hljs-built_in">offset</span>;<br>            l=lower_bound(idx.begin(),idx.end(),<span class="hljs-built_in">left</span>)-idx.begin();<br>            r=upper_bound(idx.begin(),idx.end(),<span class="hljs-built_in">right</span>)-idx.begin();<br>            res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">sum</span>[r]-<span class="hljs-built_in">sum</span>[l]);<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>检查替换后的词是否有效</title>
    <link href="/2023/05/03/%E6%A3%80%E6%9F%A5%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E8%AF%8D%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88/"/>
    <url>/2023/05/03/%E6%A3%80%E6%9F%A5%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E8%AF%8D%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%A3%80%E6%9F%A5%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E8%AF%8D%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88">检查替换后的词是否有效</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="检查替换后的词是否有效"><a class="markdownIt-Anchor" href="#检查替换后的词是否有效"></a> 检查替换后的词是否有效</h2><p><a href="https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个字符串 s ，请你判断它是否 有效 。<br />字符串 s 有效 需要满足：假设开始有一个空字符串 t = “” ，你可以执行 任意次 下述操作将 t 转换为 s ：</p><p>将字符串 “abc” 插入到 t 中的任意位置。形式上，t 变为 tleft + “abc” + tright，其中 t == tleft + tright 。注意，tleft 和 tright 可能为 空 。<br />如果字符串 s 有效，则返回 true；否则，返回 false。</p><p>e.g.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 输入：s">输出：true<br>解释：<br>&quot;&quot; -&gt; &quot;abc&quot; -&gt; &quot;aabcbc&quot;<br>因此，&quot;aabcbc&quot; 有效。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>创建一个栈,然后遍历字符串s，如果遇到a，就加入栈，遇到b，检查一下栈顶是否为a，是的话把b入栈，否则返回false，遇到c，依次检查栈顶是否是ba，是则弹出栈顶两个元素，否则返回false。最后如果栈非空，返回false。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">bool</span> isValid(<span class="hljs-keyword">string</span> s) &#123;<br>        stack&lt;<span class="hljs-keyword">char</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:s)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;a&#x27;</span>)<br>                st.push(c);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;b&#x27;</span>&amp;&amp;!st.<span class="hljs-keyword">empty</span>()&amp;&amp;st.top()==<span class="hljs-string">&#x27;a&#x27;</span>)<br>                st.push(c);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;c&#x27;</span>&amp;&amp;!st.<span class="hljs-keyword">empty</span>()&amp;&amp;st.top()==<span class="hljs-string">&#x27;b&#x27;</span>)<br>            &#123;<br>                st.pop();<br>                <span class="hljs-keyword">if</span>(!st.<span class="hljs-keyword">empty</span>()&amp;&amp;st.top()==<span class="hljs-string">&#x27;a&#x27;</span>)<br>                    st.pop();<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!st.<span class="hljs-keyword">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最长等差数列</title>
    <link href="/2023/04/22/%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/"/>
    <url>/2023/04/22/%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97">最长等差数列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最长等差数列"><a class="markdownIt-Anchor" href="#最长等差数列"></a> 最长等差数列</h2><p><a href="https://leetcode.cn/problems/longest-arithmetic-subsequence/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。</p><p>回想一下，nums 的子序列是一个列表 nums[i1], nums[i2], …, nums[ik] ，且 0 &lt;= i1 &lt; i2 &lt; … &lt; ik &lt;= nums.length - 1。并且如果 seq[i+1] - seq[i]( 0 &lt;= i &lt; seq.length - 1) 的值都相同，那么序列 seq 是等差的。</p><p>e.g.</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">3,6,9,12</span>]<br>输出：<span class="hljs-number">4</span><br>解释： <br>整个数组是公差为 <span class="hljs-number">3</span> 的等差数列。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题其实是<a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">最长递增子序列</a>的升级版，只不过加了公差的限制，用<code>dp[i][d]</code>表示i位置处公差为d的最长子序列长度，然后遍历<code>j(j&lt;i)</code>位置，当<code>dp[j][d]+1&gt;dp[i][d]</code>时更新<code>dp[i][d]</code>，返回整个过程最大长度即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestArithSeqLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1001</span>,<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j)<br>            &#123;<br>                <span class="hljs-type">int</span> d=nums[i]-nums[j]+<span class="hljs-number">500</span>;<br>                dp[i][d]=<span class="hljs-built_in">max</span>(dp[i][d],dp[j][d]+<span class="hljs-number">1</span>);<br>                ans=<span class="hljs-built_in">max</span>(ans,dp[i][d]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使数组严格递增</title>
    <link href="/2023/04/20/%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/"/>
    <url>/2023/04/20/%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E">使数组严格递增</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="使数组严格递增"><a class="markdownIt-Anchor" href="#使数组严格递增"></a> 使数组严格递增</h2><p><a href="https://leetcode.cn/problems/make-array-strictly-increasing/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你两个整数数组 arr1 和 arr2，返回使 arr1 严格递增所需要的最小「操作」数（可能为 0）。</p><p>每一步「操作」中，你可以分别从 arr1 和 arr2 中各选出一个索引，分别为 i 和 j，0 &lt;= i &lt; arr1.length 和 0 &lt;= j &lt; arr2.length，然后进行赋值运算 arr1[i] = arr2[j]。</p><p>如果无法让 arr1 严格递增，请返回 -1。</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr1 = <span class="hljs-comment">[1,5,3,6,7]</span>, arr2 = <span class="hljs-comment">[4,3,1]</span><br>输出：2<br>解释：用 3 来替换 5，然后用 4 来替换 3，得到 arr1 = <span class="hljs-comment">[1, 3, 4, 6, 7]</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用<code>dfs（i,r）</code>表示<code>0~i</code>区间严格递增，且<code>a[i]&lt;r</code>的最小操作次数，对于<code>i</code>位置的数，记它右边的数是<code>r</code>，那么<code>i</code>位置分替换和不替换两种情况</p><ul><li>不替换：<code>a[i]&lt;r</code>，<code>dfs(i,r)=dfs(i-1,a[i])</code></li><li>替换：<code>a[i]&gt;=r</code>，通过二分查找在b中找到小于r的最大数<code>b[k]</code>，然后替换，dfs(i,pre)=dfs(i-1,b[k])+1;</li></ul><p>为了减少时间，还可以用一个哈系表记录每个位置的值，如果i已经访问过则直接返回结果即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">makeArrayIncreasing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n=a.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m[n];<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; dfs=[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> r)-&gt;<span class="hljs-type">int</span>&#123;<br>            <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">auto</span> it=m[i].<span class="hljs-built_in">find</span>(r);<br>            <span class="hljs-comment">// 计算过直接用之前的结果</span><br>            <span class="hljs-keyword">if</span>(it!=m[i].<span class="hljs-built_in">end</span>())<br>                <span class="hljs-keyword">return</span> it-&gt;second;<br>            <span class="hljs-type">int</span> res=a[i]&lt;r ? <span class="hljs-built_in">dfs</span>(i<span class="hljs-number">-1</span>,a[i]):INT_MAX/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 二分查找b中第一个大于等于r的位置</span><br>            <span class="hljs-keyword">auto</span> k=<span class="hljs-built_in">lower_bound</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>(),r);<br>            <span class="hljs-keyword">if</span>(k!=b.<span class="hljs-built_in">begin</span>())<br>                res=<span class="hljs-built_in">min</span>(res,<span class="hljs-built_in">dfs</span>(i<span class="hljs-number">-1</span>,*(--k))+<span class="hljs-number">1</span>);<br>            m[i][r]=res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-built_in">dfs</span>(n<span class="hljs-number">-1</span>,INT_MAX);<br>        <span class="hljs-keyword">return</span> ans&gt;n ? <span class="hljs-number">-1</span>:ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票的最佳时机</title>
    <link href="/2023/04/14/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <url>/2023/04/14/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">买卖股票的最佳时机</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#买卖股票的最佳时机"></a> 买卖股票的最佳时机</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>e.g.</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：k = 2, prices = [3,2,6,5,0,3]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天 (股票价格 = 2) 的时候买入，在第<span class="hljs-number"> 3 </span>天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 =<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 5 </span>天 (股票价格 = 0) 的时候买入，在第<span class="hljs-number"> 6 </span>天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>动态规划,用<code>buy[i][j]</code>表示第<code>i</code>天时发生<code>j</code>笔交易时的最大利润，且此时持有股票，同理<code>sell[i][j]</code>表示此时不持有股票，然后分类讨论。</p><p>对于<code>buy[i][j]</code>:</p><ul><li>若前一天本就持有股票，那么等于<code>buy[i-1][j]</code></li><li>若前一天不持有股票，那今天需买入股票，那么等于<code>sell[i-1][j]-prices[i]</code></li></ul><p>对于<code>sell[i][j]</code>:</p><ul><li>若前一天不持有股票，那么等于<code>sell[i-1][j]</code></li><li>若前一天持有股票，那今天需卖出股票，那么等于<code>buy[i-1][j-1]+prices[i]</code></li></ul><p>最后的答案应该是卖出所有股票后的最大值，所以返回sell[n-1]的最大值</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;<br>        int n=prices.size();<br>        k=min(k,n/2);<br>        if(n==0)<br>            return 0;<br>        vector&lt;vector&lt;int&gt;&gt; buy(n,vector&lt;int&gt;(k+1));<br>        vector&lt;vector&lt;int&gt;&gt; sell(n,vector&lt;int&gt;(k+1));<br>        buy<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>=-prices<span class="hljs-comment">[0]</span>;<br>        sell<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>=0;<br>        for(int i=1;i&lt;=k;++i)<br>            buy<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span>=sell<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span>=-1e6;<br>        for(int i=1;i&lt;n;++i)<br>        &#123;<br>            buy<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>=max(buy<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>,sell<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>-prices<span class="hljs-comment">[i]</span>);<br>            for(int j=1;j&lt;=k;++j)<br>            &#123;<br>                buy<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(buy<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>,sell<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>-prices<span class="hljs-comment">[i]</span>);<br>                sell<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(sell<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>,buy<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>+prices<span class="hljs-comment">[i]</span>);<br>            &#125;<br>        &#125;<br>        return *max_element(sell<span class="hljs-comment">[n-1]</span>.begin(),sell<span class="hljs-comment">[n-1]</span>.end());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>段式回文</title>
    <link href="/2023/04/12/%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87/"/>
    <url>/2023/04/12/%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87">段式回文</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="段式回文"><a class="markdownIt-Anchor" href="#段式回文"></a> 段式回文</h2><p><a href="https://leetcode.cn/problems/longest-chunked-palindrome-decomposition/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你会得到一个字符串 text 。你应该把它分成 k 个子字符串 (subtext1, subtext2，…， subtextk) ，要求满足:</p><ul><li>subtexti 是 非空 字符串</li><li>所有子字符串的连接等于 text ( 即subtext1 + subtext2 + … + subtextk == text )</li><li>对于所有 i 的有效值( 即 1 &lt;= i &lt;= k ) ，subtexti == subtextk - i + 1 均成立<br />返回k可能最大值。</li></ul><p>e.g.</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：text <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ghiabcdefhelloadamhelloabcdefghi&quot;</span><br>输出：<span class="hljs-number">7</span><br>解释：我们可以把字符串拆分成 <span class="hljs-string">&quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>枚举子串的长度<code>i</code>，分别截取前后长度为<code>i</code>的子串，如果相等，答案加2，否则继续枚举，当<code>i&gt;text.length/2</code>时，说明已经不可再分，答案加1</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestDecomposition</span><span class="hljs-params">(string text)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!text.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,n=text.<span class="hljs-built_in">length</span>();<br>            <span class="hljs-keyword">while</span>(i&lt;=n/<span class="hljs-number">2</span>&amp;&amp;text.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,i)!=text.<span class="hljs-built_in">substr</span>(n-i))<br>                ++i;<br>            <span class="hljs-keyword">if</span>(i&gt;n/<span class="hljs-number">2</span>)<br>            &#123;<br>                ++ans;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ans+=<span class="hljs-number">2</span>;<br>            text=text.<span class="hljs-built_in">substr</span>(i,n-i*<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>合并石头的最低成本</title>
    <link href="/2023/04/04/%E5%90%88%E5%B9%B6%E7%9F%B3%E5%A4%B4%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/"/>
    <url>/2023/04/04/%E5%90%88%E5%B9%B6%E7%9F%B3%E5%A4%B4%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%90%88%E5%B9%B6%E7%9F%B3%E5%A4%B4%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC">合并石头的最低成本</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="合并石头的最低成本"><a class="markdownIt-Anchor" href="#合并石头的最低成本"></a> 合并石头的最低成本</h2><p><a href="https://leetcode.cn/problems/minimum-cost-to-merge-stones/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。</p><p>每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。</p><p>找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。<br />e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：stones = <span class="hljs-comment">[3,2,4,1]</span>, K = 2<br>输出：20<br>解释：<br>从 <span class="hljs-comment">[3, 2, 4, 1]</span> 开始。<br>合并 <span class="hljs-comment">[3, 2]</span>，成本为 5，剩下 <span class="hljs-comment">[5, 4, 1]</span>。<br>合并 <span class="hljs-comment">[4, 1]</span>，成本为 5，剩下 <span class="hljs-comment">[5, 5]</span>。<br>合并 <span class="hljs-comment">[5, 5]</span>，成本为 10，剩下 <span class="hljs-comment">[10]</span>。<br>总成本 20，这是可能的最小值。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用<code>dfs(i,j,p)</code>表示把第i堆到第j堆合并成p堆需要的最小成本，然后将原问题划分成子问题。比如有7堆石子，k=3，实际上要求的就是<code>dfs(0,6,1)</code>，而它又可以划分为<code>dfs(0,6,3)+0到6所有堆之和</code>，对于<code>dfs(0,6,3)</code>，按第一堆的合并方式也分为几种情况，比如<code>dfs(0,0,1)+dfs(1,6,2)</code>，<code>dfs(0,2,1)+dfs(3,6,2)</code>，<code>dfs(0,4,1)+dfs(5,6,2)</code>，取这些情况中最小的即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    <span class="hljs-built_in">int</span> mergeStones(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; stones, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>=stones.size();<br>        <span class="hljs-built_in">if</span>((<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>)%(k-<span class="hljs-number">1</span>))<br>            return -<span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>);<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">n</span>;++i)<br>            <span class="hljs-built_in">sum</span>[i+<span class="hljs-number">1</span>]=<span class="hljs-built_in">sum</span>[i]+stones[i];<br>        <span class="hljs-built_in">int</span> m[<span class="hljs-built_in">n</span>][<span class="hljs-built_in">n</span>][k+<span class="hljs-number">1</span>];<br>        memset(m,-<span class="hljs-number">1</span>,sizeof(m));<br>        function&lt;<span class="hljs-built_in">int</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>)&gt; dfs=[&amp;](<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> j,<span class="hljs-built_in">int</span> p)-&gt;<span class="hljs-built_in">int</span><br>        &#123;<br>            <span class="hljs-built_in">if</span>(m[i][j][p]!=-<span class="hljs-number">1</span>)<br>                return m[i][j][p];<br>            <span class="hljs-built_in">if</span>(p==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">if</span>(i==j)<br>                    return <span class="hljs-number">0</span>;<br>                else<br>                    return dfs(i,j,k)+<span class="hljs-built_in">sum</span>[j+<span class="hljs-number">1</span>]-<span class="hljs-built_in">sum</span>[i];<br>            &#125;<br>            <span class="hljs-built_in">int</span> res=INT_MAX;<br>            for(<span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>=i;<span class="hljs-built_in">t</span>&lt;j;<span class="hljs-built_in">t</span>+=k-<span class="hljs-number">1</span>)<br>            &#123;<br>                res=<span class="hljs-built_in">min</span>(res,dfs(i,<span class="hljs-built_in">t</span>,<span class="hljs-number">1</span>)+dfs(<span class="hljs-built_in">t</span>+<span class="hljs-number">1</span>,j,p-<span class="hljs-number">1</span>));<br>            &#125;<br>            m[i][j][p]=res;<br>            return res;<br>        &#125;;<br>        return dfs(<span class="hljs-number">0</span>,<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>交换一次的先前排列</title>
    <link href="/2023/04/03/%E4%BA%A4%E6%8D%A2%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%88%E5%89%8D%E6%8E%92%E5%88%97/"/>
    <url>/2023/04/03/%E4%BA%A4%E6%8D%A2%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%88%E5%89%8D%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BA%A4%E6%8D%A2%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%88%E5%89%8D%E6%8E%92%E5%88%97">交换一次的先前排列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="交换一次的先前排列"><a class="markdownIt-Anchor" href="#交换一次的先前排列"></a> 交换一次的先前排列</h2><p><a href="https://leetcode.cn/problems/previous-permutation-with-one-swap/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个正整数数组 arr（可能存在重复的元素），请你返回可在 一次交换（交换两数字 arr[i] 和 arr[j] 的位置）后得到的、按字典序排列小于 arr 的最大排列。</p><p>如果无法这么操作，就请返回原数组。</p><p>e.g.</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[1,9,4,6,7]</span><br>输出：<span class="hljs-string">[1,7,4,6,9]</span><br>解释：交换 <span class="hljs-number">9</span> 和 <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>先从后往前，找到第一个降序排列的数<code>a[i]</code>，并可知他后面的数都是非递减排列的，再次从后往前遍历，找到第一个小于<code>a[i]</code>且下标尽可能小的数(重复数字取下标更小的)与<code>a[i]</code>交换即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prevPermOpt1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>,j=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(arr[i]&gt;arr[i+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-keyword">while</span>(arr[j]&gt;=arr[i]||arr[j]==arr[j<span class="hljs-number">-1</span>])<br>                    --j;<br>                <span class="hljs-built_in">swap</span>(arr[i],arr[j]);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多边形三角剖分的最低得分</title>
    <link href="/2023/04/02/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/"/>
    <url>/2023/04/02/%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86">多边形三角剖分的最低得分</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="多边形三角剖分的最低得分"><a class="markdownIt-Anchor" href="#多边形三角剖分的最低得分"></a> 多边形三角剖分的最低得分</h2><p><a href="https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你有一个凸的 n 边形，其每个顶点都有一个整数值。给定一个整数数组 values ，其中 values[i] 是第 i 个顶点的值（即 顺时针顺序 ）。</p><p>假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和。</p><p>返回 多边形进行三角剖分后可以得到的最低分 。<br />e.g.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：values = [3,7,4,5]<br>输出：144<br>解释：有两种三角剖分，可能得分分别为：3<span class="hljs-number">*7</span><span class="hljs-number">*5</span> + 4<span class="hljs-number">*5</span><span class="hljs-number">*7</span> = 245，或 3<span class="hljs-number">*4</span><span class="hljs-number">*5</span> + 3<span class="hljs-number">*4</span><span class="hljs-number">*7</span> = 144。最低分数为 144。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>对于顶点<code>i~j</code>，可以选取中间的顶点<code>k(i&lt;k&lt;j)</code>,这3个点会将多边形分为3部分，其中i,j,k组成的是三角形，其余两部分形状不确定，因此可以用递归的方式对其余两部分再进行划分，这样就可以得出顶点<code>i~j</code>之间剖分成三角形的最低分数，在递归的过程中，可以用记忆化搜索来跳过已经计算过的区间。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minScoreTriangulation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; values)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=values.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">m</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; dfs=[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)-&gt;<span class="hljs-type">int</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(m[i][j]||i+<span class="hljs-number">1</span>==j)<br>                <span class="hljs-keyword">return</span> m[i][j];<br>            <span class="hljs-type">int</span> res=INT_MAX;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i+<span class="hljs-number">1</span>;k&lt;j;++k)<br>                res=<span class="hljs-built_in">min</span>(res,<span class="hljs-built_in">dfs</span>(i,k)+<span class="hljs-built_in">dfs</span>(k,j)+values[i]*values[k]*values[j]);<br>            m[i][j]=res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>统计字典序元音字符串的数目</title>
    <link href="/2023/03/29/%E7%BB%9F%E8%AE%A1%E5%AD%97%E5%85%B8%E5%BA%8F%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <url>/2023/03/29/%E7%BB%9F%E8%AE%A1%E5%AD%97%E5%85%B8%E5%BA%8F%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BB%9F%E8%AE%A1%E5%AD%97%E5%85%B8%E5%BA%8F%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE">统计字典序元音字符串的数目</a></li><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul><!-- /TOC --><h2 id="统计字典序元音字符串的数目"><a class="markdownIt-Anchor" href="#统计字典序元音字符串的数目"></a> 统计字典序元音字符串的数目</h2><p><a href="https://leetcode.cn/problems/count-sorted-vowel-strings/description/">原题</a></p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。</p><p>字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。</p><p>e.g.</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">15</span><br>解释：仅由元音组成的 <span class="hljs-number">15</span> 个字典序字符串为<br>[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;ai&quot;</span>,<span class="hljs-string">&quot;ao&quot;</span>,<span class="hljs-string">&quot;au&quot;</span>,<span class="hljs-string">&quot;ee&quot;</span>,<span class="hljs-string">&quot;ei&quot;</span>,<span class="hljs-string">&quot;eo&quot;</span>,<span class="hljs-string">&quot;eu&quot;</span>,<span class="hljs-string">&quot;ii&quot;</span>,<span class="hljs-string">&quot;io&quot;</span>,<span class="hljs-string">&quot;iu&quot;</span>,<span class="hljs-string">&quot;oo&quot;</span>,<span class="hljs-string">&quot;ou&quot;</span>,<span class="hljs-string">&quot;uu&quot;</span>]<br>注意，<span class="hljs-string">&quot;ea&quot;</span> 不是符合题意的字符串，因为 <span class="hljs-string">&#x27;e&#x27;</span> 在字母表中的位置比 <span class="hljs-string">&#x27;a&#x27;</span> 靠后<br></code></pre></td></tr></table></figure><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>看到了一个很简洁的思路，😢，主要需要考虑分别以5个字母结尾的个数，对于长度为n的字符串，如果要满足按字典序排列，以a结尾的个数只有1个，而以e结尾的个数等于前一位以a结尾的数目加上以e结尾的数目，即<code>e=a+e</code>，以此类推。。。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    int countVowelStrings(int n) &#123;<br>        int <span class="hljs-attribute">a</span>=1,e=1,i=1,o=1,u=1;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">k</span>=1;k&lt;n;++k)<br>        &#123;<br>            <span class="hljs-attribute">e</span>=a+e;<br>            <span class="hljs-attribute">i</span>=e+i;<br>            <span class="hljs-attribute">o</span>=i+o;<br>            <span class="hljs-attribute">u</span>=o+u;<br>        &#125;<br>        return a+e+i+o+u;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最短公共超序列</title>
    <link href="/2023/03/28/%E6%9C%80%E7%9F%AD%E5%85%AC%E5%85%B1%E8%B6%85%E5%BA%8F%E5%88%97/"/>
    <url>/2023/03/28/%E6%9C%80%E7%9F%AD%E5%85%AC%E5%85%B1%E8%B6%85%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E7%9F%AD%E5%85%AC%E5%85%B1%E8%B6%85%E5%BA%8F%E5%88%97">最短公共超序列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最短公共超序列"><a class="markdownIt-Anchor" href="#最短公共超序列"></a> 最短公共超序列</h2><p><a href="https://leetcode.cn/problems/shortest-common-supersequence/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给出两个字符串 str1 和 str2，返回同时以 str1 和 str2 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。</p><p>（如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 任意位置），可以得到字符串 S，那么 S 就是 T 的子序列）</p><p>e.g.</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">输入：str1 = <span class="hljs-string">&quot;abac&quot;</span>, str2 = <span class="hljs-string">&quot;cab&quot;</span><br>输出：<span class="hljs-string">&quot;cabac&quot;</span><br>解释：<br>str1 = <span class="hljs-string">&quot;abac&quot;</span> 是 <span class="hljs-string">&quot;cabac&quot;</span> 的一个子串，因为我们可以删去 <span class="hljs-string">&quot;cabac&quot;</span> 的第一个 <span class="hljs-string">&quot;c&quot;</span>得到 <span class="hljs-string">&quot;abac&quot;</span>。 <br>str2 = <span class="hljs-string">&quot;cab&quot;</span> 是 <span class="hljs-string">&quot;cabac&quot;</span> 的一个子串，因为我们可以删去 <span class="hljs-string">&quot;cabac&quot;</span> 末尾的 <span class="hljs-string">&quot;ac&quot;</span> 得到 <span class="hljs-string">&quot;cab&quot;</span>。<br>最终我们给出的答案是满足上述属性的最短字符串<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>如果想要构成的超序列最短，那么公共的子串部分就要尽可能长，因此先求两个字符串最长公共子串的dp数组。得到之后需要构造最短公共超序列，若要满足最短条件，那么公共部分就要尽可能长，因此从右至左选择字符时，当<code>str[i]==str[j]</code>，同时<code>--i;--j</code>，如果不相等，则优先选择不会损失dp数组的字符，例如如果<code>dp[i-1][j]&gt;dp[i][j-1]</code>，说明选择str1[i]不会损失dp数组，也就是不会影响当当前位置的最长公共子串，因此选择str1[i]。当有一个字符串先到达左端点时退出循环，然后构造剩余部分即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    string shortestCommonSupersequence(string str1, string str2) &#123;<br>        int m=str1.size(),n=str2.size();<br>        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1));<br>        for(int i=1;i&lt;=m;++i)<br>        &#123;<br>            for(int j=1;j&lt;=n;++j)<br>            &#123;<br>                if(str1<span class="hljs-comment">[i-1]</span>==str2<span class="hljs-comment">[j-1]</span>)<br>                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>+1;<br>                else<br>                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>);<br>            &#125;<br>        &#125;<br>        string res;<br>        int i=m,j=n;<br>        while(i&gt;0&amp;&amp;j&gt;0)<br>        &#123;<br>            if(str1<span class="hljs-comment">[i-1]</span>==str2<span class="hljs-comment">[j-1]</span>)<br>            &#123;<br>                res+=str1<span class="hljs-comment">[i-1]</span>;<br>                --i;<br>                --j;<br>            &#125;<br>            else if(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>&gt;dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>)<br>            &#123;<br>                res+=str1<span class="hljs-comment">[i-1]</span>;<br>                --i;<br>            &#125;<br>            else<br>            &#123;<br>                res+=str2<span class="hljs-comment">[j-1]</span>;<br>                --j;<br>            &#125;<br>        &#125;<br>        while(i&gt;0)<br>        &#123;<br>            res+=str1<span class="hljs-comment">[i-1]</span>;<br>            --i;<br>        &#125;<br>        while(j&gt;0)<br>        &#123;<br>            res+=str2<span class="hljs-comment">[j-1]</span>;<br>            --j;<br>        &#125;<br>        reverse(res.begin(),res.end());<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>无矛盾的最佳球队</title>
    <link href="/2023/03/22/%E6%97%A0%E7%9F%9B%E7%9B%BE%E7%9A%84%E6%9C%80%E4%BD%B3%E7%90%83%E9%98%9F/"/>
    <url>/2023/03/22/%E6%97%A0%E7%9F%9B%E7%9B%BE%E7%9A%84%E6%9C%80%E4%BD%B3%E7%90%83%E9%98%9F/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%97%A0%E7%9F%9B%E7%9B%BE%E7%9A%84%E6%9C%80%E4%BD%B3%E7%90%83%E9%98%9F">无矛盾的最佳球队</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="无矛盾的最佳球队"><a class="markdownIt-Anchor" href="#无矛盾的最佳球队"></a> 无矛盾的最佳球队</h2><p><a href="https://leetcode.cn/problems/best-team-with-no-conflicts/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 总和 。</p><p>然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 没有矛盾 的球队。如果一名年龄较小球员的分数 严格大于 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。</p><p>给你两个列表 scores 和 ages，其中每组 scores[i] 和 ages[i] 表示第 i 名球员的分数和年龄。请你返回 所有可能的无矛盾球队中得分最高那支的分数 。</p><p>e.g.</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：scores = <span class="hljs-string">[1,3,5,10,15]</span>, ages = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-number">34</span><br>解释：你可以选中所有球员。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>首先对所有人按照分数升序排序，<code>dp[i]</code>表示选择到第<code>i</code>名球员时的最大分数，对于球员<code>i</code>,需要找到<code>j</code>满足<code>j</code>的年龄小于<code>i</code>且<code>j&lt;i</code>，并且<code>dp[j]</code>是所有<code>i</code>之前且年龄小于<code>i</code>的球员的最大分数，因此<code>dp[i]=dp[j]+score[i]</code>，然后更新答案即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bestTeamScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; scores, vector&lt;<span class="hljs-type">int</span>&gt;&amp; ages)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=scores.<span class="hljs-built_in">size</span>();<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; v;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>            v.<span class="hljs-built_in">push_back</span>(&#123;scores[i],ages[i]&#125;);<br>        <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;--j)<br>                <span class="hljs-keyword">if</span>(v[j].second&lt;=v[i].second)<br>                dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[j]);<br>            <br>            dp[i]+=v[i].first;<br>            ans=<span class="hljs-built_in">max</span>(ans,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分割得到字符串</title>
    <link href="/2023/03/18/%E5%88%86%E5%89%B2%E5%BE%97%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/03/18/%E5%88%86%E5%89%B2%E5%BE%97%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%88%86%E5%89%B2%E5%BE%97%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2">分割得到字符串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="分割得到字符串"><a class="markdownIt-Anchor" href="#分割得到字符串"></a> 分割得到字符串</h2><p><a href="https://leetcode.cn/problems/split-two-strings-to-make-palindrome/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 相同的下标 分割开。由 a 可以得到两个字符串： aprefix 和 asuffix ，满足 a = aprefix + asuffix ，同理，由 b 可以得到两个字符串 bprefix 和 bsuffix ，满足 b = bprefix + bsuffix 。请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。</p><p>当你将一个字符串 s 分割成 sprefix 和 ssuffix 时， ssuffix 或者 sprefix 可以为空。比方说， s = “abc” 那么 “” + “abc” ， “a” + “bc” ， “ab” + “c” 和 “abc” + “” 都是合法分割。</p><p>如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。</p><p>注意， x + y 表示连接字符串 x 和 y 。</p><p>e.g.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：<span class="hljs-keyword">a</span> = <span class="hljs-string">&quot;abdef&quot;</span>, b = <span class="hljs-string">&quot;fecab&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>使用双指针的思想，分取a的前缀和取b前缀两种情况，但是处理方式相同。以取a前缀为例，首先分别从a左端和b右端开始比较，如果<code>a[l]==b[r]</code>,那么<code>++l,--r</code>，直到不相等或者<code>l&gt;=r</code>为止，如果<code>l&gt;=r</code>说明在中间位置分割可满足要求，直接返回<code>true</code>;如果是不相等的情况，则需要判断是以l还是r为分割点，并判断l~r之间的子串是否回文，如果满足要求即可返回<code>true</code>。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">checksub</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> a,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;a[l]==a[r])<br>        &#123;<br>            ++l;--r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l&gt;=r;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">check</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> a,<span class="hljs-built_in">string</span> b,<span class="hljs-built_in">int</span> n</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;a[l]==b[r])<br>        &#123;<br>            ++l;--r;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l&gt;=r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> checksub(a,l,r)||checksub(b,l,r);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">checkPalindromeFormation</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> a, <span class="hljs-built_in">string</span> b</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n=a.size();<br>        <span class="hljs-keyword">return</span> check(a,b,n)||check(b,a,n);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>统计中位数为K的子数组</title>
    <link href="/2023/03/16/%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2023/03/16/%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">统计中位数为 K 的子数组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="统计中位数为-k-的子数组"><a class="markdownIt-Anchor" href="#统计中位数为-k-的子数组"></a> 统计中位数为 K 的子数组</h2><p><a href="https://leetcode.cn/problems/count-subarrays-with-median-k/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 不同 整数组成。另给你一个正整数 k 。</p><p>统计并返回 nums 中的 中位数 等于 k 的非空子数组的数目。</p><p>注意：</p><p>数组的中位数是按 递增 顺序排列后位于 中间 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 左 的那个元素。<br />例如，[2,3,1,4] 的中位数是 2 ，[8,4,3,5,1] 的中位数是 4 。<br />子数组是数组中的一个连续部分。</p><p>e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1,4,5]</span>, k = 4<br>输出：3<br>解释：中位数等于 4 的子数组有：<span class="hljs-comment">[4]</span>、<span class="hljs-comment">[4,5]</span> 和 <span class="hljs-comment">[1,4,5]</span> 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>首先找出<code>k</code>在数组中的位置<code>idx</code>，对于每个数，大于<code>k</code>记为1,否则为-1，统计每个位置前缀和。如果下标<code>l</code>处与<code>r</code>处的前缀和之差为0或1,那么说明<code>[l+1,r]</code>范围内的子数组元素和为0或1,那么<code>k</code>就是该子数组的中位数。在统计相同前缀和个数时，用哈系表记录前缀和出现的次数，然后对符合要求的位置累加即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> judge(<span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a&gt;b)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a&lt;b)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">int</span> countSubarrays(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> n=nums.size();<br>        <span class="hljs-built_in">int</span> idx=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==k)<br>            &#123;<br>                idx=i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt; mp;<br>        mp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            sum+=judge(nums[i],k);<br>            <span class="hljs-keyword">if</span>(i&lt;idx)<br>                ++mp[sum];<br>            <span class="hljs-keyword">else</span><br>                ans+=mp[sum]+mp[sum<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>给定行和列的和求可行矩阵</title>
    <link href="/2023/03/14/%E7%BB%99%E5%AE%9A%E8%A1%8C%E5%92%8C%E5%88%97%E7%9A%84%E5%92%8C%E6%B1%82%E5%8F%AF%E8%A1%8C%E7%9F%A9%E9%98%B5/"/>
    <url>/2023/03/14/%E7%BB%99%E5%AE%9A%E8%A1%8C%E5%92%8C%E5%88%97%E7%9A%84%E5%92%8C%E6%B1%82%E5%8F%AF%E8%A1%8C%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BB%99%E5%AE%9A%E8%A1%8C%E5%92%8C%E5%88%97%E7%9A%84%E5%92%8C%E6%B1%82%E5%8F%AF%E8%A1%8C%E7%9F%A9%E9%98%B5">给定行和列的和求可行矩阵</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="给定行和列的和求可行矩阵"><a class="markdownIt-Anchor" href="#给定行和列的和求可行矩阵"></a> 给定行和列的和求可行矩阵</h2><p><a href="https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你两个非负整数数组 rowSum 和 colSum ，其中 rowSum[i] 是二维矩阵中第 i 行元素的和， colSum[j] 是第 j 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。</p><p>请找到大小为 rowSum.length x colSum.length 的任意 非负整数 矩阵，且该矩阵满足 rowSum 和 colSum 的要求。</p><p>请你返回任意一个满足题目要求的二维矩阵，题目保证存在 至少一个 可行矩阵。<br />e.g.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：rowSum = <span class="hljs-comment">[3,8]</span>, colSum = <span class="hljs-comment">[4,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3,0]</span>,</span><br><span class="hljs-comment">      <span class="hljs-comment">[1,7]</span>]</span><br>解释：<br>第 0 行：3 + 0 = 3 == rowSum<span class="hljs-comment">[0]</span><br>第 1 行：1 + 7 = 8 == rowSum<span class="hljs-comment">[1]</span><br>第 0 列：3 + 1 = 4 == colSum<span class="hljs-comment">[0]</span><br>第 1 列：0 + 7 = 7 == colSum<span class="hljs-comment">[1]</span><br>行和列的和都满足题目要求，且所有矩阵元素都是非负的。<br>另一个可行的矩阵为：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">                  <span class="hljs-comment">[3,5]</span>]</span><br><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>矩阵每行和每列的最大值已知，那么每次填的时候选择<code>min(rowsum[i],colsum[j])</code>，这样被选择的某行/列后续的值都为0,每填一个位置后，还要更新rowsum或者colsum，这样一共需填<code>m+n-1个值</code>，其余位置都为0。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">restoreMatrix</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; rowSum, vector&lt;<span class="hljs-type">int</span>&gt;&amp; colSum) &#123;<br>        <span class="hljs-type">int</span> m=rowSum.<span class="hljs-built_in">size</span>(),n=colSum.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;m&amp;&amp;j&lt;n)<br>        &#123;<br>            <span class="hljs-type">int</span> r=rowSum[i],c=colSum[j];<br>            <span class="hljs-keyword">if</span>(r&lt;=c)<br>            &#123;<br>                colSum[j]-=r;<br>                ans[i++][j]=r;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                rowSum[i]-=c;<br>                ans[i][j++]=c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字母与数字</title>
    <link href="/2023/03/11/%E5%AD%97%E6%AF%8D%E4%B8%8E%E6%95%B0%E5%AD%97/"/>
    <url>/2023/03/11/%E5%AD%97%E6%AF%8D%E4%B8%8E%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%AD%97%E6%AF%8D%E4%B8%8E%E6%95%B0%E5%AD%97">字母与数字</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="字母与数字"><a class="markdownIt-Anchor" href="#字母与数字"></a> 字母与数字</h2><p><a href="https://leetcode.cn/problems/find-longest-subarray-lcci/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。</p><p>返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。</p><p>e.g.</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less">输入: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>,<span class="hljs-string">&quot;M&quot;</span>]</span><br><br>输出: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用到前缀和的思想，当元素为字母时加1，为数字时减1，当<code>i</code>和<code>j</code>位置处的前缀和相等，说明他们之间的子数组满足要求。用哈系表保存每一个前缀和的值第一次出现时对应的数组下标，并遍历数组，如果前缀和的值已经出现过，那么记录子数组的起始位置，更新最大长度，否则在哈系表中记录该下标。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">vector</span>&lt;string&gt; findLongestSubarray(<span class="hljs-type">vector</span>&lt;string&gt;&amp; <span class="hljs-type">array</span>) &#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        mp[<span class="hljs-number">0</span>]=-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span>,maxlen=<span class="hljs-number">0</span>,start=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n=<span class="hljs-type">array</span>.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(isalpha(<span class="hljs-type">array</span>[i][<span class="hljs-number">0</span>]))<br>                ++<span class="hljs-built_in">sum</span>;<br>            <span class="hljs-keyword">else</span><br>                --<span class="hljs-built_in">sum</span>;<br>            <span class="hljs-keyword">if</span>(mp.count(<span class="hljs-built_in">sum</span>))<br>            &#123;<br>                <span class="hljs-type">int</span> preidx=mp[<span class="hljs-built_in">sum</span>];<br>                <span class="hljs-keyword">if</span>(i-preidx&gt;maxlen)<br>                &#123;<br>                    maxlen=i-preidx;<br>                    start=preidx+<span class="hljs-number">1</span>;<br>                &#125;    <br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                mp[<span class="hljs-built_in">sum</span>]=i;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(maxlen==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-type">vector</span>&lt;string&gt;(<span class="hljs-type">array</span>.begin()+start,<span class="hljs-type">array</span>.begin()+start+maxlen);<br>    &#125;   <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使数组和能被P整除</title>
    <link href="/2023/03/10/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%ABP%E6%95%B4%E9%99%A4/"/>
    <url>/2023/03/10/%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%ABP%E6%95%B4%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%AB-p-%E6%95%B4%E9%99%A4">使数组和能被 P 整除</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="使数组和能被-p-整除"><a class="markdownIt-Anchor" href="#使数组和能被-p-整除"></a> 使数组和能被 P 整除</h2><p><a href="https://leetcode.cn/problems/make-sum-divisible-by-p/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。</p><p>请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。</p><p>子数组 定义为原数组中连续的一组元素。</p><p>e.g.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[3,1,4,2]</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">6</span><br>输出：<span class="hljs-number">1</span><br>解释：nums 中元素和为 <span class="hljs-number">10</span>，不能被 <span class="hljs-selector-tag">p</span> 整除。我们可以移除子数组 <span class="hljs-selector-attr">[4]</span> ，剩余元素的和为 <span class="hljs-number">6</span> <br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>设整个数组的和对p取模的值为<code>x</code>，前缀和(经过取模处理)数组为<code>sum</code>，若要满足去掉<code>nums[i]~nums[j]</code>之间的数后，剩下的数之和能被p整除，则满足<code>(sum[j]-x+p)%p==sum[i]</code>,为了计算最短长度，还需要用哈系表记录当前位置<code>sum[j]</code>的下标j，在代码实现时，<code>sum</code>数组可以通过维护一个整型值代替。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> minSubarray(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> p) &#123;<br>        <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a:nums)<br>            x=(x+a)%p;<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; idx;<br>        <span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>,res=nums.<span class="hljs-keyword">size</span>(),n=nums.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            idx[y]=i;<br>            y=(y+nums[i])%p;<br>            <span class="hljs-keyword">if</span>(idx.count((y-x+p)%p)&gt;<span class="hljs-number">0</span>)<br>                res=<span class="hljs-keyword">min</span>(res,i-idx[(y-x+p)%p]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res==n?<span class="hljs-number">-1</span>:res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>花括号展开</title>
    <link href="/2023/03/07/%E8%8A%B1%E6%8B%AC%E5%8F%B7%E5%B1%95%E5%BC%80/"/>
    <url>/2023/03/07/%E8%8A%B1%E6%8B%AC%E5%8F%B7%E5%B1%95%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<h2 id="花括号展开"><a class="markdownIt-Anchor" href="#花括号展开"></a> 花括号展开</h2><p><a href="https://leetcode.cn/problems/brace-expansion-ii/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。<br />花括号展开的表达式可以看作一个由 花括号、逗号 和 小写英文字母 组成的字符串，定义下面几条语法规则：<br />如果只给出单一的元素 x，那么表达式表示的字符串就只有 <code>&quot;x&quot;</code>。<code>R(x) = &#123;x&#125;</code><br />例如，表达式 <code>&quot;a&quot;</code> 表示字符串 <code>&quot;a&quot;</code>。<br />而表达式 <code>&quot;w&quot;</code> 就表示字符串 <code>&quot;w&quot;</code>。<br />当两个或多个表达式并列，以逗号分隔，我们取这些表达式中元素的并集。<code>R(&#123;e_1,e_2,...&#125;) = R(e_1) ∪ R(e_2) ∪ ...</code><br />例如，表达式 <code>&quot;&#123;a,b,c&#125;&quot;</code> 表示字符串 <code>&quot;a&quot;,``&quot;b&quot;</code>,<code>&quot;c&quot;</code>。<br />而表达式 <code>&quot;&#123;&#123;a,b&#125;,&#123;b,c&#125;&#125;&quot;</code> 也可以表示字符串 <code>&quot;a&quot;</code>,<code>&quot;b&quot;</code>,<code>&quot;c&quot;</code>。<br />要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。<code>R(e_1 + e_2) = &#123;a + b for (a, b) in R(e_1) × R(e_2)&#125;</code><br />例如，表达式 <code>&quot;&#123;a,b&#125;&#123;c,d&#125;&quot;</code> 表示字符串 <code>&quot;ac&quot;,&quot;ad&quot;,&quot;bc&quot;,&quot;bd&quot;</code>。<br />表达式之间允许嵌套，单一元素与表达式的连接也是允许的。<br />例如，表达式 <code>&quot;a&#123;b,c,d&#125;&quot;</code> 表示字符串 <code>&quot;ab&quot;,&quot;ac&quot;,&quot;ad&quot;​​​​​​</code>。<br />例如，表达式 <code>&quot;a&#123;b,c&#125;&#123;d,e&#125;f&#123;g,h&#125;&quot;</code> 可以表示字符串 <code>&quot;abdfg&quot;, &quot;abdfh&quot;, &quot;abefg&quot;, &quot;abefh&quot;, &quot;acdfg&quot;, &quot;acdfh&quot;, &quot;acefg&quot;, &quot;acefh&quot;</code>。<br />给出表示基于给定语法规则的表达式 expression，返回它所表示的所有字符串组成的有序列表。</p><p>e.g.</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">输入：<span class="hljs-keyword">expression</span> = <span class="hljs-string">&quot;&#123;a,b&#125;&#123;c,&#123;d,e&#125;&#125;&quot;</span><br>输出：[<span class="hljs-string">&quot;ac&quot;</span>,<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;bc&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题可以用类似中缀表达式求值的做法，把并列操作看作<code>+</code>，把组合操作看作<code>*</code>，需要建立两个栈，一个用来保存运算符，一个用来保存已有集合，然后分情况讨论：</p><ul><li>如果当前字符为<code>&#123;</code>，如果上一个字符为<code>&#125;</code>或者字母，则运算符栈先加入<code>*</code>再加入<code>&#123;</code></li><li>如果当前字符为<code>,</code>，如果运算符栈顶为<code>*</code>，那么不断弹出元素并计算，直到栈顶不是<code>*</code>，然后加入<code>+</code></li><li>如果为<code>&#125;</code>，则不断弹出元素并计算，直到遇到<code>&#123;</code>为止，并将左括号也弹出</li><li>如果为字母，如果上一个字符为<code>&#125;</code>或者字母，则运算符栈先加入<code>*</code>，再将字母单独构造成一个集合，加入集合栈</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">vector</span>&lt;char&gt; op;<br>    <span class="hljs-keyword">vector</span>&lt;set&lt;<span class="hljs-keyword">string</span>&gt;&gt; e;<br>    <span class="hljs-comment">//弹出栈顶两个元素并计算</span><br>    void compute()<br>    &#123;<br>        <span class="hljs-keyword">int</span> r=e.<span class="hljs-keyword">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> l=r<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(op.back()==<span class="hljs-string">&#x27;+&#x27;</span>)<br>            e[l].merge(e[r]);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            set&lt;<span class="hljs-keyword">string</span>&gt; tmp;<br>            <span class="hljs-keyword">for</span>(auto&amp; a:e[l])<br>            &#123;<br>                <span class="hljs-keyword">for</span>(auto&amp; b:e[r])<br>                    tmp.insert(a+b);<br>            &#125;<br>            e[l]=<span class="hljs-keyword">move</span>(tmp);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">string</span>&gt; braceExpansionII(<span class="hljs-keyword">string</span> <span class="hljs-keyword">expression</span>) &#123;<br>        <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <br>        <span class="hljs-keyword">int</span> n=<span class="hljs-keyword">expression</span>.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">expression</span>[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;(<span class="hljs-keyword">expression</span>[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;&#125;&#x27;</span>||isalpha(<span class="hljs-keyword">expression</span>[i<span class="hljs-number">-1</span>])))<br>                    op.push_back(<span class="hljs-string">&#x27;*&#x27;</span>);<br>                op.push_back(<span class="hljs-string">&#x27;&#123;&#x27;</span>);   <br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">expression</span>[i]==<span class="hljs-string">&#x27;,&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">while</span>(op.<span class="hljs-keyword">size</span>()&amp;&amp;op.back()==<span class="hljs-string">&#x27;*&#x27;</span>)<br>                &#123;<br>                    compute();<br>                    op.pop_back();<br>                    e.pop_back();<br>                &#125;<br>                op.push_back(<span class="hljs-string">&#x27;+&#x27;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">expression</span>[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">while</span>(op.<span class="hljs-keyword">size</span>()&amp;&amp;op.back()!=<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>                &#123;<br>                    compute();<br>                    op.pop_back();<br>                    e.pop_back();<br>                &#125;<br>                op.pop_back();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                set&lt;<span class="hljs-keyword">string</span>&gt; tmp;<br>                <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;(<span class="hljs-keyword">expression</span>[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;&#125;&#x27;</span>||isalpha(<span class="hljs-keyword">expression</span>[i<span class="hljs-number">-1</span>])))<br>                    op.push_back(<span class="hljs-string">&#x27;*&#x27;</span>);<br>                <span class="hljs-keyword">string</span> s;<br>                s+=<span class="hljs-keyword">expression</span>[i];<br>                tmp.insert(s);<br>                e.push_back(tmp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(op.<span class="hljs-keyword">size</span>())<br>        &#123;<br>            compute();<br>            op.pop_back();<br>            e.pop_back();<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;e.back().begin(),e.back().end()&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使字符串平衡的最少删除次数</title>
    <link href="/2023/03/06/%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0/"/>
    <url>/2023/03/06/%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0">使字符串平衡的最少删除次数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="使字符串平衡的最少删除次数"><a class="markdownIt-Anchor" href="#使字符串平衡的最少删除次数"></a> 使字符串平衡的最少删除次数</h2><p><a href="https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个字符串 s ，它仅包含字符 ‘a’ 和 'b’​​​​ 。</p><p>你可以删除 s 中任意数目的字符，使得 s 平衡 。当不存在下标对 (i,j) 满足 i &lt; j ，且 s[i] = ‘b’ 的同时 s[j]= ‘a’ ，此时认为 s 是 平衡 的。</p><p>请你返回使 s 平衡 的 最少 删除次数。</p><p>e.g.</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;aababbab&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：你可以选择以下任意一种方案：<br>下标从 <span class="hljs-number">0</span> 开始，删除第 <span class="hljs-number">2</span> 和第 <span class="hljs-number">6</span> 个字符（<span class="hljs-string">&quot;aababbab&quot;</span> -&gt; <span class="hljs-string">&quot;aaabbb&quot;</span>），<br>下标从 <span class="hljs-number">0</span> 开始，删除第 <span class="hljs-number">3</span> 和第 <span class="hljs-number">6</span> 个字符（<span class="hljs-string">&quot;aababbab&quot;</span> -&gt; <span class="hljs-string">&quot;aabbbb&quot;</span>）。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>参考了灵神的思路，tql😆<br />首先要遍历一遍记录字符<code>a</code>的个数cnt，然后遍历分割点，如果是<code>a</code>则cnt-1，否则cnt+1，这个过程中cnt最小值即为最小的删除次数，这个过程，其实相当于统计分割点左边<code>b</code>的个数和右边<code>a</code>的个数，也就是满足题意的最少删除次数。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">minimumDeletions</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">char</span> c:s)<br>            cnt+=<span class="hljs-string">&#x27;b&#x27;</span>-c;<br>        ans=cnt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">char</span> c:s)<br>        &#123;<br>            cnt+=(c-<span class="hljs-string">&#x27;a&#x27;</span>)*<span class="hljs-number">2</span><span class="hljs-number">-1</span>;<br>            ans=min(ans,cnt);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运营摩天轮</title>
    <link href="/2023/03/05/%E8%BF%90%E8%90%A5%E6%91%A9%E5%A4%A9%E8%BD%AE/"/>
    <url>/2023/03/05/%E8%BF%90%E8%90%A5%E6%91%A9%E5%A4%A9%E8%BD%AE/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%BF%90%E8%90%A5%E6%91%A9%E5%A4%A9%E8%BD%AE">运营摩天轮</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="运营摩天轮"><a class="markdownIt-Anchor" href="#运营摩天轮"></a> 运营摩天轮</h2><p><a href="https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 runningCost 。摩天轮每次轮转都恰好转动 1 / 4 周。</p><p>给你一个长度为 n 的数组 customers ， customers[i] 是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 boardingCost ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。</p><p>你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，将免费进行所有后续轮转 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。</p><p>返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。</p><p>e.g.</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：customers = [8,3], boardingCost = 5, runningCost = 6<br>输出：3<br>解释：座舱上标注的数字是该座舱的当前游客数。<br>1.<span class="hljs-number"> 8 </span>位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为<span class="hljs-number"> 4 </span>* $5 -<span class="hljs-number"> 1 </span>* $6 = $14 。<br>2.<span class="hljs-number"> 3 </span>位游客抵达，4 位在等待的游客登舱，其他<span class="hljs-number"> 3 </span>位等待，摩天轮轮转。当前利润为<span class="hljs-number"> 8 </span>* $5 -<span class="hljs-number"> 2 </span>* $6 = $28 。<br>3. 最后<span class="hljs-number"> 3 </span>位游客登舱，摩天轮轮转。当前利润为<span class="hljs-number"> 11 </span>* $5 -<span class="hljs-number"> 3 </span>* $6 = $37 。<br>轮转<span class="hljs-number"> 3 </span>次得到最大利润，最大利润为 $37 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>模拟摩天轮的运营过程，首先记录每次到来的人数<code>come</code>和排队人数<code>wait</code>，当二者之和大于4,统计收入，然后更新排队人数，当二者之和小于，统计收入，排队人数清零，每一轮过后减去运营成本，并更新最大利润即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> minOperationsMaxProfit(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; customers, <span class="hljs-built_in">int</span> boardingCost, <span class="hljs-built_in">int</span> runningCost) &#123;<br>        <span class="hljs-built_in">int</span> n=customers.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">int</span> ans=-<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> come=<span class="hljs-number">0</span>,<span class="hljs-keyword">wait</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span>,<span class="hljs-built_in">max</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;n||<span class="hljs-keyword">wait</span>&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;=n)<br>                come=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                come=customers[i];<br>            <br>            <span class="hljs-keyword">if</span>(come+<span class="hljs-keyword">wait</span>&gt;<span class="hljs-number">4</span>)<br>            &#123;<br>                <span class="hljs-built_in">sum</span>+=boardingCost*<span class="hljs-number">4</span>;<br>                <span class="hljs-keyword">wait</span>=come+<span class="hljs-keyword">wait</span>-<span class="hljs-number">4</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">sum</span>+=(come+<span class="hljs-keyword">wait</span>)*boardingCost;<br>                <span class="hljs-keyword">wait</span>=<span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-built_in">sum</span>-=runningCost;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span>&gt;<span class="hljs-built_in">max</span>)<br>            &#123;<br>                ans=i+<span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">max</span>=<span class="hljs-built_in">sum</span>;<br>            &#125;<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>按位与为0的三元组</title>
    <link href="/2023/03/04/%E6%8C%89%E4%BD%8D%E4%B8%8E%E4%B8%BA0%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84/"/>
    <url>/2023/03/04/%E6%8C%89%E4%BD%8D%E4%B8%8E%E4%B8%BA0%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8C%89%E4%BD%8D%E4%B8%8E%E4%B8%BA0%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84">按位与为0的三元组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="按位与为0的三元组"><a class="markdownIt-Anchor" href="#按位与为0的三元组"></a> 按位与为0的三元组</h2><p><a href="https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums ，返回其中 按位与三元组 的数目。</p><p>按位与三元组 是由下标 (i, j, k) 组成的三元组，并满足下述全部条件：</p><p>0 &lt;= i &lt; nums.length<br />0 &lt;= j &lt; nums.length<br />0 &lt;= k &lt; nums.length<br />nums[i] &amp; nums[j] &amp; nums[k] == 0 ，其中 &amp; 表示按位与运算符。</p><p>e.g.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：nums = [2,1,3]<br>输出：12<br>解释：可以选出如下 i, j, k 三元组：<br>(<span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">j</span>=0, <span class="hljs-attribute">k</span>=1) : 2 &amp; 2 &amp; 1<br>(<span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">j</span>=1, <span class="hljs-attribute">k</span>=0) : 2 &amp; 1 &amp; 2<br>(<span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">j</span>=1, <span class="hljs-attribute">k</span>=1) : 2 &amp; 1 &amp; 1<br>(<span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">j</span>=1, <span class="hljs-attribute">k</span>=2) : 2 &amp; 1 &amp; 3<br>(<span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">j</span>=2, <span class="hljs-attribute">k</span>=1) : 2 &amp; 3 &amp; 1<br>(<span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">j</span>=0, <span class="hljs-attribute">k</span>=0) : 1 &amp; 2 &amp; 2<br>(<span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">j</span>=0, <span class="hljs-attribute">k</span>=1) : 1 &amp; 2 &amp; 1<br>(<span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">j</span>=0, <span class="hljs-attribute">k</span>=2) : 1 &amp; 2 &amp; 3<br>(<span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">j</span>=1, <span class="hljs-attribute">k</span>=0) : 1 &amp; 1 &amp; 2<br>(<span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">j</span>=2, <span class="hljs-attribute">k</span>=0) : 1 &amp; 3 &amp; 2<br>(<span class="hljs-attribute">i</span>=2, <span class="hljs-attribute">j</span>=0, <span class="hljs-attribute">k</span>=1) : 3 &amp; 2 &amp; 1<br>(<span class="hljs-attribute">i</span>=2, <span class="hljs-attribute">j</span>=1, <span class="hljs-attribute">k</span>=0) : 3 &amp; 1 &amp; 2<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题直接枚举的话时间复杂度太高，会超时，因此可以用一个数组记录两个数字相与结果出现的频率，然后遍历第三个数与其相与，如果结果为<code>0</code>，则统计到结果中，具体代码如下。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countTriplets</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a:nums)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b:nums)<br>                ++v[a&amp;b];<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:nums)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(v[k]&amp;&amp;(x&amp;k)==<span class="hljs-number">0</span>)<br>                    ans+=v[k];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>得分最高单词集合</title>
    <link href="/2023/02/26/%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E5%8D%95%E8%AF%8D%E9%9B%86%E5%90%88/"/>
    <url>/2023/02/26/%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E5%8D%95%E8%AF%8D%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E5%8D%95%E8%AF%8D%E9%9B%86%E5%90%88">得分最高单词集合</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="得分最高单词集合"><a class="markdownIt-Anchor" href="#得分最高单词集合"></a> 得分最高单词集合</h2><p><a href="https://leetcode.cn/problems/maximum-score-words-formed-by-letters/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你将会得到一份单词表 words，一个字母表 letters （可能会有重复字母），以及每个字母对应的得分情况表 score。</p><p>请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 letters 里的字母拼写出的 任意 属于 words 单词子集中，分数最高的单词集合的得分。</p><p>单词拼写游戏的规则概述如下：</p><p>玩家需要用字母表 letters 里的字母来拼写单词表 words 中的单词。<br />可以只使用字母表 letters 中的部分字母，但是每个字母最多被使用一次。<br />单词表 words 中每个单词只能计分（使用）一次。<br />根据字母得分情况表score，字母 ‘a’, ‘b’, ‘c’, … , ‘z’ 对应的得分分别为 score[0], score[1], …, score[25]。<br />本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。</p><p>e.g.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：words = [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;dad&quot;</span>,<span class="hljs-string">&quot;good&quot;</span>], letters = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]<br>输出：23<br>解释：<br>字母得分为  <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">c</span>=9, <span class="hljs-attribute">d</span>=5, <span class="hljs-attribute">g</span>=3, <span class="hljs-attribute">o</span>=2<br>使用给定的字母表 letters，我们可以拼写单词 <span class="hljs-string">&quot;dad&quot;</span> (5+1+5)和 <span class="hljs-string">&quot;good&quot;</span> (3+2+2+5)，得分为 23 。<br>而单词 <span class="hljs-string">&quot;dad&quot;</span> 和 <span class="hljs-string">&quot;dog&quot;</span> 只能得到 21 分。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题主要用到状态压缩的思想，对于words中的每个单词，都可以用<code>0/1</code>来表示他是否被使用，比如’<code>110</code>可以表示使用了第二个和第三个单词，假设words中共有<code>n</code>个单词，那么一共有<code>1&lt;&lt;n</code>种状态，需要遍历所有状态。每次遍历时，以此遍历words中的单词，判断是否在当前状态里，如果在的话，统计各个字母出现的次数，每遍历完一个状态，计算一次得分，并更新最高分数即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxScoreWords</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, vector&lt;<span class="hljs-type">char</span>&gt;&amp; letters, vector&lt;<span class="hljs-type">int</span>&gt;&amp; score)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=words.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> &amp; c:letters)<br>            ++cnt[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">1</span>&lt;&lt;n;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;num;++i)<br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>&lt;&lt;j)&amp;i)<br>                &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span>&amp;c:words[j])<br>                        ++t[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">26</span>;++k)<br>            &#123;<br>                sum+=score[k]*t[k];<br>                <span class="hljs-keyword">if</span>(t[k]&gt;cnt[k])<br>                &#123;<br>                    flag=<span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>                ans=<span class="hljs-built_in">max</span>(ans,sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>交换字符使字符串相同</title>
    <link href="/2023/02/25/%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%90%8C/"/>
    <url>/2023/02/25/%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%90%8C">交换字符使字符串相同</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="交换字符使字符串相同"><a class="markdownIt-Anchor" href="#交换字符使字符串相同"></a> 交换字符使字符串相同</h2><p><a href="https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 “x” 和 “y”，你需要通过「交换字符」的方式使这两个字符串相同。</p><p>每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。</p><p>交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。</p><p>最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1</p><p>示例</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;xx&quot;</span>, <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;yy&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：<br>交换 <span class="hljs-built_in">s1</span>[<span class="hljs-number">0</span>] 和 <span class="hljs-built_in">s2</span>[<span class="hljs-number">1</span>]，得到 <span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;yx&quot;</span>，<span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;yx&quot;</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用xy表示<code>s1[i]=x,s2[i]=y</code>出现的次数，yx同理，这时有两种交换情况</p><ul><li><p>交换一次,使xy或者yx的值减少2,如<code>xx,yy-&gt;yx,yx</code></p></li><li><p>交换两次，使xy和yx各减少1,如<code>xy,yx-&gt;yy,xx-&gt;xy,xy</code></p></li></ul><p>为了尽可能减少交换次数，应当尽量使用第一种方式，同时如果<code>xy+yx</code>为奇数，那么怎么交换也不能相等，因为此时s1和s2两边有奇数个x或y，无法交换使得两个字符串的x和y数量相等。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">minimumSwap</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s1, <span class="hljs-built_in">string</span> s2</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> n=s1.size();<br>        <span class="hljs-built_in">int</span> xy=<span class="hljs-number">0</span>,yx=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s1[i]==<span class="hljs-string">&#x27;x&#x27;</span>&amp;&amp;s2[i]==<span class="hljs-string">&#x27;y&#x27;</span>)<br>                ++xy;<br>            <span class="hljs-keyword">if</span>(s1[i]==<span class="hljs-string">&#x27;y&#x27;</span>&amp;&amp;s2[i]==<span class="hljs-string">&#x27;x&#x27;</span>)<br>                ++yx;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((xy+yx)&amp;<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> xy/<span class="hljs-number">2</span>+yx/<span class="hljs-number">2</span>+(xy%<span class="hljs-number">2</span>)*<span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>循环码</title>
    <link href="/2023/02/23/%E5%BE%AA%E7%8E%AF%E7%A0%81/"/>
    <url>/2023/02/23/%E5%BE%AA%E7%8E%AF%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%BE%AA%E7%8E%AF%E7%A0%81">循环码</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="循环码"><a class="markdownIt-Anchor" href="#循环码"></a> 循环码</h2><p><a href="https://leetcode.cn/problems/circular-permutation-in-binary-representation/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你两个整数 n 和 start。你的任务是返回任意 (0,1,2,…,2^n-1) 的排列 p，并且满足：</p><ul><li>p[0] = start</li><li>[i] 和 p[i+1] 的二进制表示形式只有一位不同</li><li>[0] 和 p[2^n -1] 的二进制表示形式也只有一位不同</li></ul><p>示例</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：n = <span class="hljs-number">2</span>, start = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">3,2,0,1</span>]<br>解释：这个排列的二进制表示是 (<span class="hljs-number">11,10,00,01</span>)<br>     所有的相邻元素都有一位是不同的，另一个有效的排列是 [<span class="hljs-number">3,1,0,2</span>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题需要用到规律：<br />对于n位数，可生成<code>1&lt;&lt;n</code>个循环码，每个循环码的表达式为: <code>res[i]=i^(i&gt;&gt;1)</code>,如果要生成从<code>start</code>开始的循环码，则表达式为<code>res[i]=i^(i&gt;&gt;1)^start</code>。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">circularPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;res.<span class="hljs-built_in">size</span>();++i)<br>            res[i]=i^(i&gt;&gt;<span class="hljs-number">1</span>)^start;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>灌溉花园</title>
    <link href="/2023/02/21/%E7%81%8C%E6%BA%89%E8%8A%B1%E5%9B%AD/"/>
    <url>/2023/02/21/%E7%81%8C%E6%BA%89%E8%8A%B1%E5%9B%AD/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%81%8C%E6%BA%89%E8%8A%B1%E5%9B%AD">灌溉花园</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF1">思路1</a></li><li><a href="#%E4%BB%A3%E7%A0%811">代码1</a></li><li><a href="#%E6%80%9D%E8%B7%AF2">思路2</a></li><li><a href="#%E4%BB%A3%E7%A0%812">代码2</a></li></ul></li></ul><!-- /TOC --><h2 id="灌溉花园"><a class="markdownIt-Anchor" href="#灌溉花园"></a> 灌溉花园</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。</p><p>花园里总共有 n + 1 个水龙头，分别位于 [0, 1, …, n] 。</p><p>给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i -  ranges[i], i + ranges[i]] 。</p><p>请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。</p><p>示例</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 5, ranges = <span class="hljs-comment">[3,4,1,1,0,0]</span><br>输出：1<br>解释：<br>点 0 处的水龙头可以灌溉区间 <span class="hljs-comment">[-3,3]</span><br>点 1 处的水龙头可以灌溉区间 <span class="hljs-comment">[-3,5]</span><br>点 2 处的水龙头可以灌溉区间 <span class="hljs-comment">[1,3]</span><br>点 3 处的水龙头可以灌溉区间 <span class="hljs-comment">[2,4]</span><br>点 4 处的水龙头可以灌溉区间 <span class="hljs-comment">[4,4]</span><br>点 5 处的水龙头可以灌溉区间 <span class="hljs-comment">[5,5]</span><br>只需要打开点 1 处的水龙头即可灌溉整个花园 <span class="hljs-comment">[0,5]</span> 。<br></code></pre></td></tr></table></figure><h3 id="思路1"><a class="markdownIt-Anchor" href="#思路1"></a> 思路1</h3><p>动态规划，用<code>dp[i]</code>表示<code>0～i</code>之间最少的水龙头数量，首先计算每个水龙头对应的覆盖范围<code>(l,r)</code>，并按照左区间升序排序。初始化dp数组的值为INT_MAX，接下来对每个水龙头的范围进行遍历，更新dp。在遍历时，对于位置<code>i(l&lt;=i&lt;=r)</code>，<code>l~r</code>位置的已经被覆盖，所以需要关注<code>0~l</code>位置，所以状态方程为<code>dp[i]=min(dp[i],1+dp[l])</code>，如果某个范围的<code>dp[l]=INT_MAX</code>，说明<code>l</code>位置永远无法被覆盖，直接返回-1即可。</p><h3 id="代码1"><a class="markdownIt-Anchor" href="#代码1"></a> 代码1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minTaps</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; ranges)</span> </span>&#123;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; v;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> l=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,i-ranges[i]);<br>            <span class="hljs-type">int</span> r=<span class="hljs-built_in">min</span>(n,i+ranges[i]);<br>            v.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; t:v)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(dp[t.first]==INT_MAX)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=t.first;i&lt;=t.second;++i)<br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i],<span class="hljs-number">1</span>+dp[t.first]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="思路2"><a class="markdownIt-Anchor" href="#思路2"></a> 思路2</h3><p>这道题实际上与<a href="https://leetcode.cn/problems/jump-game-ii/description">跳跃游戏II</a>类似。首先需要将range数组处理成一个新数组<code>v[i]</code>，<code>v[i]</code>表示从i位置开始可以达到的最远距离。然后这道题基本就和跳跃游戏一样了，用&quot;造桥&quot;的思路可以解决。但是要注意<br />这道题存在可能无法到达终点的情况，因此当<code>i==cur</code>时，如果当前<code>cur==next_cur</code>，说明无法到达终点，返回-1。<br />注意：遍历的终点是n-1，因为如果i到达n-1时，i小于cur说明已经可以到达了，如果i等于cur,那么会自动造一个桥，所以不需要遍历到n。</p><h3 id="代码2"><a class="markdownIt-Anchor" href="#代码2"></a> 代码2</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    int minTaps(int n, vector&lt;int&gt;&amp; ranges) &#123;<br>        vector&lt;int&gt; v(n+1);<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n+1;++i)&#123;<br>            int <span class="hljs-attribute">len</span>=ranges[i];<br>            int <span class="hljs-attribute">l</span>=max(i-len,0);<br>            v[l]=max(v[l],i+len);<br>        &#125;<br>        int <span class="hljs-attribute">ans</span>=0,cur=0,next_cur=0;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n;++i)&#123;<br>            <span class="hljs-attribute">next_cur</span>=max(next_cur,v[i]);<br>            <span class="hljs-keyword">if</span>(<span class="hljs-attribute">i</span>==cur)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-attribute">cur</span>==next_cur)&#123;<br>                    return -1;<br>                &#125;<br>                <span class="hljs-attribute">cur</span>=next_cur;<br>                ++ans;<br>            &#125;<br>        &#125;<br>        return ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大平均通过率</title>
    <link href="/2023/02/19/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E9%80%9A%E8%BF%87%E7%8E%87/"/>
    <url>/2023/02/19/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E9%80%9A%E8%BF%87%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E9%80%9A%E8%BF%87%E7%8E%87">最大平均通过率</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最大平均通过率"><a class="markdownIt-Anchor" href="#最大平均通过率"></a> 最大平均通过率</h2><p><a href="https://leetcode.cn/problems/maximum-average-pass-ratio/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passi, totali] ，表示你提前知道了第 i 个班级总共有 totali 个学生，其中只有 passi 个学生可以通过考试。</p><p>给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。</p><p>一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率 是所有班级的通过率之和除以班级数目。</p><p>请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-5 以内的结果都会视为正确结果。</p><p>示例</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：classes = <span class="hljs-string">[[1,2],[3,5],[2,2]]</span>, extraStudents = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">0.78333</span><br>解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (<span class="hljs-number">3</span>/<span class="hljs-number">4</span> + <span class="hljs-number">3</span>/<span class="hljs-number">5</span> + <span class="hljs-number">2</span>/<span class="hljs-number">2</span>) / <span class="hljs-number">3</span> = <span class="hljs-number">0.78333</span> 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题的核心思想是贪心，就是需要保证每次安排的班级通过率增加的最多。</p><p>假设一个班级当前的通过率为<code>a/b</code>，如果将一个聪明的学生安排到此班级，那么班级的通过率就会变为<code>a+1/b+1</code>,可以发现，通过率的增量为<code>a+1/b+1-a/b</code>。</p><p>所以可以维护一个大顶堆，存储的是每个班级的通过率增量。</p><p>进行 <code>extraStudents</code> 次操作，每次从堆顶取出一个班级，将这个班级的人数和通过人数都加 1，然后将这个班级的通过率增量重新计算并放回堆中。重复这个过程，直到将所有的学生都分配完毕。</p><p>最后，将所有班级的通过率求和，然后除以班级数目，即为答案。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> node<br>    &#123;<br>        <span class="hljs-built_in">double</span> <span class="hljs-keyword">add</span>;<br>        <span class="hljs-built_in">int</span> pass,total;<br>        node(<span class="hljs-built_in">double</span> a,<span class="hljs-built_in">int</span> b,<span class="hljs-built_in">int</span> c):<span class="hljs-keyword">add</span>(a),pass(b),total(c)&#123;&#125;<br>        <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> node&amp; t) <span class="hljs-keyword">const</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">add</span>&lt;t.<span class="hljs-keyword">add</span>;<br>        &#125;<br>    &#125;;<br>    priority_queue&lt;node&gt; q;<br>    <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">maxAverageRatio</span>(<span class="hljs-params">vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; classes, <span class="hljs-built_in">int</span> extraStudents</span>)</span> &#123;<br>        <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; v:classes)<br>        &#123;<br>            <span class="hljs-built_in">int</span> a=v[<span class="hljs-number">0</span>],b=v[<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">double</span> <span class="hljs-keyword">add</span>=(<span class="hljs-built_in">double</span>)(a+<span class="hljs-number">1</span>)/(b+<span class="hljs-number">1</span>)-(<span class="hljs-built_in">double</span>)a/b;<br>            q.push(node(<span class="hljs-keyword">add</span>,a,b));<br>        &#125;<br>        <span class="hljs-keyword">while</span>(extraStudents--)<br>        &#123;<br>            node t=q.top();<br>            q.pop();<br>            ++t.pass;<br>            ++t.total;<br>            t.<span class="hljs-keyword">add</span>=(<span class="hljs-built_in">double</span>)(t.pass+<span class="hljs-number">1</span>)/(t.total+<span class="hljs-number">1</span>)-(<span class="hljs-built_in">double</span>)t.pass/t.total;<br>            q.push(t);<br>        &#125;<br>        <span class="hljs-built_in">double</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.empty())<br>        &#123;<br>            node t=q.top();<br>            q.pop();<br>            ans+=(<span class="hljs-built_in">double</span>) t.pass/t.total;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans/classes.size();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大正方形</title>
    <link href="/2023/02/17/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <url>/2023/02/17/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2">最大正方形</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最大正方形"><a class="markdownIt-Anchor" href="#最大正方形"></a> 最大正方形</h2><p><a href="https://leetcode.cn/problems/largest-1-bordered-square/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。</p><p>示例</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,1,1],[1,0,1],[1,1,1]]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用到前缀和的思路，把每行每列的前缀和数组保存下来，用来快速计算边界，然后依次遍历边界长度(从大到小)和左上角坐标，当满足条件时返回正方形面积即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stan">class Solution &#123;<br>public:<br>    <span class="hljs-type">int</span> largest1BorderedSquare(<span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid) &#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(),n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">vector</span>&lt;<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">row</span>(m,<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>)),<span class="hljs-built_in">col</span>(n,<span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-built_in">row</span>[i][j+<span class="hljs-number">1</span>]=<span class="hljs-built_in">row</span>[i][j]+grid[i][j];<br>                <span class="hljs-built_in">col</span>[j][i+<span class="hljs-number">1</span>]=<span class="hljs-built_in">col</span>[j][i]+grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> d=<span class="hljs-built_in">min</span>(m,n);<br>        <span class="hljs-keyword">for</span>(;d&gt;<span class="hljs-number">0</span>;--d)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m-d;++i)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n-d;++j)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">row</span>[i][j+d]-<span class="hljs-built_in">row</span>[i][j]==d&amp;&amp;<br>                    <span class="hljs-built_in">row</span>[i+d-<span class="hljs-number">1</span>][j+d]-<span class="hljs-built_in">row</span>[i+d-<span class="hljs-number">1</span>][j]==d&amp;&amp;<br>                    <span class="hljs-built_in">col</span>[j][i+d]-<span class="hljs-built_in">col</span>[j][i]==d&amp;&amp;<br>                    <span class="hljs-built_in">col</span>[j+d-<span class="hljs-number">1</span>][i+d]-<span class="hljs-built_in">col</span>[j+d-<span class="hljs-number">1</span>][i]==d)<br>                        <span class="hljs-keyword">return</span> d*d;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>检查好数组</title>
    <link href="/2023/02/16/%E6%A3%80%E6%9F%A5%E5%A5%BD%E6%95%B0%E7%BB%84/"/>
    <url>/2023/02/16/%E6%A3%80%E6%9F%A5%E5%A5%BD%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%A3%80%E6%9F%A5%E5%A5%BD%E6%95%B0%E7%BB%84">检查好数组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="检查好数组"><a class="markdownIt-Anchor" href="#检查好数组"></a> 检查好数组</h2><p><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个正整数数组 nums，你需要从中任选一些子集，然后将子集中每一个数乘以一个 任意整数，并求出他们的和。</p><p>假如该和结果为 1，那么原数组就是一个「好数组」，则返回 True；否则请返回 False。</p><p>示例</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：nums = [12,5,7,23]<br>输出：<span class="hljs-literal">true</span><br>解释：挑选数字 5 和 7。<br>5<span class="hljs-number">*3</span> + 7*(-2) = 1<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题实际上是个数学题😅，用到裴蜀定理：<br />对于不全为零的任意整数 <code>a</code> 和 <code>b</code>，记 <code>g=gcd⁡(a,b)</code>，则对于任意整数 <code>x</code> 和 <code>y</code> 都满足 <code>a×x+b×y</code> 是 <code>g</code> 的倍数，特别地，存在整数 <code>x</code> 和 <code>y</code> 满足 <code>a×x+b×y=g</code>，对于多个整数同样适用。</p><p>因此本体只需要考虑最大公约数是否为1即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isGoodArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> divisor = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            divisor = <span class="hljs-built_in">gcd</span>(divisor, num);<br>            <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> divisor == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>替换子串</title>
    <link href="/2023/02/13/%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2/"/>
    <url>/2023/02/13/%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2%E5%BE%97%E5%88%B0%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2">替换子串得到平衡字符串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="替换子串得到平衡字符串"><a class="markdownIt-Anchor" href="#替换子串得到平衡字符串"></a> 替换子串得到平衡字符串</h2><p><a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。</p><p>假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。</p><p>给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。</p><p>你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</p><p>请返回待替换子串的最小可能长度。</p><p>如果原字符串自身就是一个平衡字符串，则返回 0。</p><p>示例</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;QQWE&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：我们需要把一个 &#x27;Q&#x27; 替换成 &#x27;R&#x27;，这样得到的 <span class="hljs-string">&quot;RQWE&quot;</span> (或 <span class="hljs-string">&quot;QRWE&quot;</span>) 是平衡的。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要用到双指针，根据题目的描述可以得知，当替换部分以外的其他字母都小于等于<code>n/4</code>时，替换后才能符合要求。因此右指针向右移动，当符合要求时，更新答案，左指针缩小子串长度。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs hsp">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> balancedString(string s) &#123;<br>        <span class="hljs-keyword">int</span> n=s.size()<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">int</span> m=n/<span class="hljs-number">4</span><span class="hljs-comment">;</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">cnt</span>(<span class="hljs-number">26</span>)<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">for</span>(char c:s)<br>        &#123;<br>            ++<span class="hljs-keyword">cnt</span>[c-<span class="hljs-string">&#x27;A&#x27;</span>]<span class="hljs-comment">;</span><br>        &#125;<br>        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span><span class="hljs-comment">;</span><br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>e9<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;Q&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]==m&amp;&amp;<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;W&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]==m&amp;&amp;<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;E&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]==m&amp;&amp;<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;R&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]==m)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>        <span class="hljs-keyword">for</span>(r=<span class="hljs-number">0</span><span class="hljs-comment">;r&lt;n;++r)</span><br>        &#123;<br>            --<span class="hljs-keyword">cnt</span>[s[r]-<span class="hljs-string">&#x27;A&#x27;</span>]<span class="hljs-comment">;</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;Q&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]&lt;=m&amp;&amp;<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;W&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]&lt;=m&amp;&amp;<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;E&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]&lt;=m&amp;&amp;<span class="hljs-keyword">cnt</span>[<span class="hljs-string">&#x27;R&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]&lt;=m)<br>            &#123;<br>                ans=min(ans,r-l+<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>                ++<span class="hljs-keyword">cnt</span>[s[l]-<span class="hljs-string">&#x27;A&#x27;</span>]<span class="hljs-comment">;</span><br>                ++l<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans<span class="hljs-comment">;</span><br>    &#125;<br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>掷骰子</title>
    <link href="/2023/02/10/%E6%8E%B7%E9%AA%B0%E5%AD%90/"/>
    <url>/2023/02/10/%E6%8E%B7%E9%AA%B0%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="掷骰子模拟"><a class="markdownIt-Anchor" href="#掷骰子模拟"></a> 掷骰子模拟</h2><p><a href="https://leetcode.cn/problems/dice-roll-simulation/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。</p><p>不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。</p><p>现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。</p><p>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。</p><p>示例：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2, rollMax = [1,1,2,2,2,3]<br>输出：34<br>解释：我们掷<span class="hljs-number"> 2 </span>次骰子，如果没有约束的话，共有<span class="hljs-number"> 6 </span>*<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 36 </span>种可能的组合。但是根据 rollMax 数组，数字<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题自己完全没啥头绪，强烈推荐大佬的思路：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs prolog">// -------------------------------------------------说明-----------------------------------------------------------------<br><br>// 首先，我们创建一个二维dp数组。<br>//  dp[i][j]表示第i次掷出骰子时，数字j出现的可能的序列总数。<br>// （也就是说，第i次掷出的骰子数字是 j 所有可能的序列数) <br>// 其中 <span class="hljs-number">1</span> &lt;= i &lt;= n    <span class="hljs-number">1</span> &lt;= j &lt;= <span class="hljs-number">6</span><br><br>// 明显，dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]... dp[<span class="hljs-number">1</span>][<span class="hljs-number">6</span>]均为 <span class="hljs-number">1</span><br>// 所以，最后结果有效序列总数就是 sum (dp[n][<span class="hljs-number">1</span>] + dp[n][<span class="hljs-number">2</span>] + ... + dp[n][<span class="hljs-number">6</span>])  | sum为求和函数<br><br>// 那么，如何计算第i次骰子掷出时，掷出数字为j的序列总数为多少呢?<br>// 仔细思考一下dp[i][j]和什么有关?<br><br>// 第一: dp[i][j] 和dp[i<span class="hljs-number">-1</span>][j]有关，不仅如此，dp[i][j] 和 dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>],...dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">6</span>]都有关<br>// 第二: 由于连续数字限制，dp[i][j]还和 dp[i-rollMax[j<span class="hljs-number">-1</span>]][<span class="hljs-number">1</span>],...,dp[i-rollMax[j<span class="hljs-number">-1</span>]][<span class="hljs-number">6</span>]均有关<br>// 即， 第i次掷出骰子的序列总数只和第i<span class="hljs-number">-1</span>次掷出骰子的序列总数，以及第i-rollMax[j<span class="hljs-number">-1</span>]次掷出骰子的序列总数有关。<br><br>// --------------------------------------------------举例----------------------------------------------------------------<br><br>// 这么说 可能还是不够清楚， 举个例子<br><br>// 假如现在是第 <span class="hljs-number">5</span> 次掷出骰子， 且掷出的数字是 <span class="hljs-number">6</span>, 而最多能连续出现 <span class="hljs-number">3</span> 次 <span class="hljs-number">6</span>， dp[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>]如何计算?<br><br>// 序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>   <span class="hljs-symbol">___</span>   <span class="hljs-number">6</span> <br>// 次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>     <span class="hljs-number">4</span>    <span class="hljs-number">5</span><br><br>① 如果第 <span class="hljs-number">4</span> 次掷出的数字是 <span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span> 中的一种， 会不会对第 <span class="hljs-number">5</span> 次掷出的 <span class="hljs-number">6</span> 产生影响? <br>  答案是 不会，因为如果第 <span class="hljs-number">4</span> 次不是 <span class="hljs-number">6</span>，那么第 <span class="hljs-number">5</span> 次掷出的 <span class="hljs-number">6</span> 肯定是第一个 <span class="hljs-number">6</span>， 肯定不会连续。<br>  所以不用考虑限制数组rollMax。<br>  也就是说，可以直接将 dp[<span class="hljs-number">4</span>][<span class="hljs-number">1</span>]，dp[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]，dp[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>]，dp[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]，dp[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>]加入到 dp[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>] 中。<br>  <br>  // <span class="hljs-number">5</span>种可能<br>  // 序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>    <span class="hljs-number">1</span>   <span class="hljs-number">6</span>       序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>    <span class="hljs-number">2</span>   <span class="hljs-number">6</span>  ...  序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>    <span class="hljs-number">5</span>   <span class="hljs-number">6</span><br>  // 次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>     <span class="hljs-number">4</span>   <span class="hljs-number">5</span>       次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>     <span class="hljs-number">4</span>   <span class="hljs-number">5</span>  ...  次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>     <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br><br>② 如果第 <span class="hljs-number">4</span> 次掷出的数字是 <span class="hljs-number">6</span> ，会不会对第 <span class="hljs-number">5</span> 次掷出的 <span class="hljs-number">6</span> 产生影响? <br>  答案是 不一定。为什么是不一定? 因为第 <span class="hljs-number">4</span> 次掷出的 <span class="hljs-number">6</span> 加上第五次掷出的 <span class="hljs-number">6</span> 可能都还没达到rollMax中所设置的上限。<br>  那么，可以先将dp[<span class="hljs-number">4</span>][<span class="hljs-number">6</span>] 加入到dp[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>]中去。只是后面需要去除不合法的序列罢了。（注意）<br>   <br>   // 类似这种<br>   // 序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>    <span class="hljs-number">6</span>   <span class="hljs-number">6</span>      // 序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>   <span class="hljs-number">6</span>    <span class="hljs-number">6</span>   <span class="hljs-number">6</span><br>   // 次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>     <span class="hljs-number">4</span>   <span class="hljs-number">5</span>      // 次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br><br>③ 好的，第②步中我们多加了一些不合法的序列数目，那么，我们要将其减掉。那么到底需要减去多少呢?<br>  <br>  我们先思考一个问题， 第 <span class="hljs-number">5</span> 次掷出数字 <span class="hljs-number">6</span> 时，掷出之前连续 <span class="hljs-number">6</span> 的数量最大有多少?<br>  答案是 rollMax[<span class="hljs-number">5</span>]（数字 <span class="hljs-number">6</span> 的上限），不可能超过该数字 ，<br>  因为如果超过了rollMax[<span class="hljs-number">5</span>]（<span class="hljs-number">6</span>的上限），在第 <span class="hljs-number">4</span> 次肯定就已经被处理了。<br><br>  那么，现在又存在两种情况：<br>  a. 第 <span class="hljs-number">5</span> 次掷出数字 <span class="hljs-number">6</span> 之前连续 <span class="hljs-number">6</span> 的数量 &lt; rollMax[<span class="hljs-number">5</span>] （<span class="hljs-number">6</span>的上限）<br>  b. 第 <span class="hljs-number">5</span> 次掷出数字 <span class="hljs-number">6</span> 之前连续 <span class="hljs-number">6</span> 的数量 == rollMax[<span class="hljs-number">5</span>] （<span class="hljs-number">6</span>的上限）<br>  情况a. 我们不需要过多考虑，因为还没有达到上限，直接将dp[<span class="hljs-number">4</span>][<span class="hljs-number">6</span>]加入dp[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>] 即可（前面已经加入）<br>  情况b. 在第 <span class="hljs-number">5</span> 次掷出之前连续 <span class="hljs-number">6</span> 的数量就已经到达了上限，那么第 <span class="hljs-number">5</span> 次掷出 <span class="hljs-number">6</span> 是非法的，<br>  这种情况下的序列数目就是我们步骤②中需要减去的数量<br>  <br>  // 情况a. （合法的）                            // 情况b. （不合法的）<br>  // 序列  <span class="hljs-symbol">___</span>  <span class="hljs-symbol">___</span>   <span class="hljs-symbol">___</span>   <span class="hljs-number">6</span>   <span class="hljs-number">6</span>                // 序列  <span class="hljs-symbol">___</span>   <span class="hljs-number">6</span>    <span class="hljs-number">6</span>    <span class="hljs-number">6</span>   <span class="hljs-number">6</span><br>  // 次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>     <span class="hljs-number">3</span>    <span class="hljs-number">4</span>   <span class="hljs-number">5</span>                // 次数   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br><br>  仔细分析一下情况 b.<br>  在第 <span class="hljs-number">5</span> 次掷出之前连续 <span class="hljs-number">6</span> 的数量就已经到达了上限，说明第 <span class="hljs-number">2</span> 次，第 <span class="hljs-number">3</span> 次，第 <span class="hljs-number">4</span> 次掷出的数字一定都是<span class="hljs-number">6</span>，<br>  而且，第<span class="hljs-number">1</span>次掷出的数字一定不是<span class="hljs-number">6</span>。<br>  结果也就很明显了吧，第 <span class="hljs-number">1</span> 次不是 <span class="hljs-number">6</span> ，那就是 <span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span> 中的一种呗!!!<br>  需要减去的序列数量为: sum (dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">4</span>] + dp[<span class="hljs-number">1</span>][<span class="hljs-number">5</span>])<br><br>// ------------------------------------------------------------------------------------------------------------------<br>  <br>  其他的数字<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span>可依次类推...<br><br>// ------------------------------------------------------------------------------------------------------------------<br><br>作者：yex➰<br>链接：https://leetcode.cn/problems/dice-roll-simulation/solutions/<span class="hljs-number">492200</span>/ni-bi-dong-chao-jian-dan-dong-tai-gui-hua-fu-za-du/<br>来源：力扣（<span class="hljs-symbol">LeetCode</span>）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>tql呜呜呜</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br><br>    typedef long long ll;<br><br>    <span class="hljs-built_in">int</span> dieSimulator(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; rollMax) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mod</span>=<span class="hljs-number">1</span>e9+<span class="hljs-number">7</span>;<br>        vector&lt;vector&lt;ll&gt;&gt; dp(<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>,vector&lt;ll&gt;(<span class="hljs-number">7</span>));<br>        for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">6</span>;++j)<br>            dp[<span class="hljs-number">1</span>][j]=<span class="hljs-number">1</span>;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-built_in">n</span>;++i)<br>        &#123;<br>            for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">6</span>;++j)<br>            &#123;<br>                ll <span class="hljs-built_in">t</span>=accumulate(dp[i-<span class="hljs-number">1</span>].begin(),dp[i-<span class="hljs-number">1</span>].end(),<span class="hljs-number">0</span>ll);<br>                <span class="hljs-built_in">int</span> idx=i-<span class="hljs-number">1</span>-rollMax[j-<span class="hljs-number">1</span>];<br>                <span class="hljs-built_in">if</span>(idx&gt;=<span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-built_in">t</span>=accumulate(dp[idx].begin(),dp[idx].end(),<span class="hljs-built_in">t</span>,[&amp;](ll a,ll b)&#123;<br>                        return a+<span class="hljs-built_in">mod</span>-b;<br>                    &#125;);<br>                    <span class="hljs-built_in">t</span>+=dp[idx][j];<br>                &#125;<br>                else <span class="hljs-built_in">if</span>(idx==<span class="hljs-number">0</span>)<br>                    <span class="hljs-built_in">t</span>-=<span class="hljs-number">1</span>;<br>                dp[i][j]=<span class="hljs-built_in">t</span>%<span class="hljs-built_in">mod</span>;<br>            &#125;<br>        &#125;<br>        return accumulate(dp[<span class="hljs-built_in">n</span>].begin(),dp[<span class="hljs-built_in">n</span>].end(),<span class="hljs-number">0</span>ll)%<span class="hljs-built_in">mod</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>构造连续值</title>
    <link href="/2023/02/04/%E6%9E%84%E9%80%A0%E8%BF%9E%E7%BB%AD%E5%80%BC/"/>
    <url>/2023/02/04/%E6%9E%84%E9%80%A0%E8%BF%9E%E7%BB%AD%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9E%84%E9%80%A0%E8%BF%9E%E7%BB%AD%E5%80%BC">构造连续值</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="构造连续值"><a class="markdownIt-Anchor" href="#构造连续值"></a> 构造连续值</h2><p><a href="https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个长度为 n 的整数数组 coins ，它代表你拥有的 n 个硬币。第 i 个硬币的值为 coins[i] 。如果你从这些硬币中选出一部分硬币，它们的和为 x ，那么称，你可以 构造 出 x 。</p><p>请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。</p><p>你可能有多个相同值的硬币。</p><p>示例:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：coins = <span class="hljs-comment">[1,1,1,4]</span><br>输出：8<br>解释：你可以得到以下这些值：<br>- 0：什么都不取 <span class="hljs-comment">[]</span><br>- 1：取 <span class="hljs-comment">[1]</span><br>- 2：取 <span class="hljs-comment">[1,1]</span><br>- 3：取 <span class="hljs-comment">[1,1,1]</span><br>- 4：取 <span class="hljs-comment">[4]</span><br>- 5：取 <span class="hljs-comment">[4,1]</span><br>- 6：取 <span class="hljs-comment">[4,1,1]</span><br>- 7：取 <span class="hljs-comment">[4,1,1,1]</span><br>从 0 开始，你可以构造出 8 个连续整数。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题就是构造从0开始的连续整数的个数，代码及其简单，但思路很好，第一眼看下去我想不到😢😢😢，tcl.</p><p>首先思考，如果数组中的若干元素能构造<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">0 \sim x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，那么当加入了一个元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>,能构造的范围就变成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>x</mi><mo>∪</mo><mi>k</mi><mo>∼</mo><mi>k</mi><mo>+</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">0 \sim x \cup k \sim k+x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k \le x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，两个范围就合并为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>k</mi><mo>+</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">0 \sim k+x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>。因此，这道题中，用res表示下一个要构造的数，先对数组排序，然后依次取数组中的元素<code>i</code>，如果<code>i&lt;=res</code>，说明可构造的范围需要扩大，下一个要构造的数变为<code>res+i</code>，直到<code>i&gt;res</code>，说明此时已经无法继续构造连续的整数。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaximumConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(coins.<span class="hljs-built_in">begin</span>(),coins.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i:coins)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&lt;=res)<br>                res+=i;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>颜色交替最短路</title>
    <link href="/2023/02/02/%E9%A2%9C%E8%89%B2%E4%BA%A4%E6%9B%BF%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2023/02/02/%E9%A2%9C%E8%89%B2%E4%BA%A4%E6%9B%BF%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%A2%9C%E8%89%B2%E4%BA%A4%E6%9B%BF%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF">颜色交替的最短路</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="颜色交替的最短路"><a class="markdownIt-Anchor" href="#颜色交替的最短路"></a> 颜色交替的最短路</h2><p><a href="https://leetcode.cn/problems/shortest-path-with-alternating-colors/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在一个有向图中，节点分别标记为 0, 1, …, n-1。图中每条边为红色或者蓝色，且存在自环或平行边。</p><p>red_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的红色有向边。类似地，blue_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的蓝色有向边。</p><p>返回长度为 n 的数组 answer，其中 answer[X] 是从节点 0 到节点 X 的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么 answer[x] = -1。</p><p>示例</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span>, red_edges = <span class="hljs-string">[[0,1]]</span>, blue_edges = <span class="hljs-string">[[2,1]]</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要是bfs的思想，一开始我想的是吧红色边和蓝色边放在一个图处理，但是这样做的问题就是后面我不会处理环路的情况了，自己也晕了，参考大佬的思路后，才解决，其实红色边和蓝色边分为两个图，每个边处理后，颜色取反，然后去对应颜色的图里找下一条边即可。</p><p>首先将起点 0 和起点边的颜色 0 或 1 入队，表示从起点出发，且当前是红色或蓝色边。接下来，进行 BFS 。每次从队列中取出一个节点<code>(u,clr)</code>，如果当前节点的答案还未更新，则将当前节点的答案更新为当前层数<code>d</code>，即 <code>ans[i]=d</code>。然后，我们将当前边的颜色 <code>clr</code> 取反，即如果当前边为红色，则将其变为蓝色，之后取出颜色对应的所有边，如果边的另一端节点未被搜索过，则将其入队。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">shortestAlternatingPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; redEdges, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; blueEdges)</span> </span>&#123;<br>        vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">edges</span>(<span class="hljs-number">2</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n));<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; e : redEdges) <br>            edges[<span class="hljs-number">0</span>][e[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; e : blueEdges)<br>            edges[<span class="hljs-number">1</span>][e[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(e[<span class="hljs-number">1</span>]);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n,<span class="hljs-number">-1</span>)</span></span>;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-number">2</span>,<span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> d=<span class="hljs-number">0</span>;<br>        q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> sz=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(sz--)<br>            &#123;<br>                <span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>().first;<br>                <span class="hljs-type">int</span> clr=q.<span class="hljs-built_in">front</span>().second;<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(ans[u]==<span class="hljs-number">-1</span>)<br>                    ans[u]=d;<br>                vis[u][clr]=<span class="hljs-literal">true</span>;<br>                clr^=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; v:edges[clr][u])<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(!vis[v][clr])<br>                        q.<span class="hljs-built_in">emplace</span>(v,clr);<br>                &#125;<br>            &#125;<br>            ++d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>平衡数组方案数</title>
    <link href="/2023/01/28/%E5%B9%B3%E8%A1%A1%E6%95%B0%E7%BB%84%E6%96%B9%E6%A1%88%E6%95%B0/"/>
    <url>/2023/01/28/%E5%B9%B3%E8%A1%A1%E6%95%B0%E7%BB%84%E6%96%B9%E6%A1%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%B9%B3%E8%A1%A1%E6%95%B0%E7%BB%84%E6%96%B9%E6%A1%88%E6%95%B0">平衡数组方案数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="平衡数组方案数"><a class="markdownIt-Anchor" href="#平衡数组方案数"></a> 平衡数组方案数</h2><p><a href="https://leetcode.cn/problems/ways-to-make-a-fair-array/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums 。你需要选择 恰好 一个下标（下标从 0 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。</p><p>比方说，如果 nums = [6,1,7,4,1] ，那么：</p><p>选择删除下标 1 ，剩下的数组为 nums = [6,7,4,1] 。<br />选择删除下标 2 ，剩下的数组为 nums = [6,1,4,1] 。<br />选择删除下标 4 ，剩下的数组为 nums = [6,1,7,4] 。<br />如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 平衡数组 。</p><p>请你返回删除操作后，剩下的数组 nums 是 平衡数组 的 方案数 。</p><p>示例</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,1,6,4]<br>输出：1<br>解释：<br>删除下标<span class="hljs-number"> 0 </span>：[1,6,4] -&gt; 偶数元素下标为：1 +<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 5 </span>。奇数元素下标为：6 。不平衡。<br>删除下标<span class="hljs-number"> 1 </span>：[2,6,4] -&gt; 偶数元素下标为：2 +<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 6 </span>。奇数元素下标为：6 。平衡。<br>删除下标<span class="hljs-number"> 2 </span>：[2,1,4] -&gt; 偶数元素下标为：2 +<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 6 </span>。奇数元素下标为：1 。不平衡。<br>删除下标<span class="hljs-number"> 3 </span>：[2,1,6] -&gt; 偶数元素下标为：2 +<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 8 </span>。奇数元素下标为：1 。不平衡。<br>只有一种让剩余数组成为平衡数组的方案。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>对于位置<code>i</code>来说，需要维护4个变量 <code>prej,preo,sufj,sufo</code>,分别表示位置<code>i</code>之前奇数下标的数之和，偶数下标的数之和，以及位置<code>i</code>之后奇数下标的数之和与偶数下标的数之和。当位置<code>i</code>处的数字被去掉后，只需判断<code>prej+sufo==preo+sufj</code>是否相等，若相等则符合要求。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    int waysToMakeFair(vector&lt;int&gt;&amp; nums) &#123;<br>        int <span class="hljs-attribute">n</span>=nums.size();<br>        int <span class="hljs-attribute">prej</span>=0,preo=0,sufj=0,sufo=0;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&amp;1)<br>                sufj+=nums[i];<br>            <span class="hljs-keyword">else</span><br>                sufo+=nums[i];<br>        &#125;<br>        int <span class="hljs-attribute">res</span>=0;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&amp;1)<br>                <span class="hljs-attribute">sufj-</span>=nums[i];<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-attribute">sufo-</span>=nums[i];<br>            <span class="hljs-keyword">if</span>(prej+<span class="hljs-attribute">sufo</span>==preo+sufj)<br>                ++res;<br>            <span class="hljs-keyword">if</span>(i&amp;1)<br>                prej+=nums[i];<br>            <span class="hljs-keyword">else</span><br>                preo+=nums[i];<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>矩阵转换后的秩</title>
    <link href="/2023/01/25/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%A7%A9/"/>
    <url>/2023/01/25/%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%A7%A9/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%9F%A9%E9%98%B5%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E7%A7%A9">矩阵转换后的秩</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="矩阵转换后的秩"><a class="markdownIt-Anchor" href="#矩阵转换后的秩"></a> 矩阵转换后的秩</h2><p><a href="https://leetcode.cn/problems/rank-transform-of-a-matrix/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个 m x n 的矩阵 matrix ，请你返回一个新的矩阵 answer ，其中 answer[row][col] 是 matrix[row][col] 的秩。</p><p>每个元素的 秩 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：</p><p>秩是从 1 开始的一个整数。<br />如果两个元素 p 和 q 在 同一行 或者 同一列 ，那么：<br />如果 p &lt; q ，那么 rank(p) &lt; rank(q)<br />如果 p == q ，那么 rank(p) == rank(q)<br />如果 p &gt; q ，那么 rank(p) &gt; rank(q)<br />秩 需要越 小 越好。<br />题目保证按照上面规则 answer 数组是唯一的。</p><p>示例：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,4]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>]</span><br>解释：<br>matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 的秩为 1 ，因为它是所在行和列的最小整数。<br>matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> 的秩为 2 ，因为 matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> &gt; matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 且 matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 的秩为 1 。<br>matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span> 的秩为 2 ，因为 matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span> &gt; matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 且 matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> 的秩为 1 。<br>matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> 的秩为 3 ，因为 matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> &gt; matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span>， matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> &gt; matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span> 且 matrix<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> 和 matrix<span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span> 的秩都为 2 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题还是很麻烦的，要用到并查集+拓扑排序，看了题解也很勉强的写下来😢</p><p>主要的思路就是，用哈希表把每行相同元素的下标记录下来，然后用并查集把相同元素的下标连接起来，下面就是建图，我们希望构建这样的图，一条边<code>u-&gt;v</code>中，<code>u</code>是较小的元素的集合的<code>root</code>，<code>v</code>是较大的元素的集合的<code>root</code>，也就是说，建立的是不同集合间的拓扑图，然后通过拓扑排序，为每个集合的根节点设置它的 “秩”，然后把同一集合的元素的值设置为集合内根节点的值即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> unionset</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-class">    vector&lt;int&gt; vset,sz;</span><br><span class="hljs-class">public:</span><br><span class="hljs-class">    unionset(<span class="hljs-title">int</span> <span class="hljs-title">n</span>)</span><br><span class="hljs-class">    &#123;</span><br><span class="hljs-class">        vset=vector&lt;int&gt; (<span class="hljs-title">n</span>);</span><br><span class="hljs-class">        sz=vector&lt;int&gt; (<span class="hljs-title">n</span>,1);</span><br><span class="hljs-class">        iota(<span class="hljs-title">vset</span>.<span class="hljs-title">begin</span>(),vset.end(),0);</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">    int find(<span class="hljs-title">int</span> <span class="hljs-title">a</span>)</span><br><span class="hljs-class">    &#123;</span><br><span class="hljs-class">        if(<span class="hljs-title">vset</span>[<span class="hljs-title">a</span>]==<span class="hljs-title">a</span>)</span><br><span class="hljs-class">            return a;</span><br><span class="hljs-class">        return vset[a]=find(<span class="hljs-title">vset</span>[<span class="hljs-title">a</span>]);</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">    void con(<span class="hljs-title">int</span> <span class="hljs-title">a</span>,<span class="hljs-title">int</span> <span class="hljs-title">b</span>)</span><br><span class="hljs-class">    &#123;</span><br><span class="hljs-class">        int x=find(<span class="hljs-title">a</span>);</span><br><span class="hljs-class">        int y=find(<span class="hljs-title">b</span>);</span><br><span class="hljs-class">        if(<span class="hljs-title">x</span>!=<span class="hljs-title">y</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            if(<span class="hljs-title">sz</span>[<span class="hljs-title">x</span>]&gt;<span class="hljs-title">sz</span>[<span class="hljs-title">y</span>])</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                vset[y]=x;</span><br><span class="hljs-class">                sz[x]+=sz[y];</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">            else</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                vset[x]=y;</span><br><span class="hljs-class">                sz[y]+=sz[x];</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">&#125;;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;</span><br><span class="hljs-class">public:</span><br><span class="hljs-class">    vector&lt;vector&lt;int&gt;&gt; matrixRankTransform(<span class="hljs-title">vector</span>&lt;<span class="hljs-title">vector</span>&lt;<span class="hljs-title">int</span>&gt;&gt;&amp; <span class="hljs-title">matrix</span>) &#123;</span><br><span class="hljs-class">        int n=matrix.size(),m=matrix[0].size();</span><br><span class="hljs-class">        unionset uset(<span class="hljs-title">n</span>*<span class="hljs-title">m</span>);</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            map&lt;int,vector&lt;int&gt;&gt; mp;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">                mp[matrix[i][j]].emplace_back(<span class="hljs-title">i</span>*<span class="hljs-title">m</span>+<span class="hljs-title">j</span>);</span><br><span class="hljs-class">            for(<span class="hljs-title">auto</span> &amp;[<span class="hljs-title">num</span>,<span class="hljs-title">vec</span>]:<span class="hljs-title">mp</span>)//将每行相同元素connect</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                for(<span class="hljs-title">int</span> <span class="hljs-title">k</span>=0;<span class="hljs-title">k</span>+1&lt;<span class="hljs-title">vec</span>.<span class="hljs-title">size</span>();++k)</span><br><span class="hljs-class">                    uset.con(<span class="hljs-title">vec</span>[<span class="hljs-title">k</span>],<span class="hljs-title">vec</span>[<span class="hljs-title">k</span>+1]);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            map&lt;int,vector&lt;int&gt;&gt; mp;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">                mp[matrix[i][j]].emplace_back(<span class="hljs-title">i</span>*<span class="hljs-title">m</span>+<span class="hljs-title">j</span>);</span><br><span class="hljs-class">            for(<span class="hljs-title">auto</span> &amp;[<span class="hljs-title">num</span>,<span class="hljs-title">vec</span>]:<span class="hljs-title">mp</span>)//将每列相同元素connect</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                for(<span class="hljs-title">int</span> <span class="hljs-title">k</span>=0;<span class="hljs-title">k</span>+1&lt;<span class="hljs-title">vec</span>.<span class="hljs-title">size</span>();++k)</span><br><span class="hljs-class">                    uset.con(<span class="hljs-title">vec</span>[<span class="hljs-title">k</span>],<span class="hljs-title">vec</span>[<span class="hljs-title">k</span>+1]);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        vector&lt;vector&lt;int&gt;&gt; adj(<span class="hljs-title">n</span>*<span class="hljs-title">m</span>);</span><br><span class="hljs-class">        vector&lt;int&gt; in(<span class="hljs-title">n</span>*<span class="hljs-title">m</span>);</span><br><span class="hljs-class">        //建图</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            vector&lt;pair&lt;int,int&gt;&gt; v(<span class="hljs-title">m</span>);</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">                v[j]=&#123;matrix[i][j],j&#125;;</span><br><span class="hljs-class">            sort(<span class="hljs-title">v</span>.<span class="hljs-title">begin</span>(),v.end());</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>+1&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                if(<span class="hljs-title">v</span>[<span class="hljs-title">j</span>].<span class="hljs-title">first</span>!=<span class="hljs-title">v</span>[<span class="hljs-title">j</span>+1].<span class="hljs-title">first</span>)</span><br><span class="hljs-class">                &#123;</span><br><span class="hljs-class">                    int uu=uset.find(<span class="hljs-title">i</span>*<span class="hljs-title">m</span>+<span class="hljs-title">v</span>[<span class="hljs-title">j</span>].<span class="hljs-title">second</span>);</span><br><span class="hljs-class">                    int vv=uset.find(<span class="hljs-title">i</span>*<span class="hljs-title">m</span>+<span class="hljs-title">v</span>[<span class="hljs-title">j</span>+1].<span class="hljs-title">second</span>);</span><br><span class="hljs-class">                    adj[uu].emplace_back(<span class="hljs-title">vv</span>);</span><br><span class="hljs-class">                    ++in[vv];</span><br><span class="hljs-class">                &#125;</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            vector&lt;pair&lt;int,int&gt;&gt; v(<span class="hljs-title">n</span>);</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">                v[i]=&#123;matrix[i][j],i&#125;;</span><br><span class="hljs-class">            sort(<span class="hljs-title">v</span>.<span class="hljs-title">begin</span>(),v.end());</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>+1&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                if(<span class="hljs-title">v</span>[<span class="hljs-title">i</span>].<span class="hljs-title">first</span>!=<span class="hljs-title">v</span>[<span class="hljs-title">i</span>+1].<span class="hljs-title">first</span>)</span><br><span class="hljs-class">                &#123;</span><br><span class="hljs-class">                    int uu=uset.find(<span class="hljs-title">v</span>[<span class="hljs-title">i</span>].<span class="hljs-title">second</span>*<span class="hljs-title">m</span>+<span class="hljs-title">j</span>);</span><br><span class="hljs-class">                    int vv=uset.find(<span class="hljs-title">v</span>[<span class="hljs-title">i</span>+1].<span class="hljs-title">second</span>*<span class="hljs-title">m</span>+<span class="hljs-title">j</span>);</span><br><span class="hljs-class">                    adj[uu].emplace_back(<span class="hljs-title">vv</span>);</span><br><span class="hljs-class">                    ++in[vv];</span><br><span class="hljs-class">                &#125;</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        vector&lt;int&gt; ans(<span class="hljs-title">n</span>*<span class="hljs-title">m</span>,1);</span><br><span class="hljs-class">        queue&lt;int&gt; q;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>*<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            if(<span class="hljs-title">uset</span>.<span class="hljs-title">find</span>(<span class="hljs-title">i</span>)==i&amp;&amp;in[i]==0)</span><br><span class="hljs-class">                q.emplace(<span class="hljs-title">i</span>);</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        while(!<span class="hljs-title">q</span>.<span class="hljs-title">empty</span>())</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            int u=q.front();</span><br><span class="hljs-class">            q.pop();</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> &amp;<span class="hljs-title">v</span>:<span class="hljs-title">adj</span>[<span class="hljs-title">u</span>])</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                ans[v]=ans[u]+1;</span><br><span class="hljs-class">                <span class="hljs-comment">--in[v];</span></span><br><span class="hljs-class">                if(<span class="hljs-title">in</span>[<span class="hljs-title">v</span>]==0)</span><br><span class="hljs-class">                    q.emplace(<span class="hljs-title">v</span>);</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        vector&lt;vector&lt;int&gt;&gt; res(<span class="hljs-title">n</span>,<span class="hljs-title">vector</span>&lt;<span class="hljs-title">int</span>&gt; (<span class="hljs-title">m</span>));</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                res[i][j]=ans[uset.find(<span class="hljs-title">i</span>*<span class="hljs-title">m</span>+<span class="hljs-title">j</span>)];</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        return res;</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">&#125;;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最小侧跳次数</title>
    <link href="/2023/01/21/%E6%9C%80%E5%B0%8F%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0/"/>
    <url>/2023/01/21/%E6%9C%80%E5%B0%8F%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E5%B0%8F%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0">最小侧跳次数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最小侧跳次数"><a class="markdownIt-Anchor" href="#最小侧跳次数"></a> 最小侧跳次数</h2><p><a href="https://leetcode.cn/problems/minimum-sideway-jumps/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。</p><p>给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。</p><p>比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。<br />这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。</p><p>比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。<br />这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>动态规划，用数组<code>d[j]</code>表示当前位置在j跑道上最短侧跳次数，对于每一个位置i，先找出<code>i-1</code>位置3个跑道中最小<code>d[j]</code>，记为cnt,然后用<code>d[j]=min(d[j],cnt+1)</code>进行更新即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    int minSideJumps(vector&lt;int&gt;&amp; obstacles) &#123;<br>        int <span class="hljs-attribute">inf</span>=0x3f3f3f3f;<br>        int <span class="hljs-attribute">n</span>=obstacles.size()-1;<br>        int d[3]=&#123;1,0,1&#125;;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=n;++i)<br>        &#123;<br>            int <span class="hljs-attribute">cnt</span>=inf;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=0;j&lt;3;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-attribute">j</span>==obstacles[i]-1)<br>                    d[j]=inf;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-attribute">cnt</span>=min(cnt,d[j]);<br>            &#125;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=0;j&lt;3;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j!=obstacles[i]-1)<br>                    d[j]=min(cnt+1,d[j]);<br>            &#125;<br>        &#125;<br>        return *min_element(d,d+3);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大公约数的个数</title>
    <link href="/2023/01/14/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2023/01/14/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="最大公约数的个数"><a class="markdownIt-Anchor" href="#最大公约数的个数"></a> 最大公约数的个数</h2><p><a href="">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个由正整数组成的数组 nums 。</p><p>数字序列的 最大公约数 定义为序列中所有整数的共有约数中的最大整数。</p><p>例如，序列 [4,6,16] 的最大公约数是 2 。<br />数组的一个 子序列 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。</p><p>例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。<br />计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [6,10,3]<br>输出：5<br>解释：不同的最大公约数为<span class="hljs-number"> 6 </span>、10 、3 、2 和<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>参考了大佬的思路，枚举<code>1~maxval</code>之间的数作为最大公约数的倍数，例如[1,2,3,…]，[2,4,6,…]，当某个数在nums中时，更新该子序列的最大公约数，如果循环结束最大公约数等于开始时的值，则<code>++ans</code>，可以通过代码帮助理解。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countDifferentSubsequenceGCDs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxv=*<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(maxv+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;t:nums)<br>            vis[t]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxv;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=maxv&amp;&amp;t!=i;j+=i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(vis[j]==<span class="hljs-literal">true</span>)<br>                    t=<span class="hljs-built_in">gcd</span>(t,j);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(t==i)<br>                ++ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>破解保险箱</title>
    <link href="/2023/01/10/%E7%A0%B4%E8%A7%A3%E4%BF%9D%E9%99%A9%E7%AE%B1/"/>
    <url>/2023/01/10/%E7%A0%B4%E8%A7%A3%E4%BF%9D%E9%99%A9%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%A0%B4%E8%A7%A3%E4%BF%9D%E9%99%A9%E7%AE%B1">破解保险箱</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="破解保险箱"><a class="markdownIt-Anchor" href="#破解保险箱"></a> 破解保险箱</h2><p><a href="https://leetcode.cn/problems/cracking-the-safe/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>There is a safe protected by a password. The password is a sequence of n digits where each digit can be in the range [0, k - 1].</p><p>The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the most recent n digits that were entered each time you type a digit.</p><p>For example, the correct password is “345” and you enter in “012345”:<br />After typing 0, the most recent 3 digits is “0”, which is incorrect.<br />After typing 1, the most recent 3 digits is “01”, which is incorrect.<br />After typing 2, the most recent 3 digits is “012”, which is incorrect.<br />After typing 3, the most recent 3 digits is “123”, which is incorrect.<br />After typing 4, the most recent 3 digits is “234”, which is incorrect.<br />After typing 5, the most recent 3 digits is “345”, which is correct and the safe unlocks.<br />Return any string of minimum length that will unlock the safe at some point of entering it.</p><p>example：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Input:</span> n = <span class="hljs-number">2</span>, k = <span class="hljs-number">2</span><br><span class="hljs-symbol">Output:</span> <span class="hljs-string">&quot;01100&quot;</span><br><span class="hljs-symbol">Explanation:</span> <span class="hljs-keyword">For</span> <span class="hljs-keyword">each</span> possible password:<br>- <span class="hljs-string">&quot;00&quot;</span> <span class="hljs-built_in">is</span> typed <span class="hljs-keyword">in</span> starting <span class="hljs-keyword">from</span> the <span class="hljs-number">4</span>th digit.<br>- <span class="hljs-string">&quot;01&quot;</span> <span class="hljs-built_in">is</span> typed <span class="hljs-keyword">in</span> starting <span class="hljs-keyword">from</span> the <span class="hljs-number">1s</span>t digit.<br>- <span class="hljs-string">&quot;10&quot;</span> <span class="hljs-built_in">is</span> typed <span class="hljs-keyword">in</span> starting <span class="hljs-keyword">from</span> the <span class="hljs-number">3</span>rd digit.<br>- <span class="hljs-string">&quot;11&quot;</span> <span class="hljs-built_in">is</span> typed <span class="hljs-keyword">in</span> starting <span class="hljs-keyword">from</span> the <span class="hljs-number">2</span>nd digit.<br>Thus <span class="hljs-string">&quot;01100&quot;</span> will unlock the safe. <span class="hljs-string">&quot;01100&quot;</span>, <span class="hljs-string">&quot;10011&quot;</span>, <span class="hljs-built_in">and</span> <span class="hljs-string">&quot;11001&quot;</span> would also unlock the safe.<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这题很大一部分难度在于读题，中文题目描述实在是太偷懒了，差评!!!😠<br />所以这里题目描述给英文的🐱</p><p>题意是说，给一个k值，然后有一个n位的密码，密码的每一位来自<code>0~k-1</code>之间，需要返回一个字符串，该字符串的后n位是可能的密码。</p><p>那么密码到底是怎么规定的呢？ 密码其实是n位数字的任意排列，比如<code>k=5,n=3</code>，如果3位取的是<code>012</code>，那么密码可能就是<code>000,001,002,010,011,012,021,022...,222</code>;如果3位取的是<code>123</code>,那么密码可能是<code>111,112,113,121,122,123....</code>，对于<code>k=5,n=3</code>的情况,n每一位都可以取<code>0,1,2,3,4</code>,所以满足条件的密码一共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>k</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">k^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>个</p><p>要返回的是一个字符串，包含了所有可能的密码，所以可以通过构造密码组成答案<br />通过代码可以更好的理解思路 <s>(其实是不想打字了🐶)</s></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_set&lt;<span class="hljs-built_in">string</span>&gt; st;<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">crackSafe</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> k</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> cnt=pow(k,n);<br>        <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ans</span>(<span class="hljs-params">n,<span class="hljs-string">&#x27;0&#x27;</span></span>)</span>;<br>        st.insert(ans);<br>        <span class="hljs-built_in">string</span> t=ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            t.erase(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=k<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;--j)<br>            &#123;<br>                t+=j+<span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(!st.count(t))<br>                &#123;<br>                    st.insert(t);<br>                    ans+=j+<span class="hljs-string">&#x27;0&#x27;</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    t.pop_back();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>减为0的最小操作数</title>
    <link href="/2023/01/07/%E5%87%8F%E4%B8%BA0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/"/>
    <url>/2023/01/07/%E5%87%8F%E4%B8%BA0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%87%8F%E4%B8%BA0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0">减为0的最小操作数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="减为0的最小操作数"><a class="markdownIt-Anchor" href="#减为0的最小操作数"></a> 减为0的最小操作数</h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。</p><p>如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。</p><p>示例</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span>]<span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>输出：<span class="hljs-number">2</span><br>解释：最佳解决方案是移除后两个元素，将 <span class="hljs-keyword">x</span> 减到 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>双指针，首先计算小于<code>x</code>的最长后缀长度，然后依次从左向右加入左边元素，每加入一个元素，就尝试减少后缀长度，当前缀后缀的元素和等于<code>x</code>时更新<code>ans</code></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> minOperations(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> x) &#123;<br>        <span class="hljs-built_in">int</span> n=nums.size();<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>,r=n;<br>        <span class="hljs-keyword">while</span>(r&gt;<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-keyword">sum</span>+nums[r<span class="hljs-number">-1</span>]&lt;=x)<br>            <span class="hljs-keyword">sum</span>+=nums[--r];<br>        <span class="hljs-keyword">if</span>(r==<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-keyword">sum</span>&lt;x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-keyword">sum</span>==x?n-r:INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> l=<span class="hljs-number">0</span>;l&lt;n;++l)<br>        &#123;<br>            <span class="hljs-keyword">sum</span>+=nums[l];<br>            <span class="hljs-keyword">while</span>(r&lt;n&amp;&amp;<span class="hljs-keyword">sum</span>&gt;x)<span class="hljs-comment">//减少后缀</span><br>                <span class="hljs-keyword">sum</span>-=nums[r++];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&gt;x)<span class="hljs-comment">//前缀过大</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>==x)<br>                ans=min(ans,l+<span class="hljs-number">1</span>+n-r);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans&gt;n ? <span class="hljs-number">-1</span>:ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>考场就座</title>
    <link href="/2022/12/30/%E8%80%83%E5%9C%BA%E5%B0%B1%E5%BA%A7/"/>
    <url>/2022/12/30/%E8%80%83%E5%9C%BA%E5%B0%B1%E5%BA%A7/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%80%83%E5%9C%BA%E5%B0%B1%E5%BA%A7">考场就座</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="考场就座"><a class="markdownIt-Anchor" href="#考场就座"></a> 考场就座</h2><p><a href="https://leetcode.cn/problems/exam-room/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在考场里，一排有 N 个座位，分别编号为 0, 1, 2, …, N-1 。</p><p>当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)</p><p>返回 ExamRoom(int N) 类，它有两个公开的函数：其中，函数 ExamRoom.seat() 会返回一个 int （整型数据），代表学生坐的位置；函数 ExamRoom.leave(int p) 代表坐在座位 p 上的学生现在离开了考场。每次调用 ExamRoom.leave(p) 时都保证有学生坐在座位 p 上。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题主要解决坐在哪里的问题，设置一个<code>set</code>，每次安排座位，遍历一遍<code>set</code>，找出最大位置处，在此过程中，需要一个<code>pre</code>记录上一个座位的位置，然后<code>maxd</code>记录当前最大距离，如果当前位置距离大于<code>maxd</code>,那就更新插入位置和<code>maxd</code>即可</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExamRoom</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m;<br>    set&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-built_in">ExamRoom</span>(<span class="hljs-type">int</span> n) &#123;<br>        m=n;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">seat</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> pre=<span class="hljs-number">-1</span>,maxd=<span class="hljs-number">0</span>,p=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; t:st)<br>        &#123;<br>            <span class="hljs-type">int</span> d=(t-pre)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(d&gt;maxd)<br>            &#123;<br>                maxd=d;<br>                p= pre==<span class="hljs-number">-1</span>?<span class="hljs-number">0</span>:pre+d;<br>            &#125;<br>            pre=t;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(m<span class="hljs-number">-1</span>-pre&gt;maxd)<br>            p=m<span class="hljs-number">-1</span>;<br>        st.<span class="hljs-built_in">insert</span>(p);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leave</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>        st.<span class="hljs-built_in">erase</span>(p);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>统计特殊整数</title>
    <link href="/2022/12/22/%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E6%95%B4%E6%95%B0/"/>
    <url>/2022/12/22/%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E6%95%B4%E6%95%B0">统计特殊整数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="统计特殊整数"><a class="markdownIt-Anchor" href="#统计特殊整数"></a> 统计特殊整数</h2><p><a href="https://leetcode.cn/problems/count-special-integers/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。</p><p>给你一个 正 整数 n ，请你返回区间 [1, n] 之间特殊整数的数目。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>数位dp模板题，需要按位进行分情况讨论.</p><ul><li><p>用<code>dp[i][mask]</code>记录第i位状态为mask时的数目</p></li><li><p>定义了函数<code>f(int i,int mask,bool limit,bool isnum)</code></p></li><li><p><code>i</code>表示当前计算第<code>i</code>位，<code>mask</code>存储之前使用过得数字，<code>limit</code>表示当前位可以取的值是否受限制，<code>isnum</code>表示当前位前面是否有数字</p></li></ul><p>具体实现看代码即可</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSpecialNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        string s=<span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>,<span class="hljs-number">-1</span>));<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">bool</span>,<span class="hljs-type">bool</span>)&gt; f=[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> mask,<span class="hljs-type">bool</span> limit,<span class="hljs-type">bool</span> isnum)-&gt;<span class="hljs-type">int</span>&#123;<br>            <span class="hljs-keyword">if</span>(i==len)<br>                <span class="hljs-keyword">return</span> isnum;<br>            <span class="hljs-comment">//剪枝，如果当前位无limit且前面有数字，则可以利用之前计算过的结果</span><br>            <span class="hljs-keyword">if</span>(!limit&amp;&amp;isnum&amp;&amp;dp[i][mask]&gt;=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> dp[i][mask];<br>            <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//如果当前位之前没有填数字，跳过当前位</span><br>            <span class="hljs-keyword">if</span>(!isnum)<br>                res=<span class="hljs-built_in">f</span>(i+<span class="hljs-number">1</span>,mask,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>            <span class="hljs-type">int</span> up,down;<br>            <span class="hljs-comment">//如果有limit上界为s[i]，没有则上界为9</span><br>            up= limit ? s[i]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">9</span>;<br>            <span class="hljs-comment">//如果前面的位有数字，下界为0，否则下界为1</span><br>            down= isnum ? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=down;t&lt;=up;++t)<br>            &#123;<br>                <span class="hljs-comment">//如果当前数字没用过,则继续</span><br>                <span class="hljs-keyword">if</span>((mask&gt;&gt;t&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)<br>                &#123;<br>                    res+=<span class="hljs-built_in">f</span>(i+<span class="hljs-number">1</span>,mask|<span class="hljs-number">1</span>&lt;&lt;t,limit&amp;&amp;t==up,<span class="hljs-literal">true</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!limit&amp;&amp;isnum)<br>                 dp[i][mask]=res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分袋子里的球</title>
    <link href="/2022/12/20/%E5%88%86%E8%A2%8B%E5%AD%90%E9%87%8C%E7%9A%84%E7%90%83/"/>
    <url>/2022/12/20/%E5%88%86%E8%A2%8B%E5%AD%90%E9%87%8C%E7%9A%84%E7%90%83/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%88%86%E8%A2%8B%E5%AD%90%E9%87%8C%E7%9A%84%E7%90%83">分袋子里的球</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="分袋子里的球"><a class="markdownIt-Anchor" href="#分袋子里的球"></a> 分袋子里的球</h2><p><a href="">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。</p><p>你可以进行如下操作至多 maxOperations 次：</p><p>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。<br />比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。<br />你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。</p><p>请你返回进行上述操作后的最小开销。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用到二分的思想(<s>为什么我就想不到😢</s>)，对于二分的中间量mid，表示把当前所有数字全部分成小于等于mid的数字，统计操作次数，如果操作次数小于规定次数，r=mid-1，继续寻找更小的符合要求的mid，否则，l=mid+1,调大mid的值。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumSize</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> maxOperations)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=*<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,mid;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)<br>        &#123;<br>            mid=(l+r)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> cnt=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:nums)<br>                cnt+=(x<span class="hljs-number">-1</span>) / mid;<br>            <span class="hljs-keyword">if</span>(cnt&lt;=maxOperations)<br>            &#123;<br>                ans=mid;<br>                r=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>边长度限制的路径</title>
    <link href="/2022/12/14/%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/12/14/%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84">边长度限制的路径</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="边长度限制的路径"><a class="markdownIt-Anchor" href="#边长度限制的路径"></a> 边长度限制的路径</h2><p><a href="https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个 n 个点组成的无向图边集 edgeList ，其中 edgeList[i] = [ui, vi, disi] 表示点 ui 和点 vi 之间有一条长度为 disi 的边。请注意，两个点之间可能有 超过一条边 。</p><p>给你一个查询数组queries ，其中 queries[j] = [pj, qj, limitj] ，你的任务是对于每个查询 queries[j] ，判断是否存在从 pj 到 qj 的路径，且这条路径上的每一条边都 严格小于 limitj 。</p><p>请你返回一个 布尔数组 answer ，其中 answer.length == queries.length ，当 queries[j] 的查询结果为 true 时， answer 第 j 个值为 true ，否则为 false 。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><blockquote><p>主要用到并查集的思想，先将edgelist和queries中的边按长度升序排序，对于queries的每条边，先将edgelist中长度小于limit的边加入并查集，然后再判断queries的p,q是否连通，如果是，说明存在p到q的路径，而且因为当前并查集中的边都小于此query的limit，所以p到q路径上的所有边也小于limit，该query的结果为true，否则为false。</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><p>我在实现并查集时习惯初始化为-1，但这道题不知道为什么不能初始化为-1，后面后机会再看吧😢</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vset,<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(vset[a]==a)<br>            <span class="hljs-keyword">return</span> a;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> vset[a]=<span class="hljs-built_in">find</span>(vset,vset[a]);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">distanceLimitedPathsExist</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edgeList, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(edgeList.<span class="hljs-built_in">begin</span>(),edgeList.<span class="hljs-built_in">end</span>(),[](vector&lt;<span class="hljs-type">int</span>&gt;&amp; a,vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>]&lt;b[<span class="hljs-number">2</span>];<br>        &#125;);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vset</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-built_in">iota</span>(vset.<span class="hljs-built_in">begin</span>(),vset.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">idx</span><span class="hljs-params">(queries.size())</span></span>;<br>        <span class="hljs-built_in">iota</span>(idx.<span class="hljs-built_in">begin</span>(),idx.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">sort</span>(idx.<span class="hljs-built_in">begin</span>(),idx.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;<br>            <span class="hljs-keyword">return</span> queries[a][<span class="hljs-number">2</span>]&lt;queries[b][<span class="hljs-number">2</span>];<br>        &#125;);<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(queries.size())</span></span>;<br>        <span class="hljs-type">int</span> sz=edgeList.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:idx)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(k&lt;sz&amp;&amp;edgeList[k][<span class="hljs-number">2</span>]&lt;queries[i][<span class="hljs-number">2</span>])<br>            &#123;<br>                <span class="hljs-type">int</span> x=<span class="hljs-built_in">find</span>(vset,edgeList[k][<span class="hljs-number">0</span>]);<br>                <span class="hljs-type">int</span> y=<span class="hljs-built_in">find</span>(vset,edgeList[k][<span class="hljs-number">1</span>]);<br>                vset[x]=y;<br>                ++k;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(vset,queries[i][<span class="hljs-number">0</span>])==<span class="hljs-built_in">find</span>(vset,queries[i][<span class="hljs-number">1</span>]))<br>                ans[i]=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆长方体</title>
    <link href="/2022/12/10/%E5%A0%86%E9%95%BF%E6%96%B9%E4%BD%93/"/>
    <url>/2022/12/10/%E5%A0%86%E9%95%BF%E6%96%B9%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%A0%86%E9%95%BF%E6%96%B9%E4%BD%93">堆长方体</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="堆长方体"><a class="markdownIt-Anchor" href="#堆长方体"></a> 堆长方体</h2><p><a href="https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你 n 个长方体 cuboids ，其中第 i 个长方体的长宽高表示为 cuboids[i] = [widthi, lengthi, heighti]（下标从 0 开始）。请你从 cuboids 选出一个 子集 ，并将它们堆叠起来。</p><p>如果 widthi &lt;= widthj 且 lengthi &lt;= lengthj 且 heighti &lt;= heightj ，你就可以将长方体 i 堆叠在长方体 j 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。</p><p>返回 堆叠长方体 cuboids 可以得到的 最大高度 。</p><p>示例:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cuboids = [[50,45,20],[95,37,53],[45,23,12]]<br>输出：190<br>解释：<br>第<span class="hljs-number"> 1 </span>个长方体放在底部，53x37 的一面朝下，高度为<span class="hljs-number"> 95 </span>。<br>第<span class="hljs-number"> 0 </span>个长方体放在中间，45x20 的一面朝下，高度为<span class="hljs-number"> 50 </span>。<br>第<span class="hljs-number"> 2 </span>个长方体放在上面，23x12 的一面朝下，高度为<span class="hljs-number"> 45 </span>。<br>总高度是<span class="hljs-number"> 95 </span>+<span class="hljs-number"> 50 </span>+<span class="hljs-number"> 45 </span>=<span class="hljs-number"> 190 </span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用到动态规划的思路，<code>dp[i]</code>表示到第i个长方体的最大高度，状态方程为<code>dp[i]=max(dp[i],dp[j]+cu[i][2])</code></p><p>动态规划之前，先对每个长方体内部排序，然后按<code>w,h,l</code>之和排序</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int maxHeight(vector&lt;vector&lt;int&gt;&gt;&amp; cuboids) &#123;<br>        int n=cuboids.size();<br>        for(auto&amp; t:cuboids)<br>        &#123;<br>            sort(t.begin(),t.end());<br>        &#125;<br>        sort(cuboids.begin(),cuboids.end(),<span class="hljs-comment">[&amp;]</span>(vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;<br>            return a<span class="hljs-comment">[0]</span>+a<span class="hljs-comment">[1]</span>+a<span class="hljs-comment">[2]</span>&lt;b<span class="hljs-comment">[0]</span>+b<span class="hljs-comment">[1]</span>+b<span class="hljs-comment">[2]</span>;<br>        &#125;);<br>        vector&lt;int&gt; dp(n);<br>        int ans=0;<br>        for(int i=0;i&lt;n;++i)<br>        &#123;<br>            dp<span class="hljs-comment">[i]</span>=cuboids<span class="hljs-comment">[i]</span><span class="hljs-comment">[2]</span>;<br>            for(int j=0;j&lt;i;++j)<br>            &#123;<br>                if(cuboids<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>&gt;=cuboids<span class="hljs-comment">[j]</span><span class="hljs-comment">[0]</span>&amp;&amp;cuboids<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span>&gt;=cuboids<span class="hljs-comment">[j]</span><span class="hljs-comment">[1]</span>&amp;&amp;cuboids<span class="hljs-comment">[i]</span><span class="hljs-comment">[2]</span>&gt;=cuboids<span class="hljs-comment">[j]</span><span class="hljs-comment">[2]</span>)<br>                &#123;<br>                    dp<span class="hljs-comment">[i]</span>=max(dp<span class="hljs-comment">[i]</span>,dp<span class="hljs-comment">[j]</span>+cuboids<span class="hljs-comment">[i]</span><span class="hljs-comment">[2]</span>);<br>                &#125;<br>            &#125;<br>            ans=max(ans,dp<span class="hljs-comment">[i]</span>);<br>        &#125;<br>        return ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>甜点成本</title>
    <link href="/2022/12/04/%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC/"/>
    <url>/2022/12/04/%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="甜点成本"><a class="markdownIt-Anchor" href="#甜点成本"></a> 甜点成本</h2><p><a href="https://leetcode.cn/problems/closest-dessert-cost/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则：</p><p>必须选择 一种 冰激凌基料。<br />可以添加 一种或多种 配料，也可以不添加任何配料。<br />每种类型的配料 最多两份 。<br />给你以下三个输入：</p><p>baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。<br />toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。<br />target ，一个整数，表示你制作甜点的目标价格。<br />你希望自己做的甜点总成本尽可能接近目标价格 target 。</p><p>返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。</p><p>示例</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：baseCosts = [2,3], toppingCosts = [4,5,100], target = 18<br>输出：17<br>解释：考虑下面的方案组合（所有下标均从<span class="hljs-number"> 0 </span>开始）：<br>- 选择<span class="hljs-number"> 1 </span>号基料：成本 3<br>- 选择<span class="hljs-number"> 1 </span>份<span class="hljs-number"> 0 </span>号配料：成本<span class="hljs-number"> 1 </span>x<span class="hljs-number"> 4 </span>= 4<br>- 选择<span class="hljs-number"> 2 </span>份<span class="hljs-number"> 1 </span>号配料：成本<span class="hljs-number"> 2 </span>x<span class="hljs-number"> 5 </span>= 10<br>- 选择<span class="hljs-number"> 0 </span>份<span class="hljs-number"> 2 </span>号配料：成本<span class="hljs-number"> 0 </span>x<span class="hljs-number"> 100 </span>= 0<br>总成本：3 +<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 10 </span>+<span class="hljs-number"> 0 </span>=<span class="hljs-number"> 17 </span>。不存在总成本为<span class="hljs-number"> 18 </span>的甜点制作方案。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这是一道背包问题的变种，可以把所有的方案分成两大类，总成本大于target的和总成本小于target的，我们要做的就是用一个变量res记录大于target的最小成本，然后对小于target的方案进行动态规划。</p><p>首先维护一个数组<code>can[]</code>,表示每个小于target的方案是否合法（即可以通过base或者配料组合得到的数值），先遍历basecosts，如果有x小于target的，则<code>can[x]=true</code>，大于target则更新res。然后开始动态规划，每个配料遍历两次，如果加上当前配料后成本大于target，则更新res，如果当前成本不合法，那么有可能减去当前配料后就合法了，所以据此更新当前的<code>can</code></p><p>最后，只需要考虑在<code>res-target</code>的距离内，小于target的方案有没有合法的，因为如果大于这个距离，那么最接近target的方案就是res了。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> closestCost(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; baseCosts, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; toppingCosts, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-built_in">int</span> b=*min_element(baseCosts.begin(),baseCosts.<span class="hljs-keyword">end</span>());<br>        <span class="hljs-keyword">if</span>(b&gt;=<span class="hljs-keyword">target</span>)<br>            <span class="hljs-keyword">return</span> b;<br>        vector&lt;bool&gt; can(<span class="hljs-keyword">target</span>+<span class="hljs-number">1</span>,false);<br>        <span class="hljs-built_in">int</span> res=<span class="hljs-number">2</span>*<span class="hljs-keyword">target</span>-b;<br>        for(<span class="hljs-built_in">int</span> &amp;t:baseCosts)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(t&lt;=<span class="hljs-keyword">target</span>)<br>                can[t]=true;<br>            <span class="hljs-keyword">else</span><br>                res=<span class="hljs-built_in">min</span>(res,t);<br>        &#125;<br>        for(<span class="hljs-built_in">int</span>&amp; t:toppingCosts)<br>        &#123;<br>            for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;++i)<br>            &#123;<br>                for(<span class="hljs-built_in">int</span> j=<span class="hljs-keyword">target</span>;j&gt;=<span class="hljs-number">0</span>;--j)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(can[j]&amp;&amp;j+t&gt;<span class="hljs-keyword">target</span>)<br>                        res=<span class="hljs-built_in">min</span>(res,j+t);<br>                    <span class="hljs-keyword">if</span>(j-t&gt;=<span class="hljs-number">0</span>)<br>                        can[j]=can[j]|can[j-t];<br>                &#125;<br>            &#125;<br>        &#125;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;=res-<span class="hljs-keyword">target</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(can[<span class="hljs-keyword">target</span>-i])<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">target</span>-i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动球的最小次数</title>
    <link href="/2022/12/02/%E7%A7%BB%E5%8A%A8%E7%90%83%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/12/02/%E7%A7%BB%E5%8A%A8%E7%90%83%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%A7%BB%E5%8A%A8%E6%89%80%E6%9C%89%E7%90%83%E5%88%B0%E6%AF%8F%E4%B8%AA%E7%9B%92%E5%AD%90%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0">移动所有球到每个盒子所需的最小操作数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="移动所有球到每个盒子所需的最小操作数"><a class="markdownIt-Anchor" href="#移动所有球到每个盒子所需的最小操作数"></a> 移动所有球到每个盒子所需的最小操作数</h2><p><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有 n 个盒子。给你一个长度为 n 的二进制字符串 boxes ，其中 boxes[i] 的值为 ‘0’ 表示第 i 个盒子是 空 的，而 boxes[i] 的值为 ‘1’ 表示盒子里有 一个 小球。</p><p>在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。第 i 个盒子和第 j 个盒子相邻需满足 abs(i - j) == 1 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p><p>返回一个长度为 n 的数组 answer ，其中 answer[i] 是将所有小球移动到第 i 个盒子所需的 最小 操作数。</p><p>每个 answer[i] 都需要根据盒子的 初始状态 进行计算。</p><p>示例</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：boxes = &quot;110&quot;<br>输出：[1,1,3]<br>解释：每个盒子对应的最小操作数如下：<br>1) 第<span class="hljs-number"> 1 </span>个盒子：将一个小球从第<span class="hljs-number"> 2 </span>个盒子移动到第<span class="hljs-number"> 1 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。<br>2) 第<span class="hljs-number"> 2 </span>个盒子：将一个小球从第<span class="hljs-number"> 1 </span>个盒子移动到第<span class="hljs-number"> 2 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。<br>3) 第<span class="hljs-number"> 3 </span>个盒子：将一个小球从第<span class="hljs-number"> 1 </span>个盒子移动到第<span class="hljs-number"> 3 </span>个盒子，需要<span class="hljs-number"> 2 </span>步操作。将一个小球从第<span class="hljs-number"> 2 </span>个盒子移动到第<span class="hljs-number"> 3 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。共计<span class="hljs-number"> 3 </span>步操作。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题因为样例少，所以暴力也能过，这里用前缀和与后缀和进行优化。</p><p><code>pre[i]</code>表示把i位置之前所有的1移到i位置所需要的次数，状态方程<code>pre[i]=pre[i-1]+presum</code>,可以看做先把前面的所有球移动到i-1位置，需要<code>pre[i-1]</code>次，然后i-1位置一共有presum个小球，把他们依次移动到i位置即可</p><p>后缀同理，那么每个位置所需的移动次数就是<code>pre[i]+aft[i]</code></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minOperations</span><span class="hljs-params">(string boxes)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = boxes.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">aft</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-type">int</span> prsum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)<br>                pre[i] = pre[i - <span class="hljs-number">1</span>] + prsum;<br>            <span class="hljs-keyword">if</span>(boxes[i] == <span class="hljs-string">&#x27;1&#x27;</span>) <br>                ++prsum;<br>        &#125;<br><br>        <span class="hljs-type">int</span> afsum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&lt;n<span class="hljs-number">-1</span>)<br>                aft[i] = aft[i + <span class="hljs-number">1</span>] + afsum;<br>            <span class="hljs-keyword">if</span>(boxes[i] == <span class="hljs-string">&#x27;1&#x27;</span>) <br>                ++afsum;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i++)<br>            res[i] = pre[i] + aft[i];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大频率栈</title>
    <link href="/2022/11/30/%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/"/>
    <url>/2022/11/30/%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="最大频率栈"><a class="markdownIt-Anchor" href="#最大频率栈"></a> 最大频率栈</h2><p><a href="https://leetcode.cn/problems/maximum-frequency-stack/description/">题目</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。</p><p>实现 FreqStack 类:</p><p>FreqStack() 构造一个空的堆栈。<br />void push(int val) 将一个整数 val 压入栈顶。<br />int pop() 删除并返回堆栈中出现频率最高的元素。<br />如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</p><p>示例</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<br>[<span class="hljs-string">&quot;FreqStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>],<br>[[],[<span class="hljs-number">5</span>],[<span class="hljs-number">7</span>],[<span class="hljs-number">5</span>],[<span class="hljs-number">7</span>],[<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>],[],[],[],[]]<br>输出：[<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>]<br>解释：<br>FreqStack = <span class="hljs-keyword">new</span> FreqStack();<br>freqStack.<span class="hljs-built_in">push</span> (<span class="hljs-number">5</span>);<span class="hljs-comment">//堆栈为 [5]</span><br>freqStack.<span class="hljs-built_in">push</span> (<span class="hljs-number">7</span>);<span class="hljs-comment">//堆栈是 [5,7]</span><br>freqStack.<span class="hljs-built_in">push</span> (<span class="hljs-number">5</span>);<span class="hljs-comment">//堆栈是 [5,7,5]</span><br>freqStack.<span class="hljs-built_in">push</span> (<span class="hljs-number">7</span>);<span class="hljs-comment">//堆栈是 [5,7,5,7]</span><br>freqStack.<span class="hljs-built_in">push</span> (<span class="hljs-number">4</span>);<span class="hljs-comment">//堆栈是 [5,7,5,7,4]</span><br>freqStack.<span class="hljs-built_in">push</span> (<span class="hljs-number">5</span>);<span class="hljs-comment">//堆栈是 [5,7,5,7,4,5]</span><br>freqStack.<span class="hljs-built_in">pop</span> ();<span class="hljs-comment">//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。</span><br>freqStack.<span class="hljs-built_in">pop</span> ();<span class="hljs-comment">//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。</span><br>freqStack.<span class="hljs-built_in">pop</span> ();<span class="hljs-comment">//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。</span><br>freqStack.<span class="hljs-built_in">pop</span> ();<span class="hljs-comment">//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用一个map记录数字和对应频率，然后每一个频率对应一个栈，每当加入一个元素，就把这个元素加入到对应频率的栈中，取出时从最大频率对应的栈弹出元素即可。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FreqStack</span> &#123;<br><span class="hljs-keyword">public</span>: <br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>    unordered_map&lt;<span class="hljs-type">int</span>,stack&lt;<span class="hljs-type">int</span>&gt;&gt; st;<br>    <span class="hljs-type">int</span> maxfreq;<br>    <span class="hljs-built_in">FreqStack</span>() &#123;<br>        maxfreq=<span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ++mp[val];<br>        st[mp[val]].<span class="hljs-built_in">push</span>(val);<br>        maxfreq=<span class="hljs-built_in">max</span>(maxfreq,mp[val]);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=st[maxfreq].<span class="hljs-built_in">top</span>();<br>        st[maxfreq].<span class="hljs-built_in">pop</span>();<br>        --mp[res];<br>        <span class="hljs-keyword">if</span>(st[maxfreq].<span class="hljs-built_in">empty</span>())<br>            --maxfreq;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大平均值和的分组</title>
    <link href="/2022/11/28/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/"/>
    <url>/2022/11/28/%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84">最大平均值和的分组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最大平均值和的分组"><a class="markdownIt-Anchor" href="#最大平均值和的分组"></a> 最大平均值和的分组</h2><p><a href="https://leetcode.cn/problems/largest-sum-of-averages/description/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个相邻的非空子数组 。 分数 由每个子数组内的平均值的总和构成。</p><p>注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。</p><p>返回我们所能得到的最大 分数 是多少。答案误差在 10-6 内被视为是正确的。</p><p>示例</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: nums = [<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>], k = <span class="hljs-number">3</span><br>输出: <span class="hljs-number">20.00000</span><br>解释: <br>nums 的最优分组是[<span class="hljs-number">9</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">9</span>]. 得到的分数是 <span class="hljs-number">9</span> + (<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>) / <span class="hljs-number">3</span> + <span class="hljs-number">9</span> = <span class="hljs-number">20.</span> <br>我们也可以把 nums 分成[<span class="hljs-number">9</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>]. <br>这样的分组得到的分数为 <span class="hljs-number">5</span> + <span class="hljs-number">2</span> + <span class="hljs-number">6</span> = <span class="hljs-number">13</span>, 但不是最大值.<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>动态规划，用<code>dp[i][j]</code>表示前i个数分j组时的最大平均值和，然后写出状态方程:<br /><code>dp[i][j]=max(dp[i][j],dp[x][j-1]+(sum[i]-sum[x])/(i-x))</code></p><ul><li>j:<code>2~k</code></li><li>i:<code>j~n</code></li><li>x:<code>j-1~i</code></li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">largestSumOfAverages</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            sum[i+<span class="hljs-number">1</span>]=sum[i]+nums[i];<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(k+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            dp[i][<span class="hljs-number">1</span>]=sum[i]/i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=k;++j)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=j;i&lt;=n;++i)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=j<span class="hljs-number">-1</span>;x&lt;i;++x)<br>                &#123;<br>                    dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j],dp[x][j<span class="hljs-number">-1</span>]+(sum[i]-sum[x])/(i-x));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最长公共子串</title>
    <link href="/2022/11/27/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/11/27/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2">最长公共子串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82">题目要求</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最长公共子串"><a class="markdownIt-Anchor" href="#最长公共子串"></a> 最长公共子串</h2><h3 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h3><p>给定两个字符串str1和str2,输出两个字符串的最长公共子串，如果最长公共子串为空，输出-1。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>一道模板题，这里要输出最长的公共子串而不是其长度，代码如下</p><p>注意，<code>starti</code>从第一个字符串末尾开始，<code>startj</code>从第二个字符串开头开始</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>string maxsubstr(string s1,string s2)<br>&#123;<br>int <span class="hljs-attribute">l1</span>=s1.size();<br>int <span class="hljs-attribute">l2</span>=s2.size();<br>int <span class="hljs-attribute">maxlen</span>=0,curlen=0;<br>int <span class="hljs-attribute">starti</span>=l1-1,startj=0;<br>int <span class="hljs-attribute">endi</span>=-1;<br><span class="hljs-keyword">while</span>(startj&lt;l2)<br>&#123;<br><span class="hljs-attribute">curlen</span>=0;<br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=starti,j=startj;i&lt;l1&amp;&amp;j&lt;l2;++i,++j)<br>&#123;<br><span class="hljs-keyword">if</span>(s1[i]==s2[j])<br>&#123;<br>++curlen;<br><span class="hljs-keyword">if</span>(curlen&gt;maxlen)<br>&#123;<br><span class="hljs-attribute">maxlen</span>=curlen;<br><span class="hljs-attribute">endi</span>=i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-attribute">curlen</span>=0;<br>&#125;<br><span class="hljs-keyword">if</span>(starti&gt;0)<br>--starti;<br><span class="hljs-keyword">else</span><br>++startj;<br>&#125;<br>return <span class="hljs-attribute">maxlen</span>==0 ? <span class="hljs-string">&quot;-1&quot;</span>:s1.substr(endi-maxlen+1,maxlen);<br>&#125;<br><br>int main()<br>&#123;<br>string s1,s2;<br>cin&gt;&gt;s1&gt;&gt;s2;<br>cout&lt;&lt;maxsubstr(s1,s2)&lt;&lt;endl;<br>return 0;<br><br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>细分图的可到达节点</title>
    <link href="/2022/11/26/%E7%BB%86%E5%88%86%E5%9B%BE%E7%9A%84%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9/"/>
    <url>/2022/11/26/%E7%BB%86%E5%88%86%E5%9B%BE%E7%9A%84%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BB%86%E5%88%86%E5%9B%BE%E7%9A%84%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9">细分图的可到达节点</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="细分图的可到达节点"><a class="markdownIt-Anchor" href="#细分图的可到达节点"></a> 细分图的可到达节点</h2><p><a href="https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个无向图（原始图），图中有 n 个节点，编号从 0 到 n - 1 。你决定将图中的每条边 细分 为一条节点链，每条边之间的新节点数各不相同。</p><p>图用由边组成的二维数组 edges 表示，其中 edges[i] = [ui, vi, cnti] 表示原始图中节点 ui 和 vi 之间存在一条边，cnti 是将边 细分 后的新节点总数。注意，cnti == 0 表示边不可细分。</p><p>要 细分 边 [ui, vi] ，需要将其替换为 (cnti + 1) 条新边，和 cnti 个新节点。新节点为 x1, x2, …, xcnti ，新边为 [ui, x1], [x1, x2], [x2, x3], …, [xcnti+1, xcnti], [xcnti, vi] 。</p><p>现在得到一个 新的细分图 ，请你计算从节点 0 出发，可以到达多少个节点？如果节点间距离是 maxMoves 或更少，则视为 可以到达 。</p><p>给你原始图和 maxMoves ，返回 新的细分图中从节点 0 出发 可到达的节点数 。</p><p>示例</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：edges = <span class="hljs-comment">[<span class="hljs-comment">[0,1,4]</span>,<span class="hljs-comment">[1,2,6]</span>,<span class="hljs-comment">[0,2,8]</span>,<span class="hljs-comment">[1,3,1]</span>]</span>, maxMoves = 10, n = 4<br>输出：23<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题看了一遍题没太看懂，本来想直接cv了😢，看了眼题解发现是最短路，就参考大佬灵茶山的题解写了，顺便复习一下堆优化的dijkstra和链式前向星存图</p><p><a href="https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/solutions/1991509/tu-jie-zhuan-huan-cheng-dan-yuan-zui-dua-6l8o/">链接</a></p><ul><li>首先需要进行一边dijkstra，求出0到其他点的最短路</li><li>遍历所有顶点，小于maxmoves则<code>++ans</code></li><li>遍历所有边，设一条边的起点和终点为u和v，分别用maxmoves减去<code>dis[u]</code>和<code>dis[v]</code>得到a和b,这条边上符合要求的点个数即为<code>min(a+b,cnt)</code>,加入到ans中即可</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> dis[<span class="hljs-number">3005</span>];<br>    <span class="hljs-built_in">bool</span> vis[<span class="hljs-number">3005</span>];<br>    static <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">int</span> head[N];<br>    <span class="hljs-built_in">int</span> cnt;<br>    struct edges<br>    &#123;<br>        <span class="hljs-built_in">int</span> to,next,w;<br>    &#125;e[<span class="hljs-number">2</span>*N];<br><br>    struct node<br>    &#123;<br>        <span class="hljs-built_in">int</span> n,w;<br>        node(<span class="hljs-built_in">int</span> nn,<span class="hljs-built_in">int</span> ww):n(nn),w(ww)&#123;&#125;<br>        <span class="hljs-built_in">bool</span> operator &lt; (<span class="hljs-keyword">const</span> node &amp; t) <span class="hljs-keyword">const</span>&#123;<br>            <span class="hljs-keyword">return</span> w&gt;t.w;<br>        &#125;<br>    &#125;;<br>    priority_queue&lt;node&gt; q;<br>    <span class="hljs-built_in">void</span> add(<span class="hljs-built_in">int</span> u,<span class="hljs-built_in">int</span> v,<span class="hljs-built_in">int</span> w)<br>    &#123;<br>        ++cnt;<br>        e[cnt].to=v;<br>        e[cnt].w=w;<br>        e[cnt].next=head[u];<br>        head[u]=cnt;<br>    &#125;<br>    <span class="hljs-built_in">int</span> reachableNodes(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; edges, <span class="hljs-built_in">int</span> maxMoves, <span class="hljs-built_in">int</span> n) <br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">auto</span> &amp;e: edges) <br>        &#123;<br>            <span class="hljs-built_in">int</span> u = e[<span class="hljs-number">0</span>], v = e[<span class="hljs-number">1</span>], cnt = e[<span class="hljs-number">2</span>];<br>            add(u,v,cnt+<span class="hljs-number">1</span>);<br>            add(v,u,cnt+<span class="hljs-number">1</span>);<br>        &#125;<br>        memset(dis,<span class="hljs-number">0x3f</span>,sizeof(dis));<br>        <span class="hljs-built_in">int</span> u,v,w;<br>        dis[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        q.push(node(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">while</span>(!q.empty())<br>        &#123;<br>            node t=q.top();<br>            q.pop();<br>            u=t.n;<br>            <span class="hljs-keyword">if</span>(!vis[u])<br>            &#123;<br>                vis[u]=<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=head[u];i;i=e[i].next)<br>                &#123;<br>                    v=e[i].to;<br>                    w=e[i].w;<br>                    <span class="hljs-keyword">if</span>(dis[u]+w&lt;dis[v])<br>                    &#123;<br>                        dis[v]=dis[u]+w;<br>                        <span class="hljs-keyword">if</span>(!vis[v])<br>                            q.push(node(v,dis[v]));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// return dis[2];</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(dis[i]&lt;=maxMoves)<br>                ++ans;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">auto</span> &amp;e: edges) <br>        &#123;<br>            <span class="hljs-built_in">int</span> u = e[<span class="hljs-number">0</span>], v = e[<span class="hljs-number">1</span>], cnt = e[<span class="hljs-number">2</span>];<br>            <span class="hljs-built_in">int</span> a=max(maxMoves-dis[u],<span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">int</span> b=max(maxMoves-dis[v],<span class="hljs-number">0</span>);<br>            ans+=min(a+b,cnt);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>情感丰富的文字</title>
    <link href="/2022/11/25/%E6%83%85%E6%84%9F%E4%B8%B0%E5%AF%8C%E7%9A%84%E6%96%87%E5%AD%97/"/>
    <url>/2022/11/25/%E6%83%85%E6%84%9F%E4%B8%B0%E5%AF%8C%E7%9A%84%E6%96%87%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="情感丰富的文字"><a class="markdownIt-Anchor" href="#情感丰富的文字"></a> 情感丰富的文字</h2><p><a href="https://leetcode.cn/problems/expressive-words/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有时候人们会用重复写一些字母来表示额外的感受，比如 “hello” -&gt; “heeellooo”, “hi” -&gt; “hiii”。我们将相邻字母都相同的一串字符定义为相同字母组，例如：“h”, “eee”, “ll”, “ooo”。</p><p>对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 c ），然后往其中添加相同的字母 c 使其长度达到 3 或以上。</p><p>例如，以 “hello” 为例，我们可以对字母组 “o” 扩张得到 “hellooo”，但是无法以同样的方法得到 “helloo” 因为字母组 “oo” 长度小于 3。此外，我们可以进行另一种扩张 “ll” -&gt; “lllll” 以获得 “helllllooo”。如果 S = “helllllooo”，那么查询词 “hello” 是可扩张的，因为可以对它执行这两种扩张操作使得 query = “hello” -&gt; “hellooo” -&gt; “helllllooo” = S。</p><p>输入一组查询单词，输出其中可扩张的单词数量。</p><p>示例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">输入： <br>S = <span class="hljs-string">&quot;heeellooo&quot;</span><br>words = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;helo&quot;</span>]<br>输出：1<br>解释：<br>我们能通过扩张 <span class="hljs-string">&quot;hello&quot;</span> 的 <span class="hljs-string">&quot;e&quot;</span> 和 <span class="hljs-string">&quot;o&quot;</span> 来得到 <span class="hljs-string">&quot;heeellooo&quot;</span>。<br>我们不能通过扩张 <span class="hljs-string">&quot;helo&quot;</span> 来得到 <span class="hljs-string">&quot;heeellooo&quot;</span> 因为 <span class="hljs-string">&quot;ll&quot;</span> 的长度小于 3 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>定义两个指针分别从左到右遍历字符串，统计连续字符的出现频率，分以下情况：</p><ul><li>当两个指针对应的字符不同，不匹配</li><li>当s的指针统计的字符c出现次数小于于t中该字符次数，不匹配</li><li>如果字符c在两个串中出现的次数不相等，且在s中出现次数小于3,不匹配</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">judge</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>&amp; s,<span class="hljs-built_in">string</span>&amp; t</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> len1=s.size();<br>        <span class="hljs-built_in">int</span> len2=t.size();<br>        <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">char</span> c;<br>        <span class="hljs-keyword">while</span>(i&lt;len1&amp;&amp;j&lt;len2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]!=t[j])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            c=s[i];<br>            <span class="hljs-built_in">int</span> c1=<span class="hljs-number">0</span>,c2=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(i&lt;len1&amp;&amp;s[i]==c)<br>            &#123;<br>                ++i;<br>                ++c1;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(j&lt;len2&amp;&amp;t[j]==c)<br>            &#123;<br>                ++j;<br>                ++c2;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(c1&lt;c2)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c1&gt;c2&amp;&amp;c1&lt;<span class="hljs-number">3</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i==len1&amp;&amp;j==len2;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">expressiveWords</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s, vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; words</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">string</span>&amp; ss:words)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(judge(s,ss))<br>                ++ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>到达首都的最小油耗</title>
    <link href="/2022/11/21/%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B2%B9%E8%80%97/"/>
    <url>/2022/11/21/%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B2%B9%E8%80%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B2%B9%E8%80%97">到达首都的最小油耗</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="到达首都的最小油耗"><a class="markdownIt-Anchor" href="#到达首都的最小油耗"></a> 到达首都的最小油耗</h2><p><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一棵 n 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 0 到 n - 1 ，且恰好有 n - 1 条路。0 是首都。给你一个二维整数数组 roads ，其中 roads[i] = [ai, bi] ，表示城市 ai 和 bi 之间有一条 双向路 。</p><p>每个城市里有一个代表，他们都要去首都参加一个会议。</p><p>每座城市里有一辆车。给你一个整数 seats 表示每辆车里面座位的数目。</p><p>城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。</p><p>请你返回到达首都最少需要多少升汽油。</p><p>示例</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2<br>输出：7<br>解释：<br>- 代表<span class="hljs-number"> 2 </span>到达城市<span class="hljs-number"> 3 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 2 </span>和代表<span class="hljs-number"> 3 </span>一起到达城市<span class="hljs-number"> 1 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 2 </span>和代表<span class="hljs-number"> 3 </span>一起到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 1 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 5 </span>直接到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 6 </span>到达城市<span class="hljs-number"> 4 </span>，消耗<span class="hljs-number"> 1 </span>升汽油。<br>- 代表<span class="hljs-number"> 4 </span>和代表<span class="hljs-number"> 6 </span>一起到达首都，消耗<span class="hljs-number"> 1 </span>升汽油。<br>最少消耗<span class="hljs-number"> 7 </span>升汽油。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题实际上是在算车的数量，以0为根节点，用dfs来计算所有树对0的贡献值</p><p>例如，某个子树如下图:</p><p><img src="https://pic.leetcode.cn/1668950622-FRRlaR-4.png" alt="fig1" /></p><p>最下面两个节点的贡献各自为1,然后第二层的节点有3个人，而座位数为2，那么贡献值就是2（3/2向上取整）,所以该子树的总贡献是1+1+2=4</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">minimumFuelCost</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; roads, <span class="hljs-type">int</span> seats)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=roads.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; t:roads)<br>        &#123;<br>            g[t[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(t[<span class="hljs-number">1</span>]);<br>            g[t[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(t[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">0</span>;<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; dfs=[&amp;](<span class="hljs-type">int</span> t,<span class="hljs-type">int</span> par)-&gt;<span class="hljs-type">int</span>&#123;<br>            <span class="hljs-type">int</span> num=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp; c:g[t])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(c!=par)<br>                    num+=<span class="hljs-built_in">dfs</span>(c,t);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(t!=<span class="hljs-number">0</span>)<br>                ans+=(num<span class="hljs-number">-1</span>)/seats+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> num;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>香槟塔</title>
    <link href="/2022/11/20/%E9%A6%99%E6%A7%9F%E5%A1%94/"/>
    <url>/2022/11/20/%E9%A6%99%E6%A7%9F%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%A6%99%E6%A7%9F%E5%A1%94">香槟塔</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="香槟塔"><a class="markdownIt-Anchor" href="#香槟塔"></a> 香槟塔</h2><p><a href="https://leetcode.cn/problems/champagne-tower/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p><p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p><p>示例</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: poured = <span class="hljs-number">100000009</span>, query_row = <span class="hljs-number">33</span>, query_glass = <span class="hljs-number">17</span><br>输出: <span class="hljs-number">1.00000</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>一开始以为是个数学规律题，结果没想到还是个动态规划😂</p><p><code>dp[i][j]</code>表示第i行第j个杯子的盛水量，可以得出状态方程为：</p><p><code>dp[i][j]=max(dp[i-1][j]-1,0.0)/2+max(dp[i-1][j-1]-1,0.0)/2;</code></p><p>为了防止下标越界，dp数组下标从1开始</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">champagneTower</span><span class="hljs-params">(<span class="hljs-type">int</span> poured, <span class="hljs-type">int</span> query_row, <span class="hljs-type">int</span> query_glass)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">101</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">101</span>));<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=poured;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=query_row+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;++j)<br>            &#123;<br>                dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j]<span class="hljs-number">-1</span>,<span class="hljs-number">0.0</span>)/<span class="hljs-number">2</span>+<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>,<span class="hljs-number">0.0</span>)/<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[query_row+<span class="hljs-number">1</span>][query_glass+<span class="hljs-number">1</span>],<span class="hljs-number">1.0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子序列宽度之和</title>
    <link href="/2022/11/18/%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/11/18/%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C">子序列宽度之和</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="子序列宽度之和"><a class="markdownIt-Anchor" href="#子序列宽度之和"></a> 子序列宽度之和</h2><p><a href="https://leetcode.cn/problems/sum-of-subsequence-widths/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>一个序列的 宽度 定义为该序列中最大元素和最小元素的差值。</p><p>给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 109 + 7 取余 后的结果。</p><p>子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。</p><p>示例</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,1,3]</span><br>输出：6<br>解释：子序列为 <span class="hljs-comment">[1]</span>, <span class="hljs-comment">[2]</span>, <span class="hljs-comment">[3]</span>, <span class="hljs-comment">[2,1]</span>, <span class="hljs-comment">[2,3]</span>, <span class="hljs-comment">[1,3]</span>, <span class="hljs-comment">[2,1,3]</span> 。<br>相应的宽度是 0, 0, 0, 1, 1, 2, 2 。<br>宽度之和是 6 。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题没什么好的思路，参考了大佬的：<a href="https://leetcode.cn/problems/sum-of-subsequence-widths/solutions/1977443/tan-xin-by-heren1229-bo9s/">链接</a></p><p>我们知道，一个数组有<code>2^n-1个</code>非空子序列，枚举显然是不可行的。 换一个角度思考这个问题，事实上，对于每一个子序列，元素的顺序不影响结果，因为我们只要知道它的最大值和最小值就可以了。所以我们想知道，对每一个元素来说，有几个子序列以它为最大值，又有几个子序列以它为最小值？ 考虑以某个元素为最小值的序列个数。如果是整个序列的最小值，显然，所有包含它的子序列都以它为最小值，数目为<code>2^(n-1)</code>。那次小值呢？就是包含它，但不包含最小值的序列个数，就是2<sup>(n-2)，这样，我们就看出规律来了：如果某个数是数组中第k小的元素，那么以它为最小值的子序列就有2</sup>(n-k)个。其实也很好理解，我们从选与不选的角度考虑子序列个数，当确定以第k小的元素为最小值时，前面k-1个都不能选，第k个必须选，剩下可选可不选的还有n-k个，子序列自然就是<code>2^(n-k)</code>个了。 同理，以第k大元素为最大值的子序列也有<code>2^(n-k)</code>个。 接下来考虑如何用代码计算。直接写是不可能的，因为不可能算<code>2^100000</code>，所以我们维护一个系数，从1到<code>2^(n-1)</code>，每次乘二，根据上述的描述，可以推知，以第k小元素为最大值的序列数=以第k大元素为最小值的序列数<code>2^k</code>，(k从0开始)，所以我们从小到大遍历，每次加上<code>(2^k)</code>乘以第k小值，减去<code>(2^k)</code>乘以第k大值。 排序时间复杂度O(nlogn)，计算时间复杂度O(n)</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">mod</span>=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>; <br>    <span class="hljs-built_in">int</span> sumSubseqWidths(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">int</span> n=nums.size();<br>        sort(nums.begin(),nums.end());<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> k=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            ans=(ans+nums[i]*k-nums[n<span class="hljs-number">-1</span>-i]*k)%<span class="hljs-keyword">mod</span>;<br>            k=(k*<span class="hljs-number">2</span>)%<span class="hljs-keyword">mod</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>匹配子序列的单词数</title>
    <link href="/2022/11/17/%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
    <url>/2022/11/17/%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0">匹配子序列的单词数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="匹配子序列的单词数"><a class="markdownIt-Anchor" href="#匹配子序列的单词数"></a> 匹配子序列的单词数</h2><p><a href="https://leetcode.cn/problems/number-of-matching-subsequences/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定字符串 s 和字符串数组 words, 返回  words[i] 中是s的子序列的单词个数 。</p><p>字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。</p><p>例如， “ace” 是 “abcde” 的子序列。</p><p>示例：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入: s = <span class="hljs-string">&quot;dsahjpjauf&quot;</span>, <span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;ahjpjau&quot;</span>,<span class="hljs-string">&quot;ja&quot;</span>,<span class="hljs-string">&quot;ahbwzgqnuk&quot;</span>,<span class="hljs-string">&quot;tnmlanowax&quot;</span>]<br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用<code>pair(i,j)</code>表示words中，第<code>i</code>个字符串的查询到了第<code>j</code>个字符，开始先将words中所有字符串的第一个字符放入对应queue中，然后遍历所有s中的字符，取出字符对应的queue，然后依次出队列，将对应words中的字符串的下标<code>j</code>增加1，如果<code>j</code>等于所在字符串的长度，说明该字符串符合要求。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numMatchingSubseq</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=words.<span class="hljs-built_in">size</span>();<br>        vector&lt;queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">v</span>(<span class="hljs-number">26</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>            v[words[i][<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">push</span>(&#123;i,<span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span>&amp; c:s)<br>        &#123;<br>            <span class="hljs-keyword">auto</span>&amp; q=v[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-type">int</span> n=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(n--)<br>            &#123;<br>                <span class="hljs-type">int</span> i=q.<span class="hljs-built_in">front</span>().first;<br>                <span class="hljs-type">int</span> j=q.<span class="hljs-built_in">front</span>().second;<br>                q.<span class="hljs-built_in">pop</span>();<br>                ++j;<br>                <span class="hljs-keyword">if</span>(j==words[i].<span class="hljs-built_in">size</span>())<br>                    ++ans;<br>                <span class="hljs-keyword">else</span><br>                    v[words[i][j]-<span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">push</span>(&#123;i,j&#125;);                <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回文串个数</title>
    <link href="/2022/11/13/%E5%9B%9E%E6%96%87%E4%B8%B2%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/11/13/%E5%9B%9E%E6%96%87%E4%B8%B2%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">回文子串</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE">不重叠回文子字符串的最大数目</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="回文子串"><a class="markdownIt-Anchor" href="#回文子串"></a> 回文子串</h2><p><a href="https://leetcode.cn/problems/palindromic-substrings/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aaa&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<span class="hljs-number">6</span>个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>关于回文串数量问题一般用中心扩展法，即：</p><blockquote><p>枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。</p></blockquote><p>关于回文中心的数量，有以下规律：</p><ul><li>长度为<code>n</code>的字符串可以得到<code>2*n-1</code>组回文中心<code>[l,r]</code></li><li>第<code>i</code>组回文中心的<code>l=i/2,r=i/2+i%2</code>;</li></ul><p>从所有回文中心开始扩展，可以得到所有回文子串的数量</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> countSubstrings(<span class="hljs-built_in">string</span> s) &#123;<br>        <span class="hljs-built_in">int</span> n=s.size();<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-built_in">int</span> l=i/<span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">int</span> r=l+i%<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span>(l&gt;=<span class="hljs-number">0</span>&amp;&amp;r&lt;n&amp;&amp;s[l]==s[r])<br>            &#123;<br>                --l;<br>                ++r;<br>                ++ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="不重叠回文子字符串的最大数目"><a class="markdownIt-Anchor" href="#不重叠回文子字符串的最大数目"></a> 不重叠回文子字符串的最大数目</h2><p><a href="https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/description/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>给你一个字符串 s 和一个 正 整数 k 。</p><p>从字符串 s 中选出一组满足下述条件且 不重叠 的子字符串：</p><p>每个子字符串的长度 至少 为 k 。<br />每个子字符串是一个 回文串 。<br />返回最优方案中能选择的子字符串的 最大 数目。</p><p>子字符串 是字符串中一个连续的字符序列。</p><p>示例</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abaccdbbd&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：可以选择 <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abaccdbbd&quot;</span> 中斜体加粗的子字符串。<span class="hljs-string">&quot;aba&quot;</span> 和 <span class="hljs-string">&quot;dbbd&quot;</span> 都是回文，且长度至少为 <span class="hljs-attr">k</span> = <span class="hljs-number">3</span> 。<br>可以证明，无法选出两个以上的有效子字符串。<br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>主要思路是中心扩展法+dp</p><p>中心扩展法可参考上面的题，此题中用<code>dp[i]</code>表示<code>0～i-1</code>的子串中符合要求的子串个数，通过中心扩展法可得到若干回文中心，对于每一个回文中心，要更新l、r对应的dp值，即<code>dp[l+1]</code>和<code>dp[r+1]</code>。</p><ul><li>对于<code>dp[l+1]</code>，要考虑是否加入<code>l</code>位置的字符，所以<code>dp[l+1]=max(dp[l+1],dp[l])</code></li><li>对于<code>dp[r+1]</code>，因为<code>l~r</code>是个回文串，所以比较的是<code>0~l-1</code>和<code>0~r</code>这两段，<code>dp[r+1]=max(dp[r+1],dp[l]+1)</code></li></ul><p>最后<code>dp[n]</code>即最终答案</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> maxPalindromes(<span class="hljs-keyword">string</span> s, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">int</span> n=s.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">int</span> l=i/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> r=l+i%2;<br>            dp[l+<span class="hljs-number">1</span>]=<span class="hljs-keyword">max</span>(dp[l+<span class="hljs-number">1</span>],dp[l]);<br>            <span class="hljs-keyword">while</span>(l&gt;=<span class="hljs-number">0</span>&amp;&amp;r&lt;n&amp;&amp;s[l]==s[r])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(r-l+<span class="hljs-number">1</span>&gt;=k)<br>                &#123;<br>                    dp[r+<span class="hljs-number">1</span>]=<span class="hljs-keyword">max</span>(dp[r+<span class="hljs-number">1</span>],dp[l]+<span class="hljs-number">1</span>);<br>                &#125;<br>                --l;<br>                ++r;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多米诺和托米诺平铺</title>
    <link href="/2022/11/12/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/"/>
    <url>/2022/11/12/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA">多米诺和托米诺平铺</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="多米诺和托米诺平铺"><a class="markdownIt-Anchor" href="#多米诺和托米诺平铺"></a> 多米诺和托米诺平铺</h2><p><a href="https://leetcode.cn/problems/domino-and-tromino-tiling/description/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。<br /><img src="https://assets.leetcode.com/uploads/2021/07/15/lc-domino.jpg" alt="" /><br />给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 109 + 7 取模 的值。</p><p>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 3</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>动态规划题目，<code>dp[i][4]</code>表示第i列在4种情况下的类数。</p><ul><li>dp[i][0]:当第i列一个瓷砖也没有，说明上一列填满了,<code>dp[i][0]=dp[i-1][3]</code></li><li>dp[i][1]:第i列只有上边有瓷砖，说明i-1列可能只有下边有，或者一个也没有，<code>dp[i][1]=dp[i-1][0]+dp[i-1][2]</code></li><li>dp[i][2]:第i列只有下边有瓷砖，说明i-1列可能只有上边有，或者一个也没有，<code>dp[i][2]=dp[i-1][0]+dp[i-1][1]</code></li><li>dp[i][3]:第i列上下都有，可能i-1列上下都有，也可能i-1列上或者下有，要加L型的，也可能i-1列上下都没有，加了两个多米诺的。<code>dp[i][3]=dp[i-1][0]+dp[i-1][1]+dp[i-1][2]+dp[i-1][3]</code></li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><br>class <span class="hljs-symbol">Solution</span> &#123;<br>public:<br>    static const int mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>    long long dp[<span class="hljs-number">1001</span>][<span class="hljs-number">4</span>];<br>    int numTilings(int n) &#123;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;<br>        for(int i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            dp[i][<span class="hljs-number">0</span>]=dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>]<span class="hljs-comment">%mod;</span><br>            dp[i][<span class="hljs-number">1</span>]=(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>])<span class="hljs-comment">%mod;</span><br>            dp[i][<span class="hljs-number">2</span>]=(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])<span class="hljs-comment">%mod;</span><br>            dp[i][<span class="hljs-number">3</span>]=(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>]+dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">3</span>])<span class="hljs-comment">%mod;</span><br>        &#125;<br>        return dp[n][<span class="hljs-number">3</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2022/11/11/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/11/11/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%95%BF%E5%BA%A6%E4%B8%BA-k-%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">长度为 K 子数组中的最大和</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0">区间子数组个数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li></ul><!-- /TOC --><blockquote><p>滑动窗口也是很典型的一类题，这里举个简单的例子回顾一下主要思想。<s>(水篇博客😂)</s></p></blockquote><h2 id="长度为-k-子数组中的最大和"><a class="markdownIt-Anchor" href="#长度为-k-子数组中的最大和"></a> 长度为 K 子数组中的最大和</h2><p><a href="https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和：</p><p>子数组的长度是 k，且<br />子数组中的所有元素 各不相同 。<br />返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。</p><p>子数组 是数组中一段连续非空的元素序列。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>设置一个<code>hashset</code>，用<code>l</code>记录滑动窗口左端下标，然后遍历数组中的所有元素，分以下三种情况：</p><ul><li>判断set中有没有该元素，有的话不断删除最左边的数直到没有该元素</li><li>窗口大小如果大于等于k，从左边删除一个元素，然后加入当前元素，更新最大和</li><li>窗口大小如果小于k，则加入当前元素，如果加入后窗口大小为k，更新最大和</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_set&lt;<span class="hljs-built_in">int</span>&gt; st;<br>    <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> maximumSubarraySum(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> len=nums.size();<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> l=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-keyword">count</span>(nums[i]))<br>            &#123;<br>                <span class="hljs-keyword">sum</span>-=nums[l];<br>                st.erase(nums[l]);<br>                ++l;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i-l&gt;=k)<br>            &#123;<br>                <span class="hljs-keyword">sum</span>-=nums[l];<br>                st.erase(nums[l]);<br>                ++l;<br>                <span class="hljs-keyword">sum</span>+=nums[i];<br>                st.insert(nums[i]);<br>                ans=max(ans,<span class="hljs-keyword">sum</span>);   <br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                st.insert(nums[i]);<br>                <span class="hljs-keyword">sum</span>+=nums[i];<br>                <span class="hljs-keyword">if</span>(i-l==k<span class="hljs-number">-1</span>)<br>                    ans=max(ans,<span class="hljs-keyword">sum</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="区间子数组个数"><a class="markdownIt-Anchor" href="#区间子数组个数"></a> 区间子数组个数</h2><p><a href="https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/description/">题目链接</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。</p><p>生成的测试用例保证结果符合 32-bit 整数范围。</p><p>示例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[2,1,4,3]</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">2</span>, right = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：满足条件的三个子数组：<span class="hljs-selector-attr">[2]</span>, <span class="hljs-selector-attr">[2, 1]</span>, <span class="hljs-selector-attr">[3]</span><br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>用l和r记录滑动窗口的左右端，然后从左到右遍历数组，如果当前元素符合要求，<code>r=i</code>，如果当前元素大于right，<code>r=i+1</code>,然后加上每次的结果<code>r-l+1</code></p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>publ<span class="hljs-symbol">ic:</span><br>    <span class="hljs-built_in">int</span> numSubarrayBoundedMax(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span>=nums.size();<br>        <span class="hljs-built_in">int</span> l=<span class="hljs-number">0</span>,r=-<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>;++i)<br>        &#123;<br>            <span class="hljs-built_in">if</span>(nums[i]&gt;=<span class="hljs-built_in">left</span>&amp;&amp;nums[i]&lt;=<span class="hljs-built_in">right</span>)<br>                r=i;<br>            else <span class="hljs-built_in">if</span>(nums[i]&gt;<span class="hljs-built_in">right</span>)<br>                l=i+<span class="hljs-number">1</span>;<br>            ans+=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,r-l+<span class="hljs-number">1</span>);<br>        &#125;<br>        return ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>获取所有钥匙的最短路径</title>
    <link href="/2022/11/10/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/11/10/%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">获取所有钥匙的最短路径</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="获取所有钥匙的最短路径"><a class="markdownIt-Anchor" href="#获取所有钥匙的最短路径"></a> 获取所有钥匙的最短路径</h2><p><a href="https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个二维网格 grid ，其中：</p><p>‘.’ 代表一个空房间<br />‘#’ 代表一堵<br />‘@’ 是起点<br />小写字母代表钥匙<br />大写字母代表锁<br />我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p><p>假设 k 为 钥匙/锁 的个数，且满足 1 &lt;= k &lt;= 6，字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p><p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。</p><p>示例：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">输入：<span class="hljs-built_in">grid</span> = [<span class="hljs-string">&quot;@.a.#&quot;</span>,<span class="hljs-string">&quot;###.#&quot;</span>,<span class="hljs-string">&quot;b.A.B&quot;</span>]<br>输出：<span class="hljs-number">8</span><br>解释：目标是获得所有钥匙，而不是打开所有锁<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用一个三元组<code>(x,y,status)</code> 表示当前的状态，其中 <code>(x,y)</code> 表示当前所处的位置，<code>status</code> 是一个二进制数，长度恰好等于网格中钥匙的数目，<code>status</code> 的第 i 个二进制位为 1，当且仅当我们已经获得了网格中的第 i 把钥匙。</p><p>这样一来，我们就可以使用上述的状态进行广度优先搜索。初始时，我们把 <code>(srcx,srcy,0)</code>加入队列，其中 <code>srcx,srcy)</code> 为起点。在搜索的过程中，我们可以向上下左右四个方向进行扩展：</p><p>如果对应方向是空房间，那么 <code>status</code> 的值不变；</p><p>如果对应方向是第 i 把钥匙，那么将 <code>status</code> 的第 i 位置为 111；</p><p>如果对应方向是第 i 把锁，那么只有在 <code>status</code> 的第 i 位为 1 时，才可以通过。</p><p>当 <code>status</code> 每一位都为1时，说明获取了所有钥匙，此时就可以返回最短路作为答案。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs prolog">int dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>class <span class="hljs-symbol">Solution</span> &#123;<br>public:<br>    unordered_map&lt;char,int&gt; mp;<br>    queue&lt;tuple&lt;int,int,int&gt;&gt; q;<br>    int shortestPathAllKeys(vector&lt;string&gt;&amp; grid) &#123;<br>        int m=grid.size(),n=grid[<span class="hljs-number">0</span>].size();<br>        int srcx,srcy,dx,dy;<br>        for(int i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            for(int j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                if(grid[i][j]==<span class="hljs-string">&#x27;@&#x27;</span>)<br>                &#123;<br>                    srcx=i;<br>                    srcy=j;<br>                &#125;<br>                else if(grid[i][j]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;grid[i][j]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)<br>                &#123;<br>                    if(!mp.count(grid[i][j]))<br>                        mp[grid[i][j]]=mp.size();<br>                &#125;<br>            &#125;<br>        &#125;<br>        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dis(m,vector&lt;vector&lt;int&gt;&gt;(n,vector&lt;int&gt;(<span class="hljs-number">1</span>&lt;&lt;mp.size(),<span class="hljs-number">-1</span>)));<br>        q.push(&#123;srcx,srcy,<span class="hljs-number">0</span>&#125;);<br>        dis[srcx][srcy][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        while(!q.empty())<br>        &#123;   <br>            auto[x,y,status]=q.front();<br>            q.pop();<br>            for(int i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)<br>            &#123;<br>                dx=x+dir[i][<span class="hljs-number">0</span>];<br>                dy=y+dir[i][<span class="hljs-number">1</span>];<br>                if(dx&gt;=<span class="hljs-number">0</span>&amp;&amp;dx&lt;m&amp;&amp;dy&gt;=<span class="hljs-number">0</span>&amp;&amp;dy&lt;n&amp;&amp;grid[dx][dy]!=<span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123;<br>                    if(grid[dx][dy]==<span class="hljs-string">&#x27;.&#x27;</span>||grid[dx][dy]==<span class="hljs-string">&#x27;@&#x27;</span>)<br>                    &#123;<br>                        if(dis[dx][dy][status]==<span class="hljs-number">-1</span>)<br>                        &#123;<br>                            dis[dx][dy][status]=dis[x][y][status]+<span class="hljs-number">1</span>;<br>                            q.push(&#123;dx,dy,status&#125;);<br>                        &#125;<br>                    &#125;<br>                    else if(grid[dx][dy]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;grid[dx][dy]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)<br>                    &#123;<br>                        int idx=mp[grid[dx][dy]];<br>                        if(dis[dx][dy][status|(<span class="hljs-number">1</span>&lt;&lt;idx)]==<span class="hljs-number">-1</span>)<br>                        &#123;<br>                            dis[dx][dy][status|(<span class="hljs-number">1</span>&lt;&lt;idx)]=dis[x][y][status]+<span class="hljs-number">1</span>;<br>                            if((status|(<span class="hljs-number">1</span>&lt;&lt;idx))==(<span class="hljs-number">1</span>&lt;&lt;mp.size())<span class="hljs-number">-1</span>)<br>                                return dis[dx][dy][status|(<span class="hljs-number">1</span>&lt;&lt;idx)];<br>                            q.push(&#123;dx,dy,status|(<span class="hljs-number">1</span>&lt;&lt;idx)&#125;);<br>                        &#125;<br>                    &#125;<br>                    else<br>                    &#123;<br>                        int idx=mp[grid[dx][dy]+<span class="hljs-number">32</span>];<br>                        if((status &amp; (<span class="hljs-number">1</span>&lt;&lt;idx)) &amp;&amp; dis[dx][dy][status]==<span class="hljs-number">-1</span>)<br>                        &#123;<br>                            dis[dx][dy][status]=dis[x][y][status]+<span class="hljs-number">1</span>;<br>                            q.push(&#123;dx,dy,status&#125;);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        return <span class="hljs-number">-1</span>;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大加号标志</title>
    <link href="/2022/11/09/%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97/"/>
    <url>/2022/11/09/%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97">最大加号标志</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最大加号标志"><a class="markdownIt-Anchor" href="#最大加号标志"></a> 最大加号标志</h2><p><a href="https://leetcode.cn/problems/largest-plus-sign/description/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在一个 n x n 的矩阵 grid 中，除了在数组 mines 中给出的元素为 0，其他每个元素都为 1。mines[i] = [xi, yi]表示 grid[xi][yi] == 0</p><p>返回  grid 中包含 1 的最大的 轴对齐 加号标志的阶数 。如果未找到加号标志，则返回 0 。</p><p>一个 k 阶由 1 组成的 “轴对称”加号标志 具有中心网格 grid[r][c] == 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 0 也可能为 1 。</p><p>示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: n = <span class="hljs-number">5</span>, mines = <span class="hljs-string">[[4, 2]]</span><br>输出: <span class="hljs-number">2</span><br>解释: 在上面的网格中，最大加号标志的阶只能是<span class="hljs-number">2</span>。一个标志已在图中标出。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><blockquote><p>这道题属于动态规划，用<code>dp[i][j]</code>表示在<code>(i,j)</code>位置四个方向阶数的最小值，然后找到dp数组中的最大值即可。<br />注意：遍历时要先处理水平方向，再处理垂直方向，不然无法正确更新dp数组</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Solution &#123;<br>public:<br>    bool vis[250001];<br>    int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) &#123;<br>        vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(n,n));<br>        <span class="hljs-keyword">for</span>(auto &amp; t:mines)<br>            vis[t[0]*n+t[1]]=<span class="hljs-literal">true</span>;<br>        int <span class="hljs-attribute">count</span>=0;<br>        int <span class="hljs-attribute">ans</span>=0;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=0;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(vis[i*n+j])<br>                    <span class="hljs-attribute">count</span>=0;<br>                <span class="hljs-keyword">else</span><br>                    ++count;<br>                dp[i][j]=min(dp[i][j],count);<br>            &#125;<br>            <span class="hljs-attribute">count</span>=0;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=n-1;j&gt;=0;--j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(vis[i*n+j])<br>                    <span class="hljs-attribute">count</span>=0;<br>                <span class="hljs-keyword">else</span><br>                    ++count;<br>                dp[i][j]=min(dp[i][j],count);<br>            &#125;<br>            <span class="hljs-attribute">count</span>=0;<br>            <br>        &#125;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=0;j&lt;n;++j)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n;++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(vis[i*n+j])<br>                    <span class="hljs-attribute">count</span>=0;<br>                <span class="hljs-keyword">else</span><br>                    ++count;<br>                dp[i][j]=min(dp[i][j],count);<br>            &#125;<br>            <span class="hljs-attribute">count</span>=0;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=n-1;i&gt;=0;--i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(vis[i*n+j])<br>                    <span class="hljs-attribute">count</span>=0;<br>                <span class="hljs-keyword">else</span><br>                    ++count;<br>                dp[i][j]=min(dp[i][j],count);<br>                <span class="hljs-attribute">ans</span>=max(dp[i][j],ans);<br>            &#125;<br>            <span class="hljs-attribute">count</span>=0;<br>        &#125;<br>        return ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>美丽整数最小增量</title>
    <link href="/2022/11/08/%E7%BE%8E%E4%B8%BD%E6%95%B4%E6%95%B0%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/"/>
    <url>/2022/11/08/%E7%BE%8E%E4%B8%BD%E6%95%B4%E6%95%B0%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BE%8E%E4%B8%BD%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F">美丽整数的最小增量</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="美丽整数的最小增量"><a class="markdownIt-Anchor" href="#美丽整数的最小增量"></a> 美丽整数的最小增量</h2><p><a href="https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/description/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给你两个正整数 n 和 target 。</p><p>如果某个整数每一位上的数字相加小于或等于 target ，则认为这个整数是一个 美丽整数 。</p><p>找出并返回满足 n + x 是 美丽整数 的最小非负整数 x 。生成的输入保证总可以使 n 变成一个美丽整数。</p><p>示例：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 16, target = 6<br>输出：4<br>解释：最初，n 是<span class="hljs-number"> 16 </span>，且其每一位数字的和是<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 7 </span>。<br>在加<span class="hljs-number"> 4 </span>之后，n 变为<span class="hljs-number"> 20 </span>且每一位数字的和变成<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 0 </span>=<span class="hljs-number"> 2 </span>。可以证明无法加上一个小于<span class="hljs-number"> 4 </span>的非负整数使 n 变成一个美丽整数。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>从右到左遍历，依次进行高位加1,低位置0,直到满足条件为止</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> makeIntegerBeautiful(<span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> n, <span class="hljs-built_in">int</span> target) &#123;<br>        string s=to_string(n);<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> len=s.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">char</span> c:s)<br>            <span class="hljs-keyword">sum</span>+=c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&lt;=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=len<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;9&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;++j)<br>                <span class="hljs-keyword">sum</span>+=s[j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            ++<span class="hljs-keyword">sum</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span>&lt;=target)<br>            &#123;<br>                string ans=s;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=i+<span class="hljs-number">1</span>;j&lt;len;++j)<br>                    ans[j]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>                ++ans[i];<br>                <span class="hljs-keyword">return</span> stoll(ans)-n;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> stoll(<span class="hljs-string">&#x27;1&#x27;</span>+string(len,<span class="hljs-string">&#x27;0&#x27;</span>))-n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>transformer笔记</title>
    <link href="/2022/11/03/transformer%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/03/transformer%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#transformer%E7%AC%94%E8%AE%B0">Transformer笔记</a><ul><li><a href="#transformer%E7%9A%84%E6%8F%90%E5%87%BA">transformer的提出</a></li><li><a href="#%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6">自注意力机制</a></li><li><a href="#%E5%A4%9A%E5%A4%B4%E6%B3%A8%E6%84%8F%E5%8A%9B">多头注意力</a></li><li><a href="#%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81">位置编码</a><ul><li><a href="#token-embedding">Token Embedding</a></li><li><a href="#positional-embedding">Positional Embedding</a></li></ul></li><li><a href="#transformer%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84">Transformer网络结构</a><ul><li><a href="#encoder">Encoder</a></li><li><a href="#decoder">Decoder</a></li><li><a href="#%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%8E%A9%E7%A0%81%E6%9C%BA%E5%88%B6">注意力掩码机制</a></li></ul></li><li><a href="#%E5%9F%BA%E4%BA%8Etransformer%E7%9A%84%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B">基于transformer的分类模型</a></li></ul></li></ul><!-- /TOC --><h1 id="transformer笔记"><a class="markdownIt-Anchor" href="#transformer笔记"></a> Transformer笔记</h1><p>在写本篇博客时，主要参考了这篇博客（<a href="https://zhuanlan.zhihu.com/p/420820453">博客链接</a>），博主介绍的非常细致，强烈推荐。</p><h2 id="transformer的提出"><a class="markdownIt-Anchor" href="#transformer的提出"></a> transformer的提出</h2><p>该模型的提出，来源于2017年的一篇论文：Attention is all you need</p><p>在论文中作者提到，当前主流的序列模型都是基于复杂的RNN或者CNN构造的Encoder-Decoder模型,这种模型使得下一个时刻的计算过程依赖于上一个时刻的输出，因此RNN在计算效率上受到很大限制。于是作者提出了transformer架构，他抛弃了RNN结构，引入了注意力机制来计算模型输入输出间的隐含表示。</p><h2 id="自注意力机制"><a class="markdownIt-Anchor" href="#自注意力机制"></a> 自注意力机制</h2><p>注意力机制可以描述为将query和一系列的key-value对映射到某个输出的过程，而这个输出的向量就是根据query和key计算得到的权重作用于value上的权重和。</p><p><img src="https://pic2.zhimg.com/80/v2-21ebe709cd12dda0a9c9da7559d3e045_720w.webp" alt="" /><br />可以看出，自注意力的计算过程就是通过Query和Key计算出权重，然后与Value相乘得到输出。</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mo fence="true">(</mo><mfrac><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac><mo fence="true">)</mo></mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">Attention\left(Q,K,V\right)=softmax\left(\frac{QK^T}{\sqrt{d_k}}\right)V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.468361em;vertical-align:-0.95003em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p><p>其中Q,K,V分别是三个矩阵，而除以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.18278000000000005em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span></span>就是上图中的scale过程。作者发现某些情况下<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">QK^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>会得到很大的值，这会导致softmax后产生很小的梯度，不利于训练，所以加入scale的过程。</p><p>下面举例说明Q,K,V是怎么来的。</p><p><img src="https://pic4.zhimg.com/80/v2-28903ee6a9c01d4895af7836b1e5997f_720w.webp" alt="" /></p><p>从上图可以看出，Q，K，V其实就是输入X乘以三个不同的矩阵计算而来，即：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>X</mi><msup><mi>W</mi><mi>q</mi></msup><mspace linebreak="newline"></mspace><mi>K</mi><mo>=</mo><mi>X</mi><msup><mi>W</mi><mi>k</mi></msup><mspace linebreak="newline"></mspace><mi>V</mi><mo>=</mo><mi>X</mi><msup><mi>W</mi><mi>v</mi></msup></mrow><annotation encoding="application/x-tex">Q=XW^q\\K=XW^k\\V=XW^v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.714392em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8991079999999999em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span></span></span></span></span></span></span></span></p><p>得到Q,K,V之后，就可以进一步计算得到权重向量。</p><p><img src="https://pic4.zhimg.com/80/v2-3173490f0b8fb89b22a22b65d2851c7f_720w.webp" alt="" /><br />假如Q和K的计算结果如上图，对于权重矩阵的第1行来说，0.7表示的就是“我”与“我”的注意力值；0.2表示的就是“我”与”是”的注意力值；0.1表示的就是“我”与“谁”的注意力值。换句话说，在对序列中的“我“进行编码时，应该将0.7的注意力放在“我”上，0.2的注意力放在“是”上，将0.1的注意力放在谁上。</p><p>不过，上面的规律也反映了一个小问题：<strong>模型在对当前位置的信息进行编码时，会过度的将注意力集中于自身的位置而可能忽略了其它位置。</strong></p><p>得到权重矩阵之后，与V相乘：</p><p><img src="https://pic3.zhimg.com/80/v2-a574d12396e1e2006716eb58f9fa5806_720w.webp" alt="" /></p><p>对于“是”而言，它的编码向量其实就是“我，是，谁”三个字的加权和，如下图所示：</p><p><img src="https://pic2.zhimg.com/80/v2-3de3645627bd94e4258a89c4376227c1_720w.webp" alt="" /></p><p>这种自注意力机制,确实解决了作者在论文中所提出的“传统序列模型在编码过程中都需顺序进行的弊端”的问题，有了自注意力机制后，仅仅只需要对原始输入进行几次矩阵变换便能够得到最终包含有不同位置注意力信息的编码向量。</p><h2 id="多头注意力"><a class="markdownIt-Anchor" href="#多头注意力"></a> 多头注意力</h2><p>之前提到，自注意力在对当前位置的信息进行编码时，会过度的将注意力集中于自身的位置，所以提出了Multi-head Attention来进行改进。</p><p><img src="https://pic4.zhimg.com/80/v2-849a1a08e54a4ab3b2bfadfaceddfeab_720w.webp" alt="" /></p><p>多头注意力机制其实就是将原始的输入序列进行多组的自注意力处理过程；然后再将每一组自注意力的结果拼接起来进行一次线性变换得到最终的输出结果。具体的，其计算公式为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>H</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>a</mi><mi>t</mi><mo stretchy="false">(</mo><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>h</mi></msub><mo stretchy="false">)</mo><msup><mi>W</mi><mi>O</mi></msup><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mi>W</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>Q</mi><msubsup><mi>W</mi><mi>i</mi><mi>Q</mi></msubsup><mo separator="true">,</mo><mi>K</mi><msubsup><mi>W</mi><mi>i</mi><mi>K</mi></msubsup><mo separator="true">,</mo><mi>V</mi><msubsup><mi>W</mi><mi>i</mi><mi>V</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">MultiHead(Q,K,V)=Concat(head_1,...,head_h)W^O\\\\Where head_i=Attention(QW_i^Q,KW^K_i,VW_i^V)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.236103em;vertical-align:-0.276864em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9592389999999998em;"><span style="top:-2.4231360000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.180908em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>作者使用了个并行的自注意力模块（8个头）来构建一个注意力层，论文中所使用的多头注意力机制其实就是将一个大的高维单头拆分成了h个多头。</p><p><img src="https://pic4.zhimg.com/80/v2-382a68f2a5543f00b7a4a1fd84e29b83_720w.webp" alt="" /></p><p>当进行进行注意力权重矩阵计算时，h越大那么Q,K,V就会被切分得越小，进而得到的注意力权重分配方式越多，如图所示。</p><p><img src="https://pic1.zhimg.com/80/v2-8837a813f9028886bb8529a59c6cd9c8_720w.webp" alt="" /></p><p>因而多头这一做法也恰好用于克服模型在对当前位置的信息进行编码时，会过度的将注意力集中于自身的位置的问题，使得权重分配更合理。</p><h2 id="位置编码"><a class="markdownIt-Anchor" href="#位置编码"></a> 位置编码</h2><h3 id="token-embedding"><a class="markdownIt-Anchor" href="#token-embedding"></a> Token Embedding</h3><p>在对文本相关的数据进行建模时首先要做的便是对其进行向量化(Embedding),在深度学习中，更常见的做法便是将各个词（或者字）通过一个Embedding层映射到低维稠密的向量空间。因此，在Transformer模型中，首先第一步要做的同样是将文本以这样的方式进行向量化表示，并且将其称之为Token Embedding，也就是深度学习中常说的词嵌入（Word Embedding）</p><p><img src="https://pic4.zhimg.com/80/v2-9e4cb60bd2ed3e1aca137928bf34a537_720w.webp" alt="" /></p><p>如果是换做之前的网络模型，例如CNN或者RNN，那么对于文本向量化的步骤就到此结束了，因为这些网络结构本身已经具备了捕捉时序特征的能力,但是这对仅仅只有自注意力机制的网络结构来说却不行。自注意力机制在实际运算过程中不过就是几个矩阵来回相乘进行<strong>线性变换</strong>而已。因此，这就导致即使是打乱各个词的顺序，那么最终计算得到的结果本质上却没有发生任何变换，换句话说仅仅只使用自注意力机制会丢失文本原有的序列信息（<s>换个顺序学习不到新的东西</s>）。</p><p>下面举例说明原因：</p><p><img src="https://pic4.zhimg.com/80/v2-a61fbde8b2b7958eef3dd134f722c69b_720w.webp" alt="" /></p><p>经过词嵌入表示后，序列“我 在 看 书”经过了一次线性变换。现在，我们将序列变成“书 在 看 我”，然后同样以中间这个权重矩阵来进行线性变换。</p><p><img src="https://pic4.zhimg.com/80/v2-9aede5435fe5c6f010457c5818ec3ce3_720w.webp" alt="" /></p><p>所以，序列在交换位置前和交换位置后计算得到的结果在本质上并没有任何区别，仅仅只是交换了对应的位置。因此，基于这样的原因，Transformer在原始输入文本进行Embedding后，又额外的加入了一个Positional Embedding来刻画数据在时序上的特征。</p><h3 id="positional-embedding"><a class="markdownIt-Anchor" href="#positional-embedding"></a> Positional Embedding</h3><p>先来通过一幅图直观看看经过Positional Embedding处理后到底产生了什么样的变化。</p><p><img src="https://pic3.zhimg.com/80/v2-8110b24565ffbfb028866a19050940fa_720w.webp" alt="" /></p><blockquote><p>如图所示，横坐标表示输入序列中的每一个Token，每一条曲线或者直线表示对应Token在每个维度上对应的位置信息。在左图中，每个维度所对应的位置信息都是一个不变的常数；而在右图中，每个维度所对应的位置信息都是基于某种公式变换所得到。换句话说就是，左图中任意两个Token上的向量都可以进行位置交换而模型却不能捕捉到这一差异，但是加入右图这样的位置信息模型却能够感知到。例如位置20这一处的向量，在左图中无论你将它换到哪个位置，都和原来一模一样；但在右图中，你却再也找不到与位置20处位置信息相同的位置。</p></blockquote><p>下面再看一个例子</p><p><img src="https://pic1.zhimg.com/80/v2-9a4be9596e49f523e90c2c9eb7b37864_720w.webp" alt="" /></p><p>原始输入在经过Token Embedding后，又加入了一个常数位置信息的的Positional Embedding。在经过一次线性变换后便得到了图2-5左右边所示的结果。接下来，我们再交换序列的位置，并同时进行Positional Embedding观察其结果。</p><p><img src="https://pic3.zhimg.com/80/v2-d98e246f487827ee1ad6411cc00928e6_720w.webp" alt="" /></p><p>可以看到，交换位置后得到的权重矩阵只是发生了普通的线性变换，说明上述类型的PE是无效的。</p><p>在Transformer中，作者采用了以下公式所示的规则来生成各个维度的位置信息。</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><msub><mi>E</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi></mrow></msub><mo>=</mo><mi>s</mi><mi>i</mi><mi>n</mi><mrow><mo fence="true">(</mo><mfrac><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><mrow><mn>1000</mn><msup><mn>0</mn><mfrac><mrow><mn>2</mn><mi>i</mi></mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub></mfrac></msup></mrow></mfrac><mo fence="true">)</mo></mrow><mspace linebreak="newline"></mspace><mi>P</mi><msub><mi>E</mi><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>c</mi><mi>o</mi><mi>s</mi><mrow><mo fence="true">(</mo><mfrac><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><mrow><mn>1000</mn><msup><mn>0</mn><mfrac><mrow><mn>2</mn><mi>i</mi></mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub></mfrac></msup></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">PE_{pos,2i}=sin\left(\frac{pos}{10000^{\frac{2i}{d_{model}}}}\right)\\PE_{pos,2i+1}=cos\left(\frac{pos}{10000^{\frac{2i}{d_{model}}}}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4619299999999997em;vertical-align:-1.01193em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.12193em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1219299999999999em;"><span style="top:-3.5233700000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8550857142857142em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.69444em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34963999999999995em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5937428571428571em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.35193em;"><span class="pstrut" style="height:3.12193em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.79893em;"><span class="pstrut" style="height:3.12193em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.01193em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4619299999999997em;vertical-align:-1.01193em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.12193em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1219299999999999em;"><span style="top:-3.5233700000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8550857142857142em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.69444em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34963999999999995em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5937428571428571em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.35193em;"><span class="pstrut" style="height:3.12193em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.79893em;"><span class="pstrut" style="height:3.12193em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.01193em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>上式中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">PE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>就是embedding的矩阵，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span></span></span></span>代表某一个位置,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>代表某一个维度，在融入这种非常数的Positional Embedding位置信息后，便可以得到下图结果。</p><p><img src="https://pic3.zhimg.com/80/v2-0c62651daf9f5c0c1de77e9137b058b6_720w.webp" alt="" /></p><p>这就说明通过Positional Embedding可以弥补自注意力机制不能捕捉序列时序信息的缺陷(<s>感觉类似于激活层的作用</s>)。</p><h2 id="transformer网络结构"><a class="markdownIt-Anchor" href="#transformer网络结构"></a> Transformer网络结构</h2><p>整体结构如下：</p><p><img src="https://pic1.zhimg.com/80/v2-6da4c9720ec88860295bd63e19344820_720w.webp" alt="" /></p><h3 id="encoder"><a class="markdownIt-Anchor" href="#encoder"></a> Encoder</h3><p><img src="https://pic3.zhimg.com/80/v2-5da93887d468045677e9983f14b35db6_720w.webp" alt="" /></p><p>主要由多头注意力机制和两层前馈神经网络构成，并且都加入了残差连接，并进行了层归一化。其中前馈神经网络主要用于变换维度，增强模型表达能力。</p><h3 id="decoder"><a class="markdownIt-Anchor" href="#decoder"></a> Decoder</h3><p><img src="https://pic1.zhimg.com/80/v2-8ab2c37e224137c05332419d525c88cc_720w.webp" alt="" /></p><p>不同于Encoder部分，在Decoder中一共包含有3个部分的网络结构。最上面的和最下面的部分（暂时忽略Mask）与Encoder相同，只是多了中间这个与Encoder输出（Memory）进行交互的部分，作者称之为“Encoder-Decoder attention”。<strong>对于这部分的输入，Q来自于下面多头注意力机制的输出，K和V均是Encoder部分的输出（Memory）经过线性变换后得到。</strong></p><p>具体解码过程如下：</p><p>首先，待解码向量和Memory分别各自乘上一个矩阵后得到Q、K、V。</p><p><img src="https://pic2.zhimg.com/80/v2-22669eedb0931017b8ed1d56dcd28089_720w.webp" alt="" /></p><p><img src="https://pic4.zhimg.com/80/v2-56ab4338fc9da4ca495fe070904846cf_720w.webp" alt="" /></p><p>在解码第1个时刻时，首先Q通过与K进行交互得到权重向量，此时可以看做是<strong>Q（待解码向量）在K（本质上也就是Memory）中查询Memory中各个位置与Q有关的信息</strong>；然后将权重向量与V进行运算得到解码向量，此时这个解码向量可以看作是<strong>考虑了Memory中各个位置编码信息的输出向量</strong>，也就是说它包含了在解码当前时刻时应该将注意力放在Memory中哪些位置上的信息。</p><p>在得到这个解码向量并经过图2-10中最上面的两层全连接层后，便将其输入到分类层中进行分类得到当前时刻的解码输出值。</p><h3 id="注意力掩码机制"><a class="markdownIt-Anchor" href="#注意力掩码机制"></a> 注意力掩码机制</h3><p>模型在实际的预测过程中只是将当前时刻之前（包括当前时刻）的所有时刻作为输入来预测下一个时刻，也就是说模型在预测时是看不到当前时刻之后的信息。因此，Transformer中的Decoder通过加入注意力掩码机制（Masked Multi-Head Attention）来解决了这一问题。</p><p><img src="https://pic4.zhimg.com/80/v2-ef714b246dfc08c912db18aaec0542cb_720w.webp" alt="" /></p><p>如图所示，左边依旧是通过Q和K计算得到了注意力权重矩阵（此时还未进行softmax操作），而中间的就是所谓的注意力掩码矩阵，两者在相加之后再乘上矩阵V便得到了整个自注意力机制的输出。（因为attention mask的加入，使得softmax之后，后面时刻的权重变为0，正好屏蔽了当前时刻之后的输入。）</p><h2 id="基于transformer的分类模型"><a class="markdownIt-Anchor" href="#基于transformer的分类模型"></a> 基于transformer的分类模型</h2><p><img src="https://moonhotel.oss-cn-shanghai.aliyuncs.com/images/2107052058585050890.jpg" alt="" /></p><p>上图便是一个基于Transformer结构的文本分类模型。不过准确的说应该只是一个基于Transformer中Encoder的文本分类模型。这是因为在文本分类任务中并没有解码这一过程，所以我们只需要将Encoder编码得到的向量输入到分类器中进行分类即可。</p>]]></content>
    
    
    <categories>
      
      <category>资料</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调双端队列</title>
    <link href="/2022/10/26/%E5%8D%95%E8%B0%83%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    <url>/2022/10/26/%E5%8D%95%E8%B0%83%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-k-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84">和至少为 K 的最短子数组</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="和至少为-k-的最短子数组"><a class="markdownIt-Anchor" href="#和至少为-k-的最短子数组"></a> 和至少为 K 的最短子数组</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/">题目链接</a></p><p>给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。</p><p>子数组 是数组中 连续 的一部分。</p><p>示例</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [2,-1,2], k = 3</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题自己想的就是前缀和然后暴力，但TLE了，看了题解发现需要用单调双端队列对前缀和数组进行优化</p><p>主要做两处优化：</p><ol><li><p>弹出队首并更新答案</p></li><li><p>弹出队尾，保证队列单调递增</p></li></ol><p><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/solution/liang-zhang-tu-miao-dong-dan-diao-dui-li-9fvh/">参考链接</a></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(len+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;++i)<br>            a[i]=nums[i<span class="hljs-number">-1</span>]+a[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-type">int</span> ans=INT_MAX;<br>        deque&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=len;++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]-a[q.<span class="hljs-built_in">front</span>()]&gt;=k)<br>            &#123;<br>                ans=<span class="hljs-built_in">min</span>(ans,i-q.<span class="hljs-built_in">front</span>());<br>                q.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]&lt;=a[q.<span class="hljs-built_in">back</span>()])<br>               q.<span class="hljs-built_in">pop_back</span>();<br>            q.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans==INT_MAX ? <span class="hljs-number">-1</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大人工岛</title>
    <link href="/2022/10/25/%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B/"/>
    <url>/2022/10/25/%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B">最大人工岛</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5">最短的桥</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="最大人工岛"><a class="markdownIt-Anchor" href="#最大人工岛"></a> 最大人工岛</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p><a href="https://leetcode.cn/problems/making-a-large-island/">原题链接</a></p><p>给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。</p><p>返回执行此操作后，grid 中最大的岛屿面积是多少？</p><p>岛屿 由一组上、下、左、右四个方向相连的 1 形成。</p><p>示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: grid = <span class="hljs-string">[[1, 1], [1, 0]]</span><br>输出: <span class="hljs-number">4</span><br>解释: 将一格<span class="hljs-number">0</span>变成<span class="hljs-number">1</span>，岛屿的面积扩大为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>主要思路是dfs，用dfs给不同的岛编号，用哈系表记录每个编号的岛的面积，然后遍历所有非岛屿部分，更新最大面积即可</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;</span><br><span class="hljs-class">public:</span><br><span class="hljs-class">    void dfs(<span class="hljs-title">int</span> <span class="hljs-title">x</span>,<span class="hljs-title">int</span> <span class="hljs-title">y</span>,<span class="hljs-title">int</span> <span class="hljs-title">bh</span>,<span class="hljs-title">vector</span>&lt;<span class="hljs-title">vector</span>&lt;<span class="hljs-title">int</span>&gt;&gt;&amp; <span class="hljs-title">grid</span>,<span class="hljs-title">int</span> <span class="hljs-title">m</span>,<span class="hljs-title">int</span> <span class="hljs-title">n</span>)</span><br><span class="hljs-class">    &#123;</span><br><span class="hljs-class">        if(<span class="hljs-title">grid</span>[<span class="hljs-title">x</span>][<span class="hljs-title">y</span>]!=1)</span><br><span class="hljs-class">            return;</span><br><span class="hljs-class">        grid[x][y]=bh;</span><br><span class="hljs-class">        if(<span class="hljs-title">x</span>+1&lt;<span class="hljs-title">m</span>)</span><br><span class="hljs-class">            dfs(<span class="hljs-title">x</span>+1,<span class="hljs-title">y</span>,<span class="hljs-title">bh</span>,<span class="hljs-title">grid</span>,<span class="hljs-title">m</span>,<span class="hljs-title">n</span>);</span><br><span class="hljs-class">        if(<span class="hljs-title">y</span>+1&lt;<span class="hljs-title">n</span>)</span><br><span class="hljs-class">            dfs(<span class="hljs-title">x</span>,<span class="hljs-title">y</span>+1,<span class="hljs-title">bh</span>,<span class="hljs-title">grid</span>,<span class="hljs-title">m</span>,<span class="hljs-title">n</span>);</span><br><span class="hljs-class">        if(<span class="hljs-title">x</span>-1&gt;=0)</span><br><span class="hljs-class">            dfs(<span class="hljs-title">x</span>-1,<span class="hljs-title">y</span>,<span class="hljs-title">bh</span>,<span class="hljs-title">grid</span>,<span class="hljs-title">m</span>,<span class="hljs-title">n</span>);</span><br><span class="hljs-class">        if(<span class="hljs-title">y</span>-1&gt;=0)</span><br><span class="hljs-class">            dfs(<span class="hljs-title">x</span>,<span class="hljs-title">y</span>-1,<span class="hljs-title">bh</span>,<span class="hljs-title">grid</span>,<span class="hljs-title">m</span>,<span class="hljs-title">n</span>);</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">    int largestIsland(<span class="hljs-title">vector</span>&lt;<span class="hljs-title">vector</span>&lt;<span class="hljs-title">int</span>&gt;&gt;&amp; <span class="hljs-title">grid</span>) &#123;</span><br><span class="hljs-class">        int m=grid.size();</span><br><span class="hljs-class">        int n=grid[0].size();</span><br><span class="hljs-class">        unordered_map&lt;int,int&gt; mp;</span><br><span class="hljs-class">        mp[0]=0;</span><br><span class="hljs-class">        int ans=0;</span><br><span class="hljs-class">        int bh=2;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                if(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>]==1)</span><br><span class="hljs-class">                &#123;</span><br><span class="hljs-class">                    dfs(<span class="hljs-title">i</span>,<span class="hljs-title">j</span>,<span class="hljs-title">bh</span>,<span class="hljs-title">grid</span>,<span class="hljs-title">m</span>,<span class="hljs-title">n</span>);</span><br><span class="hljs-class">                    ++bh;</span><br><span class="hljs-class">                &#125;</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                if(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>]!=0)</span><br><span class="hljs-class">                    ++mp[grid[i][j]];</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        int flag=0;</span><br><span class="hljs-class">        for(<span class="hljs-title">int</span> <span class="hljs-title">i</span>=0;<span class="hljs-title">i</span>&lt;<span class="hljs-title">m</span>;++<span class="hljs-title">i</span>)</span><br><span class="hljs-class">        &#123;</span><br><span class="hljs-class">            for(<span class="hljs-title">int</span> <span class="hljs-title">j</span>=0;<span class="hljs-title">j</span>&lt;<span class="hljs-title">n</span>;++<span class="hljs-title">j</span>)</span><br><span class="hljs-class">            &#123;</span><br><span class="hljs-class">                if(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>]==0)</span><br><span class="hljs-class">                &#123;</span><br><span class="hljs-class">                    flag=1;</span><br><span class="hljs-class">                    int t=0;</span><br><span class="hljs-class">                    unordered_set&lt;int&gt; s;</span><br><span class="hljs-class">                    if(<span class="hljs-title">i</span>-1&gt;=0)</span><br><span class="hljs-class">                        s.insert(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>-1][<span class="hljs-title">j</span>]);</span><br><span class="hljs-class">                    if(<span class="hljs-title">j</span>-1&gt;=0)</span><br><span class="hljs-class">                        s.insert(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>-1]);</span><br><span class="hljs-class">                    if(<span class="hljs-title">i</span>+1&lt;<span class="hljs-title">m</span>)</span><br><span class="hljs-class">                        s.insert(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>+1][<span class="hljs-title">j</span>]);</span><br><span class="hljs-class">                    if(<span class="hljs-title">j</span>+1&lt;<span class="hljs-title">n</span>)</span><br><span class="hljs-class">                        s.insert(<span class="hljs-title">grid</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>+1]);</span><br><span class="hljs-class">                    for(<span class="hljs-title">auto</span> <span class="hljs-title">it</span>=<span class="hljs-title">s</span>.<span class="hljs-title">begin</span>();it!=s.end();++it)</span><br><span class="hljs-class">                        t+=mp[*it];</span><br><span class="hljs-class">                    ans=max(<span class="hljs-title">ans</span>,<span class="hljs-title">t</span>+1);</span><br><span class="hljs-class">                &#125;</span><br><span class="hljs-class">            &#125;</span><br><span class="hljs-class">        &#125;</span><br><span class="hljs-class">        if(<span class="hljs-title">flag</span>)</span><br><span class="hljs-class">            return ans;</span><br><span class="hljs-class">        else</span><br><span class="hljs-class">            return m*n;</span><br><span class="hljs-class">    &#125;</span><br><span class="hljs-class">&#125;;</span><br></code></pre></td></tr></table></figure><h2 id="最短的桥"><a class="markdownIt-Anchor" href="#最短的桥"></a> 最短的桥</h2><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p><a href="https://leetcode.cn/problems/shortest-bridge/">原题链接</a></p><p>给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。</p><p>岛 是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 。</p><p>你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。</p><p>返回必须翻转的 0 的最小数目。</p><p>示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[0,1,0],[0,0,0],[0,0,1]]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>这道题实际上是求两个岛之间的最短距离，主要思路是dfs标记其中一个岛，然后用bfs进行岛屿之间最短距离的求解</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        grid[x][y]=<span class="hljs-number">2</span>;<br>        q.<span class="hljs-built_in">emplace</span>(x,y);<br>        <span class="hljs-keyword">if</span>(x<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;grid[x<span class="hljs-number">-1</span>][y]==<span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">dfs</span>(x<span class="hljs-number">-1</span>,y,grid);<br>        <span class="hljs-keyword">if</span>(x+<span class="hljs-number">1</span>&lt;n&amp;&amp;grid[x+<span class="hljs-number">1</span>][y]==<span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">dfs</span>(x+<span class="hljs-number">1</span>,y,grid);<br>        <span class="hljs-keyword">if</span>(y<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;grid[x][y<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">dfs</span>(x,y<span class="hljs-number">-1</span>,grid);<br>        <span class="hljs-keyword">if</span>(y+<span class="hljs-number">1</span>&lt;n&amp;&amp;grid[x][y+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">dfs</span>(x,y+<span class="hljs-number">1</span>,grid);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span>&amp; step)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> len=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(len--)<br>            &#123;<br>                <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>().first;<br>                <span class="hljs-type">int</span> y=q.<span class="hljs-built_in">front</span>().second;<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(x<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;grid[x<span class="hljs-number">-1</span>][y]!=<span class="hljs-number">2</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(grid[x<span class="hljs-number">-1</span>][y]==<span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(x<span class="hljs-number">-1</span>,y);<br>                    grid[x<span class="hljs-number">-1</span>][y]=<span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(y<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;grid[x][y<span class="hljs-number">-1</span>]!=<span class="hljs-number">2</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(grid[x][y<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(x,y<span class="hljs-number">-1</span>);<br>                    grid[x][y<span class="hljs-number">-1</span>]=<span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(x+<span class="hljs-number">1</span>&lt;n&amp;&amp;grid[x+<span class="hljs-number">1</span>][y]!=<span class="hljs-number">2</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(grid[x+<span class="hljs-number">1</span>][y]==<span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(x+<span class="hljs-number">1</span>,y);<br>                    grid[x+<span class="hljs-number">1</span>][y]=<span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(y+<span class="hljs-number">1</span>&lt;n&amp;&amp;grid[x][y+<span class="hljs-number">1</span>]!=<span class="hljs-number">2</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(grid[x][y+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(x,y+<span class="hljs-number">1</span>);<br>                    grid[x][y+<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>            ++step;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestBridge</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        n=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> step=<span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(i,j,grid);<br>                    <span class="hljs-built_in">bfs</span>(grid,step);<br>                    <span class="hljs-keyword">return</span> step;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数位dp</title>
    <link href="/2022/10/23/%E6%95%B0%E4%BD%8Ddp/"/>
    <url>/2022/10/23/%E6%95%B0%E4%BD%8Ddp/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%95%B0%E4%BD%8Ddp">数位DP</a><ul><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#ac%E4%BB%A3%E7%A0%81">AC代码</a></li></ul></li></ul><!-- /TOC --><h2 id="数位dp"><a class="markdownIt-Anchor" href="#数位dp"></a> 数位DP</h2><blockquote><p>一般指在限定条件下，关于每位数字出现次数的相关题目，先从入门开始吧(😢自己tcl)</p></blockquote><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p><a href="https://www.luogu.com.cn/problem/P2602">P2602 [ZJOI2010] 数字计数</a></p><p><strong>题目描述</strong></p><p>给定两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，求在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> 中的所有整数中，每个数码(digit)各出现了多少次。</p><p><strong>输入格式</strong></p><p>仅包含一行两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span></span></span></span>，含义如上所述。</p><p><strong>输出格式</strong></p><p>包含一行十个整数，分别表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">0\sim 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> 中出现了多少次。</p><p>样例输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">99</span><br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">9 </span><span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><strong>数据规模与约定</strong></p><ul><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，保证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">a\le b\le10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>；</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，保证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>a</mi><mo>≤</mo><mi>b</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">1\le a\le b\le 10^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>。</li></ul><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题主要就是找到各种规律</p><p>首先找到递推公式，如果有<code>i</code>位数字，那么对于<code>0～9</code>的每一个数字，出现的次数是一样的，所以不考虑前导0时有<br /><code>dp[i]=10*dp[i-1]+10^(i-1)</code><br />dp[i]表示i位的数每个数字出现的次数</p><p>对于ABCD</p><p>看A000，把这个A000看成0000～1000～2000…A000对于不考虑首位每一个式子的数字的出现个数为 <code>A*dp[3]</code>。加上首位出现也就是小于A每一个数都出现了<code>10^3</code>次，再加上，我们就把A000处理完了。</p><p>另外，首位A还出现了BCD+1次呢，也就是从A000~ABCD，这个A还出现了BCD+1次，最后减去前导0的个数，就是<code>10^(i-1)</code></p><h3 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> AC代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll a,b;<br>ll cnta[<span class="hljs-number">10</span>],cntb[<span class="hljs-number">10</span>];<br>ll dp[<span class="hljs-number">13</span>],ten[<span class="hljs-number">13</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dig</span><span class="hljs-params">(ll x,ll* cnt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">13</span>,<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">while</span>(x)<br>&#123;<br>v[++len]=x%<span class="hljs-number">10</span>;<br>x/=<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len;i&gt;=<span class="hljs-number">1</span>;--i)<br>&#123;<br><span class="hljs-comment">//不算首位，每个数字出现了x*dp[i-1]次,x是当前最高位 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10</span>;++j)<br>cnt[j]+=v[i]*dp[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">//算首位，即小于x的数增加10^(i-1)个 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;v[i];++j)<br>cnt[j]+=ten[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">//首位还多出现了低位+1次</span><br>ll tmp=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">1</span>;--j)<br>&#123;<br>tmp=tmp*<span class="hljs-number">10</span>+v[j];<br>&#125;<br>cnt[v[i]]+=tmp+<span class="hljs-number">1</span>;<br><span class="hljs-comment">//减去前导0</span><br>cnt[<span class="hljs-number">0</span>]-=ten[i<span class="hljs-number">-1</span>]; <br>&#125;<br>&#125;<br><span class="hljs-comment">//dp[i]=10*dp[i-1]+10^(i-1)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ll a,b;<br>cin&gt;&gt;a&gt;&gt;b;<br>ten[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//初始化dp </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">13</span>;++i)<br>&#123;<br>dp[i]=<span class="hljs-number">10</span>*dp[i<span class="hljs-number">-1</span>]+ten[i<span class="hljs-number">-1</span>];<br>ten[i]=<span class="hljs-number">10</span>*ten[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-built_in">dig</span>(a<span class="hljs-number">-1</span>,cnta);<br><span class="hljs-built_in">dig</span>(b,cntb);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i)<br>&#123;<br>cout&lt;&lt;cntb[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>规划兼职工作</title>
    <link href="/2022/10/22/%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C/"/>
    <url>/2022/10/22/%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C">规划兼职工作</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="规划兼职工作"><a class="markdownIt-Anchor" href="#规划兼职工作"></a> 规划兼职工作</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>你打算利用空闲时间兼职来赚些零花钱</p><p>现在有若<code>n</code>条兼职信息，一条兼职信息包含<code>a,b,c</code>3个数据</p><p><code>a</code>表示该兼职的开始时间<br /><code>b</code>表示该兼职的终止时间<br /><code>c</code>表示该兼职的收入</p><p>你在一个时间段内只能有1份兼职，也就是说上一份兼职的终止时间要满足小于等于下一份兼职的开始时间</p><p>请你算出你能获得的最大收入</p><p>输入第一行<code>n</code>，表示兼职个数<br />下面<code>n</code>行，每行3个数，表示<code>a,b,c</code></p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">10</span> <span class="hljs-number">100</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">70</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">9</span> <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">150<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题可以用动态规划解决，先将所有兼职按照终止时间升序排序，<code>dp[i]</code>表示到第<code>i</code>份能获得的最大收益</p><ul><li>当不选择第<code>i</code>份兼职，<code>dp[i]=dp[i-1]</code></li><li>当选择第<code>i</code>份兼职，<code>dp[i]=dp[k]+profit[i]</code>，<code>k</code>是满足终止时间小于等于第<code>i</code>份兼职开始时间的第<code>k</code>份兼职</li></ul><p>状态方程：<code>dp[i]=max(dp[i-1],dp[k]+profit[i])</code>;</p><p>关于<code>k</code>的确定，很多人是通过二分查找来确定<code>k</code>的，但我自己写的二分查找总是没法ac，所以就没用(tcl😢😢😢)</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e4</span>+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">e</span><br>&#123;<br>    <span class="hljs-type">int</span> a,b,c;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> e&amp; t) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> b&lt;t.b;<br>    &#125; <br>&#125;e[N];<br><span class="hljs-type">int</span> dp[N]; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-type">int</span> k;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>cin&gt;&gt;e[i].a&gt;&gt;e[i].b&gt;&gt;e[i].c;<br>&#125;<br><span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>k=i;<br><span class="hljs-keyword">while</span>(e[k].b&gt;e[i].a)<br>--k;<br>dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],dp[k]+e[i].c);<br>&#125;<br>cout&lt;&lt;dp[n]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第k个语法符号</title>
    <link href="/2022/10/20/%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/10/20/%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7">第k个语法符号</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%89%A9%E5%B1%95">位操作扩展</a></li></ul></li><li><a href="#%E6%89%A9%E5%B1%95%E6%B1%82%E6%9F%90%E4%B8%AA%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0">扩展：求某个数二进制表示中1的个数</a><ul><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="第k个语法符号"><a class="markdownIt-Anchor" href="#第k个语法符号"></a> 第k个语法符号</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p><a href="https://leetcode.cn/problems/k-th-symbol-in-grammar/">原题链接</a><br />我们构建了一个包含 n 行( 索引从 1  开始 )的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。</p><p>例如，对于 n = 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。<br />给定行数 n 和序数 k，返回第 n 行中第 k 个字符。（ k 从索引 1 开始）</p><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 2, k = 1</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: </span><br><span class="hljs-section">第一行: 0 </span><br><span class="hljs-section">第二行: 01</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题大致看上去不是很难，自己的思路就是中规中矩的算，没什么亮点(😢tcl)</p><p>看了评论区的一位大佬，瞬间的折服了，时间复杂度直接<code>O(1)</code></p><p>大佬解这道题就是一句话：<strong>对K-1做奇偶校验</strong></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><p>下面放上大佬的代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">class</span> <span class="hljs-variable">Solution</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-variable">public</span><span class="hljs-operator">:</span><br>    <span class="hljs-variable">int</span> <span class="hljs-variable">kthGrammar</span><span class="hljs-punctuation">(</span><span class="hljs-variable">int</span> <span class="hljs-built_in">N</span><span class="hljs-operator">,</span> <span class="hljs-variable">unsigned</span> <span class="hljs-variable">int</span> <span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span> <br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-built_in">K</span> <span class="hljs-operator">-=</span> <span class="hljs-number">1</span><span class="hljs-operator">;</span><br>        <span class="hljs-built_in">K</span> <span class="hljs-operator">^=</span> <span class="hljs-built_in">K</span> <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">1</span><span class="hljs-operator">;</span><br>        <span class="hljs-built_in">K</span> <span class="hljs-operator">^=</span> <span class="hljs-built_in">K</span> <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">2</span><span class="hljs-operator">;</span><br>        <span class="hljs-built_in">K</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">(</span><span class="hljs-built_in">K</span> <span class="hljs-operator">&amp;</span> <span class="hljs-number">0</span><span class="hljs-variable">x11111111</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">*</span> <span class="hljs-number">0</span><span class="hljs-variable">x11111111</span><span class="hljs-operator">;</span><br>        <span class="hljs-variable">return</span> <span class="hljs-punctuation">(</span><span class="hljs-built_in">K</span> <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">28</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">&amp;</span> <span class="hljs-number">1</span><span class="hljs-operator">;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">;</span><br></code></pre></td></tr></table></figure><p>第一眼看过去，我还是不会😢</p><p>于是仔细看了一番，下面我来解释一下</p><h3 id="位操作扩展"><a class="markdownIt-Anchor" href="#位操作扩展"></a> 位操作扩展</h3><p>大佬的话，翻译一下，就是求<code>K-1</code>对应的二进制数中，1的个数是奇数还是偶数，奇数返回1,偶数返回0</p><p>因为在奇偶校验中，常常需要需要判断一个数中1的个数，以确定奇偶校验位</p><p>也就是说，这道题的本质，就是判断<code>K-1</code>对应的二进制数中，1的个数是奇数还是偶数。(大佬太强了%%%)</p><p>关于代码呢，我主要参考了这篇博客  <a href="https://blog.csdn.net/u012028275/article/details/112596947"><em>博客链接</em></a>，说的非常详细，还带图示。</p><p><code>K ^= K &gt;&gt; 1;</code>，作用就是相邻两位异或，判断每两位1的个数，奇数个1则为，否则为0，结果存在相邻2位的低位</p><p><code>K ^= K &gt;&gt; 2;</code>，和上一步差不多，不过判断的是每4位的1的个数</p><p><code>K &amp; 0x11111111</code>，作用是每4位只取最低位，其他置0</p><p><code>K * 0x11111111;</code>，作用是将整个32位的1的个数奇偶性压缩到最高4位，也就是28～31位</p><p><code>(K &gt;&gt; 28) &amp; 1;</code>，移到最低4位，解出1的个数的奇偶性</p><h2 id="扩展求某个数二进制表示中1的个数"><a class="markdownIt-Anchor" href="#扩展求某个数二进制表示中1的个数"></a> 扩展：求某个数二进制表示中1的个数</h2><p>位操作还可以求某个数二进制表示中1的个数</p><p>比如现在需要求一个无符号整形数的二进制数中1的个数</p><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>其实和奇偶校验有点关系，求每2个数、每4个数、每8个数、每16个数的1的个数相加就好了</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-attr">std</span><span class="hljs-punctuation">;</span><br>int main()<br><span class="hljs-punctuation">&#123;</span><br>int n<span class="hljs-punctuation">;</span><br>cin&gt;&gt;n<span class="hljs-punctuation">;</span><br><span class="hljs-comment">//int n=0b0111100110011000000000000000001; </span><br>n=((n<span class="hljs-variable">&amp;0xaaaaaaaa</span>)&gt;&gt;<span class="hljs-number">1</span>)+(n<span class="hljs-variable">&amp;0x55555555</span>)<span class="hljs-punctuation">;</span> <br>n=((n<span class="hljs-variable">&amp;0xcccccccc</span>)&gt;&gt;<span class="hljs-number">2</span>)+(n<span class="hljs-variable">&amp;0x33333333</span>)<span class="hljs-punctuation">;</span><br>n=((n<span class="hljs-variable">&amp;0xf0f0f0f0</span>)&gt;&gt;<span class="hljs-number">4</span>)+(n<span class="hljs-variable">&amp;0x0f0f0f0f</span>)<span class="hljs-punctuation">;</span><br>n=((n<span class="hljs-variable">&amp;0xff00ff00</span>)&gt;&gt;<span class="hljs-number">8</span>)+(n<span class="hljs-variable">&amp;0x00ff00ff</span>)<span class="hljs-punctuation">;</span><br>n=((n<span class="hljs-variable">&amp;0xffff0000</span>)&gt;&gt;<span class="hljs-number">16</span>)+(n<span class="hljs-variable">&amp;0x0000ffff</span>)<span class="hljs-punctuation">;</span><br>cout<span class="hljs-params">&lt;&lt;n&lt;&lt;endl;</span><br><span class="hljs-params">return <span class="hljs-number">0</span>;</span><br><span class="hljs-params">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使序列递增的最小交换次数</title>
    <link href="/2022/10/18/%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/10/18/%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0">使序列递增的最小交换次数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="使序列递增的最小交换次数"><a class="markdownIt-Anchor" href="#使序列递增的最小交换次数"></a> 使序列递增的最小交换次数</h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p><a href="https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/">原题</a></p><p>我们有两个长度相等且不为空的整型数组 nums1 和 nums2 。在一次操作中，我们可以交换 nums1[i] 和 nums2[i]的元素。</p><p>例如，如果 nums1 = [1,2,3,8] ， nums2 =[5,6,7,4] ，你可以交换 i = 3 处的元素，得到 nums1 =[1,2,3,4] 和 nums2 =[5,6,7,8] 。<br />返回 使 nums1 和 nums2 严格递增 所需操作的最小次数 。</p><p>数组 arr 严格递增 且  arr[0] &lt; arr[1] &lt; arr[2] &lt; … &lt; arr[arr.length - 1] 。<br />input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p><code>dp[i][0]</code>表示不交换 <code>i</code> 处元素时满足条件的最小操作次数，<code>dp[i][1]</code>表示交换 <code>i</code> 处元素时满足条件的最小操作次数</p><p>下面要分类讨论：</p><ul><li>当nums1和nums都递增，且在<code>i</code>处交换后也都递增，那么在<code>i</code>处可换可不换</li><li>当nums1和nums都递增，但在<code>i</code>处交换后不递增，那么如果在<code>i</code>处交换，在<code>i-1</code>处也要交换</li><li>当nums1或nums2不递增，如果在<code>i</code>处交换，那么<code>i-1</code>处不交换，如果<code>i-1</code>处交换，<code>i</code>处不交换</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int N=1e5;<br>int a<span class="hljs-comment">[N]</span>;<br>int b<span class="hljs-comment">[N]</span>;<br>int dp<span class="hljs-comment">[N]</span><span class="hljs-comment">[2]</span>;<br>int main()<br>&#123;<br>int n;<br>cin&gt;&gt;n;<br>for(int i=0;i&lt;n;++i)<br>cin&gt;&gt;a<span class="hljs-comment">[i]</span>;<br>for(int i=0;i&lt;n;++i)<br>cin&gt;&gt;b<span class="hljs-comment">[i]</span>;<br>dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span>=1;<br>for(int i=1;i&lt;n;++i)<br>&#123;<br>if((a<span class="hljs-comment">[i-1]</span>&lt;a<span class="hljs-comment">[i]</span>&amp;&amp;b<span class="hljs-comment">[i-1]</span>&lt;b<span class="hljs-comment">[i]</span>)&amp;&amp;(a<span class="hljs-comment">[i-1]</span>&lt;b<span class="hljs-comment">[i]</span>&amp;&amp;b<span class="hljs-comment">[i-1]</span>&lt;a<span class="hljs-comment">[i]</span>))<br>&#123;<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>=min(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>,dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>);<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span>=dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>+1;<br>&#125;<br>else if(a<span class="hljs-comment">[i-1]</span>&lt;a<span class="hljs-comment">[i]</span>&amp;&amp;b<span class="hljs-comment">[i-1]</span>&lt;b<span class="hljs-comment">[i]</span>)<br>&#123;<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>=dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>;<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span>=dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>+1;<br>&#125;<br>else<br>&#123;<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>=dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>;<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span>=dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>+1;<br>&#125;<br>&#125;<br>cout&lt;&lt;min(dp<span class="hljs-comment">[n-1]</span><span class="hljs-comment">[0]</span>,dp<span class="hljs-comment">[n-1]</span><span class="hljs-comment">[1]</span>);<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>不同的子序列</title>
    <link href="/2022/10/14/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/10/14/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97">不同的子序列</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="不同的子序列"><a class="markdownIt-Anchor" href="#不同的子序列"></a> 不同的子序列</h2><p><a href="https://leetcode.cn/problems/distinct-subsequences-ii/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。</p><p>字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。</p><p>例如，“ace” 是 “abcde” 的一个子序列，但 “aec” 不是。</p><p>示例：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aba&quot;</span><br>输出：<span class="hljs-number">6</span><br>解释：<span class="hljs-number">6</span> 个不同的子序列分别是 <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-string">&quot;ba&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span> 以及 <span class="hljs-string">&quot;aba&quot;</span>。<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这是一道动态规划的题目，自己没想出来，看了题解才理解<br />核心的思想就是，<em>以当前字符结尾的不同子序列的个数=之前部分的个数+新增加的个数-重复序列个数</em><br />其中，需要一个数组<code>recount[]</code>来记录每个字符带来的增加量，当某字符多次出现时，它带来的重复量就等于<code>recount[i]</code></p><p>比如：对于序列 abcb</p><p>a : “”, a<br /><strong>newcnt=1</strong></p><p>ab : “”, a, b, ab<br /><strong>newcnt=2</strong></p><p>abc : “”,a, b, ab, c, ac, bc, cc<br /><strong>newcnt=4</strong></p><p>abcb: “”,a, b, ab, c, ac, bc, cc, <s>b</s>, <s>ab</s>, bb, abb, cb, acb, bcb, ccb<br /><strong>newcnt=8, recount[‘b’]=2</strong></p><p>根据以上例子，可得到下面的结论：</p><ul><li>newcnt=pre_cnt(上一个字符的个数)</li><li>recount[x]=newcnt_x(字符x上一次出现带来的新增个数)</li></ul><p>为了计算，在子集前面加了空串 <code>“”</code>，所以初始个数为1</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> distinctSubseqII(string s) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">mod</span>=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        <span class="hljs-built_in">int</span> len=s.size();<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; recount(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> newcnt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            newcnt=ans;<br>            ans=((ans+newcnt)%<span class="hljs-keyword">mod</span>-recount[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]+<span class="hljs-keyword">mod</span>)%<span class="hljs-keyword">mod</span>;<br>            recount[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]=newcnt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>优势洗牌</title>
    <link href="/2022/10/09/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/"/>
    <url>/2022/10/09/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C">优势洗牌</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="优势洗牌"><a class="markdownIt-Anchor" href="#优势洗牌"></a> 优势洗牌</h2><p><a href="https://leetcode.cn/problems/advantage-shuffle/">题目链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] &gt; nums2[i] 的索引 i 的数目来描述。</p><p>返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。</p><p>示例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums1 = <span class="hljs-string">[12,24,8,32]</span>, nums2 = <span class="hljs-string">[13,25,32,11]</span><br>输出：<span class="hljs-string">[24,32,8,12]</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><blockquote><p>题目有一个隐含条件是，当nums1中的某个数不大于于nums2的任意数时，该数对应nums2的较大的数。具体步骤如下，先将两个数组的下标根据数字的大小升序排序，然后当nums1中的数大于nums2的数，加入答案数组中，否则找到对应nums2中的较大数的对应位置，根据该位置加入答案数组中</p></blockquote><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">advantageCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(len)</span>,<span class="hljs-title">a</span><span class="hljs-params">(len)</span>,<span class="hljs-title">b</span><span class="hljs-params">(len)</span></span>;<br>        <span class="hljs-built_in">iota</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">iota</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)&#123;<br>            <span class="hljs-keyword">return</span> nums1[i]&lt;nums1[j];<br>        &#125;);<br>        <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)&#123;<br>            <span class="hljs-keyword">return</span> nums2[i]&lt;nums2[j];<br>        &#125;);<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=len<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums1[a[i]]&gt;nums2[b[l]])<br>            &#123;<br>                ans[b[l]]=nums1[a[i]];<br>                ++l;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ans[b[r]]=nums1[a[i]];<br>                --r;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>括号问题</title>
    <link href="/2022/10/07/%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/"/>
    <url>/2022/10/07/%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D">括号匹配</a></li><li><a href="#%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%91%E6%B7%BB%E5%8A%A0">使括号有效的最少添加</a></li><li><a href="#%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90">括号生成</a></li><li><a href="#%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%95%B0">括号的分数</a></li></ul><!-- /TOC --><blockquote><p>关于括号多多少少会用到栈，下面举几个简单例子</p></blockquote><h3 id="括号匹配"><a class="markdownIt-Anchor" href="#括号匹配"></a> 括号匹配</h3><p><a href="https://leetcode.cn/problems/valid-parentheses/">题目链接</a></p><p><strong>题目描述</strong></p><p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ul><p>example：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">bool</span> isValid(<span class="hljs-keyword">string</span> s) &#123;<br>        <span class="hljs-keyword">int</span> len=s.size();<br>        stack&lt;<span class="hljs-keyword">char</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-keyword">empty</span>()&amp;&amp;(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>||s[i]==<span class="hljs-string">&#x27;]&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st.<span class="hljs-keyword">empty</span>())<br>                st.push(s[i]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>||s[i]==<span class="hljs-string">&#x27;[&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>            &#123;<br>                <span class="hljs-comment">// if(s[i]&lt;=st.top())</span><br>                    st.push(s[i]);<br>                <span class="hljs-comment">// else</span><br>                <span class="hljs-comment">//     return false;</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>||s[i]==<span class="hljs-string">&#x27;]&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(st.top()==s[i]<span class="hljs-number">-1</span>||st.top()==s[i]<span class="hljs-number">-2</span>)<br>                    st.pop();<br>                <span class="hljs-keyword">else</span> <br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!st.<span class="hljs-keyword">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使括号有效的最少添加"><a class="markdownIt-Anchor" href="#使括号有效的最少添加"></a> 使括号有效的最少添加</h3><p><a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/">题目链接</a></p><p><strong>题目描述</strong></p><p>只有满足下面几点之一，括号字符串才是有效的：</p><p>它是一个空字符串，或者<br />它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者<br />它可以被写作 (A)，其中 A 是有效字符串。<br />给定一个括号字符串 s ，移动N次，你就可以在字符串的任何位置插入一个括号。</p><p>例如，如果 s = “()))” ，你可以插入一个开始括号为 “(()))” 或结束括号为 “())))” 。<br />返回 为使结果字符串 s 有效而必须添加的最少括号数。</p><p>example：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;())&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> minAddToMakeValid(string s) &#123;<br>        <span class="hljs-keyword">int</span> len=s.<span class="hljs-keyword">size</span>();<br>        stack&lt;<span class="hljs-keyword">char</span>&gt; st;<br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>&amp; c:s)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;(&#x27;</span>)<br>                st.<span class="hljs-keyword">push</span>(c);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;)&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(st.empty())<br>                    ++ans;<br>                <span class="hljs-keyword">else</span><br>                    st.<span class="hljs-keyword">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans+st.<span class="hljs-keyword">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="括号生成"><a class="markdownIt-Anchor" href="#括号生成"></a> 括号生成</h3><p><a href="https://leetcode.cn/problems/generate-parentheses/">题目链接</a></p><p><strong>题目描述</strong><br />数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。</p><p>example：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bk</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> &amp;tmp,vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; ans,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> n</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(tmp.size()==<span class="hljs-number">2</span>*n)<br>        &#123;<br>            ans.push_back(tmp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l&lt;n)<br>        &#123;<br>            tmp.push_back(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            bk(tmp,ans,l+<span class="hljs-number">1</span>,r,n);<br>            tmp.pop_back();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r&lt;l)<br>        &#123;<br>            tmp.push_back(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            bk(tmp,ans,l,r+<span class="hljs-number">1</span>,n);<br>            tmp.pop_back();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">generateParenthesis</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> &#123;<br>        <span class="hljs-built_in">string</span> tmp;<br>        vector&lt;<span class="hljs-built_in">string</span>&gt; ans;<br>        bk(tmp,ans,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="括号的分数"><a class="markdownIt-Anchor" href="#括号的分数"></a> 括号的分数</h3><p><a href="https://leetcode.cn/problems/score-of-parentheses/">题目链接</a></p><p><strong>题目描述</strong></p><p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：</p><ul><li>() 得 1 分。```A 是平衡括号字符串。</li></ul><p>样例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">输入： &quot;(()(()))&quot;<br>输出： <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p>因为(()(())) = (()) + ((()))，所以记录层数就好<br />出现 ‘(’ 代表层数+1 ， 出现 ‘)’ 代表层数-1<br />当<code>s[i]==')'&amp;&amp;s[i-1]=='('</code>,该部分得分为 2^(层数-1) ,更新一下总分数</p><p>代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">scoreOfParentheses</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> d=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> len=s.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>)<br>                ++d;<br>            <span class="hljs-keyword">else</span><br>                --d;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;(&#x27;</span>)<br>                ans+=<span class="hljs-number">1</span>&lt;&lt;d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LR字符串</title>
    <link href="/2022/10/02/LR%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/10/02/LR%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%9C%A8lr%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6">在LR字符串中交换相邻字符</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="在lr字符串中交换相邻字符"><a class="markdownIt-Anchor" href="#在lr字符串中交换相邻字符"></a> 在LR字符串中交换相邻字符</h2><p><a href="https://leetcode.cn/problems/swap-adjacent-in-lr-string/">原题链接</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如&quot;RXXLRXRXL&quot;）中进行移动操作。一次移动操作指用一个&quot;LX&quot;替换一个&quot;XL&quot;，或者用一个&quot;XR&quot;替换一个&quot;RX&quot;。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。</p><p>input:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">start</span> = <span class="hljs-string">&quot;RXXLRXRXL&quot;</span>, end = <span class="hljs-string">&quot;XRLXXRRLX&quot;</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>用 i 和 j 分别表示 start 和 end 中的下标，跳过所有的<code>X</code>，当<code>start[i]!=start[j]</code>,直接返回false,当<code>start[i]==start[j]</code>，如果字符是<code>L</code>,应满足<code>j&lt;=i</code>,如果字符是<code>R</code>,应满足<code>i&lt;=j</code>，否则返回<code>false</code></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canTransform</span><span class="hljs-params">(string start, string end)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=start.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;n&amp;&amp;j&lt;n)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(i&lt;n&amp;&amp;start[i]==<span class="hljs-string">&#x27;X&#x27;</span>)<br>                ++i;<br>            <span class="hljs-keyword">while</span>(j&lt;n&amp;&amp;end[j]==<span class="hljs-string">&#x27;X&#x27;</span>)<br>                ++j;<br>            <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;j&lt;n)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(start[i]!=end[j])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(start[i]==<span class="hljs-string">&#x27;L&#x27;</span>&amp;&amp;i&lt;j)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span>(start[i]==<span class="hljs-string">&#x27;R&#x27;</span>&amp;&amp;i&gt;j)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                ++i;<br>                ++j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i&lt;n)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(start[i]!=<span class="hljs-string">&#x27;X&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j&lt;n)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(end[j]!=<span class="hljs-string">&#x27;X&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>非零段划分</title>
    <link href="/2022/09/29/%E9%9D%9E%E9%9B%B6%E6%AE%B5%E5%88%92%E5%88%86/"/>
    <url>/2022/09/29/%E9%9D%9E%E9%9B%B6%E6%AE%B5%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%9D%9E%E9%9B%B6%E6%AE%B5%E5%88%92%E5%88%86">非零段划分</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="非零段划分"><a class="markdownIt-Anchor" href="#非零段划分"></a> 非零段划分</h2><p>题目来自CCF 201909-2</p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>A1,A2,⋯,An 是一个由 n 个自然数组成的数组。我们称其中 Ai,⋯,Aj 是一个非零段，当且仅当以下条件同时满足：</p><ul><li>1≤i≤j≤n；</li><li>对于任意的整数 k，若 i≤k≤j，则 Ak&gt;0；</li><li>i=1 或 Ai−1=0；</li><li>j=n 或 Aj+1=0。</li></ul><p>下面展示了几个简单的例子：</p><p>A=[3,1,2,0,0,2,0,4,5,0,2] 中的 4 个非零段依次为 [3,1,2]、[2]、[4,5] 和 [2]；<br />A=[2,3,1,4,5] 仅有 1 个非零段；<br />A=[0,0,0] 则不含非零段（即非零段个数为 0）。</p><p>现在我们可以对数组 A 进行如下操作：任选一个正整数 p，然后将 A 中所有小于 p 的数都变为 0。试选取一个合适的 p，使得数组 A 中的非零段个数达到最大。若输入的 A 所含非零段数已达最大值，可取 p=1，即不对 A 做任何修改。</p><p>输入：<br />从标准输入读入数据。</p><p>输入的第一行包含一个正整数 n。</p><p>输入的第二行包含 n 个用空格分隔的自然数 A1,A2,⋯,An。</p><p>输出：</p><p>输出到标准输出。</p><p>仅输出一个整数，表示对数组 A 进行操作后，其非零段个数能达到的最大值。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>差分与前缀和<br />如果 <code>a[i]&gt;a[i−1]</code>，意味着当p取到 <code>a[i−1]+1 </code>到 <code>a[i]</code>之间的值时，非零段+1<br />数组<code>b[i]</code>表示<code>p</code>从<code>a[i-1]</code>到<code>a[i]</code>，非零段数量的变化<br />从正向前缀和中找出最大值就是所要的结果</p><p>差分前缀和之前练习过，但这道题真没想到还能这样，tcl😢，看了别人的思路，实在是太妙了啊😢😢😢😢</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M=<span class="hljs-number">1e4</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> b[M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>cin&gt;&gt;a[i];<br><span class="hljs-keyword">if</span>(a[i]&gt;a[i<span class="hljs-number">-1</span>])<br>&#123;<br><span class="hljs-comment">//a[i-1]~a[i]的非零段数加1 </span><br>++b[a[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>];<br>--b[a[i]+<span class="hljs-number">1</span>];<br>&#125; <br>&#125;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=M;++i)<br>&#123;<br>sum+=b[i];<br>ans=<span class="hljs-built_in">max</span>(ans,sum);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第k个数</title>
    <link href="/2022/09/29/%E7%AC%ACk%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/09/29/%E7%AC%ACk%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%AC%ACk%E4%B8%AA%E6%95%B0">第k个数</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E7%AC%AC-n-%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97">第 N 个神奇数字</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF-1">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81-1">代码</a></li></ul></li></ul><!-- /TOC --><h2 id="第k个数"><a class="markdownIt-Anchor" href="#第k个数"></a> 第k个数</h2><blockquote><p>此题不是特别难，但是第一眼看过去没有什么太好的想法，看了眼题解觉得思路很好，就记录下来<br /><s>顺便水一个博客😄</s></p></blockquote><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p><p>输入k，输出符合条件的第k个数</p><p>input:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">9<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>建立一个数组<code>dp[]</code>，<code>dp[i]</code>表示第<code>i</code>个数什么，然后三个变量a,b,c表示3、5、7的指针</p><p>状态方程：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int <span class="hljs-attribute">numa</span>=dp[a]<span class="hljs-number">*3</span>,<span class="hljs-attribute">numb</span>=dp[b]<span class="hljs-number">*5</span>,<span class="hljs-attribute">numc</span>=dp[c]<span class="hljs-number">*7</span>;<br>dp[i]=min(min(numa,numb),numc);<br></code></pre></td></tr></table></figure><p>然后如果<code>dp[i]</code>与任何一个num相等，对应的指针加1</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>const int <span class="hljs-attribute">N</span>=1e3;<br>int dp[N];<br>int main()<br>&#123;<br>int n;<br>cin&gt;&gt;n;<br>int <span class="hljs-attribute">a</span>=1,b=1,c=1;<br>dp[1]=1;<br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=2;i&lt;=n;++i)<br>&#123;<br>int <span class="hljs-attribute">numa</span>=dp[a]<span class="hljs-number">*3</span>,<span class="hljs-attribute">numb</span>=dp[b]<span class="hljs-number">*5</span>,<span class="hljs-attribute">numc</span>=dp[c]<span class="hljs-number">*7</span>;<br>dp[i]=min(min(numa,numb),numc);<br><span class="hljs-keyword">if</span>(dp[i]==numa)<br>++a;<br><span class="hljs-keyword">if</span>(dp[i]==numb)<br>++b;<br><span class="hljs-keyword">if</span>(dp[i]==numc)<br>++c;<br>&#125;<br>cout&lt;&lt;dp[n]&lt;&lt;endl;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第-n-个神奇数字"><a class="markdownIt-Anchor" href="#第-n-个神奇数字"></a> 第 N 个神奇数字</h2><p><a href="https://leetcode.cn/problems/nth-magical-number/description/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>一个正整数如果能被 a 或 b 整除，那么它是神奇的。</p><p>给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 109 + 7 取模 后的值。</p><p>示例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">4</span>, <span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>用到了容斥原理，对于一个数x，他包含<code>x/a</code>个数能被a整除，包含<code>x/b</code>个数能被b整除,若a和b最小公倍数为c，那么x包含<code>x/c</code>个数能被a和b同时整除，因此，能被a或b整除的数的个数为：<code>x/a+x/b-x/c</code></p><p>根据以上规律，使用二分查找即可得出答案。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">mod</span>=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">mod</span>=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>    <span class="hljs-built_in">int</span> gcd(<span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b)<br>            <span class="hljs-keyword">return</span> gcd(b,a%b);<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-built_in">int</span> nthMagicalNumber(<span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) &#123;<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> l=min(a,b);<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> r=(<span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span>)n*l;<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> c=a*b/gcd(a,b);<br>        <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> mid,t;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)<br>        &#123;<br>            mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>            t=mid/a+mid/b-mid/c;<br>            <span class="hljs-keyword">if</span>(t&lt;n)<br>                l=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                r=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (r+<span class="hljs-number">1</span>)%<span class="hljs-keyword">mod</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>素数筛</title>
    <link href="/2022/09/25/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    <url>/2022/09/25/%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9A%B4%E5%8A%9B">暴力</a></li><li><a href="#%E5%9F%83%E6%B0%8F%E7%AD%9B">埃氏筛</a></li><li><a href="#%E6%AC%A7%E6%8B%89%E7%AD%9B">欧拉筛</a></li><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li></ul><!-- /TOC --><p><strong>素数筛</strong></p><blockquote><p>找到1到n区间里的所有素数,通常有以下几种方法</p></blockquote><h3 id="暴力"><a class="markdownIt-Anchor" href="#暴力"></a> 暴力</h3><p>最基本的方法，时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h3 id="埃氏筛"><a class="markdownIt-Anchor" href="#埃氏筛"></a> 埃氏筛</h3><p>主要思想是通过一个<code>bool</code>类型的数组记录某数是否为素数，思路不难，直接看代码就行</p><p><strong>代码</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>        isPrime[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//假设2-n都是素数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)   <span class="hljs-comment">//遍历2-n里面所有数</span><br>        <span class="hljs-keyword">if</span>(isPrime[i])      <span class="hljs-comment">//如果i是素数</span><br>            <span class="hljs-comment">//i是素数的话，那么i的倍数肯定就不是合适</span><br>            <span class="hljs-comment">//即 i*2，i*3 .....i*j肯定不是素数，注意边界i*j&lt;=n</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;i*j&lt;=n;++j)<br>                <span class="hljs-comment">//n以内，且是i的倍数的数肯定不是素数，设为false</span><br>                isPrime[i*j] = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h3 id="欧拉筛"><a class="markdownIt-Anchor" href="#欧拉筛"></a> 欧拉筛</h3><p>在埃尼筛的基础上加以改进，需要维护一个<code>vis[]</code>数组判断是否被标记过，然后<code>prime[]</code>数组记录第几个素数是什么，比较好理解，看一道例题就行</p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p><strong>题目描述</strong></p><p>Output the k-th prime number.</p><p>input:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">17<br></code></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>;<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-type">int</span> prime[<span class="hljs-number">10000</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    cin&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=N;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(cnt==k)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-literal">false</span>)<br>            prime[++cnt]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=N;++j)<br>        &#123;<br>            vis[i*prime[j]]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;prime[k]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>相似度为k的字符串</title>
    <link href="/2022/09/23/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%BAk%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/09/23/%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%BAk%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%BAk%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2">相似度为k的字符串</a></li></ul><!-- /TOC --><h3 id="相似度为k的字符串"><a class="markdownIt-Anchor" href="#相似度为k的字符串"></a> 相似度为k的字符串</h3><p><a href="https://leetcode.cn/problems/k-similar-strings/">题目链接</a></p><p><strong>题目描述</strong></p><p>对于某些非负整数 <code>k</code> ，如果交换 <code>s1</code> 中两个字母的位置恰好 <code>k</code> 次，能够使结果字符串等于 <code>s2</code> ，则认为字符串 <code>s1</code> 和 <code>s2</code> 的 相似度为<code> k</code> 。</p><p>给你两个字母异位词 <code>s1 </code>和 <code>s2</code> ，返回 <code>s1 </code>和<code>s2</code>的相似度<code>k</code>的最小值。</p><p><strong>思路</strong></p><blockquote><p>主要是BFS+剪枝，当s1和s2在某个位置出现s1[i] != s2[i]时，将s1的指针后移，找到j使得s1[j] == s2[i],然后交换s1[i]和s1[j]，将字符串和位置加入队列中。同时要注意剪枝，当s1[j]==s2[j]时说明本来就能匹配，所以无需交换，当交换后的字符串在之前已经出现时，无需再次加入队列。</p></blockquote><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> queue&lt;pair&lt;string,<span class="hljs-type">int</span>&gt;&gt; qpi;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_set&lt;string&gt; vis;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kSimilarity</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        qpi q;<br>        <span class="hljs-type">int</span> len=s1.<span class="hljs-built_in">size</span>();<br>        q.<span class="hljs-built_in">push</span>(&#123;s1,<span class="hljs-number">0</span>&#125;);<br>        vis.<span class="hljs-built_in">insert</span>(s1);<br>        string ts;<br>        <span class="hljs-type">int</span> idx;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;;++ans)<br>        &#123;<br>            <span class="hljs-type">int</span> sz=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(sz--)<br>            &#123;<br>                pair&lt;string,<span class="hljs-type">int</span>&gt; t=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                ts=t.first;<br>                idx=t.second;<br>                <span class="hljs-keyword">if</span>(ts==s2)<br>                    <span class="hljs-keyword">return</span> ans;<br>                <span class="hljs-keyword">while</span>(idx&lt;len&amp;&amp;ts[idx]==s2[idx])<br>                    ++idx;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=idx+<span class="hljs-number">1</span>;i&lt;len;++i)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(ts[i]!=s2[i]&amp;&amp;ts[i]==s2[idx])<br>                    &#123;<br>                        <span class="hljs-built_in">swap</span>(ts[idx],ts[i]);<br>                        <span class="hljs-keyword">if</span>(!vis.<span class="hljs-built_in">count</span>(ts))<br>                        &#123;<br>                            q.<span class="hljs-built_in">push</span>(&#123;ts,idx+<span class="hljs-number">1</span>&#125;);<br>                            vis.<span class="hljs-built_in">insert</span>(ts);<br>                        &#125;<br>                        <span class="hljs-built_in">swap</span>(ts[idx],ts[i]);<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组中的逆序对</title>
    <link href="/2022/09/20/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <url>/2022/09/20/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9">数组中的逆序对</a></li></ul><!-- /TOC --><h3 id="数组中的逆序对"><a class="markdownIt-Anchor" href="#数组中的逆序对"></a> 数组中的逆序对</h3><p><strong>题目描述</strong></p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p>这道题可以用归并排序的思路来解决</p><p>假设我们有两个已排序的序列等待合并，分别是L={8,12,16,22,100} 和 R={9,26,55,64,91}。一开始我们用指针 lPtr = 0 指向 L 的首部，rPtr = 0 指向 R 的头部。记已经合并好的部分为 M。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">L = <span class="hljs-comment">[8, 12, 16, 22, 100]</span>   R = <span class="hljs-comment">[9, 26, 55, 64, 91]</span>  M = <span class="hljs-comment">[]</span><br>     |                          |<br>   lPtr                       rPtr<br></code></pre></td></tr></table></figure><p>发现 lPtr 指向的元素小于 rPtr 指向的元素，于是把 lPtr 指向的元素放入答案，并把 lPtr 后移一位。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">L = <span class="hljs-comment">[8, 12, 16, 22, 100]</span>   R = <span class="hljs-comment">[9, 26, 55, 64, 91]</span>  M = <span class="hljs-comment">[8]</span><br>        |                       |<br>      lPtr                     rPtr<br><br></code></pre></td></tr></table></figure><p>这个时候我们把左边的 8 加入了答案，我们发现右边没有数比 8 小，所以 8 对逆序对总数的「贡献」为 0。</p><p>接着我们继续合并，把 9 加入了答案，此时 lPtr 指向 12，rPtr 指向 26。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">L = <span class="hljs-comment">[8, 12, 16, 22, 100]</span>   R = <span class="hljs-comment">[9, 26, 55, 64, 91]</span>  M = <span class="hljs-comment">[8, 9]</span><br>        |                          |<br>       lPtr                       rPtr<br><br></code></pre></td></tr></table></figure><p>此时12对逆序数贡献为1，以此类推。</p><p><strong>代码</strong>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>int nums[100005];<br>int cnt;<br>int <span class="hljs-attribute">mod</span>=1e9+7;<br>void merge(int l,int m,int r)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-attribute">l</span>==r)<br>        return ;<br>    int i,j;<br>    int <span class="hljs-attribute">n1</span>=m-l+1;<br>    int <span class="hljs-attribute">n2</span>=r-m;<br>    vector&lt;int&gt; al(n1);<br>    vector&lt;int&gt; ar(n2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-attribute">i</span>=0;i&lt;n1;++i)<br>        al[i]=nums[l+i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-attribute">i</span>=0;i&lt;n2;++i)<br>        ar[i]=nums[m+1+i];<br>    <span class="hljs-attribute">i</span>=0;<br>    <span class="hljs-attribute">j</span>=0;<br>    int <span class="hljs-attribute">k</span>=l;<br>    <span class="hljs-keyword">while</span>(i&lt;n1&amp;&amp;j&lt;n2)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(al[i]&lt;=ar[j])<br>        &#123;<br>            nums[k]=al[i];<br>            ++k;<br>            ++i;<br>            cnt+=j;<br>            <span class="hljs-attribute">cnt</span>=cnt%mod;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            nums[k]=ar[j];<br>            ++k;<br>            ++j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;n1)<br>    &#123;<br>        nums[k++]=al[i];<br>        cnt+=j;<br>        <span class="hljs-attribute">cnt</span>=cnt%mod;<br>        ++i;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j&lt;n2)<br>    &#123;<br>        nums[k++]=ar[j];<br>        ++j;<br>    &#125;    <br>&#125;<br>void mergesort(int l,int r)<br>&#123;<br>    <span class="hljs-keyword">if</span>(l&lt;r)<br>    &#123;<br>        int <span class="hljs-attribute">m</span>=l+r&gt;&gt;1;<br>        mergesort(l,m);<br>        mergesort(m+1,r);<br>        merge(l,m,r);<br>    &#125;<br>&#125;<br>int main() <br>&#123;<br>int n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0;i&lt;n;++i)<br>cin&gt;&gt;nums[i];<br>    mergesort(0,n-1);<br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最长达标子串</title>
    <link href="/2022/09/17/%E6%9C%80%E9%95%BF%E8%BE%BE%E6%A0%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/09/17/%E6%9C%80%E9%95%BF%E8%BE%BE%E6%A0%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%9C%80%E9%95%BF%E8%BE%BE%E6%A0%87%E5%AD%90%E4%B8%B2">最长达标子串</a></li><li><a href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%BB%83%E4%B9%A0">位操作练习</a></li></ul><!-- /TOC --><h3 id="最长达标子串"><a class="markdownIt-Anchor" href="#最长达标子串"></a> 最长达标子串</h3><p><strong>题目描述</strong></p><p>给定一个字符串<code>s</code>，其中都是英文小写字母，如果<code>s</code>的子串中含有的每种字符都是偶数个，那么这样的子串就是达标子串，输出达标子串的最大长度。</p><p>input:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">aababcdcdc</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用一个数组记录当前的状态，<code>1</code>表示当前字母出现了奇数次，<code>0</code>表示当前字母出现了偶数次</p><p>例如：如果<code>s</code>一共有四个字母<code>abcd</code>，子串<code>a</code>的状态可记为<code>1000</code>，子串<code>aab</code>记为<code>0100</code><br />,子串<code>abacd</code>记为<code>0111</code></p><p>可以得出这样的结论：如果<code>i</code>处的状态与<code>i+k</code>处的状态相同，则<code>i~i+k</code>之间的子串中的每个字母都出现了偶数次</p><p>原理就是出现偶数次，不会改变某个字母的状态</p><p>所以，只需要记录每个状态序列最早出现的位置，然后当他再次出现时，最晚出现的位置减去最早出现的位置就是最长的达标子串。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s;<br>cin&gt;&gt;s;<br><span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br><span class="hljs-type">int</span> status=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>mp[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<span class="hljs-comment">//初始化-1位置为0...00 32个0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>&#123;<br><span class="hljs-comment">//假设当前s[i]是&#x27;c&#x27;,那么将1左移2位，然后和status异或</span><br><span class="hljs-comment">//即可改变&#x27;c&#x27;处的状态 </span><br>status=status^<span class="hljs-number">1</span>&lt;&lt;s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(status))<br>ans=<span class="hljs-built_in">max</span>(ans,i-mp[status]);<br><span class="hljs-keyword">else</span><br>mp[status]=i; <br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="位操作练习"><a class="markdownIt-Anchor" href="#位操作练习"></a> 位操作练习</h3><p><strong>题目描述</strong></p><p>给出两个不大于65535的非负整数，判断其中一个的16位二进制表示形式，是否能由另一个的16位二进制表示形式经过循环左移若干位而得到。 循环左移和普通左移的区别在于：最左边的那一位经过循环左移一位后就会被移到最右边去。比如： 1011 0000 0000 0001 经过循环左移一位后，变成 0110 0000 0000 0011, 若是循环左移2位，则变成 1100 0000 0000 0110</p><p>输入两个不大于65535的非负整数</p><p>如果能通过循环左移相等，输出<code>YES</code>,否则输出<code>NO</code></p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">45057 </span><span class="hljs-number">49158</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">YES</span><br></code></pre></td></tr></table></figure><p>这个就不说了，直接看代码就行了</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> a,b;<br>cin&gt;&gt;a&gt;&gt;b;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">16</span>;++i)<br>&#123;<br><span class="hljs-keyword">if</span>(a==b)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(i==<span class="hljs-number">15</span>)<br>cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>a=a&lt;&lt;<span class="hljs-number">1</span> | a&gt;&gt;<span class="hljs-number">15</span>&amp;<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>龙与地下城游戏问题</title>
    <link href="/2022/09/16/%E9%BE%99%E4%B8%8E%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/16/%E9%BE%99%E4%B8%8E%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%BE%99%E4%B8%8E%E5%9C%B0%E4%B8%8B%E5%9F%8E%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98">龙与地下城迷宫问题</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li></ul><!-- /TOC --><h2 id="龙与地下城迷宫问题"><a class="markdownIt-Anchor" href="#龙与地下城迷宫问题"></a> 龙与地下城迷宫问题</h2><p><a href="https://www.nowcoder.com/practice/c0ca4c9e65144af69ada03febaa0e33a?tpId=230&amp;tqId=537494&amp;ru=/exam/oj&amp;qru=/ta/dynamic-programming/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D230">题目链接</a></p><p><strong>题目描述</strong></p><p>给定一个二维数组map，含义是一张地图</p><p>游戏的规则如下:<br />1）骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。<br />2）地图中每个位置的值代表骑士要遭遇的事情。如果是负数，说明此处有怪兽，要让骑士损失血量。如果是非负数，代表此处有血瓶，能让骑士回血。<br />3）骑士从左上角到右下角的过程中，走到任何一个位置时，血量都不能少于1。为了保证骑土能见到公主，初始血量至少是多少?</p><p>根据map,输出初始血量。</p><p>输入第一行<code>n,m</code>，表示矩阵大小<br />然后输入矩阵</p><p>输出初始血量</p><p>input:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">3 3<br><span class="hljs-string">-2</span> <span class="hljs-string">-3</span> 3<br><span class="hljs-string">-5</span> <span class="hljs-string">-10</span> 1<br>0 30 <span class="hljs-string">-5</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>这道题也属于dp，但是有意思的是，如果我们选择 <code>自顶向下</code> 的方式，即从左上角出发，在前进过程中，每一个位置的最小血量是由后面的路径决定的，因此<code>自顶向下</code> 方法是不行的，那么我们可以选择<code> 自底向上</code> 的方式，从右下角出发。</p><p><code>dp[i][j]</code>可理解为，走<code>a[i][j]</code>之前，至少要拥有的血量，且这个血量始终不能小于1</p><p>所以<code>dp[n][m]</code>初始化为<code>max(1-a[n][m],1)</code></p><p>然后从右下角到左上角更新dp数组即可</p><p><strong>代码</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include &lt;bits/stdc++.h&gt;<br>using namespace std;<br><br>const int N=1e3+5;<br>int a<span class="hljs-comment">[N]</span><span class="hljs-comment">[N]</span>,dp<span class="hljs-comment">[N]</span><span class="hljs-comment">[N]</span>;<br>int main()<br>&#123;<br>    int n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        for(int j=1;j&lt;=m;++j)<br>            cin&gt;&gt;a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>;<br>    &#125;<br>    dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[m]</span>=max(1-a<span class="hljs-comment">[n]</span><span class="hljs-comment">[m]</span>,1);<br>    for(int i=n-1;i&gt;=1;--i)<br>        dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[m]</span>=max(dp<span class="hljs-comment">[i+1]</span><span class="hljs-comment">[m]</span>-a<span class="hljs-comment">[i]</span><span class="hljs-comment">[m]</span>,1);<br>    for(int i=m-1;i&gt;=1;--i)<br>        dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[i]</span>=max(dp<span class="hljs-comment">[n]</span><span class="hljs-comment">[i+1]</span>-a<span class="hljs-comment">[n]</span><span class="hljs-comment">[i]</span>,1);<br>    for(int i=n-1;i&gt;=1;--i)<br>    &#123;<br>        for(int j=m-1;j&gt;=1;--j)<br>        &#123;<br>            int t=min(dp<span class="hljs-comment">[i+1]</span><span class="hljs-comment">[j]</span>-a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j+1]</span>-a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>);<br>            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(t,1);<br>        &#125;<br>    &#125;<br>    <br>    cout&lt;&lt;dp<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span>&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dp练习</title>
    <link href="/2022/09/15/dp%E7%BB%83%E4%B9%A0/"/>
    <url>/2022/09/15/dp%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%B8%8D%E5%90%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%B8%AA%E6%95%B0">不同二叉搜索树的个数</a></li><li><a href="#%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF">最小花费爬楼梯</a></li><li><a href="#%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9">最小花费</a></li><li><a href="#%E5%88%86%E9%85%8D%E5%AE%9D%E8%97%8F">分配宝藏</a></li></ul><!-- /TOC --><h2 id="不同二叉搜索树的个数"><a class="markdownIt-Anchor" href="#不同二叉搜索树的个数"></a> 不同二叉搜索树的个数</h2><p><strong>题目描述</strong></p><p>给定一个由节点值从 1 到 n 的 n 个节点。请问由多少种不同的方法用这 n 个节点构成互不相同的二叉搜索树。</p><p>仅一行输入一个正整数 n ，表示节点的数量。</p><p>输出组成不同二叉搜索树的方法数。</p><p>input:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p><code>dp[k]</code>表示<code>k</code>个节点时不同二叉搜索树的个数，当有<code>n</code>个节点时，以<code>i</code>为根节点的左子树有<code>i-1</code>个节点，而右子树有<code>i-j</code>个节点，所以以<code>i</code>为根节点的二叉搜索树一共有<code>dp[i-1]*d[i-j]</code>个</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">20</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>        &#123;<br>            dp[i]+=dp[j<span class="hljs-number">-1</span>]*dp[i-j];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最小花费爬楼梯"><a class="markdownIt-Anchor" href="#最小花费爬楼梯"></a> 最小花费爬楼梯</h2><p><strong>题目描述</strong></p><p>给定一个整数数组 <code>cost[]</code> ，其中 <code>cost[i]</code>是从楼梯第<code>i</code>个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">10</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">100</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">90</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">80</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></table></figure><p><strong>思路</strong></p><p><code>dp[i]</code>表示第<code>i</code>个台阶之前的最小花费<br />因为一次能走一级或者两级台阶，所以<code>dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])</code></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> cost[N];<br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        cin&gt;&gt;cost[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n+<span class="hljs-number">1</span>;++i)<br>    &#123;<br>        dp[i]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>]+cost[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]+cost[i<span class="hljs-number">-2</span>]);<br>    &#125;<br>    cout&lt;&lt;dp[n+<span class="hljs-number">1</span>]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最小花费"><a class="markdownIt-Anchor" href="#最小花费"></a> 最小花费</h2><p><strong>题目描述</strong></p><p>在某条线路上有N个火车站，有三种距离的路程，L1，L2，L3,对应的价格为C1,C2,C3.<br />每两个站之间的距离不超过L3。 当乘客要移动的两个站的距离大于L3的时候，可以选择从中间一个站下车，然后买票再上车，所以乘客整个过程中至少会买两张票。 现在给你一个 L1，L2，L3，C1，C2，C3。然后是A，B的值，其分别为乘客旅程的起始站和终点站。 然后输入N，N为该线路上的总的火车站数目，然后输入N-1个整数，分别代表从该线路上的第一个站，到第2个站，第3个站，……，第N个站的距离。 根据输入，输出乘客从A到B站的最小花费。</p><p><strong>输入描述</strong></p><p>第一行输入l1,l2,l3,c1,c2,c3<br />第二行输入a,b<br />第三行输入n<br />第四行输入n-1个数，表示第一站到后面站的距离</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>output:</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>;<br><span class="hljs-type">int</span> l1,l2,l3,c1,c2,c3;<br><span class="hljs-type">int</span> a,b;<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getprice</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(dis[b]-dis[a]&lt;=l1)<br>        <span class="hljs-keyword">return</span> c1;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dis[b]-dis[a]&lt;=l2)<br>        <span class="hljs-keyword">return</span> c2;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> c3;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;l1&gt;&gt;l2&gt;&gt;l3&gt;&gt;c1&gt;&gt;c2&gt;&gt;c3)<br>    &#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        cin&gt;&gt;n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>            cin&gt;&gt;dis[i];<br>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>        dp[a]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a+<span class="hljs-number">1</span>;i&lt;=b;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=a;j&lt;i;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dis[i]-dis[j]&lt;=l3)<br>                    dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[j]+<span class="hljs-built_in">getprice</span>(j,i));<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;dp[b]&lt;&lt;endl;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分配宝藏"><a class="markdownIt-Anchor" href="#分配宝藏"></a> 分配宝藏</h2><p><strong>题目描述</strong></p><p>两个寻宝者找到一个宝藏，里面包含n件物品，每件物品的价值分别是W[0]，W[1]，…W[n-1]。<br />SumA代表寻宝者A所获物品价值总和，SumB代表寻宝者B所获物品价值总和，请问怎么分配才能使得两人所获物品价值总和差距最小，即两人所获物品价值总和之差的绝对值|SumA - SumB|最小。</p><p>输入说明<br />输入数据由两行构成：<br />第一行为一个正整数n，表示物品个数，其中<code>0&lt;n&lt;=200</code>。<br />第二行有n个正整数，分别代表每件物品的价值<code>W[i]</code>，其中<code>0&lt;W[i]&lt;=200</code>。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><p><strong>思路</strong><br />其实是一道<strong>01背包问题</strong>，只需要将背包容量设置为总价值的一半即可</p><p>代码</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs excel">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const <span class="hljs-built_in">int</span> <span class="hljs-built_in">N</span>=<span class="hljs-number">1</span>e6+<span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> a[<span class="hljs-built_in">N</span>];<br><span class="hljs-built_in">int</span> dp[<span class="hljs-built_in">N</span>]; <br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>;<br>cin&gt;&gt;<span class="hljs-built_in">n</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span>;<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">n</span>;++i)<br>&#123;<br>cin&gt;&gt;a[i];<br><span class="hljs-built_in">sum</span>+=a[i];<br>&#125;<br><span class="hljs-built_in">int</span> v=<span class="hljs-built_in">sum</span>/<span class="hljs-number">2</span>;<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">n</span>;++i)<br>&#123;<br>for(<span class="hljs-built_in">int</span> j=v;j&gt;=a[i];--j)<br>&#123;<br>dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-a[i]]+a[i]);<br>&#125;<br>&#125;<br>    cout&lt;&lt;<span class="hljs-built_in">abs</span>(<span class="hljs-number">2</span>*dp[v]-<span class="hljs-built_in">sum</span>)&lt;&lt;endl;<br>return <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2022/09/13/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2022/09/13/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BE%8B1">例1</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><strong>题目描述</strong></a></li><li><a href="#%E6%80%9D%E8%B7%AF"><strong>思路</strong></a></li><li><a href="#%E4%BB%A3%E7%A0%81"><strong>代码：</strong></a></li></ul></li><li><a href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2">柱状图中最大的矩形</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4">接雨水</a><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><strong>题目描述</strong></a></li><li><a href="#%E4%BB%A3%E7%A0%81"><strong>代码</strong></a></li></ul></li></ul><!-- /TOC --><h2 id="例1"><a class="markdownIt-Anchor" href="#例1"></a> 例1</h2><p>###<strong>题目描述</strong></p><p>给出项数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的整数数列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>…</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{1 \dots n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="minner mtight">…</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>定义函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> 代表数列中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个元素之后第一个大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的元素的<strong>下标</strong>，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>j</mi></msub><mo>&gt;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow></msub><mo stretchy="false">{</mo><mi>j</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f(i)=\min_{i&lt;j\leq n, a_j &gt; a_i} \{j\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0973199999999999em;vertical-align:-0.34731999999999996em;"></span><span class="mop"><span class="mop">min</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166400000000005em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">&lt;</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">n</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mrel mtight">&gt;</span><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">}</span></span></span></span>。若不存在，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(i)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><p>试求出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo>…</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(1\dots n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><p><strong>输入格式</strong></p><p>第一行一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p>第二行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>…</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{1\dots n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="minner mtight">…</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><strong>输出格式</strong></p><p>一行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo>…</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(1\dots n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的值。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>数据规模</strong></p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">n\leq 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>；</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>60</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">60\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n\leq 5 \times 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> ；</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1 \le n\leq 3\times 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1\leq a_i\leq 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> <strong>思路</strong></h3><p>找到a[i]右边第一个比他大的数的下标，也就是说对于栈中的元素来说，栈顶元素小于等于a[i]的数要不断出栈，直到遇到栈顶元素大于a[i]，此时栈顶的元素就是第一个比a[i]大的数。</p><ul><li>一般找a[i]右边比他大的数，要从右向左遍历</li><li>a[i]左边比他大的数，要从左向右遍历</li></ul><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> <strong>代码：</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3</span>*<span class="hljs-number">1e6</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> a[N];<br>stack&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-type">int</span> f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cin&gt;&gt;a[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;--i)<br>&#123;<br><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]&gt;a[st.<span class="hljs-built_in">top</span>()])<br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>())<br>f[i]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>f[i]=st.<span class="hljs-built_in">top</span>();<br>st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cout&lt;&lt;f[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="柱状图中最大的矩形"><a class="markdownIt-Anchor" href="#柱状图中最大的矩形"></a> 柱状图中最大的矩形</h2><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">原题</a></p><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>e.g.</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：heights = <span class="hljs-string">[2,1,5,6,2,3]</span><br>输出：<span class="hljs-number">10</span><br>解释：最大的矩形为图中红色区域，面积为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3><p>这道题实际上需要找出<code>heights[i]</code>左侧和右侧第一个小于他的数，因此要分别记录左右两侧第一个小于heights[i]的数的下标。然后以<code>heights[i]</code>为高的矩形面积就为<code>(right[i]-left[i]-1)*heights[i]</code><br /><code>left[i]和right[i]</code>与上一道例题类似，当栈顶元素大于heights[i]要不断出栈，直到栈顶元素小于heights[i]，分别向左向右遍历并更新两个单调栈即可。</p><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs mel">class Solution &#123;<br>public:<br>    <span class="hljs-keyword">int</span> largestRectangleArea(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights) &#123;<br>        <span class="hljs-keyword">int</span> n=heights.<span class="hljs-keyword">size</span>();<br>        <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; left(n),right(n);<span class="hljs-comment">//记录左侧和右侧第一个比他小的数</span><br>        stack&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">ls</span>,rs;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">ls</span>.empty()&amp;&amp;heights[<span class="hljs-keyword">ls</span>.top()]&gt;=heights[i])<br>                <span class="hljs-keyword">ls</span>.pop();<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">ls</span>.empty())<br>                left[i]=<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left[i]=<span class="hljs-keyword">ls</span>.top();<br>            <span class="hljs-keyword">ls</span>.push(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!rs.empty()&amp;&amp;heights[rs.top()]&gt;=heights[i])<br>                rs.pop();<br>            <span class="hljs-keyword">if</span>(rs.empty())<br>                right[i]=n;<br>            <span class="hljs-keyword">else</span><br>                right[i]=rs.top();<br>            rs.push(i);<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            ans=<span class="hljs-keyword">max</span>(ans,(right[i]-left[i]<span class="hljs-number">-1</span>)*heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="接雨水"><a class="markdownIt-Anchor" href="#接雨水"></a> 接雨水</h2><p><a href="https://leetcode.cn/problems/trapping-rain-water/">原题</a></p><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> <strong>题目描述</strong></h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>输入输出</strong><br />第一行输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>表示柱子数量<br />第二行输入n个数<br />输出最多能接多少雨水</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">6</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">9<br></code></pre></td></tr></table></figure><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> <strong>代码</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> a[N];<br>stack&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cin&gt;&gt;a[i];<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()&amp;&amp;a[i]&gt;a[st.<span class="hljs-built_in">top</span>()])<br>        &#123;<br>            <span class="hljs-type">int</span> idx=st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>())<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">int</span> l=st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-type">int</span> h=<span class="hljs-built_in">min</span>(a[i],a[l])-a[idx];<br>            <span class="hljs-type">int</span> w=i-l<span class="hljs-number">-1</span>;<br>            ans+=w*h;<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归</title>
    <link href="/2022/09/11/%E9%80%92%E5%BD%92/"/>
    <url>/2022/09/11/%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98">汉诺塔问题</a></li><li><a href="#2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9">2的幂次方</a></li></ul><!-- /TOC --><h3 id="汉诺塔问题"><a class="markdownIt-Anchor" href="#汉诺塔问题"></a> 汉诺塔问题</h3><blockquote><p>汉诺塔问题的种类非常多，这里就写一下最最基础的那个吧</p></blockquote><p>问题描述</p><p>有<code>n</code>个大小不一的圆盘和 a,b,c 三根柱子，初始时n个盘子全在a上，现在要将他们移动到c上</p><ul><li>一次只能移动1个柱子</li><li>大盘子不能在小盘子上面</li></ul><p>input:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">to</span> c<br>move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">b</span><br>move <span class="hljs-selector-tag">from</span> c <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">b</span><br>move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">to</span> c<br>move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">a</span><br>move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">to</span> c<br>move <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">to</span> c<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">char</span> a,<span class="hljs-type">char</span> b,<span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;move from &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; to &quot;</span>&lt;&lt;c&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">move</span>(x<span class="hljs-number">-1</span>,a,c,b);<br>cout&lt;&lt;<span class="hljs-string">&quot;move from &quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot; to &quot;</span>&lt;&lt;c&lt;&lt;endl;<br><span class="hljs-built_in">move</span>(x<span class="hljs-number">-1</span>,b,a,c);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-type">char</span> a=<span class="hljs-string">&#x27;a&#x27;</span>,b=<span class="hljs-string">&#x27;b&#x27;</span>,c=<span class="hljs-string">&#x27;c&#x27;</span>;<br><span class="hljs-built_in">move</span>(n,a,b,c);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2的幂次方"><a class="markdownIt-Anchor" href="#2的幂次方"></a> 2的幂次方</h3><p><strong>题目描述</strong></p><p>任何一个正整数都可以用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的幂次方表示。</p><p>例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>137</mn><mo>=</mo><msup><mn>2</mn><mn>7</mn></msup><mo>+</mo><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">137= 2^7 + 2^3 + 2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>。</p><p>同时约定方次用括号来表示，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">a^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span> 可表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>。</p><p>由此可知，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>137</mn></mrow><annotation encoding="application/x-tex">137</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">7</span></span></span></span> 可表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(7)+2(3)+2(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></p><p>进一步：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>=</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><mn>2</mn><mo>+</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">7= 2^2+2+2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>  ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span> 用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 表示)，并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>=</mo><mn>2</mn><mo>+</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">3=2+2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>。</p><p>所以最后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>137</mn></mrow><annotation encoding="application/x-tex">137</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">7</span></span></span></span> 可表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(2(2)+2+2(0))+2(2+2(0))+2(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>。</p><p>又如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1315</mn><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup><mo>+</mo><msup><mn>2</mn><mn>8</mn></msup><mo>+</mo><msup><mn>2</mn><mn>5</mn></msup><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1315=2^{10} +2^8 +2^5 +2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1315</mn></mrow><annotation encoding="application/x-tex">1315</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span></span></span></span> 最后可表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>。</p><p><strong>输入格式</strong></p><p>一行一个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><p><strong>输出格式</strong></p><p>符合约定的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">0, 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span></span> 表示（在表示中不能有空格）。</p><p>input：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1315</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>(<span class="hljs-number">2</span>(<span class="hljs-number">2</span>+<span class="hljs-number">2</span>(<span class="hljs-number">0</span>))+<span class="hljs-number">2</span>)+<span class="hljs-number">2</span>(<span class="hljs-number">2</span>(<span class="hljs-number">2</span>+<span class="hljs-number">2</span>(<span class="hljs-number">0</span>)))+<span class="hljs-number">2</span>(<span class="hljs-number">2</span>(<span class="hljs-number">2</span>)+<span class="hljs-number">2</span>(<span class="hljs-number">0</span>))+<span class="hljs-number">2</span>+<span class="hljs-number">2</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>思路</p><blockquote><p>先找出当前数最大的次方，然后递归的对这个数分解，继续递归分解剩下的数</p></blockquote><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxm</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n)<br>&#123;<br>++k;<br>n/=<span class="hljs-number">2</span>;<br>&#125;<br>--k;<br><span class="hljs-keyword">return</span> k;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dg</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> mm=<span class="hljs-built_in">maxm</span>(n);<br><span class="hljs-keyword">if</span>(mm==<span class="hljs-number">1</span>)<br>cout&lt;&lt;<span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;2(&quot;</span>;<br><span class="hljs-keyword">if</span>(mm==<span class="hljs-number">0</span>)<br>cout&lt;&lt;<span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">dg</span>(mm);<br>cout&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br>n=n-<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,mm);<br><span class="hljs-keyword">if</span>(n) <br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&#x27;+&#x27;</span>;<br><span class="hljs-built_in">dg</span>(n);<br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-built_in">dg</span>(n);<br>cout&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>贪心</title>
    <link href="/2022/09/08/%E8%B4%AA%E5%BF%83/"/>
    <url>/2022/09/08/%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BE%8B%E9%A2%98to-fill-or-not-to-fill">例题：To Fill or Not to Fill</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E9%A2%98%E8%A7%A3">题解</a></li></ul><!-- /TOC --><blockquote><p>贪心的基本思想是，每一步都求出局部最有解，从而来求得可能的全局最优解，但是这种方式求得的全局的解并不一定是全局最优的</p></blockquote><h3 id="例题to-fill-or-not-to-fill"><a class="markdownIt-Anchor" href="#例题to-fill-or-not-to-fill"></a> 例题：To Fill or Not to Fill</h3><p><strong>题目描述</strong></p><p>With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.</p><p><strong>输入描述</strong></p><p>For each case, the first line contains 4 positive numbers: Cmax (&lt;= 100), the maximum capacity of the tank; D (&lt;=30000), the distance between Hangzhou and the destination city; Davg (&lt;=20), the average distance per unit gas that the car can run; and N (&lt;= 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: Pi, the unit gas price, and Di (&lt;=D), the distance between this station and Hangzhou, for i=1,…N. All the numbers in a line are separated by a space.</p><p><strong>输出描述</strong></p><p>For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print “The maximum travel distance = X” where X is the maximum possible distance the car can run, accurate up to 2 decimal places.</p><p>input：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">50</span> <span class="hljs-number">1300</span> <span class="hljs-number">12</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">6</span>.<span class="hljs-number">00</span> <span class="hljs-number">1250</span><br><span class="hljs-attribute">7</span>.<span class="hljs-number">00</span> <span class="hljs-number">600</span><br><span class="hljs-attribute">7</span>.<span class="hljs-number">00</span> <span class="hljs-number">150</span><br><span class="hljs-attribute">7</span>.<span class="hljs-number">10</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">7</span>.<span class="hljs-number">20</span> <span class="hljs-number">200</span><br><span class="hljs-attribute">7</span>.<span class="hljs-number">50</span> <span class="hljs-number">400</span><br><span class="hljs-attribute">7</span>.<span class="hljs-number">30</span> <span class="hljs-number">1000</span><br><span class="hljs-attribute">6</span>.<span class="hljs-number">85</span> <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">749</span>.<span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>将所有加油站油价按升序排序，让油价最便宜的加油站尽可能加更多的油，维护一个数组<code>dis[]</code>来记录距离，同时需要注意低油价覆盖过的距离不可再次被覆盖</p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">st</span><br>&#123;<br>    <span class="hljs-type">double</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-built_in">st</span>():<span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">b</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>    <span class="hljs-built_in">st</span>(<span class="hljs-type">double</span> aa,<span class="hljs-type">int</span> bb):<span class="hljs-built_in">a</span>(aa),<span class="hljs-built_in">b</span>(bb)&#123;&#125;<br>&#125;sta[<span class="hljs-number">501</span>];<br><span class="hljs-type">int</span> dis[<span class="hljs-number">30001</span>];<br><span class="hljs-type">int</span> cmax,d,davg,n,di;<br><span class="hljs-type">double</span> pi;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> func=[](st&amp; a,st&amp; b)&#123;<br>        <span class="hljs-keyword">if</span>(a.a!=b.a)<br>            <span class="hljs-keyword">return</span> a.a&lt;b.a;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> a.b&lt;b.b;<br>    &#125;;<br>    cin&gt;&gt;cmax&gt;&gt;d&gt;&gt;davg&gt;&gt;n; <br><span class="hljs-built_in">memset</span>(sta,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(sta));<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>    &#123;<br>           cin&gt;&gt;pi&gt;&gt;di;<br>           sta[i]=<span class="hljs-built_in">st</span>(pi,di);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(sta,sta+n,func);<br>    <span class="hljs-type">int</span> maxlen=cmax*davg;<br>    <span class="hljs-type">double</span> cost=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>    &#123;<br>    <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(sta[i].b+maxlen&lt;d)<br>        len=maxlen;<br>        <span class="hljs-keyword">else</span><br>            len=d-sta[i].b;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=sta[i].b;j&lt;sta[i].b+len;++j)<br>&#123;<br>        <span class="hljs-keyword">if</span>(dis[j]==<span class="hljs-number">0</span>)<br>&#123;<br>                dis[j]=<span class="hljs-number">1</span>;<br>                ++cnt;<br>            &#125;<br>        &#125;<br>        cost+=(<span class="hljs-type">double</span>)cnt/davg*sta[i].a;<br>    &#125;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;d;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dis[i]==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The maximum travel distance = %d.00\n&quot;</span>,i);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i==d)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f\n&quot;</span>,cost);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大子矩阵</title>
    <link href="/2022/09/01/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/09/01/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul><!-- /TOC --><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>矩阵的大小定义为矩阵中所有元素的和，现在给定一个n维矩阵，输出他的最大子矩阵</p><p>输入：第一行输入n，表示矩阵的维数，随后输入n×n的矩阵</p><p>input:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">4<br>0 <span class="hljs-string">-2</span> <span class="hljs-string">-7</span> 0<br>9 2 <span class="hljs-string">-6</span> 2<br><span class="hljs-string">-4</span> 1 <span class="hljs-string">-4</span>  1<br><span class="hljs-string">-1</span> 8  0 <span class="hljs-string">-2</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">15<br></code></pre></td></tr></table></figure><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>这道题可以说是矩阵版的<em>最大连续子序列的和</em>，为了减少时间复杂度，将矩阵每个元素变成所在列的前缀和，如<code>s[i][j]</code>表示第<code>j</code>列前<code>i</code>个元素的和，然后按照一维的方式求最大和就好了</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>const int <span class="hljs-attribute">N</span>=105;<br>int <span class="hljs-attribute">inf</span>=-1e6;<br>int s[N][N];<br>int main()<br>&#123;<br>    int n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=1;j&lt;=n;++j)<br>        &#123;<br>            cin&gt;&gt;s[i][j];<br>            s[i][j]+=s[i-1][j];<br>        &#125;<br>    &#125;<br>    int <span class="hljs-attribute">ans</span>=inf;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=1;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=i;j&lt;=n;++j)<br>        &#123;<br>            int <span class="hljs-attribute">pre</span>=inf;<br>            <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">col</span>=1;col&lt;=n;++col)<br>            &#123;<br>                int <span class="hljs-attribute">t</span>=s[j][col]-s[i-1][col];<br>                <span class="hljs-attribute">pre</span>=max(pre+t,t);<br>                <span class="hljs-attribute">ans</span>=max(ans,pre);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常见排序算法</title>
    <link href="/2022/08/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/08/31/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li><li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li><li><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8Fradix-sort">基数排序（Radix Sort)</a></li><li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li><li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fmerge-sort">归并排序（Merge Sort）</a></li><li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li><li><a href="#%E6%A1%B6%E6%8E%92%E5%BA%8Fbucket-sort">桶排序（Bucket Sort）</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li></ul><!-- /TOC --><blockquote><p>这篇博客主要总结一下常见排序算法及其时间复杂度</p></blockquote><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">平均时间复杂度</th><th style="text-align:center">最好</th><th style="text-align:center">最差</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">稳定性</th></tr></thead><tbody><tr><td style="text-align:center">插入排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">希尔排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">基数排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">桶排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">稳定</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">不稳定</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td><td style="text-align:center">不稳定</td></tr></tbody></table><h3 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h3><blockquote><p>每次选择一个元素，并且将这个元素和前面元素进行比较，然后插入到合适的位置</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">void <span class="hljs-keyword">insert_sort(int </span>arr[], int length)<br>&#123;<br>    int i,<span class="hljs-keyword">j;</span><br><span class="hljs-keyword"></span>    for (i = <span class="hljs-number">1</span><span class="hljs-comment">; i &lt; length; i++) &#123;</span><br>        int tmp = arr[i];<br>        for (<span class="hljs-keyword">j </span>= i<span class="hljs-comment">; j &gt; 0 &amp;&amp; arr[j - 1] &gt; tmp; j--) &#123;</span><br>            arr[<span class="hljs-keyword">j] </span>= arr[<span class="hljs-keyword">j </span>- <span class="hljs-number">1</span>];<br>        &#125;<br>        arr[<span class="hljs-keyword">j] </span>= tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h3><blockquote><p>插入排序的升级版，初始间隔<em>gap</em>为元素数目的一般，每次间隔<em>gap</em>个元素进行插入排序，直到gap为1</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> shellSort(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n) <br>&#123; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap = n/<span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) <br>    &#123; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; i += <span class="hljs-number">1</span>) <br>        &#123; <br>            <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = arr[i]; <br>            <span class="hljs-type">int</span> j;             <br>            <span class="hljs-keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; <span class="hljs-keyword">temp</span>; j -= gap) <br>                arr[j] = arr[j - gap]; <br>            arr[j] = <span class="hljs-keyword">temp</span>; <br>        &#125; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基数排序radix-sort"><a class="markdownIt-Anchor" href="#基数排序radix-sort"></a> 基数排序（Radix Sort)</h3><blockquote><p>将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程是将所有待比较数值统一为同样的数位长度，数位较短的数前面补零，然后从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p></blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> getMax(<span class="hljs-built_in">int</span> arr[], <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) <br>&#123; <br>    <span class="hljs-built_in">int</span> mx = arr[<span class="hljs-number">0</span>]; <br>    for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">n</span>; i++) <br>        <span class="hljs-built_in">if</span> (arr[i] &gt; mx) <br>            mx = arr[i]; <br>    return mx; <br>&#125; <br><br>void countSort(<span class="hljs-built_in">int</span> arr[], <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">exp</span>) <br>&#123; <br>    <span class="hljs-built_in">int</span> output[<span class="hljs-built_in">n</span>]; <br>    <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">count</span>[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;; <br>  <br>    for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i++) <br>        <span class="hljs-built_in">count</span>[ (arr[i]/<span class="hljs-built_in">exp</span>)%<span class="hljs-number">10</span> ]++; <br>  <br>    for (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) <br>        <span class="hljs-built_in">count</span>[i] += <span class="hljs-built_in">count</span>[i - <span class="hljs-number">1</span>]; //此时<span class="hljs-built_in">count</span>[i]每位数字存放的位置，实际下标还要-<span class="hljs-number">1</span><br>  <br>    for (i = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) //从后往前保证稳定性<br>    &#123; <br>        output[<span class="hljs-built_in">count</span>[ (arr[i]/<span class="hljs-built_in">exp</span>)%<span class="hljs-number">10</span> ] - <span class="hljs-number">1</span>] = arr[i]; <br>        <span class="hljs-built_in">count</span>[ (arr[i]/<span class="hljs-built_in">exp</span>)%<span class="hljs-number">10</span> ]--; <br>    &#125; <br>  <br>    for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i++) <br>        arr[i] = output[i]; <br>&#125; <br>  <br>void radixsort(<span class="hljs-built_in">int</span> arr[], <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) <br>&#123; <br>    <span class="hljs-built_in">int</span> m = getMax(arr, <span class="hljs-built_in">n</span>); <br>    for (<span class="hljs-built_in">int</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">1</span>; m/<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">0</span>; <span class="hljs-built_in">exp</span> *= <span class="hljs-number">10</span>) <br>        countSort(arr, <span class="hljs-built_in">n</span>, <span class="hljs-built_in">exp</span>); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3><blockquote><p>每次比较相邻两个元素大小，然后交换位置，每次将最大或最小的元素放到最后</p></blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs excel">void bubblesort(<span class="hljs-built_in">int</span> arr[],<span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span>)<br>&#123;<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>-<span class="hljs-number">1</span>;++i)<br>&#123;<br>for( <span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">len</span>-i-<span class="hljs-number">1</span>;++j)<br>&#123;<br><span class="hljs-built_in">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>=arr[j];<br>arr[j]=arr[j+<span class="hljs-number">1</span>];<br>arr[j+<span class="hljs-number">1</span>]=<span class="hljs-built_in">t</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序merge-sort"><a class="markdownIt-Anchor" href="#归并排序merge-sort"></a> 归并排序（Merge Sort）</h3><blockquote><p>主要思想是分治（Divide and Conquer），将数组不断分成两个部分，对分开的部分比较然后拼接</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> merge(<span class="hljs-built_in">int</span> arr[], <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> m, <span class="hljs-built_in">int</span> r) <br>&#123; <br>    <span class="hljs-built_in">int</span> i, j, k; <br>    <span class="hljs-built_in">int</span> n1 = m - l + <span class="hljs-number">1</span>; <br>    <span class="hljs-built_in">int</span> n2 =  r - m; <br><br>    <span class="hljs-built_in">int</span> L[n1], R[n2]; <br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n1; i++) <br>        L[i] = arr[l + i]; <br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n2; j++) <br>        R[j] = arr[m + <span class="hljs-number">1</span>+ j]; <br><br>    i = <span class="hljs-number">0</span>; <br>    j = <span class="hljs-number">0</span>; <br>    k = l; <br>    <span class="hljs-keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) <br>    &#123; <br>        <span class="hljs-keyword">if</span> (L[i] &lt;= R[j]) <br>        &#123; <br>            arr[k] = L[i]; <br>            i++; <br>        &#125; <br>        <span class="hljs-keyword">else</span><br>        &#123; <br>            arr[k] = R[j]; <br>            j++; <br>        &#125; <br>        k++; <br>    &#125; <br>  <br>    <span class="hljs-keyword">while</span> (i &lt; n1) <br>    &#123; <br>        arr[k] = L[i]; <br>        i++; <br>        k++; <br>    &#125; <br>  <br>    <span class="hljs-keyword">while</span> (j &lt; n2) <br>    &#123; <br>        arr[k] = R[j]; <br>        j++; <br>        k++; <br>    &#125; <br>&#125; <br>  <br><span class="hljs-built_in">void</span> mergeSort(<span class="hljs-built_in">int</span> arr[], <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r) <br>&#123; <br>    <span class="hljs-keyword">if</span> (l &lt; r) <br>    &#123; <br>        <span class="hljs-built_in">int</span> m = l+r&gt;&gt;<span class="hljs-number">1</span>; <br>        mergeSort(arr, l, m); <br>        mergeSort(arr, m+<span class="hljs-number">1</span>, r); <br>        merge(arr, l, m, r); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3><blockquote><p>主要是建立小顶堆或者大顶堆，排序的时候，每次取出堆顶元素，然后剩下元素重新建堆，<s>建堆可以直接用STL的make_heap()😄</s></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i)</span> <br>&#123; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxv</span> <span class="hljs-operator">=</span> i; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>*i + <span class="hljs-number">2</span>; <br>    <span class="hljs-keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[maxv]) <br>        maxv = l; <br>    <span class="hljs-keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[maxv]) <br>        maxv = r; <br>    <span class="hljs-keyword">if</span> (maxv != i) <br>    &#123; <br>        swap(arr[i], arr[maxv]); <br>        heapify(arr, n, maxv); <br>    &#125; <br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">heapsort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> len)</span><br>&#123;<br>    <span class="hljs-comment">//建堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        heapify(arr,len;i);<br>    <span class="hljs-comment">//排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>    &#123;<br>        swap(arr[i],a[<span class="hljs-number">0</span>]);<span class="hljs-comment">//堆顶放到最后</span><br>        heapify(arr,i,<span class="hljs-number">0</span>);<span class="hljs-comment">//重新调整</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="桶排序bucket-sort"><a class="markdownIt-Anchor" href="#桶排序bucket-sort"></a> 桶排序（Bucket Sort）</h3><blockquote><p>将数组分到有限数量的桶中，再对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。</p></blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs excel">\\该代码只适合正数数组的排序<br>void bucketSort(float arr[], <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) <br>&#123; <br>    vector&lt;float&gt; b[<span class="hljs-built_in">n</span>]; <br><br>    for (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">n</span>; i++) <br>    &#123; <br>       <span class="hljs-built_in">int</span> bi = <span class="hljs-built_in">n</span>*arr[i]; <br>       b[bi].push_back(arr[i]); <br>    &#125; <br>    for (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">n</span>; i++) <br>       sort(b[i].begin(), b[i].end()); <br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">index</span> = <span class="hljs-number">0</span>; <br>    for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i++) <br>        for (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; b[i].size(); j++) <br>          arr[<span class="hljs-built_in">index</span>++] = b[i][j]; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3><blockquote><p>核心思想也是分治，每次选择一个pivot(一般选第一个)，设置左右端点两个指针，每一趟调整将比pivot元素小的值放到左指针位置，比pivot元素大的值放到位置，这样左半部分就小于右半部分，然后递归，分别对左右两个部分进行快排</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> adjust(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)<br>&#123;<br><span class="hljs-type">int</span> t=arr[l];<br><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br><span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;arr[r]&gt;=t)<br><span class="hljs-comment">--r;</span><br>arr[l]=arr[r];<br><span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;arr[l]&lt;=t)<br>++l;<br>arr[r]=arr[l];<br>&#125;<br>arr[l]=t;<br><span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-type">void</span> quicksort(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)<br>&#123;<br><span class="hljs-keyword">if</span>(l&lt;r)<br>&#123;<br><span class="hljs-type">int</span> pos=adjust(arr,l,r);<br>quicksort(arr,l,pos);<br>quicksort(arr,pos+<span class="hljs-number">1</span>,r);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日期计算</title>
    <link href="/2022/08/29/%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97/"/>
    <url>/2022/08/29/%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>先来看一道题</p><p>输入一年中的一天，输出这一天是星期几</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">14 </span>October <span class="hljs-number">2001</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Sunday</span><br></code></pre></td></tr></table></figure><p>用以下公式计算天数：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi>X</mi><mo>−</mo><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>4</mn><mo>−</mo><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>100</mn><mo>+</mo><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>400</mn><mo>+</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">S=X-1+(X-1)/4-(X-1)/100+(X-1)/400+C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></p><p>其中，<code>X</code>是年份，<code>C</code>表示这一天是这一年的第<code>C</code>天</p><p>计算出<code>S</code>后用<code>S%7</code>判断星期几即可</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// S=X-1+(X-1)/4-(X-1)/100+(X-1)/400+C</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isrun</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;n%<span class="hljs-number">100</span>||n%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> d,y;<br>    string m;<br>    vector&lt;pair&lt;string,<span class="hljs-type">int</span>&gt;&gt; mon=&#123;&#123;<span class="hljs-string">&quot;January&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;February&quot;</span>,<span class="hljs-number">28</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;March&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;April&quot;</span>,<span class="hljs-number">30</span>&#125;,&#123;<span class="hljs-string">&quot;May&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;June&quot;</span>,<span class="hljs-number">30</span>&#125;,&#123;<span class="hljs-string">&quot;July&quot;</span>,<span class="hljs-number">31</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;August&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;September&quot;</span>,<span class="hljs-number">30</span>&#125;,&#123;<span class="hljs-string">&quot;October&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;November&quot;</span>,<span class="hljs-number">30</span>&#125;,<br>                                  &#123;<span class="hljs-string">&quot;December&quot;</span>,<span class="hljs-number">31</span>&#125;&#125;;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;d&gt;&gt;m&gt;&gt;y)<br>    &#123;<br>        <span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isrun</span>(y))<br>            flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=mon.<span class="hljs-built_in">begin</span>();it!=mon.<span class="hljs-built_in">end</span>();++it)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(it-&gt;first!=m)   <br>                sum+=it-&gt;second;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        sum=sum+d+flag;<br>        <span class="hljs-type">int</span> s=y<span class="hljs-number">-1</span>+(y<span class="hljs-number">-1</span>)/<span class="hljs-number">4</span>-(y<span class="hljs-number">-1</span>)/<span class="hljs-number">100</span>+(y<span class="hljs-number">-1</span>)/<span class="hljs-number">400</span>+sum;<br>        <span class="hljs-keyword">switch</span>(s%<span class="hljs-number">7</span>)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Sunday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Monday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Tuesday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Wednesday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Thursday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Friday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <br>                cout&lt;&lt;<span class="hljs-string">&quot;Saturday&quot;</span>&lt;&lt;endl;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="/2022/08/27/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/08/27/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E7%BA%BF%E6%AE%B5%E6%A0%91">线段树</a><ul><li><a href="#%E9%80%92%E5%BD%92%E5%BB%BA%E6%A0%91">递归建树</a></li></ul></li><li><a href="#%E7%B1%BB%E5%9E%8B%E4%B8%80%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">类型一：单点修改，区间查询</a><ul><li><a href="#%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9">单点修改</a></li><li><a href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">区间查询</a></li><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li></ul></li><li><a href="#%E7%B1%BB%E5%9E%8B%E4%BA%8C%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2">类型二：区间修改，单点查询</a><ul><li><a href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9">区间修改</a></li><li><a href="#%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2">单点查询</a></li><li><a href="#%E4%BE%8B%E9%A2%98-1">例题</a></li></ul></li><li><a href="#%E7%B1%BB%E5%9E%8B%E4%B8%89-%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2">类型三： 区间修改，区间查询</a><ul><li><a href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9-1">区间修改</a></li><li><a href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2-1">区间查询</a></li><li><a href="#%E4%BE%8B%E9%A2%98-2">例题</a></li></ul></li></ul><!-- /TOC --><h3 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h3><blockquote><p>能把对区间的修改、查询的时间复杂度由 O(n) 变为 O(logn)</p></blockquote><p>线段树实际上也是一种二叉树，每个节点用一个结构体<code>node</code>保存</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">node</span><br><span class="hljs-title">&#123;</span><br><span class="hljs-title">int</span> l,r,sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>l</code>和<code>r</code>表示线段的左右端点，<code>sum</code>表示线段的和</p><p>如果用数组存储，一棵二叉树，左孩子下标为<code>2*i</code>，右孩子下标为<code>2*i+1</code><br />因此，每一个节点的<code>sum</code>值为：<code>tree[i].sum=tree[2*i].sum+tree[2*i+1].sum</code></p><h4 id="递归建树"><a class="markdownIt-Anchor" href="#递归建树"></a> 递归建树</h4><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">void</span> build(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)<br>&#123;<br><span class="hljs-comment">//i:当前节点编号 l:左端点 r:右端点 </span><br>tree[i].l=l;<br>tree[i].r=r;<br><span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><br><span class="hljs-keyword">if</span>(l==r)<br>&#123;<br>tree[i].<span class="hljs-built_in">sum</span>=<span class="hljs-type">array</span>[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>build(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span><br>build(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span><br><span class="hljs-comment">//更新线段和 </span><br>tree[i].<span class="hljs-built_in">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-built_in">sum</span>+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-built_in">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型一单点修改区间查询"><a class="markdownIt-Anchor" href="#类型一单点修改区间查询"></a> 类型一：单点修改，区间查询</h3><p>单点修改：给第<code>idx</code>个数加<code>k</code><br />区间查询：输出区间[x,y]内所有数的和</p><h4 id="单点修改"><a class="markdownIt-Anchor" href="#单点修改"></a> 单点修改</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> mod1(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> idx,<span class="hljs-built_in">int</span> k)<br>&#123;<br><span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>+=k;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(idx&lt;=mid)<br>mod1(<span class="hljs-number">2</span>*i,idx,k);<br><span class="hljs-keyword">else</span><br>mod1(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,idx,k);<br><span class="hljs-comment">//更新线段和</span><br>tree[i].<span class="hljs-keyword">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span>+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="区间查询"><a class="markdownIt-Anchor" href="#区间查询"></a> 区间查询</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//区间查询</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query1</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//如果当前区间完全被查询区间包括，返回当前区间的和 </span><br><span class="hljs-keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)<br><span class="hljs-keyword">return</span> tree[i].sum;<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-comment">//如果左孩子区间与查询区间相交，进入左子树 </span><br><span class="hljs-keyword">if</span>(l&lt;=mid)<br>res+=<span class="hljs-built_in">query1</span>(<span class="hljs-number">2</span>*i,l,r);<br><span class="hljs-comment">//如果右孩子区间与查询区间相交，进入右子树</span><br><span class="hljs-keyword">if</span>(r&gt;mid)<br>res+=<span class="hljs-built_in">query1</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r);<br> <span class="hljs-keyword">return</span> res;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h4><p><a href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1</a></p><p><strong>题目描述</strong></p><p>如题，已知一个数列，你需要进行下面两种操作：</p><ul><li><p>将某一个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span></p></li><li><p>求出某区间每一个数的和</p></li></ul><p><strong>输入格式</strong></p><p>第一行包含两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n,m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span></span></span></span>，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个用空格分隔的整数，其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数字表示数列第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 项的初始值。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 行每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 个整数，表示一个操作，具体如下：</p><ul><li><p><code>1 x k</code>  含义：将第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></p></li><li><p><code>2 x y</code>  含义：输出区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 内每个数的和</p></li></ul><p><strong>输出格式</strong></p><p>输出包含若干行整数，即为所有操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的结果。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> -<span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">14<br>16<br></code></pre></td></tr></table></figure><p><strong>【数据范围】</strong></p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">1 \le n \le 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">1\le m \le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>；<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>70</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">70\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">7</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1\le n,m \le 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>；<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1\le n,m \le 5\times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</p><p>ac代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> nums[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> l,r,sum;<br>&#125;tree[<span class="hljs-number">4</span>*N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//i:当前节点编号 l:左端点 r:右端点 </span><br>tree[i].l=l;<br>tree[i].r=r;<br><span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><br><span class="hljs-keyword">if</span>(l==r)<br>&#123;<br>tree[i].sum=nums[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span><br><span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span><br><span class="hljs-comment">//更新线段和 </span><br>tree[i].sum=tree[<span class="hljs-number">2</span>*i].sum+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].sum;<br>&#125;<br><span class="hljs-comment">//单点修改 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mod1</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<br>&#123;<br>tree[i].sum+=k;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(idx&lt;=mid)<br><span class="hljs-built_in">mod1</span>(<span class="hljs-number">2</span>*i,idx,k);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">mod1</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,idx,k);<br><span class="hljs-comment">//更新线段和</span><br>tree[i].sum=tree[<span class="hljs-number">2</span>*i].sum+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].sum;<br>&#125;<br><span class="hljs-comment">//区间查询</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query1</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//如果当前区间完全被查询区间包括，返回当前区间的和 </span><br><span class="hljs-keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)<br><span class="hljs-keyword">return</span> tree[i].sum;<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-comment">//如果左孩子区间与查询区间相交，进入左子树 </span><br><span class="hljs-keyword">if</span>(l&lt;=mid)<br>res+=<span class="hljs-built_in">query1</span>(<span class="hljs-number">2</span>*i,l,r);<br><span class="hljs-comment">//如果右孩子区间与查询区间相交，进入右子树</span><br><span class="hljs-keyword">if</span>(r&gt;mid)<br>res+=<span class="hljs-built_in">query1</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r);<br> <span class="hljs-keyword">return</span> res;<br>&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cin&gt;&gt;nums[i];<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><span class="hljs-type">int</span> op,a,b;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;<br><span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br><span class="hljs-built_in">mod1</span>(<span class="hljs-number">1</span>,a,b);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)<br>cout&lt;&lt;<span class="hljs-built_in">query1</span>(<span class="hljs-number">1</span>,a,b)&lt;&lt;endl;<br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="类型二区间修改单点查询"><a class="markdownIt-Anchor" href="#类型二区间修改单点查询"></a> 类型二：区间修改，单点查询</h3><p>区间修改：给区间<code>[a,b]</code>每个数加k<br />单点查询：查询第<code>x</code>个数的值</p><p>思路：把修改区间所覆盖的区间加k，然后单点查询时从上到下将所有k相加</p><h4 id="区间修改"><a class="markdownIt-Anchor" href="#区间修改"></a> 区间修改</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)<br>&#123;<br><span class="hljs-comment">//完全在区间内，+k </span><br><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>+=k;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-comment">//落在左区间 </span><br><span class="hljs-keyword">if</span>(l&lt;=mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<br><span class="hljs-comment">//落在右区间 </span><br><span class="hljs-keyword">if</span>(r&gt;mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="单点查询"><a class="markdownIt-Anchor" href="#单点查询"></a> 单点查询</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> x)<br>&#123;<br><span class="hljs-comment">//从上到下计算所有k的和 </span><br><span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<br><span class="hljs-keyword">return</span> tree[i].<span class="hljs-keyword">sum</span>;<br><span class="hljs-built_in">int</span> res=tree[i].<span class="hljs-keyword">sum</span>;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid)<br>res+=query(<span class="hljs-number">2</span>*i,x);<br><span class="hljs-keyword">else</span><br>res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,x);<br><span class="hljs-keyword">return</span> res;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h4><p><a href="https://www.luogu.com.cn/problem/P3368">P3368 树状数组 2</a></p><p><strong>题目描述</strong></p><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li><p>将某区间每一个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>；</p></li><li><p>求出某一个数的值。</p></li></ol><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个用空格分隔的整数，其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数字表示数列第 $i $ 项的初始值。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 行每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>个整数，表示一个操作，具体如下：</p><p>操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>： 格式：<code>1 x y k</code> 含义：将区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 内每个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>；</p><p>操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>： 格式：<code>2 x</code> 含义：输出第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 个数的值。</p><p><strong>输出格式</strong></p><p>输出包含若干行整数，即为所有操作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的结果。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span> -<span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">6<br>10<br></code></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">2</span>;<br><span class="hljs-built_in">int</span> nums[N];<br>struct node<br>&#123;<br><span class="hljs-built_in">int</span> l,r,<span class="hljs-keyword">sum</span>;<br>&#125;tree[<span class="hljs-number">4</span>*N];<br><span class="hljs-keyword">void</span> build(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)<br>&#123;<br>tree[i].l=l;<br>tree[i].r=r;<br>tree[i].<span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>; <br><span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><br><span class="hljs-keyword">if</span>(l==r)<br><span class="hljs-keyword">return</span>; <br><span class="hljs-built_in">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>build(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span><br>build(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span><br>&#125;<br><br><span class="hljs-comment">//区间修改</span><br><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)<br>&#123;<br><span class="hljs-comment">//完全在区间内，+k </span><br><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>+=k;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-comment">//落在左区间 </span><br><span class="hljs-keyword">if</span>(l&lt;=mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<br><span class="hljs-comment">//落在右区间 </span><br><span class="hljs-keyword">if</span>(r&gt;mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);<br>&#125; <br><span class="hljs-comment">//单点查询</span><br><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> x)<br>&#123;<br><span class="hljs-comment">//从上到下计算所有k的和 </span><br><span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<br><span class="hljs-keyword">return</span> tree[i].<span class="hljs-keyword">sum</span>;<br><span class="hljs-built_in">int</span> res=tree[i].<span class="hljs-keyword">sum</span>;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid)<br>res+=query(<span class="hljs-number">2</span>*i,x);<br><span class="hljs-keyword">else</span><br>res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,x);<br><span class="hljs-keyword">return</span> res;<br>&#125; <br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cin&gt;&gt;nums[i];<br>build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><span class="hljs-built_in">int</span> op,a,b,c;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>cin&gt;&gt;op;<br><span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>&#123;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">1</span>,a,b,c);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)<br>&#123;<br>cin&gt;&gt;a;<br>cout&lt;&lt;query(<span class="hljs-number">1</span>,a)+nums[a]&lt;&lt;endl; <br>&#125;<br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>数据规模与约定</strong></p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">N\le8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">M\le10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>；</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>70</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">70\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">7</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">N\le 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">M\le10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>；</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>N</mi><mo separator="true">,</mo><mi>M</mi><mo>≤</mo><mn>500000</mn></mrow><annotation encoding="application/x-tex">1 \leq N, M\le 500000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \leq x, y \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，保证任意时刻序列中任意元素的绝对值都不大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>。</p><p>ac代码：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">2</span>;<br><span class="hljs-built_in">int</span> nums[N];<br>struct node<br>&#123;<br><span class="hljs-built_in">int</span> l,r,<span class="hljs-keyword">sum</span>;<br>&#125;tree[<span class="hljs-number">4</span>*N];<br><span class="hljs-keyword">void</span> build(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)<br>&#123;<br>tree[i].l=l;<br>tree[i].r=r;<br>tree[i].<span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>; <br><span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><br><span class="hljs-keyword">if</span>(l==r)<br><span class="hljs-keyword">return</span>; <br><span class="hljs-built_in">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>build(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span><br>build(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span><br>&#125;<br><br><span class="hljs-comment">//区间修改</span><br><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)<br>&#123;<br><span class="hljs-comment">//完全在区间内，+k </span><br><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>+=k;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-comment">//落在左区间 </span><br><span class="hljs-keyword">if</span>(l&lt;=mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<br><span class="hljs-comment">//落在右区间 </span><br><span class="hljs-keyword">if</span>(r&gt;mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);<br>&#125; <br><span class="hljs-comment">//单点查询</span><br><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> x)<br>&#123;<br><span class="hljs-comment">//从上到下计算所有k的和 </span><br><span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<br><span class="hljs-keyword">return</span> tree[i].<span class="hljs-keyword">sum</span>;<br><span class="hljs-built_in">int</span> res=tree[i].<span class="hljs-keyword">sum</span>;<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid)<br>res+=query(<span class="hljs-number">2</span>*i,x);<br><span class="hljs-keyword">else</span><br>res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,x);<br><span class="hljs-keyword">return</span> res;<br>&#125; <br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cin&gt;&gt;nums[i];<br>build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><span class="hljs-built_in">int</span> op,a,b,c;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>cin&gt;&gt;op;<br><span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>&#123;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">1</span>,a,b,c);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)<br>&#123;<br>cin&gt;&gt;a;<br>cout&lt;&lt;query(<span class="hljs-number">1</span>,a)+nums[a]&lt;&lt;endl; <br>&#125;<br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="类型三-区间修改区间查询"><a class="markdownIt-Anchor" href="#类型三-区间修改区间查询"></a> 类型三： 区间修改，区间查询</h3><p>需要定义一个懒标记，然后每次修改或查询需要进行<code>pushdown</code></p><p>pushdown步骤：</p><ul><li>当前节点懒标记不为0时，给左右子节点的懒标记加上父亲的懒标记</li><li>更新左右子节点的sum</li><li>父节点的懒标记置0</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">void pushdown(int i)<br>&#123;<br>if(tree<span class="hljs-comment">[i]</span>.lz)<br>&#123;<br>tree<span class="hljs-comment">[2*i]</span>.lz+=tree<span class="hljs-comment">[i]</span>.lz;<br>tree<span class="hljs-comment">[2*i+1]</span>.lz+=tree<span class="hljs-comment">[i]</span>.lz;<br>int mid=tree<span class="hljs-comment">[i]</span>.l+tree<span class="hljs-comment">[i]</span>.r&gt;&gt;1;<br>tree<span class="hljs-comment">[2*i]</span>.sum+=tree<span class="hljs-comment">[i]</span>.lz*(mid-tree<span class="hljs-comment">[i]</span>.l+1);<br>tree<span class="hljs-comment">[2*i+1]</span>.sum+=tree<span class="hljs-comment">[i]</span>.lz*(tree<span class="hljs-comment">[i]</span>.r-mid);<br>tree<span class="hljs-comment">[i]</span>.lz=0;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="区间修改-2"><a class="markdownIt-Anchor" href="#区间修改-2"></a> 区间修改</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)<br>&#123;<br><span class="hljs-comment">//区间被完全包括，更新sum，lz </span><br><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>+=k*(tree[i].r-tree[i].l+<span class="hljs-number">1</span>);<br>tree[i].lz+=k;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>pushdown(i);<br><span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(l&lt;=mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<br><span class="hljs-keyword">if</span>(r&gt;mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);<br><span class="hljs-comment">//更新和</span><br>tree[i].<span class="hljs-keyword">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span> +tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="区间查询-2"><a class="markdownIt-Anchor" href="#区间查询-2"></a> 区间查询</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)<br>&#123;<br>//区间被完全包括，返回<span class="hljs-built_in">sum</span> <br><span class="hljs-built_in">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br>return tree[i].<span class="hljs-built_in">sum</span>;<br>pushdown(i);<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span>=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">if</span>(l&lt;=<span class="hljs-built_in">mid</span>)<br>res+=query(<span class="hljs-number">2</span>*i,l,r);<br><span class="hljs-built_in">if</span>(r&gt;<span class="hljs-built_in">mid</span>)<br>res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r);<br>return res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例题-3"><a class="markdownIt-Anchor" href="#例题-3"></a> 例题</h4><p><a href="https://www.luogu.com.cn/problem/P3372">P3372【模板】线段树 1</a></p><p><strong>题目描述</strong></p><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</li><li>求出某区间每一个数的和。</li></ol><p><strong>输入格式</strong></p><p>第一行包含两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n, m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span></span></span></span>，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个用空格分隔的整数，其中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 个数字表示数列第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 项的初始值。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 行每行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 个整数，表示一个操作，具体如下：</p><ol><li><code>1 x y k</code>：将区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x, y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 内每个数加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>。</li><li><code>2 x y</code>：输出区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x, y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 内每个数的和。</li></ol><p><strong>输出格式</strong><br />输出包含若干行整数，即为所有操作 2 的结果。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">11<br>8<br>20<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">n \le 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">m \le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>。<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>70</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">70\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">7</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><msup><mn>10</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n \le {10}^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.848448em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">0</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.848448em;"><span style="top:-3.09734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><msup><mn>10</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">m \le {10}^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.848448em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">0</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.848448em;"><span style="top:-3.09734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>。<br />对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \le n, m \le {10}^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.848448em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">0</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.848448em;"><span style="top:-3.09734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</p><p>保证任意时刻数列中所有元素的绝对值之和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msup><mn>10</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">\le {10}^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.848448em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">0</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.848448em;"><span style="top:-3.09734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>。</p><p>ac代码：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>typedef <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> ll;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">2</span>;<br><span class="hljs-built_in">int</span> nums[N];<br>struct node<br>&#123;<br>ll l,r,<span class="hljs-keyword">sum</span>,lz;<br>&#125;tree[<span class="hljs-number">4</span>*N];<br><span class="hljs-keyword">void</span> build(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)<br>&#123; <br>tree[i].l=l;<br>tree[i].r=r;<br>tree[i].lz=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><br><span class="hljs-keyword">if</span>(l==r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>=nums[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ll mid=(l+r)/<span class="hljs-number">2</span>;<br>build(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span><br>build(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span><br><span class="hljs-comment">//更新线段和 </span><br>tree[i].<span class="hljs-keyword">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span>+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>;<br>&#125;<br><span class="hljs-keyword">void</span> pushdown(<span class="hljs-built_in">int</span> i)<br>&#123;<br><span class="hljs-keyword">if</span>(tree[i].lz)<br>&#123;<br>tree[<span class="hljs-number">2</span>*i].lz+=tree[i].lz;<br>tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].lz+=tree[i].lz;<br>ll mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br>tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span>+=tree[i].lz*(mid-tree[i].l+<span class="hljs-number">1</span>);<br>tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>+=tree[i].lz*(tree[i].r-mid);<br>tree[i].lz=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)<br>&#123;<br><span class="hljs-comment">//区间被完全包括，更新sum，lz </span><br><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br>&#123;<br>tree[i].<span class="hljs-keyword">sum</span>+=k*(tree[i].r-tree[i].l+<span class="hljs-number">1</span>);<br>tree[i].lz+=k;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>pushdown(i);<br>ll mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(l&lt;=mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<br><span class="hljs-keyword">if</span>(r&gt;mid)<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);<br><span class="hljs-comment">//更新和</span><br>tree[i].<span class="hljs-keyword">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span> +tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>;<br>&#125;<br>ll query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)<br>&#123;<br><span class="hljs-comment">//区间被完全包括，返回sum </span><br><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<br><span class="hljs-keyword">return</span> tree[i].<span class="hljs-keyword">sum</span>;<br>pushdown(i);<br>ll mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<br>ll res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(l&lt;=mid)<br>res+=query(<span class="hljs-number">2</span>*i,l,r);<br><span class="hljs-keyword">if</span>(r&gt;mid)<br>res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">int</span> n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cin&gt;&gt;nums[i];<br>build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><span class="hljs-built_in">int</span> op,a,b,c;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>cin&gt;&gt;op;<br><span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>&#123;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-keyword">mod</span>(<span class="hljs-number">1</span>,a,b,c);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)<br>&#123;<br>cin&gt;&gt;a&gt;&gt;b;<br>cout&lt;&lt;query(<span class="hljs-number">1</span>,a,b)&lt;&lt;endl;<br>&#125;<br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进制转换与大阶乘</title>
    <link href="/2022/08/27/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%A4%A7%E9%98%B6%E4%B9%98/"/>
    <url>/2022/08/27/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%A4%A7%E9%98%B6%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</a><ul><li><a href="#%E9%A2%98%E7%9B%AE">题目</a></li></ul></li><li><a href="#%E5%A4%A7%E9%98%B6%E4%B9%98">大阶乘</a><ul><li><a href="#%E9%A2%98%E7%9B%AE-1">题目</a></li></ul></li></ul><!-- /TOC --><h3 id="进制转换"><a class="markdownIt-Anchor" href="#进制转换"></a> 进制转换</h3><blockquote><p>下面的模板可用于36以内进制任意转换</p></blockquote><h4 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h4><p>将M进制的数X转换为N进制的数输出。<br />输入的第一行包括两个整数：M和N(2&lt;=M,N&lt;=36)。<br />下面的一行输入一个数X，X是M进制的数，现在要求你将M进制的数X转换成N进制的数输出。</p><p>input:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">36</span> <span class="hljs-number">9</span><br><span class="hljs-attribute">XYZZA765</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">10374545654665<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">convert</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s,<span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> len=s.size();<br>    <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">string</span> res;<br>    <span class="hljs-keyword">while</span>(i&lt;len)<br>    &#123;<br>        <span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>,tmp1=<span class="hljs-number">0</span>,tmp2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=i;j&lt;len;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[j]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[j]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>                tmp1=s[j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">else</span><br>                tmp1=s[j]-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">10</span>;<br>            <span class="hljs-built_in">int</span> t=k*a+tmp1;<br>            k=t%b;<br>            tmp2=t/b;<br>            <span class="hljs-keyword">if</span>(tmp2&lt;=<span class="hljs-number">9</span>)<br>                s[j]=tmp2+<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">else</span><br>                s[j]=tmp2<span class="hljs-number">-10</span>+<span class="hljs-string">&#x27;A&#x27;</span>;<br>            <br>        &#125;<br>        <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">9</span>)<br>            res+=k+<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            res+=k<span class="hljs-number">-10</span>+<span class="hljs-string">&#x27;A&#x27;</span>;<br>        <span class="hljs-keyword">while</span>(s[i]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            ++i;<br>    &#125;<br>    reverse(res.begin(),res.end());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> m,n;<br>    <span class="hljs-built_in">string</span> s;<br>    cin&gt;&gt;m&gt;&gt;n;<br>    cin&gt;&gt;s;<br>    cout&lt;&lt;convert(s,m,n)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="大阶乘"><a class="markdownIt-Anchor" href="#大阶乘"></a> 大阶乘</h3><h4 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h4><p>输入一个正整数N，输出N的阶乘<br />N&lt;=1000</p><p>input:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>int a[100000];<br>int main()<br>&#123;<br>    int n;<br>    cin&gt;&gt;n; <br>    int <span class="hljs-attribute">ws</span>=1;<br>    a[0]=1;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=2;i&lt;=n;++i)<br>    &#123;<br>        int <span class="hljs-attribute">k</span>=0;<br>        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=0;j&lt;ws;++j)<br>        &#123;<br>            int <span class="hljs-attribute">t</span>=i*a[j]+k;<br>            <span class="hljs-attribute">k</span>=t/10;<br>            a[j]=t%10;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(k)<br>        &#123;<br>            a[ws]=k%10;<br>            k/=10;<br>            ++ws;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=ws-1;i&gt;=0;--i)<br>        cout&lt;&lt;a[i];<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常见问题</title>
    <link href="/2022/08/26/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/26/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#java">Java</a><ul><li><a href="#jdkjre%E5%92%8Cjvm%E6%98%AF%E4%BB%80%E4%B9%88">JDK、JRE和JVM是什么？</a><ul><li><a href="#jdk">JDK</a></li><li><a href="#jre">JRE</a></li><li><a href="#jvm">JVM</a></li></ul></li><li><a href="#%E5%AD%97%E8%8A%82%E7%A0%81">字节码</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4java%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%85%B1%E5%AD%98">为什么说Java“编译与解释共存”？</a></li><li><a href="#aot%E5%92%8Cjit">AOT和JIT</a></li><li><a href="#%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9D%9E%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8C%BA%E5%88%AB">受检异常和非受检异常的区别</a></li><li><a href="#jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F">JVM内存区域</a><ul><li><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">程序计数器</a></li><li><a href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">虚拟机栈</a></li><li><a href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">本地方法栈</a></li><li><a href="#%E5%A0%86">堆</a></li><li><a href="#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a></li><li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0">运行时常量池和字符串常量池</a></li><li><a href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">直接内存</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%86%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%85%83%E7%A9%BA%E9%97%B4">为什么要将永久代替换为元空间？</a></li><li><a href="#string-s--new-stringabc-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F">String s = new String(“abc”) 执行过程中分别对应哪些内存区域？</a></li><li><a href="#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">四种引用类型？</a></li></ul></li><li><a href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD">类加载</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B">什么是类加载器，类加载器有哪些？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6">什么是双亲委派机制？为什么要用双亲委派机制？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6">如何打破双亲委派机制？</a></li><li><a href="#jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B">JVM类加载的过程</a></li></ul></li><li><a href="#jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">JVM垃圾回收</a><ul><li><a href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E5%88%99">内存分配和回收原则</a></li><li><a href="#minorgcmixedgcfullgc%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">MinorGC、MixedGC、FullGC的区别是什么？</a></li><li><a href="#fullgc%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91">FullGC什么时候触发？</a></li><li><a href="#%E6%AD%BB%E4%BA%A1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95">死亡对象的判断方法</a></li><li><a href="#gc-roots%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B">GC Roots包括哪些？</a></li><li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95">垃圾回收算法</a></li><li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B">垃圾回收器有哪些？</a></li><li><a href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bg1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8">详细介绍一下G1垃圾回收器</a></li><li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8cms%E5%92%8Cg1%E7%9A%84%E5%8C%BA%E5%88%AB">垃圾回收器CMS和G1的区别?</a></li><li><a href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8">如何选择合适的垃圾回收器？</a></li></ul></li><li><a href="#jvm%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B7%A5%E5%85%B7">JVM调优的参数有哪些？有哪些工具？</a></li><li><a href="#java%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF">Java内存泄漏的排查思路？</a></li><li><a href="#cpu%E9%A3%99%E5%8D%87%E7%9A%84%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF">CPU飙升的排查思路？</a></li><li><a href="#jmm">JMM</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFjmm">什么是JMM?</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4jmm%E6%8A%BD%E8%B1%A1%E4%BA%86%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%B8%BB%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">为什么说JMM抽象了线程和主内存之间的关系？</a></li><li><a href="#happens-before%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88">happens-before原则是什么？</a></li></ul></li><li><a href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基础数据类型</a></li><li><a href="#%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%A6%E7%94%9F%E7%B1%BB%E6%83%B3%E6%8C%89%E7%85%A7%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F%E5%86%8D%E6%8C%89%E5%AD%A6%E5%8F%B7%E6%8E%92%E5%BA%8F%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A">有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</a></li><li><a href="#java%E9%9B%86%E5%90%88">Java集合</a><ul><li><a href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB">数组和集合的区别？</a></li><li><a href="#arraylist%E5%92%8Clinkedlist%E7%9A%84%E5%8C%BA%E5%88%AB">ArrayList和LinkedList的区别？</a></li><li><a href="#list%E4%B8%AD%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E4%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98">List中遍历删除元素会有哪些问题？</a></li><li><a href="#arraylist%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88">ArrayList的扩容机制是什么？</a></li><li><a href="#copyonwritearraylist%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84">CopyonWriteArraylist是如何实现线程安全的？</a></li><li><a href="#hashmap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B">HashMap实现原理介绍一下？</a></li><li><a href="#hashmap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8">HashMap为什么线程不安全？</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">解决哈希冲突的方法有哪些？</a></li><li><a href="#hashmap%E7%9A%84put%E8%BF%87%E7%A8%8B">HashMap的put过程？</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88hashmap%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8D%E7%94%A8%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">为什么HashMap用红黑树不用平衡二叉树？</a></li><li><a href="#hashmap-key%E5%8F%AF%E4%BB%A5%E4%B8%BAnull%E5%90%97">HashMap key可以为null吗？</a></li><li><a href="#%E9%87%8D%E5%86%99hashmap%E7%9A%84equals%E5%92%8Chashcode%E6%96%B9%E6%B3%95%E6%97%B6%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88">重写HashMap的equals和hashCode方法时，要注意什么？</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88hashmap%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9">为什么HashMap的大小是2的幂次方？</a></li><li><a href="#concurrenthashmap%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84">ConcurrentHashMap是如何实现线程安全的？</a></li><li><a href="#%E5%88%86%E6%AE%B5%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84">分段锁是怎么加锁的？</a></li><li><a href="#concurrenthashmap%E7%94%A8%E7%9A%84%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%E8%BF%98%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81">ConcurrentHashMap用的是乐观锁还是悲观锁？</a></li><li><a href="#hashtable%E5%92%8Cconcurrenthashmap%E7%9A%84%E5%8C%BA%E5%88%AB">hashtable和ConcurrentHashMap的区别？</a></li></ul></li><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a><ul><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B">面向对象的设计原则有哪些？</a></li><li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB">抽象类和接口的区别</a></li><li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%90%97">抽象类可以被实例化吗？</a></li><li><a href="#java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">Java深拷贝的方式有哪些？</a></li></ul></li><li><a href="#java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1">Java中的对象</a><ul><li><a href="#java%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F">Java中创建对象有哪些方式？</a></li><li><a href="#new%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9B%9E%E6%94%B6">new的对象什么时候回收？</a></li></ul></li><li><a href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6">反射机制</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6">什么是反射机制？</a></li><li><a href="#%E5%8F%8D%E5%B0%84%E5%9C%A8%E4%BD%A0%E5%B9%B3%E6%97%B6%E5%86%99%E4%BB%A3%E7%A0%81%E6%88%96%E8%80%85%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B">反射在你平时写代码或者框架中的应用场景有哪些?</a></li></ul></li><li><a href="#java%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86">Java注解的原理</a></li><li><a href="#-%E4%B8%8E-equals-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">== 与 equals 有什么区别？</a></li><li><a href="#stringbuffer%E5%92%8Cstringbuilder%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">StringBuffer和StringBuilder区别是什么？</a></li><li><a href="#%E5%B9%B6%E5%8F%91">并发</a><ul><li><a href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2">线程安全体现在哪些方面？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFcas%E6%93%8D%E4%BD%9C">什么是CAS操作？</a></li><li><a href="#cas%E7%9A%84%E7%BC%BA%E7%82%B9">CAS的缺点？</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">线程创建方式有哪些？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B">如何停止线程？</a></li><li><a href="#sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB">sleep和wait的区别？</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B">线程的状态有哪些？</a></li><li><a href="#blocked%E5%92%8Cwaiting%E7%9A%84%E5%8C%BA%E5%88%AB">blocked和waiting的区别？</a></li><li><a href="#notify%E5%92%8Cnotifyall%E7%9A%84%E5%8C%BA%E5%88%AB">notify和notifyAll的区别？</a></li><li><a href="#%E5%86%99%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E5%A5%87%E5%81%B6%E6%95%B0">写一段代码，实现线程交替打印奇偶数</a></li><li><a href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">怎么保证多线程安全？</a></li><li><a href="#java%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88">java中有哪些常用的锁？使用场景是什么？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81">什么是公平锁和非公平锁？</a></li><li><a href="#%E8%AE%B2%E8%AE%B2reentrantlock">讲讲ReentrantLock？</a></li><li><a href="#synchronized%E5%92%8Creentrantlock%E7%9A%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C">synchronized和ReentrantLock的的应用场景有什么不同？</a></li><li><a href="#synchronized%E5%92%8Creentrantlock%E7%9A%84%E5%8C%BA%E5%88%AB">synchronized和ReentrantLock的区别？</a></li><li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Baqs">介绍一下AQS?</a></li><li><a href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8">volatile关键字的作用？</a></li><li><a href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6">死锁产生的条件？</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B">线程池的提交任务流程？</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B">线程池的参数有哪些？</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B">线程池的拒绝策略有哪些？</a></li><li><a href="#%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE">核心线程数如何设置？</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B">线程池种类有哪些？</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B">线程池的阻塞队列有哪些？</a></li><li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95">多线程顺序执行的几种写法?</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADshutdown%E5%92%8Cshutdownnow%E7%9A%84%E5%8C%BA%E5%88%AB">线程池中shutdown和shutdownNow的区别？</a></li><li><a href="#%E6%8F%90%E4%BA%A4%E7%BB%99%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%92%A4%E5%9B%9E%E5%90%97">提交给线程池的任务可以被撤回吗？</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">线程池用到了哪些设计模式？</a></li><li><a href="#threadlocal%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">ThreadLocal为什么会发生内存泄漏？</a></li><li><a href="#threadlocal%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%A7%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">ThreadLocal的继承性问题以及解决方法？</a></li><li><a href="#completablefuture%E6%80%8E%E4%B9%88%E7%94%A8">CompletableFuture怎么用？</a></li></ul></li><li><a href="#mybatis">MyBatis</a><ul><li><a href="#mybatis%E4%B8%AD%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB">MyBatis中#{}和${}的区别？</a></li><li><a href="#mybatis%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86">MyBatis的延迟加载及其原理？</a></li><li><a href="#mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB">MyBatis的一级缓存和二级缓存的区别？</a></li></ul></li><li><a href="#mysql">MYSQL</a><ul><li><a href="#sql%E6%B3%A8%E5%85%A5%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90">SQL注入是什么？举个例子？</a></li><li><a href="#mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">mysql的事务隔离级别</a><ul><li><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7">事务的四个特性</a></li><li><a href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">事务隔离解决的问题</a></li><li><a href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务隔离级别</a></li></ul></li><li><a href="#mysql%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%84%8F%E8%AF%BB%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%B9%BB%E8%AF%BB%E7%9A%84">MYSQL具体怎么解决脏读、不可重复读、幻读的？</a></li><li><a href="#%E9%BB%98%E8%AE%A4%E7%9A%84%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E4%BC%9A%E5%8F%91%E7%94%9F%E5%B9%BB%E8%AF%BB">默认的可重复读隔离级别下，为什么还会发生幻读？</a></li><li><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84">事务的四个特性是如何实现的？</a></li><li><a href="#%E8%AE%B2%E8%AE%B2mvcc">讲讲MVCC?</a></li><li><a href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB">当前读和快照读的区别？</a></li><li><a href="#mvcc%E7%9A%84readview%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B">MVCC的ReadView介绍一下？</a></li><li><a href="#mysql%E7%9A%84%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%BC%95%E6%93%8E">MYSQL的有哪几种引擎？</a></li><li><a href="#mysql%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E6%97%A5%E5%BF%97">MYSQL了解哪些日志？</a></li><li><a href="#undolog%E5%92%8Credolog%E7%9A%84%E5%8C%BA%E5%88%AB">undolog和redolog的区别？</a></li><li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bredo-log">介绍一下redo log?</a></li><li><a href="#redo-log%E5%88%B7%E7%9B%98%E7%9A%84%E6%97%B6%E6%9C%BA">redo log刷盘的时机</a></li><li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bbin-log">介绍一下bin log？</a></li><li><a href="#mysql%E6%80%8E%E4%B9%88%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2">MYSQL怎么连表查询？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">如何避免重复插入数据？</a></li><li><a href="#in%E5%92%8Cexists%E7%9A%84%E5%8C%BA%E5%88%AB">in和exists的区别？</a></li><li><a href="#mysql%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">mysql的执行过程？</a></li><li><a href="#sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">SQL查询语句的执行顺序？</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88innodb%E6%98%AF%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">为什么InnoDB是默认存储引擎？</a></li><li><a href="#innodb%E5%92%8Cmyisam%E7%9A%84%E5%8C%BA%E5%88%AB">InnoDB和MyISAM的区别？</a></li><li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB">索引的分类？</a></li><li><a href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E9%80%89%E5%8F%96%E7%9A%84%E4%BE%9D%E6%8D%AE%E6%98%AF%E4%BB%80%E4%B9%88">聚簇索引选取的依据是什么？</a></li><li><a href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB">聚簇索引和非聚簇索引的区别？</a></li><li><a href="#b%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7">B+树的特性？</a></li><li><a href="#b%E6%A0%91%E5%92%8Cb%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB">B+树和B树的区别？</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E4%B8%8D%E7%94%A8%E8%B7%B3%E8%A1%A8">为什么MYSQL不用跳表？</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%87%AA%E5%A2%9Eid%E5%BF%AB%E4%B8%80%E4%BA%9B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8uuid">为什么自增ID快一些？为什么不用UUID？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">什么是覆盖索引？</a></li><li><a href="#%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95">深度分页有什么优化方法？</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88">创建联合索引要注意什么？</a></li><li><a href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%9C%89%E9%82%A3%E4%BA%9B%E6%83%85%E5%86%B5">索引失效有那些情况？</a></li><li><a href="#mysql%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2">mysql如何定位慢查询？</a></li><li><a href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">慢查询如何解决？</a></li><li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9">索引的缺点</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%82%E5%90%88%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95">什么时候适合建立索引？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95">什么时候不需要索引？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96">如何对索引进行优化？</a></li><li><a href="#%E4%BA%8B%E5%8A%A1%E7%89%B9%E5%88%AB%E5%A4%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%8A%E7%AB%AF">事务特别多有哪些弊端？</a></li><li><a href="#mysql%E9%87%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81">MYSQL里有哪些锁？</a></li><li><a href="#mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B">MYSQL主从复制过程？</a></li><li><a href="#%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">主从延迟有哪些解决方法？</a></li><li><a href="#%E5%88%86%E5%BA%93%E5%92%8C%E5%88%86%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB">分库和分表的区别？</a></li></ul></li><li><a href="#redis">Redis</a><ul><li><a href="#redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">Redis的数据结构以及应用场景？</a><ul><li><a href="#string">String</a></li><li><a href="#list">List:</a></li><li><a href="#hash">Hash</a></li><li><a href="#set">Set</a></li><li><a href="#zset">zset</a></li><li><a href="#bitmap">Bitmap</a></li><li><a href="#hyperloglog">hyperloglog</a></li><li><a href="#geo">GEO</a></li><li><a href="#stream">Stream</a></li></ul></li><li><a href="#redis%E7%9A%84string%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">redis的string实现原理</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88redis%E7%94%A8%E8%B7%B3%E8%A1%A8%E8%80%8C%E4%B8%8D%E6%98%AFb%E6%A0%91">为什么Redis用跳表而不是B+树？</a></li><li><a href="#%E8%B7%B3%E8%A1%A8%E7%9A%84%E5%B1%82%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%E7%9A%84">跳表的层数是怎么设置的？</a></li><li><a href="#redis%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%E7%9A%84">Redis的哈希表是怎么扩容的？</a></li><li><a href="#redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB">Redis为什么快？</a></li><li><a href="#redis%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B">Redis哪里用到了多线程？</a></li><li><a href="#io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0">IO多路复用怎么实现？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0redis%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7">如何实现Redis的原子性？</a></li><li><a href="#redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8Baof">Redis持久化之AOF？</a></li><li><a href="#aof%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6">AOF重写机制？</a></li><li><a href="#redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8Brdb">Redis持久化之RDB?</a></li><li><a href="#bgsave%E6%97%B6%E6%95%B0%E6%8D%AE%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%97">bgsave时，数据能被修改吗？</a></li><li><a href="#aof%E5%92%8Crdb%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">AOF和RDB的优缺点？</a></li><li><a href="#%E8%AE%B2%E8%AE%B2redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">讲讲Redis的内存淘汰策略？</a></li><li><a href="#lru%E5%92%8Clfu%E7%9A%84%E7%BC%BA%E7%82%B9">LRU和LFU的缺点？</a></li><li><a href="#redis%E7%9A%84%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5">Redis的过期删除策略？</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AB%8B%E5%88%BB%E5%88%A0%E9%99%A4%E8%BF%87%E6%9C%9Fkey">为什么不立刻删除过期key？</a></li><li><a href="#redis%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5">Redis全量同步？</a></li><li><a href="#redis%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5">Redis增量同步？</a></li><li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bredis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6">介绍一下Redis哨兵机制？</a></li><li><a href="#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7">哨兵机制如何监控？</a></li><li><a href="#%E5%93%A8%E5%85%B5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%96%B0%E7%9A%84%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8">哨兵如何选择新的主服务器？</a></li><li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4">介绍一下分片集群？</a></li><li><a href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86">Redis分布式锁的原理？</a><ul><li><a href="#%E5%8A%A0%E9%94%81">加锁</a></li><li><a href="#%E8%A7%A3%E9%94%81">解锁</a></li></ul></li><li><a href="#redis%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">redis实现的分布式锁有什么问题？</a></li><li><a href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BA%92%E6%96%A5%E6%80%A7%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3">redis分布式锁的互斥性问题怎么解决？</a></li><li><a href="#%E5%9F%BA%E4%BA%8Eredis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F">基于redis实现分布式锁如何自动续期？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7key%E9%97%AE%E9%A2%98">什么是大Key问题？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%A7key%E9%97%AE%E9%A2%98">如何解决大Key问题？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%83%ADkey%E9%97%AE%E9%A2%98">如何解决热key问题？</a></li><li><a href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">缓存雪崩如何解决？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91%E5%92%8C%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98">如何设计秒杀场景处理高并发和超卖问题？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%87%8D%E5%A4%8D%E4%B8%8B%E5%8D%95%E9%97%AE%E9%A2%98">如何处理重复下单问题？</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">基础性解决方案</a></li><li><a href="#%E7%BB%BC%E5%90%88%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">综合性解决方案</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7">如何保证双写一致性？</a></li></ul></li><li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95">介绍一下雪花算法？</a></li><li><a href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">动态代理</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">什么是动态代理？</a></li><li><a href="#jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4">JDK动态代理的实现步骤？</a></li><li><a href="#cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4">CGLIB动态代理的实现步骤？</a></li></ul></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%89%E4%B8%AA%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%90%AB%E4%B9%89">自定义注解的三个注解的含义？</a></li><li><a href="#aop">AOP</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFaop">什么是AOP？</a></li><li><a href="#aop%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD%E6%9C%89%E5%93%AA%E4%BA%9B">AOP的一些术语有哪些？</a></li><li><a href="#aop%E7%9A%84%E9%80%9A%E7%9F%A5%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B">AOP的通知都有哪些类型？</a></li><li><a href="#aop%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">AOP的应用场景？</a></li><li><a href="#aop%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%80%8E%E4%B9%88%E5%81%9A">AOP实现日志记录怎么做？</a></li></ul></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">创建型模式</a></li><li><a href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F">结构型模式</a></li><li><a href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">行为型模式</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">实现一个单例模式</a></li></ul></li><li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a><ul><li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%8E%E4%B9%88%E9%80%89%E5%9E%8B">消息队列怎么选型？</a></li><li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B">消息队列的应用场景有哪些？</a></li><li><a href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3">消息丢失怎么解决？</a></li><li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%A1%BA%E5%BA%8F%E6%80%A7%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81">消息队列的可靠性、顺序性怎么保证？</a></li></ul></li><li><a href="#spring">Spring</a><ul><li><a href="#spring%E7%9A%84%E5%8D%95%E4%BE%8Bbean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97">Spring的单例Bean是线程安全的吗？</a></li><li><a href="#spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84">Spring中的事务是如何实现的？</a></li><li><a href="#spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E6%9C%89%E5%93%AA%E4%BA%9B">Spring中事务的传播行为有哪些？</a></li><li><a href="#%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B">事务失效的场景有哪些？</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8transactional%E6%B3%A8%E8%A7%A3%E4%BC%9A%E5%A4%B1%E6%95%88">为什么方法内部调用@Transactional注解会失效？</a></li><li><a href="#bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Bean的生命周期？</a></li><li><a href="#bean%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3">Bean的循环依赖怎么解决？</a></li></ul></li><li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bcap%E5%92%8Cbase%E7%90%86%E8%AE%BA">介绍一下CAP和BASE理论</a></li><li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Btcc%E6%A8%A1%E5%BC%8F">介绍一下TCC模式</a></li><li><a href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">定时任务有哪些实现方式？</a></li><li><a href="#%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83">认证授权</a><ul><li><a href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Brbac%E6%A8%A1%E5%9E%8B">介绍一下RBAC模型？</a></li></ul></li><li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">负载均衡</a><ul><li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%80%8E%E4%B9%88%E5%88%86%E7%B1%BB">负载均衡怎么分类？</a></li><li><a href="#%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%8C%BA%E5%88%AB">四层负载均衡和七层负载均衡的区别？</a></li><li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">负载均衡算法有哪些？</a></li><li><a href="#%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%81%9A">七层负载均衡可以怎么做？</a></li></ul></li></ul></li><li><a href="#cs%E5%9F%BA%E7%A1%80">CS基础</a><ul><li><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">进程和线程的区别</a></li><li><a href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB">硬链接和软链接的区别</a><ul><li><a href="#%E7%A1%AC%E9%93%BE%E6%8E%A5">硬链接</a></li><li><a href="#%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5">软链接（符号链接）</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A1%AC%E8%BF%9E%E6%8E%A5%E4%B8%8D%E8%83%BD%E8%B7%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">为什么硬连接不能跨文件系统？</a></li></ul></li><li><a href="#%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91">动态编译和静态编译</a><ul><li><a href="#%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91">静态编译</a></li><li><a href="#%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%97%B6%E7%BC%96%E8%AF%91">动态编译(运行时编译)</a></li></ul></li><li><a href="#tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP三次握手</a><ul><li><a href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">三次握手</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">为什么要三次握手？</a></li><li><a href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%8F%91%E9%80%81%E4%BA%86ack%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E5%8F%91%E9%80%81syn">第二次发送了ACK，为什么还要发送SYN？</a></li><li><a href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%90%97">三次握手过程可以携带数据吗？</a></li></ul></li><li><a href="#tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP四次挥手</a><ul><li><a href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">四次挥手</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">为什么要四次挥手？</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8D%E6%8A%8A-ack-%E5%92%8C-fin-%E4%B8%80%E8%B5%B7%E5%8F%91%E9%80%81%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B">为什么服务端不把 ACK 和 FIN 一起发送，变成三次挥手？</a></li><li><a href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%91%E9%80%81ack%E6%B2%A1%E6%9C%89%E5%88%B0%E8%BE%BE%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7">第二次挥手服务端发送ACK没有到达会怎么样？</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%A6%81%E7%AD%89%E5%BE%85-2msl%E6%8A%A5%E6%96%87%E6%9C%80%E9%95%BF%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4%E6%89%8D%E8%BF%9B%E5%85%A5closed%E7%8A%B6%E6%80%81">为什么第四次挥手，客户端要等待 2MSL（报文最长存活时间）才进入CLOSED状态？</a></li></ul></li></ul></li><li><a href="#c">C++</a><ul><li><a href="#c%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97">c++中的static关键字</a></li><li><a href="#c%E6%A8%A1%E6%9D%BF">c++模板</a></li><li><a href="#c%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB">c++深拷贝和浅拷贝的区别</a></li><li><a href="#c%E5%A4%9A%E6%80%81">c++多态</a></li><li><a href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0">虚函数与纯虚函数</a></li><li><a href="#c%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">c++智能指针</a></li><li><a href="#const-%E5%92%8C-volatile%E8%BE%A8%E6%9E%90">const 和 volatile辨析</a></li><li><a href="#null-%E5%92%8C-nullptr%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5nulllptr">NULL 和 nullptr的区别是什么，为什么引入nulllptr？</a></li><li><a href="#git-fetch%E5%92%8Cgit-pull%E7%9A%84%E5%8C%BA%E5%88%AB">git fetch和git pull的区别</a></li><li><a href="#delete%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9F%A5%E9%81%93%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E7%9A%84">delete[]是怎样知道数组长度的？</a></li><li><a href="#%E7%A8%8B%E5%BA%8F%E6%98%AF%E4%BB%8Emain-%E5%87%BD%E6%95%B0%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E5%90%97">程序是从main 函数开始执行的吗？</a></li></ul></li><li><a href="#python">python</a><ul><li><a href="#python%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">python的垃圾回收机制</a></li></ul></li><li><a href="#deep-learning">deep learning</a><ul><li><a href="#%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B">判别模型和生成模型</a></li><li><a href="#%E8%BD%AC%E7%BD%AE%E5%8D%B7%E7%A7%AF%E5%92%8C%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF">转置卷积和空洞卷积</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8D%E5%B9%B3%E8%A1%A1%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">数据集不平衡的处理方式</a></li><li><a href="#tensorflow%E5%92%8Cpytorch%E7%9A%84%E5%8C%BA%E5%88%AB">tensorflow和pytorch的区别</a></li><li><a href="#transformer%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81">transformer中的位置编码</a></li><li><a href="#%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%92%8C%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%9A%84%E5%8C%BA%E5%88%AB">自注意力和注意力的区别</a></li></ul></li></ul><!-- /TOC --><h1 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h1><h2 id="jdk-jre和jvm是什么"><a class="markdownIt-Anchor" href="#jdk-jre和jvm是什么"></a> JDK、JRE和JVM是什么？</h2><h3 id="jdk"><a class="markdownIt-Anchor" href="#jdk"></a> JDK</h3><p>JDK（Java Development Kit）是一个功能齐全的 Java 开发工具包，供开发者使用，用于创建和编译 Java 程序。<br />它包含了 JRE（Java Runtime Environment），以及编译器 javac 和其他工具，如 javadoc（文档生成器）、jdb（调试器）、jconsole（监控工具）、javap（反编译工具）等。</p><h3 id="jre"><a class="markdownIt-Anchor" href="#jre"></a> JRE</h3><p>JRE 是运行已编译 Java 程序所需的环境，主要包含以下两个部分：</p><ul><li>JVM : 也就是我们上面提到的 Java 虚拟机。</li><li>Java 基础类库（Class Library）：一组标准的类库，提供常用的功能和 API（如 I/O 操作、网络通信、数据结构等）。</li></ul><h3 id="jvm"><a class="markdownIt-Anchor" href="#jvm"></a> JVM</h3><p>Java 虚拟机（Java Virtual Machine, JVM）是运行 Java 字节码的虚拟机。<br />JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。<br />字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。<br />不同编程语言（Java、Groovy、Kotlin、JRuby、Clojure …）通过各自的编译器编译成 .class 文件，并最终通过 JVM 在不同平台（Windows、Mac、Linux）上运行。</p><h2 id="字节码"><a class="markdownIt-Anchor" href="#字节码"></a> 字节码</h2><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。<br />Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><p>Java程序运行流程如下图:<br /><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png" alt="Java程序运行流程" /></p><p>需要格外注意的是 .class-&gt;机器码 这一步。</p><ul><li>在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。</li><li>而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（Just in Time Compilation） 编译器，而 JIT 属于运行时编译。</li><li>当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</li><li>机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言 。</li></ul><h2 id="为什么说java编译与解释共存"><a class="markdownIt-Anchor" href="#为什么说java编译与解释共存"></a> 为什么说Java“编译与解释共存”？</h2><ul><li>编译型语言：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li><li>解释型语言：解释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li></ul><p>Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p><h2 id="aot和jit"><a class="markdownIt-Anchor" href="#aot和jit"></a> AOT和JIT</h2><ul><li><p>AOT（Ahead of Time）：提前编译，是指在程序运行之前，将字节码编译成机器码，然后直接运行机器码。这样做的好处是可以提高程序的启动速度，减少内存占用。</p></li><li><p>JIT(Just in Time)：即时编译，是指在程序运行时，将热点代码（被频繁调用的代码）编译成机器码，然后再执行。这样做的好处是可以提高程序的执行效率。</p></li></ul><p>为什么AOT没有完全代替JIT?</p><ul><li>AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。但是，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载等，很多框架和库都用到了这些特性。只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。</li></ul><h2 id="受检异常和非受检异常的区别"><a class="markdownIt-Anchor" href="#受检异常和非受检异常的区别"></a> 受检异常和非受检异常的区别</h2><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">受检异常 (Checked Exceptions)</th><th style="text-align:left">非受检异常 (Unchecked Exceptions)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>处理方式</strong></td><td style="text-align:left"><strong>必须处理</strong> 。Java编译器强制要求程序员必须捕获（使用 <code>try-catch</code>）或者在方法签名中通过 <code>throws</code> 关键字声明抛出。</td><td style="text-align:left"><strong>无需强制处理</strong> 。程序员可以选择捕获处理，也可以不处理，编译器不作强制要求。</td></tr><tr><td style="text-align:left"><strong>检查时机</strong></td><td style="text-align:left"><strong>编译时检查</strong> 。编译器会在编译代码时检查受检异常是否被妥善处理，有助于及早发现潜在错误 。</td><td style="text-align:left"><strong>运行时检查</strong> 。这类异常通常在程序运行时才会被发现，与程序的逻辑错误相关。</td></tr><tr><td style="text-align:left"><strong>继承关系</strong></td><td style="text-align:left">继承自 <code>Exception</code>类，但不是 <code>RuntimeException</code> 或其子类。</td><td style="text-align:left">继承自 <code>java.lang.RuntimeException</code> 或 <code>java.lang.Error</code>。</td></tr><tr><td style="text-align:left"><strong>使用场景</strong></td><td style="text-align:left">用于表示程序外部的可控、可预见的错误情况，调用者可以从这些异常中进行合理的恢复。例如：<br>- <code>IOException</code> (IO异常)<br>- <code>SQLException</code> (数据库操作异常) <br>- <code>FileNotFoundException</code> (文件未找到异常) <br>- <code>ClassNotFoundException</code> (类未找到异常)</td><td style="text-align:left">用于表示程序内部的逻辑错误或运行时错误，这些错误通常是程序员应该避免的。例如：<br>- <code>NullPointerException</code> (空指针异常)<br>- <code>ArrayIndexOutOfBoundsException</code> (数组越界异常)<br>- <code>ClassCastException</code> (类型转换异常)<br>- <code>IllegalArgumentException</code> (非法参数异常)</td></tr></tbody></table><h2 id="jvm内存区域"><a class="markdownIt-Anchor" href="#jvm内存区域"></a> JVM内存区域</h2><p>JVM 在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域，主要包括以下几个区域：</p><ul><li>线程私有的：程序计数器、虚拟机栈、本地方法栈</li><li>线程共享的：堆、方法区、直接内存</li></ul><h3 id="程序计数器"><a class="markdownIt-Anchor" href="#程序计数器"></a> 程序计数器</h3><ul><li>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><blockquote><p>程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p></blockquote><h3 id="虚拟机栈"><a class="markdownIt-Anchor" href="#虚拟机栈"></a> 虚拟机栈</h3><ul><li>虚拟机栈由一个个栈帧组成，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。</li></ul><h3 id="本地方法栈"><a class="markdownIt-Anchor" href="#本地方法栈"></a> 本地方法栈</h3><ul><li>本地方法栈和虚拟机栈所发挥的作用相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法(非Java语言编写的方法)服务。</li></ul><h3 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h3><ul><li>堆是 Java 虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，几乎所有的对象实例都在这里分配内存。</li><li>堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”。</li><li>在jdk7及以前，堆中内存被分为新生代、老年代和永久代，实际上永久代处于方法区，与堆是隔离的，但是内存上是连续的。在jdk8中，<strong>永久代被元空间取代</strong>，元空间位于本地内存，因此堆中主要分为新生代和老年代。</li></ul><h3 id="方法区"><a class="markdownIt-Anchor" href="#方法区"></a> 方法区</h3><ul><li>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域</li><li>当JVM要使用一个类时，会检查并解析字节码文件的相关信息，并将信息存储在方法区中</li></ul><h3 id="运行时常量池和字符串常量池"><a class="markdownIt-Anchor" href="#运行时常量池和字符串常量池"></a> 运行时常量池和字符串常量池</h3><ul><li>常量池表主要存放编译期生成的各种字面量和符号引用。</li><li>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</li></ul><p>jdk7中，运行时常量池存放在方法区中，而字符串常量池存放在堆中。在jdk8中，运行时常量池存放在元空间中。</p><h3 id="直接内存"><a class="markdownIt-Anchor" href="#直接内存"></a> 直接内存</h3><ul><li>直接内存并不是虚拟机运行时数据区的一部分，也不是JVM中定义的内存区域。</li><li>直接内存是本地内存的一部分，本地内存包括直接内存和元空间</li></ul><h3 id="为什么要将永久代替换为元空间"><a class="markdownIt-Anchor" href="#为什么要将永久代替换为元空间"></a> 为什么要将永久代替换为元空间？</h3><ul><li>永久代有一个 JVM 本身设置的固定上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li><li>永久代会为 GC 带来不必要的复杂度，例如永久代的 GC 会因为频繁的类加载而导致 Full GC，而元空间的 GC 将会更简单高效。</li></ul><h3 id="string-s-new-stringabc-执行过程中分别对应哪些内存区域"><a class="markdownIt-Anchor" href="#string-s-new-stringabc-执行过程中分别对应哪些内存区域"></a> String s = new String(“abc”) 执行过程中分别对应哪些内存区域？</h3><ul><li><p>首先，我们看到这个代码中有一个new关键字，我们知道new指令是创建一个类的实例对象并完成加载初始化的，因此这个字符串对象是在运行期才能确定的，创建的字符串对象是在<strong>堆内存</strong>上。</p></li><li><p>其次，在String的构造方法中传递了一个字符串abc，由于这里的abc是被final修饰的属性，所以它是一个字符串常量。在首次构建这个对象时，JVM拿字面量&quot;abc&quot;去字符串常量池试图获取其对应String对象的引用。于是在堆中创建了一个&quot;abc&quot;的String对象，并将其引用保存到字符串常量池中，然后返回；</p></li><li><p>所以，如果abc这个字符串常量不存在，则创建两个对象，分别是abc这个字符串常量，以及new String这个实例对象。如果abc这字符串常量存在，则只会创建一个对象。</p></li></ul><h3 id="四种引用类型"><a class="markdownIt-Anchor" href="#四种引用类型"></a> 四种引用类型？</h3><p>Java 中有四种引用类型，分别是：</p><ul><li>强引用：常见的引用类型，如<code>A a = new A()</code>，强引用的对象不会被GC回收。（不是不会被回收，而是只要有一个强引用，GC就不会回收，如果没有，还是会回收的）</li><li>软引用：在内存不足时，垃圾回收器会回收被软引用的对象。可以使用<code>SoftReference</code>类来创建软引用。</li><li>弱引用：弱引用的对象在<strong>下一次垃圾回收时就会被回收</strong>。可以使用<code>WeakReference</code>类来创建弱引用。</li><li>虚引用：最弱的引用类型，必须和引用队列（<code>ReferenceQueue</code>）一起使用。可用来管理堆外内存。</li></ul><h2 id="类加载"><a class="markdownIt-Anchor" href="#类加载"></a> 类加载</h2><h3 id="什么是类加载器类加载器有哪些"><a class="markdownIt-Anchor" href="#什么是类加载器类加载器有哪些"></a> 什么是类加载器，类加载器有哪些？</h3><p>类加载器的作用是将字节码文件加载到JVM中，从而让Java程序启动起来<br />类加载器一共有四种：</p><ul><li>启动类加载类BootStrap ClassLoader：负责加载Java的核心类库，通常是<code>JAVA_HOME/jre/lib/</code>下的库</li><li>扩展类加载器Extension ClassLoader：负责加载Java的扩展类库，通常是<code>JAVA_HOME/jre/lib/ext/</code>下的库</li><li>应用类加载器Application ClassLoader：负责加载用户类路径下的类，通常是<code>CLASSPATH</code>下的库</li><li>自定义类加载器：用户可以自定义类加载器</li></ul><h3 id="什么是双亲委派机制为什么要用双亲委派机制"><a class="markdownIt-Anchor" href="#什么是双亲委派机制为什么要用双亲委派机制"></a> 什么是双亲委派机制？为什么要用双亲委派机制？</h3><p>加载某一个类时，会委托上一级的类加载器去加载，如果上级也有上级，则一直到上级去尝试加载，如果上级类加载器无法加载，才由当前类加载器去加载。</p><p>JVM使用双亲委派的原因：</p><ul><li>避免类的重复加载，当父类已经加载后，子类就无需加载了</li><li>为了安全，保证核心类库的API不会被修改</li></ul><h3 id="如何打破双亲委派机制"><a class="markdownIt-Anchor" href="#如何打破双亲委派机制"></a> 如何打破双亲委派机制？</h3><ul><li>自定义类加载器，继承 ClassLoader，重写 findClass 方法</li><li>使用线程上下文类加载器来加载特定的类</li><li>使用动态代理，并在代理类中实现自定义类加载逻辑</li></ul><h3 id="jvm类加载的过程"><a class="markdownIt-Anchor" href="#jvm类加载的过程"></a> JVM类加载的过程</h3><ul><li>加载，即加载字节码文件</li><li>验证，确保字节码文件符合 JVM 规范</li><li>准备，为变量分配内存并设置初始值</li><li>解析，把类中的符号引用变为直接引用（符号引用是逻辑上的名称，直接引用是实际的内存地址）</li><li>初始化，为静态变量和静态代码块进行初始化</li><li>使用</li><li>卸载</li></ul><h2 id="jvm垃圾回收"><a class="markdownIt-Anchor" href="#jvm垃圾回收"></a> JVM垃圾回收</h2><p>在堆的新生代中，由Eden 区、两个 Survivor 区组成， 两个 Survivor 区中包括S0 和 S1。</p><h3 id="内存分配和回收原则"><a class="markdownIt-Anchor" href="#内存分配和回收原则"></a> 内存分配和回收原则</h3><ul><li>对象优先在 Eden 区分配，当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC，Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。</li><li>大对象直接进入老年代，大对象是指需要大量连续内存空间的对象，比如一个很长的字符串或数组。</li><li>长期存活的对象将进入老年代，虚拟机给每个对象定义了一个年龄计数器，对象在 Eden 区出生后，经过一次 Minor GC 仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 区，并且年龄设为 1，对象在 Survivor 区每熬过一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代。</li></ul><h3 id="minorgc-mixedgc-fullgc的区别是什么"><a class="markdownIt-Anchor" href="#minorgc-mixedgc-fullgc的区别是什么"></a> MinorGC、MixedGC、FullGC的区别是什么？</h3><ul><li>MinorGC：发生在新生代的垃圾回收，回收停顿时间短。</li><li>MixedGC：新生代+老年代部分区域的垃圾回收，G1回收器特有</li><li>FullGC：新生代+老年代完整区域的垃圾回收，回收停顿时间长</li></ul><h3 id="fullgc什么时候触发"><a class="markdownIt-Anchor" href="#fullgc什么时候触发"></a> FullGC什么时候触发？</h3><ul><li>显式调用 System.gc()，建议JVM进行FullGC，但是不一定会执行</li><li>未设置堆的初始化大小</li><li>老年代空间不足，无法分配对象</li></ul><h3 id="死亡对象的判断方法"><a class="markdownIt-Anchor" href="#死亡对象的判断方法"></a> 死亡对象的判断方法</h3><ul><li>引用计数法：当对象被引用时，计数器加 1，当引用失效时，计数器减 1，当计数器为 0 时，说明对象不再被引用，可以被回收。但这种方法无法解决循环引用的问题。</li><li>可达性分析法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。即GC roots到某个对象不可达，则说明此对象是可以被回收的。</li><li>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；</li></ul><h3 id="gc-roots包括哪些"><a class="markdownIt-Anchor" href="#gc-roots包括哪些"></a> GC Roots包括哪些？</h3><ul><li>全局性引用，如对方法区的静态属性、常量引用的对象</li><li>执行上下文，如本地方法栈中的引用的对象</li><li>已经启动且未停止的线程</li></ul><h3 id="垃圾回收算法"><a class="markdownIt-Anchor" href="#垃圾回收算法"></a> 垃圾回收算法</h3><ul><li>标记-清除算法：标记出所有活动对象，然后统一回收未标记对象。这种算法会产生大量不连续的内存碎片，导致以后在分配大对象时可能出现内存不足的情况。</li><li>复制算法：将内存分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，就将还存活的对象复制到另一块上面，然后把已使用的内存空间一次清理掉。这种算法没有内存碎片问题，但是会浪费一半的内存空间。</li><li>标记-整理算法：标记出所有活动对象，然后将存活的对象向一端移动，然后直接清理掉端边界以外的内存。这种算法没有内存碎片问题，也不会浪费内存，但是需要移动对象，所以比较耗时。</li><li>分代收集算法：根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，新生代由于每次收集会有大量对象死去，所以可选用复制算法，而老年代因为对象存活率高，所以可选用标记清除或标记整理算法。</li></ul><h3 id="垃圾回收器有哪些"><a class="markdownIt-Anchor" href="#垃圾回收器有哪些"></a> 垃圾回收器有哪些？</h3><ul><li>Serial收集器 (复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>Parallel Old收集器 (标记-整理算法): 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li><li>CMS(Concurrent Mark Sweep)收集器 (标记-清除算法): 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (标记-整理算法): Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li><li>ZGC: 低延迟垃圾收集器，回收停顿时间小于1ms，支持超大堆内存，适用于大规模服务</li></ul><h3 id="详细介绍一下g1垃圾回收器"><a class="markdownIt-Anchor" href="#详细介绍一下g1垃圾回收器"></a> 详细介绍一下G1垃圾回收器</h3><p>G1垃圾回收器中，划分了多个区域，每个区域都可以充当eden区、survivor区和老年代</p><p>主要分3个阶段：</p><ul><li>年轻代垃圾回收<br />当产生了一些对象，这些对象先被分配到eden区，当需要进行垃圾回收时，会进行minorGC，将存活的对象标记出来，复制到survivor区，标记和复制过程中，都会触发STW(stop the world)，但时间会很短，多次minorGC中还存活的对象会被放入老年代</li><li>并发标记阶段<br />当老年代内存超过阈值后，会进行并发标记，标记存活的对象，并发标记不会触发STW</li><li>混合收集阶段<br />混合收集阶段既进行年轻代的收集，又进行老年代的收集。因为G1回收器有一个<strong>预设的回收停顿时间</strong>，为了保证不超过这个时间，在进行老年代收集时，会优先收集回收价高的区域(存活对象少)。</li><li>如果回收速度赶不上创建对象的速度，会触发Full GC，回收时间会比较长。</li></ul><h3 id="垃圾回收器cms和g1的区别"><a class="markdownIt-Anchor" href="#垃圾回收器cms和g1的区别"></a> 垃圾回收器CMS和G1的区别?</h3><ol><li>使用范围不同，CMS主要用于老年代收集，G1可以收集老年代和新生代</li><li>CMS基于“标记-清除”算法实现，G1基于“标记-整理”算法实现</li><li>CMS以最小停顿时间为目标，G1可设置垃圾回收的停顿时间<br />使用场景不同：</li></ol><ul><li>CMS适合低延迟、老年代收集、对内存碎片不敏感的场景</li><li>G1适合大堆内存，对内存碎片敏感，需要平衡性能的场景</li></ul><h3 id="如何选择合适的垃圾回收器"><a class="markdownIt-Anchor" href="#如何选择合适的垃圾回收器"></a> 如何选择合适的垃圾回收器？</h3><ul><li>小堆+单核心CPU使用Serial</li><li>高吞吐量（批处理任务）使用Parallel</li><li>低延迟应用使用CMS</li><li>大堆（大于10G）内存+综合场景使用G1</li><li>超大堆（大于100G）+低延迟使用ZGC</li></ul><h2 id="jvm调优的参数有哪些有哪些工具"><a class="markdownIt-Anchor" href="#jvm调优的参数有哪些有哪些工具"></a> JVM调优的参数有哪些？有哪些工具？</h2><p>参数主要有：</p><ul><li>堆的大小Xms和Xmx,分别表示初始堆大小和最大堆大小</li><li>虚拟机栈大小-Xss，一般256k或512k</li><li>Eden区和两个Survivor区的比例，默认是8:1:1</li><li>新生代晋升老年代的阈值，不超过15</li><li>垃圾回收器的选择</li></ul><p>工具主要有：</p><ul><li>jps：类似ps</li><li>jstat：查看JVM的运行状态</li><li>jmap：查看堆的内存快照</li><li>jstack：查看线程的堆栈信息</li><li>VisualVM：可视化工具，查看JVM的运行状态和内存使用情况</li></ul><h2 id="java内存泄漏的排查思路"><a class="markdownIt-Anchor" href="#java内存泄漏的排查思路"></a> Java内存泄漏的排查思路？</h2><p>内存泄漏通常指的是堆上的一些对象没有被回收<br />排查思路如下：</p><ul><li>通过jmap获取堆的内存快照dump</li><li>通过VisualVM分析dump文件</li><li>查看堆中信息，定位出问题的代码</li></ul><h2 id="cpu飙升的排查思路"><a class="markdownIt-Anchor" href="#cpu飙升的排查思路"></a> CPU飙升的排查思路？</h2><ul><li>先通过top查看那个进程占用cpu最高，获取他的进程id</li><li>通过ps和grep查看进程中的线程信息，找到占用cpu最高的线程id</li><li>通过jstack查看进程，定位出问题的代码</li></ul><h2 id="jmm"><a class="markdownIt-Anchor" href="#jmm"></a> JMM</h2><h3 id="什么是jmm"><a class="markdownIt-Anchor" href="#什么是jmm"></a> 什么是JMM?</h3><p>JMM指的是java内存模型，它定义了java并发编程相关的一些规范，抽象了线程和主内存之间的关系，主要目的是为了规范和简化并发编程。</p><h3 id="为什么说jmm抽象了线程和主内存之间的关系"><a class="markdownIt-Anchor" href="#为什么说jmm抽象了线程和主内存之间的关系"></a> 为什么说JMM抽象了线程和主内存之间的关系？</h3><ul><li>线程之间的共享变量必须存储在主内存中</li><li>每个线程都有自己的本地内存，本地内存中主内存中共享变量的副本，线程只能操作本地内存中的变量，不能直接操作主内存中的变量。</li><li>线程之间的通信必须通过主内存来完成。</li></ul><h3 id="happens-before原则是什么"><a class="markdownIt-Anchor" href="#happens-before原则是什么"></a> happens-before原则是什么？</h3><p>是一种设计思想，主要用于解决多线程之间的可见性和有序性问题。<br />他的设计思想是：</p><ul><li>只要不改变程序的执行结果，编译器和处理器怎么进行重排序优化都行。</li><li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序</li></ul><h2 id="基础数据类型"><a class="markdownIt-Anchor" href="#基础数据类型"></a> 基础数据类型</h2><p>java中八种基础数据类型如下图：<br /><img src="https://cdn.xiaolincoding.com//picgo/1715930589177-73932d2c-b0c0-4f58-a5c1-ab514b1a389c.png" alt="基础数据类型" /></p><p>值得注意的是：</p><ul><li>1个字节的有boolean和byte,2个字节的有short和char,4个字节的有int和float,8个字节的有long和double。</li><li>浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）。</li><li>整数的默认类型为int（声明Long型在末尾加上l或者L）</li><li>8种基本类型的包装类，除了char是Character，int是Integer，其余的都是首字母大写。</li><li>char是无符号的，最小值是0</li></ul><p>long和int可以互转吗？<br />答：可以，long的范围更大，int可以直接赋值给long,long转int需要强制类型转换。</p><p>字节支付实习一面：String类可以被继承吗？<br />答：String类是final类，不可以被继承。所有基本数据类型对应的包装类都是final类，不可以被继承。</p><p>为什么用bigDecimal 不用double ？<br />答：double类型是不精确的，因为double类型是采用二进制浮点数进行计算的，而二进制浮点数无法精确表示大部分的十进制小数，所以在计算时会有精度丢失的问题。而BigDecimal是采用十进制浮点数进行计算的，可以精确表示大部分的十进制小数。</p><p>为什么要有Integer？<br />答：Integer是int的包装类，封装之后包含一些数据处理的方法，便于处理数据;<br />Java中大部分方法和类以及集合只能处理类型对象，比如ArrayList；<br />基本类型和引用类型不能直接转换，比如int要转为String类需要先专程Integer。</p><h2 id="有一个学生类想按照分数排序再按学号排序应该怎么做"><a class="markdownIt-Anchor" href="#有一个学生类想按照分数排序再按学号排序应该怎么做"></a> 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</h2><p>答：可以让学生类实现Comparable接口，重写compareTo方法，然后在compareTo方法中按照分数排序，再按照学号排序。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Student</span>&gt;</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Student t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.score!=t.score)&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">return</span> Integer.<span class="hljs-title">compare</span><span class="hljs-params">(t.score,<span class="hljs-keyword">this</span>.score)</span></span>; <span class="hljs-comment">//按分数降序</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">return</span> Integer.<span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">this</span>.id,t.id)</span></span>; <span class="hljs-comment">//分数相同按学号升序</span><br>        &#125;<br>    &#125;<br>&#125;<br>List&lt;Student&gt; st = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>Collections.sort(st);<br></code></pre></td></tr></table></figure><h2 id="java集合"><a class="markdownIt-Anchor" href="#java集合"></a> Java集合</h2><h3 id="数组和集合的区别"><a class="markdownIt-Anchor" href="#数组和集合的区别"></a> 数组和集合的区别？</h3><ul><li>数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素。</li><li>数组可以包含基本数据类型和对象，而集合只能包含对象。</li><li>数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。</li></ul><h3 id="arraylist和linkedlist的区别"><a class="markdownIt-Anchor" href="#arraylist和linkedlist的区别"></a> ArrayList和LinkedList的区别？</h3><ul><li>ArrayList基于数组，而LinkedList基于链表实现。</li><li>插入删除、随机访问效率不同</li><li>ArrayList创建时要分配一段连续空间，占用空间更大</li><li>前者适合需要频繁随机访问的场景，后者适合需要频繁插入删除的场景。</li></ul><h3 id="list中遍历删除元素会有哪些问题"><a class="markdownIt-Anchor" href="#list中遍历删除元素会有哪些问题"></a> List中遍历删除元素会有哪些问题？</h3><ul><li><p>使用for循环按照下标删除元素时，会导致后面的元素向前移动，导致元素漏删。</p></li><li><p>如果使用iterator遍历删除元素，使用list的remove方法，会抛出ConcurrentModificationException异常。<br />这是因为，List自身会维护一个modCount计数器，使用<code>list.remove()</code>方法时，会修改modCount，而iterator在创建时会记录最开始的modCount，如果遍历过程中iterator检查到modCount不一致，就会抛出异常。</p></li><li><p>正确的删除方法是使用iterator的remove方法，这样不会抛出异常。</p></li></ul><h3 id="arraylist的扩容机制是什么"><a class="markdownIt-Anchor" href="#arraylist的扩容机制是什么"></a> ArrayList的扩容机制是什么？</h3><p>如果当前元素数量达到内部数组容量上限，就会触发扩容机制。分以下几步骤：</p><ul><li>计算新的容量，一般会扩大1.5倍</li><li>创建新的数组</li><li>将旧数组元素复制到新数组</li><li>更新引用指向新数组</li></ul><p>之所以扩容是 1.5 倍，是因为 1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。</p><h3 id="copyonwritearraylist是如何实现线程安全的"><a class="markdownIt-Anchor" href="#copyonwritearraylist是如何实现线程安全的"></a> CopyonWriteArraylist是如何实现线程安全的？</h3><ul><li>CopyonWriteArraylist底层也是通过一个数组保存数据，使用volatile修饰，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。</li><li>对读操作没有加锁，对写操作加了一个ReentrantLock锁，保证写操作的线程安全。</li></ul><h3 id="hashmap实现原理介绍一下"><a class="markdownIt-Anchor" href="#hashmap实现原理介绍一下"></a> HashMap实现原理介绍一下？</h3><ul><li>早期HashMap是数组+链表，通过哈希算法将元素映射到数组中，如果发生冲突，就会在链表中存储多个元素，当链表元素过多查询效率会降低很多。</li><li>JDK1.8之后，HashMap引入了红黑树，当链表长度超过8时，链表会转换为红黑树，提高查询效率（查询复杂度<code>log n</code>）,数量少于6会转回链表。</li></ul><h3 id="hashmap为什么线程不安全"><a class="markdownIt-Anchor" href="#hashmap为什么线程不安全"></a> HashMap为什么线程不安全？</h3><p>HashMap线程不安全主要是由于多个线程对HashMap的put操作引起的，有下面两种情况：</p><ul><li>一种是两个线程同时put，假如线程1先完成了哈希冲突判断后，时间片耗尽挂起，线程2进行哈希冲突判断然后put，如果发生了哈希冲突，线程1是感知不到的，它轮到时间片后会继续put,这样导致了数据覆盖。</li><li>一种是两个线程同时put,同时读到当前size为10，这样线程1读完size后时间片耗尽挂起，线程2完成put,size变为11，线程1继续执行put，size还是改成11，这样导致增加了两个元素，但size只增加了1。</li></ul><h3 id="解决哈希冲突的方法有哪些"><a class="markdownIt-Anchor" href="#解决哈希冲突的方法有哪些"></a> 解决哈希冲突的方法有哪些？</h3><ul><li>链地址法：将哈希冲突的元素存储的在链表或其他数据结构中</li><li>开放寻址法：找到另一个可用的位置来存储，包括线性探测、二次探测、双重散列等。</li><li>再哈希法：使用另一个哈希函数计算新的哈希值。</li><li>哈希桶扩容：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对。</li></ul><h3 id="hashmap的put过程"><a class="markdownIt-Anchor" href="#hashmap的put过程"></a> HashMap的put过程？</h3><ol><li>计算要添加的key的哈希值，找到在数组中的索引</li><li>如果该索引位置没有元素，直接添加</li><li>如果该索引位置有元素，检查key是否相等，如果相等，直接覆盖value，如果不相等，发生哈希冲突，通过链表或红黑树中查找这个key，找到则更新value，为找到则添加</li><li>检查链表长度是否超过8，超过则转换为红黑树</li><li>检查负载因子是否超过0.75，超过则扩容</li><li>扩容时，首先创建一个新的数组，大小是原数组的2倍，然后重新计算旧数组的哈希值分配到新数组中，更新引用。</li></ol><h3 id="为什么hashmap用红黑树不用平衡二叉树"><a class="markdownIt-Anchor" href="#为什么hashmap用红黑树不用平衡二叉树"></a> 为什么HashMap用红黑树不用平衡二叉树？</h3><ul><li>平衡二叉树追求完全平衡的状态，左右子树的高度差不超过1，每次插入删除都需要左旋右旋调整，效率很低</li><li>红黑树追求一种弱平衡状态，整个树的最长路径不超过最短路径的2倍，插入删除效率更高。</li></ul><h3 id="hashmap-key可以为null吗"><a class="markdownIt-Anchor" href="#hashmap-key可以为null吗"></a> HashMap key可以为null吗？</h3><p>答：HashMap的key可以为null，HashMap使用hash()方法计算key的哈希值，如果key为null，哈希值为0。不会去调用hashCode()方法。</p><h3 id="重写hashmap的equals和hashcode方法时要注意什么"><a class="markdownIt-Anchor" href="#重写hashmap的equals和hashcode方法时要注意什么"></a> 重写HashMap的equals和hashCode方法时，要注意什么？</h3><ul><li>HashMap在比较元素时，一般先比较hashCode，如果hashCode相等，再通过equals方法比较。</li><li>hashCode相等，equals不一定相等，但是equals相等，hashCode一定相等。</li><li>重写了equals方法，如果不重写hashCode方法，可能会导致相等的两个对象的hashCode不相等，从而导致相同的key被重复添加。</li></ul><h3 id="为什么hashmap的大小是2的幂次方"><a class="markdownIt-Anchor" href="#为什么hashmap的大小是2的幂次方"></a> 为什么HashMap的大小是2的幂次方？</h3><p>答：为了加速计算以及减少哈希冲突，计算哈希时一般按照<code>hash(key)%n</code>计算索引，如果n是2的幂次方，等价于<code>hash(key)&amp;(n-1)</code>，这样可以加快计算速度;<br />此外，这种与运算的方式可以让元素分布更加均匀，减少哈希冲突。</p><h3 id="concurrenthashmap是如何实现线程安全的"><a class="markdownIt-Anchor" href="#concurrenthashmap是如何实现线程安全的"></a> ConcurrentHashMap是如何实现线程安全的？</h3><p>ConcurrentHashMap主要通过volatile+CAS或者synchronized来保证线程安全。<br />添加元素时，先判断容器是否为空？</p><ul><li>为空则用volatile和CAS来初始化</li><li>不为空则计算该位置是否为空<ul><li>为空则用CAS添加元素</li><li>不为空则使用synchronized来更新或添加元素</li></ul></li></ul><p>锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。</p><h3 id="分段锁是怎么加锁的"><a class="markdownIt-Anchor" href="#分段锁是怎么加锁的"></a> 分段锁是怎么加锁的？</h3><ul><li>ConcurrentHashMap在JDK1.7之前使用分段锁，将整个数据分为若干个Segment，每个Segment都是一个小的HashMap，每个Segment都有自己的锁，不同 Segment 之间的操作互不影响，从而提高并发性能。</li><li>当进行增删改操作时，首先定位到具体的Segment，然后对这个Segment加锁，其他Segment不受影响，可以并发操作。</li></ul><h3 id="concurrenthashmap用的是乐观锁还是悲观锁"><a class="markdownIt-Anchor" href="#concurrenthashmap用的是乐观锁还是悲观锁"></a> ConcurrentHashMap用的是乐观锁还是悲观锁？</h3><p>答：都有用到。</p><ul><li>初始化时如果容器为空，通过volatile+CAS(乐观锁)初始化</li><li>如果不为空，则判断元素要添加的位置是否为空，为空则用CAS添加，不为空则用synchronized(悲观锁)添加或更新。</li></ul><h3 id="hashtable和concurrenthashmap的区别"><a class="markdownIt-Anchor" href="#hashtable和concurrenthashmap的区别"></a> hashtable和ConcurrentHashMap的区别？</h3><ul><li>从结构上看，hashtable是数组+链表，ConcurrentHashMap是数组+链表/红黑树</li><li>都是线程安全的，但hashtable所有方法都是synchronized，效率低，ConcurrentHashMap使用volatile+CAS或synchronized，效率更高</li></ul><h2 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h2><h3 id="面向对象的设计原则有哪些"><a class="markdownIt-Anchor" href="#面向对象的设计原则有哪些"></a> 面向对象的设计原则有哪些？</h3><ul><li>单一职责原则（SRP）：一个类只负责一个功能领域中的相应职责。</li><li>开放封闭原则（OCP）：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</li><li>里氏替换原则（LSP）：子类对象应该能够替换掉所有父类对象。</li><li>依赖隔离原则（ISP）：客户端不应该依赖那些它不需要的接口，接口应该而专。</li><li>依赖倒置原则（DIP）：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</li><li>最少知识原则（迪米特法则，LoD）：一个对象应该对其他对象有最少的了解。</li></ul><h3 id="抽象类和接口的区别"><a class="markdownIt-Anchor" href="#抽象类和接口的区别"></a> 抽象类和接口的区别</h3><p>抽象类：</p><ul><li>抽象类是包含至少一个抽象方法的类，抽象方法是没有方法体的方法。</li><li>抽象类可以包含具体的方法（有方法体的），也可以包含成员变量。</li><li>抽象类可以被继承，一个子类必须实现抽象类中的所有抽象方法，除非该子类也是抽象类。</li></ul><p>接口：</p><ul><li>接口是一个完全抽象的类，所有的方法默认是抽象的（Java 8 后，可以包含默认方法和静态方法）。</li><li>接口只能包含常量和抽象方法（除非定义了默认方法和静态方法）。</li></ul><p>特点：</p><ul><li>抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。</li><li>接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。适用于定义类的能力或功能</li></ul><p>区别：</p><ul><li>实现方式：实现接口的关键字为 implements，继承抽象类的关键字为 extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li><li>方法方式：接口只有定义，不能有方法的实现，java 1.8 中可以定义 default 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</li><li>访问修饰符：接口成员变量默认为 public static final，必须赋初值，不能被修改；其所有的成员方法都是 public、abstract 的。抽象类中成员变量默认 default，可在子类中被重新定义，也可被重新赋值；抽象方法被 abstract 修饰，不能被 private、static、synchronized 和 native 等修饰，必须以分号结尾，不带花括号。</li><li>变量：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态常量）。</li></ul><h3 id="抽象类可以被实例化吗"><a class="markdownIt-Anchor" href="#抽象类可以被实例化吗"></a> 抽象类可以被实例化吗？</h3><p>答：抽象类不能被实例化，通常由子类继承实现。<strong>抽象类中可以有构造方法</strong>，但是构造方法实例化的是子类对象。接口没有构造方法。</p><h3 id="java深拷贝的方式有哪些"><a class="markdownIt-Anchor" href="#java深拷贝的方式有哪些"></a> Java深拷贝的方式有哪些？</h3><ul><li>实现Cloneable接口，重写clone()方法</li><li>使用序列化和反序列化</li><li>手动递归复制</li></ul><h2 id="java中的对象"><a class="markdownIt-Anchor" href="#java中的对象"></a> Java中的对象</h2><h3 id="java中创建对象有哪些方式"><a class="markdownIt-Anchor" href="#java中创建对象有哪些方式"></a> Java中创建对象有哪些方式？</h3><ul><li>使用new关键字:通过new关键字直接调用类的构造方法来创建对象。</li></ul><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">MyClass</span> obj = <span class="hljs-built_in">new</span> <span class="hljs-keyword">MyClass</span>();<br></code></pre></td></tr></table></figure><ul><li>使用Class类的newInstance()方法:通过反射机制调用newInstance()方法来创建对象。</li></ul><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">MyClass</span> obj = (<span class="hljs-keyword">MyClass</span>) <span class="hljs-keyword">Class</span>.forName(<span class="hljs-string">&quot;com.example.MyClass&quot;</span>).newInstance();<br></code></pre></td></tr></table></figure><ul><li>使用Constructor类的newInstance()方法：同样通过反射机制调用Constructor类的newInstance()方法来创建对象。</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;<span class="hljs-title">MyClass</span>&gt; <span class="hljs-title">constructor</span> = <span class="hljs-title">MyClass</span>.<span class="hljs-title">class</span>.<span class="hljs-title">getConstructor</span><span class="hljs-params">()</span>;</span><br>MyClass obj = <span class="hljs-keyword">constructor</span>.newInstance();<br></code></pre></td></tr></table></figure><ul><li>使用clone()方法：如果类实现了Cloneable接口，可以使用clone()方法复制对象。</li></ul><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">MyClass</span> obj1 = <span class="hljs-built_in">new</span> <span class="hljs-keyword">MyClass</span>();<br><span class="hljs-keyword">MyClass</span> obj2 = (<span class="hljs-keyword">MyClass</span>) obj1.clone();<br></code></pre></td></tr></table></figure><ul><li>使用反序列化</li></ul><h3 id="new的对象什么时候回收"><a class="markdownIt-Anchor" href="#new的对象什么时候回收"></a> new的对象什么时候回收？</h3><p>主要由GC回收，分为以下几种情况：</p><ol><li>引用计数法：某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。</li><li>可达性分析算法：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。</li><li>终结器（Finalizer）：如果对象重写了finalize()方法，垃圾回收器会在回收该对象之前调用finalize()方法，对象可以在finalize()方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。</li></ol><h2 id="反射机制"><a class="markdownIt-Anchor" href="#反射机制"></a> 反射机制</h2><h3 id="什么是反射机制"><a class="markdownIt-Anchor" href="#什么是反射机制"></a> 什么是反射机制？</h3><p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；<br />对于任意一个对象，都能够调用它的任意一个方法和属性；<br />这种<strong>动态获取的信息以及动态调用对象的方法</strong>的功能称为 Java 语言的反射机制。</p><p>反射具有以下特性：</p><ul><li>运行时类信息访问：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。</li><li>动态对象创建：可以使用反射 API 动态地创建对象实例，即使在编译时不知道具体的类名。这是通过 Class 类的 newInstance() 方法或 Constructor 对象的 newInstance() 方法实现的。</li><li>动态方法调用：可以在运行时动态地调用对象的方法，包括私有方法。这通过 Method 类的 invoke() 方法实现，允许你传入对象实例和参数值来执行方法。</li><li>访问和修改字段值：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过 Field 类的 get() 和 set() 方法完成的。</li></ul><h3 id="反射在你平时写代码或者框架中的应用场景有哪些"><a class="markdownIt-Anchor" href="#反射在你平时写代码或者框架中的应用场景有哪些"></a> 反射在你平时写代码或者框架中的应用场景有哪些?</h3><ol><li>加载数据库驱动</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置文件加载<br />Spring 通过 XML 配置模式装载 Bean 的过程：</li></ol><ul><li>将程序中所有 XML 或 properties 配置文件加载入内存</li><li>Java 类里面解析 xml 或者 properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</li><li>使用反射机制，根据这个字符串获得某个类的 Class 实例</li><li>动态配置实例的属性</li></ul><h2 id="java注解的原理"><a class="markdownIt-Anchor" href="#java注解的原理"></a> Java注解的原理</h2><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。</p><p>我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。<br />通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。<br />该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p><h2 id="与-equals-有什么区别"><a class="markdownIt-Anchor" href="#与-equals-有什么区别"></a> == 与 equals 有什么区别？</h2><p>==对于基本数据类型和引用类型有不同的作用：</p><ul><li>对于基本数据类型，==比较的是值是否相等。</li><li>对于引用类型，==比较的是对象的内存地址</li></ul><p>equals不能比较基本数据类型，只能用来判断两个对象是否相等</p><ul><li>当类没有重写equals方法时，equals方法比较的是两个对象的内存地址</li><li>当类重写了equals方法时，equals方法一般比较的是两个对象的属性是否相等</li></ul><p>一般String类、Integer类等都重写了equals方法，比较的是对象的属性是否相等。</p><h2 id="stringbuffer和stringbuilder区别是什么"><a class="markdownIt-Anchor" href="#stringbuffer和stringbuilder区别是什么"></a> StringBuffer和StringBuilder区别是什么？</h2><p>区别：</p><ul><li>String 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以<strong>拼接字符串时会产生很多无用的中间对象，如果频繁地进行这样的操作对性能有所影响</strong>。</li><li>StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个<strong>线程安全</strong>的可修改的字符序列。在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。</li><li>StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是<strong>去掉了保证线程安全</strong>的那部分，减少了开销。</li></ul><blockquote><p>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。</p></blockquote><h2 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h2><h3 id="线程安全体现在哪些方面"><a class="markdownIt-Anchor" href="#线程安全体现在哪些方面"></a> 线程安全体现在哪些方面？</h3><ul><li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作；</li><li>可见性：一个线程对主内存的修改可以及时地被其他线程看到；</li><li>有序性：保证线程按照代码顺序执行。</li></ul><h3 id="什么是cas操作"><a class="markdownIt-Anchor" href="#什么是cas操作"></a> 什么是CAS操作？</h3><p>CAS叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：</p><ul><li>V：要更新的值</li><li>A：预期值</li><li>B：新值<br />当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。</li></ul><h3 id="cas的缺点"><a class="markdownIt-Anchor" href="#cas的缺点"></a> CAS的缺点？</h3><ul><li>ABA问题：如果一个值原来是A，准备修改前短暂变成了B，然后又变成了A，那么CAS操作会错误地认为这个值没有发生变化；解决方法是加入预期标志和更新后标志，更新时不光检查值，还要检查标志是否相等。</li><li>循环时间长开销大：CAS操作如果长时间不成功，会一直自旋，占用CPU，降低性能。</li><li>只能保证一个共享变量的原子操作：对多个共享变量操作时，需要加锁。</li></ul><h3 id="线程创建方式有哪些"><a class="markdownIt-Anchor" href="#线程创建方式有哪些"></a> 线程创建方式有哪些？</h3><ul><li>继承 Thread 类</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    public void run()&#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;MyThread run&quot;</span>);<br>    &#125;<br>&#125;<br><br>public static void main(<span class="hljs-type">String</span>[] args) &#123;<br>    <span class="hljs-type">MyThread</span> t=<span class="hljs-keyword">new</span> <span class="hljs-type">MyThread</span>();<br>    t.start();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现 Runnable 接口</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;MyRunnable run&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)&#123;<br>    <span class="hljs-title class_">Thread</span> t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>    t.<span class="hljs-title function_">start</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现Callable接口与FutureTask</li><li>使用线程池</li></ul><h3 id="如何停止线程"><a class="markdownIt-Anchor" href="#如何停止线程"></a> 如何停止线程？</h3><ul><li>通过退出标志位，让线程正常退出</li><li>stop()暴力停止</li><li>使用interrupt()方法中断线程<ul><li>如果打断阻塞的线程(sleep,wait,join)，会抛出InterruptedException异常</li><li>如果打断正常线程，会根据中断标记为判断是否退出</li></ul></li></ul><h3 id="sleep和wait的区别"><a class="markdownIt-Anchor" href="#sleep和wait的区别"></a> sleep和wait的区别？</h3><ul><li>sleep是Thread类的静态方法，wait是Object类的方法</li><li>sleep方法不会释放锁，wait方法会释放锁</li><li>sleep方法可以在任何地方调用，wait方法只能在同步方法或同步块中调用</li><li>sleep方法在指定时间后自动唤醒或通过interrupt中断，wait方法需要其他线程调用notify或notifyAll方法唤醒</li></ul><h3 id="线程的状态有哪些"><a class="markdownIt-Anchor" href="#线程的状态有哪些"></a> 线程的状态有哪些？</h3><ul><li>NEW：新创建的线程，还未执行</li><li>RUNNABLE：就绪和正在执行的线程</li><li>BLOCKED：阻塞状态，等待锁的释放</li><li>WAITING：等待状态，等待其他线程的通知</li><li>TIMED_WAITING：具有指定等待时间的等待状态</li><li>TERMINATED：线程执行完毕</li></ul><h3 id="blocked和waiting的区别"><a class="markdownIt-Anchor" href="#blocked和waiting的区别"></a> blocked和waiting的区别？</h3><ul><li>blocked 一般是因为获取锁失败，在等待其他线程释放锁后，会重新进入runnable状态</li><li>waiting 状态不参与锁的竞争，而是在等待其他线程的通知，比如调用wait()方法，join()方法，或者LockSupport.park()方法，不会占用CPU资源，当其他线程调用notify()方法后，会重新进入runnable状态</li></ul><h3 id="notify和notifyall的区别"><a class="markdownIt-Anchor" href="#notify和notifyall的区别"></a> notify和notifyAll的区别？</h3><ul><li>notify()方法会随机唤醒一个处于waitting的线程，其他线程仍然处于waiting状态。</li><li>notifyAll()方法会唤醒所有waitting的线程，让他们开始竞争锁</li></ul><h3 id="写一段代码实现线程交替打印奇偶数"><a class="markdownIt-Anchor" href="#写一段代码实现线程交替打印奇偶数"></a> 写一段代码，实现线程交替打印奇偶数</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PrintEvenOdd</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> cnt=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final Object <span class="hljs-keyword">lock</span>=<span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-built_in">int</span> MX=<span class="hljs-number">100</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>&#123;<br>        Runnable printOdd=()-&gt;&#123;<br>            synchronized(<span class="hljs-keyword">lock</span>)&#123;<br>                    <span class="hljs-keyword">while</span>(cnt&lt;=MX)&#123;<br>                    <span class="hljs-keyword">if</span>(cnt%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)&#123;<br>                        System.<span class="hljs-keyword">out</span>.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+cnt++);<br>                        <span class="hljs-keyword">lock</span>.notify();<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">try</span>&#123;<br>                            <span class="hljs-keyword">lock</span>.wait();<br>                        &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;     <br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        Runnable printEven=()-&gt;&#123;<br>            synchronized(<span class="hljs-keyword">lock</span>)&#123;<br>                <span class="hljs-keyword">while</span>(cnt&lt;=MX)&#123;<br>                    <span class="hljs-keyword">if</span>(cnt%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                        System.<span class="hljs-keyword">out</span>.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+cnt++);<br>                        <span class="hljs-keyword">lock</span>.notify();<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">try</span>&#123;<br>                            <span class="hljs-keyword">lock</span>.wait();<br>                        &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        Thread t1=<span class="hljs-keyword">new</span> Thread(printOdd,<span class="hljs-string">&quot;奇数线程&quot;</span>);<br>        Thread t2=<span class="hljs-keyword">new</span> Thread(printEven,<span class="hljs-string">&quot;偶数线程&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>任意线程数顺序打印：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> threadNum = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final Lock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final Condition condition = <span class="hljs-keyword">lock</span>.newCondition();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-title">implements</span> <span class="hljs-title">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> id;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span> &#123;<br>            <span class="hljs-keyword">this</span>.id = id;<br>        &#125;<br><br>        @Override<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (cnt &lt; <span class="hljs-number">100</span> &amp;&amp; cnt % threadNum != id) &#123;<br>                        condition.<span class="hljs-keyword">await</span>();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (cnt &gt;= <span class="hljs-number">100</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    ++cnt;<br>                    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Thread &quot;</span> + id + <span class="hljs-string">&quot; : &quot;</span> + cnt);<br>                    condition.signalAll();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">lock</span>.unlock();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = threadNum - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread(i));<br>            t.start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="怎么保证多线程安全"><a class="markdownIt-Anchor" href="#怎么保证多线程安全"></a> 怎么保证多线程安全？</h3><ul><li>使用synchronized关键字，保证同一时刻只有一个线程访问共享资源</li><li>使用volatile关键字，保证变量的可见性</li><li>使用Lock接口，比如ReentrantLock类就是Lock接口的一个实现</li><li>使用原子类，比如AtomicInteger类</li><li>使用TreadLocal</li><li>使用线程安全的集合类，比如ConcurrentHashMap、CopyOnWriteArrayList等</li></ul><h3 id="java中有哪些常用的锁使用场景是什么"><a class="markdownIt-Anchor" href="#java中有哪些常用的锁使用场景是什么"></a> java中有哪些常用的锁？使用场景是什么？</h3><ul><li>synchronized：用于修饰代码块或方法，保证同一时刻只有一个线程访问共享资源。</li><li>ReentrantLock：是Lock接口的一个实现，提供了更多的功能，比如可以设置超时时间、中断等待锁的线程、公平锁等。</li><li>读写锁：允许多个线程读，但只允许一个线程写，适用于读多写少的场景。</li><li>乐观锁和悲观锁：乐观锁不锁定资源，<strong>只在写数据时</strong>检查资源是否被其他线程修改；悲观锁在访问数据时会锁定资源，总是假设最坏的情况。</li><li>自旋锁：未获取到锁时线程不会放弃CPU资源，而是一直循环检查锁是否可用，直到获取到锁，通常用CAS实现。</li></ul><h3 id="什么是公平锁和非公平锁"><a class="markdownIt-Anchor" href="#什么是公平锁和非公平锁"></a> 什么是公平锁和非公平锁？</h3><ul><li>公平锁：按照线程请求的顺序来获取锁，先到先得，整体执行速度慢，吞吐量小，因为涉及线程从休眠到运行状态的转换。</li><li>非公平锁：多个线程争抢锁，整体执行速度快，吞吐量大。</li></ul><h3 id="讲讲reentrantlock"><a class="markdownIt-Anchor" href="#讲讲reentrantlock"></a> 讲讲ReentrantLock？</h3><p>ReentrantLock底层主要依赖AQS抽象类，AQS提供了一些基本的同步机制如队列、状态等。ReentrantLock具有以下特性：</p><ul><li>可中断：线程在等待锁的过程中，可以被其他线程中断而提前结束等待。</li><li>设置超时时间：尝试获取锁时，可以设置超时时间，超过时间后自动放弃等待。</li><li>公平锁和非公平锁：ReentrantLock默认是非公平锁，可以通过传入true参数创建公平锁。如<code>ReentrantLock lock=new ReentrantLock(true);</code></li><li>支持多个条件变量，可以更灵活的执行等待与唤醒操作。主要通过Condition接口实现。</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ReentrantLock lock<span class="hljs-operator">=</span>new ReentrantLock()<span class="hljs-comment">;</span><br>Condition condition<span class="hljs-operator">=</span>lock.newCondition()<span class="hljs-comment">;</span><br>//等待与唤醒<br>condition.await()<span class="hljs-comment">;</span><br>condition.signal()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>支持可重入性，同一个线程可以多次获取同一把锁，不会造成死锁。每次获取锁时，holdCount递增，释放锁时递减，当holdCount为0时，其他线程才能获取锁。</li></ul><h3 id="synchronized和reentrantlock的的应用场景有什么不同"><a class="markdownIt-Anchor" href="#synchronized和reentrantlock的的应用场景有什么不同"></a> synchronized和ReentrantLock的的应用场景有什么不同？</h3><ul><li>synchronized适合简单的同步场景，代码块或方法级别的同步，使用方便，但功能有限。</li><li>ReentrantLock适合复杂同步的场景，提供了一些高级功能，如可中断、超时、公平锁、多条件变量等。</li></ul><h3 id="synchronized和reentrantlock的区别"><a class="markdownIt-Anchor" href="#synchronized和reentrantlock的区别"></a> synchronized和ReentrantLock的区别？</h3><ul><li>synchronized可修饰代码块和方法，ReentrantLock只能修饰代码块</li><li>synchronized可以自动加锁和释放锁，ReentrantLock需要手动加锁和释放锁</li><li>前者只能是非公平锁，后者可以是公平锁或非公平锁</li><li>前者不能响应中断，后者可以响应中断</li><li>synchronized是JVM层面通过监视器实现的锁，ReentrantLock是基于AQS实现的锁</li></ul><h3 id="介绍一下aqs"><a class="markdownIt-Anchor" href="#介绍一下aqs"></a> 介绍一下AQS?</h3><p>答：AQS是Java中的一个抽象类，提供了一些基本的锁机制，AQS的核心思想是：</p><ul><li>如果被请求的资源空闲，就将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态；</li><li>如果被请求的资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制是通过内部的双向队列来实现的。</li></ul><p>工作机制：<br />AQS内部有一个state，被volatile修饰，0表示无锁，1表示有锁</p><ul><li>当一个线程到来时，他会尝试将state改为1，表示获取到了资源</li><li>如果state已经为1了，他会被放入一个双向队列，排队等待锁的分配</li><li>如果多个线程同时抢夺资源，为了保证原子性，修改state要用CAS操作</li></ul><p>AQS是公平锁还是非公平锁？<br />都有</p><ul><li>如果新的线程与队列头部的线程争抢资源，那么属于非公平锁</li><li>如果由于state为1,新线程放入到队列中等待，那么属于公平锁</li></ul><h3 id="volatile关键字的作用"><a class="markdownIt-Anchor" href="#volatile关键字的作用"></a> volatile关键字的作用？</h3><ul><li>保证变量对所有线程的可见性</li><li>禁止指令重排序</li></ul><p>指令重排序是编译器为了提升指令执行效率而做的优化，一般需要两个条件：</p><ul><li>单线程下不会改变程序执行结果</li><li>重排序的指令不存在数据的相互依赖</li></ul><h3 id="死锁产生的条件"><a class="markdownIt-Anchor" href="#死锁产生的条件"></a> 死锁产生的条件？</h3><ul><li>互斥条件：多个线程不能同时使用同一资源</li><li>持有和等待条件：线程持有资源，同时等待其他线程持有的资源</li><li>不可剥夺条件：线程持有的资源在使用完之前不能被其他线程抢占</li><li>循环等待条件：多个线程形成循环等待资源的关系</li></ul><h3 id="线程池的提交任务流程"><a class="markdownIt-Anchor" href="#线程池的提交任务流程"></a> 线程池的提交任务流程？</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clean">提交任务 -&gt; 核心线程是否已满？<br><br>├── 未满 -&gt; 创建核心线程执行<br><br>└── 已满 -&gt; 任务入队<br><br>    ├── 队列未满 -&gt; 等待执行<br><br>    └── 队列已满 -&gt; 创建非核心线程<br><br>        ├── 未达最大线程数 -&gt; 执行任务<br><br>        └── 已达最大线程数 -&gt; 执行拒绝策略<br><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：核心线程并不是在线程池创建的时候直接创建等于核心线程数量的线程，而是采用懒加载的模式，在线程池提交任务时逐步创建，如果新任务提交时，线程数未达到核心线程数，那么即使其他线程空闲，也会创建新的核心线程来执行任务。</p><h3 id="线程池的参数有哪些"><a class="markdownIt-Anchor" href="#线程池的参数有哪些"></a> 线程池的参数有哪些？</h3><ul><li>corePoolSize：核心线程数，线程池中一直存活的线程数量</li><li>maximumPoolSize：最大线程数，线程池中最大的线程数量</li><li>keepAliveTime：线程空闲时间，超过这个时间，多余的线程会被回收</li><li>unit：时间单位</li><li>workQueue：工作队列，存放等待执行的任务</li></ul><h3 id="线程池的拒绝策略有哪些"><a class="markdownIt-Anchor" href="#线程池的拒绝策略有哪些"></a> 线程池的拒绝策略有哪些？</h3><ul><li>CallerRunsPolicy：使用线程池的调用者所在线程去执行对应任务</li><li>AbortPolicy：拒绝并抛出异常</li><li>DiscardPolicy：不做任何处理，直接拒绝</li><li>DiscardOldestPolicy：抛弃最老的任务执行该任务。</li><li>自定义策略</li></ul><h3 id="核心线程数如何设置"><a class="markdownIt-Anchor" href="#核心线程数如何设置"></a> 核心线程数如何设置？</h3><ul><li>对于高并发，执行时间短的任务，核心线程数设置为CPU核心数+1</li><li>对于并发不高，执行时间长的任务<ul><li>CPU密集型任务：核心线程数设置为CPU核心数+1</li><li>IO密集型任务：核心线程数设置为CPU核心数*2</li></ul></li><li>对于高并发，执行时间长的任务，首先要看数据能不能做缓存，其次看能不能增加服务器</li></ul><h3 id="线程池种类有哪些"><a class="markdownIt-Anchor" href="#线程池种类有哪些"></a> 线程池种类有哪些？</h3><ul><li>ScheduledThreadPool：支持定时和周期性执行任务</li><li>FixedThreadPool：核心线程数和最大线程数相等，最大线程数满了后会进入队列等待</li><li>CachedThreadPool：核心线程数为0，最大线程数为Integer.MAX_VALUE，适用于执行大量短期异步任务</li><li>SingleThreadPool：只有一个核心线程，确保所有任务按照指定顺序执行</li></ul><h3 id="线程池的阻塞队列有哪些"><a class="markdownIt-Anchor" href="#线程池的阻塞队列有哪些"></a> 线程池的阻塞队列有哪些？</h3><ul><li>ArrayBlockingQueue，有界队列，容量固定</li><li>LinkedBlockingQueue，无界队列，容量无上限，适用于FixedThreadPool和SingleThreadPool</li><li>SynchronousQueue，同步队列，容量为0，CachedThreadPool使用的队列</li><li>PriorityBlockingQueue，支持优先级的无界阻塞队列。队列中的元素会根据其自然顺序或在构造时提供的 Comparator 进行排序，优先级高的元素会先被执行</li></ul><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">SynchronousQueue (直接提交队列)</th><th style="text-align:left">LinkedBlockingQueue (链表阻塞队列)</th><th style="text-align:left">ArrayBlockingQueue (数组阻塞队列)</th><th style="text-align:left">PriorityBlockingQueue (优先级队列)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>数据结构</strong></td><td style="text-align:left">-</td><td style="text-align:left">链表</td><td style="text-align:left">数组</td><td style="text-align:left">堆 (Heap)</td></tr><tr><td style="text-align:left"><strong>容量</strong></td><td style="text-align:left"><strong>0 (零容量)</strong>，不存储任何元素。</td><td style="text-align:left"><strong>无界 (默认)</strong> 或 <strong>有界</strong>。默认容量为 <code>Integer.MAX_VALUE</code>。</td><td style="text-align:left"><strong>有界</strong>，必须在创建时指定容量。</td><td style="text-align:left"><strong>无界</strong>，容量理论上为 <code>Integer.MAX_VALUE</code>。</td></tr><tr><td style="text-align:left"><strong>排序方式</strong></td><td style="text-align:left">直接提交，无排序。</td><td style="text-align:left"><strong>FIFO</strong> (先进先出)。</td><td style="text-align:left"><strong>FIFO</strong> (先进先出)。</td><td style="text-align:left"><strong>按优先级</strong>，由任务的自然顺序或 <code>Comparator</code> 决定。</td></tr><tr><td style="text-align:left"><strong>工作机制</strong></td><td style="text-align:left">任务直接交给空闲线程。若无空闲线程，则尝试创建新线程（直到<code>maximumPoolSize</code>），否则任务被拒绝。</td><td style="text-align:left"><strong>[无界时]</strong> 核心线程满后，任务会无限加入队列，<code>maximumPoolSize</code> 参数失效。</td><td style="text-align:left">核心线程满后，任务进入队列。队列满后，创建新线程（直到<code>maximumPoolSize</code>），否则任务被拒绝。</td><td style="text-align:left">核心线程满后，任务按优先级加入队列，<code>maximumPoolSize</code> 参数失效。</td></tr><tr><td style="text-align:left"><strong>适用场景</strong></td><td style="text-align:left">吞吐量高，处理大量<strong>短时</strong>任务的场景。要求系统响应快，能快速处理任务。</td><td style="text-align:left">任务量不确定，不希望任务被拒绝的场景。适用于<strong>任务突发</strong>的情况。</td><td style="text-align:left">需要精确控制资源（线程数、任务数），防止系统过载的场景。</td><td style="text-align:left">任务具有不同优先级，需要优先执行<strong>重要任务</strong>的场景。</td></tr><tr><td style="text-align:left"><strong>风险/注意事项</strong></td><td style="text-align:left"><code>maximumPoolSize</code> 需设置得很大（如 <code>Integer.MAX_VALUE</code>），否则任务极易被拒绝。</td><td style="text-align:left"><strong>[无界时]</strong> 任务可能大量堆积，导致<strong>内存溢出 (OOM)</strong>。</td><td style="text-align:left">队列容量和 <code>maximumPoolSize</code> 的设置需仔细权衡，不合理会降低吞吐量或频繁拒绝任务。</td><td style="text-align:left">同样存在<strong>内存溢出 (OOM)</strong> 的风险。任务优先级设置不当可能导致低优先级任务<strong>饥饿</strong>。</td></tr></tbody></table><h3 id="多线程顺序执行的几种写法"><a class="markdownIt-Anchor" href="#多线程顺序执行的几种写法"></a> 多线程顺序执行的几种写法?</h3><ul><li>使用join方法，join方法会阻塞当前线程，等待调用join方法的线程执行完毕，类似于让调用join方法的线程“插队”。</li><li>使用线程池，将核心线程数和最大线程数都设置为1，然后按顺序提交任务。</li><li>使用wait()和notify，创建两个lock，分别是lock1和lock2，线程1和线程2共用lock1,线程2和线程3共用lock2。实现如下：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintOrder</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">Object</span> lock1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">Object</span> lock2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-title class_">String</span> name;<br>        <span class="hljs-title class_">Object</span> preLock;<br>        <span class="hljs-title class_">Object</span> postLock;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-title class_">String</span> name,<span class="hljs-title class_">Object</span> preLock, <span class="hljs-title class_">Object</span> postLock)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">preLock</span>=preLock;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">postLock</span>=postLock;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">if</span>(preLock!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">preLock</span>)&#123;<br>                    preLock.<span class="hljs-title function_">wait</span>();<br>                &#125;<br>            &#125;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(name+<span class="hljs-string">&quot;执行&quot;</span>);<br>            <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">if</span>(postLock!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">postLock</span>)&#123;<br>                    postLock.<span class="hljs-title function_">notify</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)&#123;<br>        <span class="hljs-title class_">Thread</span> t1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程1&quot;</span>,<span class="hljs-literal">null</span>,lock1));<br>        <span class="hljs-title class_">Thread</span> t2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程2&quot;</span>,lock1,lock2));<br>        <span class="hljs-title class_">Thread</span> t3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程3&quot;</span>,lock2,<span class="hljs-literal">null</span>));<br>        t2.<span class="hljs-title function_">start</span>();<br>        t1.<span class="hljs-title function_">start</span>();<br>        t3.<span class="hljs-title function_">start</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用countDownLatch，通过await()方法阻塞线程，通过countDown()方法将计数器减1。实现方式和wait()和notify()类似，把wait()换成了await()，把notify()换成了countdown()。</li></ul><h3 id="线程池中shutdown和shutdownnow的区别"><a class="markdownIt-Anchor" href="#线程池中shutdown和shutdownnow的区别"></a> 线程池中shutdown和shutdownNow的区别？</h3><ul><li>shutdown会将状态置为SHUTDOWN状态，正在执行的任务会继续执行，无法向线程池添加新任务。</li><li>shutdownNow会将状态置为STOP状态，会尝试中断正在执行的任务。</li></ul><h3 id="提交给线程池的任务可以被撤回吗"><a class="markdownIt-Anchor" href="#提交给线程池的任务可以被撤回吗"></a> 提交给线程池的任务可以被撤回吗？</h3><p>答：可以。向线程池提交任务后，会返回一个Future对象，通过Future对象的cancel()方法可以取消任务的执行。</p><h3 id="线程池用到了哪些设计模式"><a class="markdownIt-Anchor" href="#线程池用到了哪些设计模式"></a> 线程池用到了哪些设计模式？</h3><ul><li>工厂模式：创建线程会用到</li><li>策略模式：包含多种拒绝策略</li><li>单例模式：线程池一般是单例的</li><li>模板方法模式：runWorker()方法定义了工作线程执行任务的核心逻辑骨架</li></ul><h3 id="threadlocal为什么会发生内存泄漏"><a class="markdownIt-Anchor" href="#threadlocal为什么会发生内存泄漏"></a> ThreadLocal为什么会发生内存泄漏？</h3><p>ThreadLocalMap的键为ThreadLocal的弱引用，而值是强引用。如果ThreadLocal对象被回收，其对应的Entry键会变为null，如果此时不删除对应的Entry，则Value仍然被Thread上的ThreadLocalMap引用，而Value往往占用较大内存，这就会导致内存泄漏。</p><p>为了解决这个问题，ThreadLocal在调用set、get、remove方法时，会清理掉ThreadLocalMap中所有键为null的Entry。但如果没有调用这些方法，那么清理工作就不会进行，从而可能导致内存泄漏。</p><h3 id="threadlocal的继承性问题以及解决方法"><a class="markdownIt-Anchor" href="#threadlocal的继承性问题以及解决方法"></a> ThreadLocal的继承性问题以及解决方法？</h3><ul><li>同一个ThreadLocal变量在父线程中设置值，在子线程中获取不到值。</li><li>解决方法：使用InheritableThreadLocal类，它是ThreadLocal的子类，可以在子线程中获取父线程中设置的值。</li></ul><h3 id="completablefuture怎么用"><a class="markdownIt-Anchor" href="#completablefuture怎么用"></a> CompletableFuture怎么用？</h3><p>CompletableFuture相比Future，优势就在于可以灵活的编排异步任务</p><blockquote><p>创建CompletableFuture对象</p></blockquote><ul><li>runAsync：不关心返回结果时使用</li><li>（常用）supplyAsync：关心返回结果时使用，例如</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">CompletableFuture&lt;<span class="hljs-built_in">String</span>&gt; future2 = CompletableFuture.supplyAsync(<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-string">&quot;hello!&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>获取结果后进一步处理</p></blockquote><ul><li>thenApply：从回调函数中获取结果后进一步处理</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">CompletableFuture&lt;<span class="hljs-type">String</span>&gt; future = CompletableFuture.<span class="hljs-built_in">completedFuture</span>(<span class="hljs-string">&quot;hello!&quot;</span>)<br>        .<span class="hljs-built_in">thenApply</span>(s -&gt; s + <span class="hljs-string">&quot;world!&quot;</span>).<span class="hljs-built_in">thenApply</span>(s -&gt; s + <span class="hljs-string">&quot;nice!&quot;</span>);<br><span class="hljs-built_in">assertEquals</span>(<span class="hljs-string">&quot;hello!world!nice!&quot;</span>, future.<span class="hljs-built_in">get</span>());<br></code></pre></td></tr></table></figure><ul><li>thenAccept: 不需要从回调函数中获取回调结果, 可以访问异步计算结果</li><li>thenRun: 不需要从回调函数中获取回调结果, 不能访问异步计算结果</li></ul><blockquote><p>组合多个CompletableFuture</p></blockquote><ul><li>thenCombine: 将两个任务的结果组合在一起，两个任务之间没有先后顺序。</li><li>thenCompose: 将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。</li></ul><blockquote><p>并行运行多个任务</p></blockquote><ul><li>allOf: 等待所有任务完成再返回</li><li>anyOf: 等待任意一个任务完成就返回</li></ul><h2 id="mybatis"><a class="markdownIt-Anchor" href="#mybatis"></a> MyBatis</h2><h3 id="mybatis中和的区别"><a class="markdownIt-Anchor" href="#mybatis中和的区别"></a> MyBatis中#{}和${}的区别？</h3><ul><li><code>#&#123;&#125;：预编译处理，会将#&#123;&#125;替换为?，然后使用PreparedStatement的set方法设置参数，可以防止SQL注入。</code></li><li><code>$&#123;&#125;：字符串替换，会将$&#123;&#125;替换为实际的值，存在SQL注入的风险。</code></li><li><code>#&#123;&#125;不用加单引号，$&#123;&#125;需要加单引号</code></li></ul><h3 id="mybatis的延迟加载及其原理"><a class="markdownIt-Anchor" href="#mybatis的延迟加载及其原理"></a> MyBatis的延迟加载及其原理？</h3><p>延迟加载指的是查询数据时，需要用到数据时才加载，不需要用到数据时就不加载，可以在配置文件中配置</p><p>原理：</p><ul><li>通过cglib动态代理实现</li><li>调用目标方法时，实际上调用invoke方法，当发现目标值为null，就去执行sql查询</li></ul><h3 id="mybatis的一级缓存和二级缓存的区别"><a class="markdownIt-Anchor" href="#mybatis的一级缓存和二级缓存的区别"></a> MyBatis的一级缓存和二级缓存的区别？</h3><p>MyBatis的一级二级缓存都是本地缓存，都是基于HashMap的</p><ul><li>一级缓存：SqlSession级别的缓存，默认开启，存储在SqlSession中，SqlSession关闭后缓存失效</li><li>二级缓存：Mapper级别的缓存，默认关闭，存储在SqlSessionFactory中，SqlSession关闭后缓存不失效</li></ul><p>二级缓存什么时候清除缓存中的数据呢？</p><ul><li>当某个作用域进行了增删改操作时，清除该作用域的缓存</li></ul><h2 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MYSQL</h2><h3 id="sql注入是什么举个例子"><a class="markdownIt-Anchor" href="#sql注入是什么举个例子"></a> SQL注入是什么？举个例子？</h3><p>指的是攻击者通过恶意构造输入参数，使得正常SQL语句被修改</p><p>例如<code>SELECT * FROM Users WHERE Username = '' AND Password = '' OR '' = ''</code><br />由于<code>&quot;=&quot;</code>永远为真，所以这个SQL语句会返回所有的用户信息</p><h3 id="mysql的事务隔离级别"><a class="markdownIt-Anchor" href="#mysql的事务隔离级别"></a> mysql的事务隔离级别</h3><h4 id="事务的四个特性"><a class="markdownIt-Anchor" href="#事务的四个特性"></a> 事务的四个特性</h4><ul><li>原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另一个一致性状态。</li><li>隔离性（Isolation）：一个事务的执行不能被其他事务干扰。</li><li>持久性（Durability）：事务一旦提交，它对数据库的改变就应该是永久性的。</li></ul><h4 id="事务隔离解决的问题"><a class="markdownIt-Anchor" href="#事务隔离解决的问题"></a> 事务隔离解决的问题</h4><ul><li>脏读：一个事务读取到另一个事务未提交的数据，读到了最终可能不存在的数据</li><li>可重复读：同一事务中多次读取同一数据时，结果是一致的，即使其他事务修改了该数据，当前事务仍然看到最初读取的值</li><li>不可重复读：同一事务在不同的时刻读到的同一批数据可能是不一样的，比如其他事务改了这批数据并提交了（针对update）</li><li>幻读：同一事务在不同的时刻读到的同一批数据可能多了或者少了，比如其他事务插入了一些数据并提交了（针对insert）</li></ul><h4 id="事务隔离级别"><a class="markdownIt-Anchor" href="#事务隔离级别"></a> 事务隔离级别</h4><p>mysql中有四种事务隔离级别，级别由低到高分别是：</p><ul><li>读未提交（Read Uncommitted）：允许脏读，一个事务还没提交时，另一个事务就可以看到它做的变更，存在脏读、不可重复读、幻读的问题</li><li>读提交（Read Committed）：只能读取已经提交的数据，可以避免脏读，但是不可重复读和幻读仍然存在</li><li>可重复读（Repeatable Read）：对同一字段的多次读取结果是一致的，除非数据被当前事务自己改变，可以避免脏读和不可重复读，但幻读仍然存在</li><li>串行化（Serializable）：最高的隔离级别，所有事务依次执行，可以避免脏读、不可重复读、幻读</li></ul><h3 id="mysql具体怎么解决脏读-不可重复读-幻读的"><a class="markdownIt-Anchor" href="#mysql具体怎么解决脏读-不可重复读-幻读的"></a> MYSQL具体怎么解决脏读、不可重复读、幻读的？</h3><ul><li>脏读：可以通过select for update ,加独占锁（排他锁）解决，事务提交前，会一直持有排他锁。通常通过MVCC实现，读提交隔离级别下，每次读数据时，都会生产一个ReadView，只能看到已经提交的数据版本</li><li>不可重复读：也是基于MVCC，可重复读隔离级别下，第一次读数据时，会产生一个ReadView，意味着事务后续的读操作只能看到第一次读到的数据版本</li><li>幻读：对读取的数据加共享锁，然后通过间隙锁，防止在某个范围内插入数据</li></ul><h3 id="默认的可重复读隔离级别下为什么还会发生幻读"><a class="markdownIt-Anchor" href="#默认的可重复读隔离级别下为什么还会发生幻读"></a> 默认的可重复读隔离级别下，为什么还会发生幻读？</h3><p>可重复读隔离级别下，可以通过当前读（加锁）或者快照读（不加锁）两种方式防止幻读。</p><p>但是，当快照读和当前读混合使用时，就会发生幻读，比如先进行了快照读，然后进行了当前读时，就会发生幻读。</p><p>所以，为了彻底防止幻读，建议事务一开始就使用当前读。</p><h3 id="事务的四个特性是如何实现的"><a class="markdownIt-Anchor" href="#事务的四个特性是如何实现的"></a> 事务的四个特性是如何实现的？</h3><ul><li>原子性：通过undo log实现，事务回滚时，通过undo log将数据恢复到事务开始之前的状态</li><li>持久性：通过redo log实现，事务提交时，将redo log写入磁盘，保证事务的持久性</li><li>隔离性：通过MVCC实现，每个事务都有自己的版本号，读取数据时，只能读取版本号小于等于当前事务版本号的数据</li><li>持久性: 通过原子性+持久性+隔离性实现</li></ul><h3 id="讲讲mvcc"><a class="markdownIt-Anchor" href="#讲讲mvcc"></a> 讲讲MVCC?</h3><p>MVCC指的是多版本并发控制，维护一个数据的多个版本，使得读写没有冲突</p><p>MVCC的实现主要依赖于隐藏字段、undolog、以及readview</p><ul><li>隐藏字段：每个数据行都有隐藏字段，包括最近修改事务ID，回滚指针等</li><li>undolog: 用来存储MVCC的版本链，每次修改数据时，都会通过头插法将新的版本插入到链表的头部</li><li>readView：用于<strong>快照读</strong>提取数据时判断数据的可见性，找到对应的数据版本</li></ul><h3 id="当前读和快照读的区别"><a class="markdownIt-Anchor" href="#当前读和快照读的区别"></a> 当前读和快照读的区别？</h3><ul><li>当前读：读数据的最新版本，通过加锁的方式保证线程安全</li><li>快照读：不加锁的读就是快照读，读的是数据的可见版本，可能是旧版本的数据。<ul><li>在读提交隔离级别下，每次select都会生成一个readView</li><li>在可重复读隔离级别下，只有第一次select会生成readView，后续的select会使用第一次的readView</li></ul></li></ul><h3 id="mvcc的readview介绍一下"><a class="markdownIt-Anchor" href="#mvcc的readview介绍一下"></a> MVCC的ReadView介绍一下？</h3><p>有四个重要的字段：</p><ul><li>m_ids: <strong>活跃且未提交</strong>的事务ID列表</li><li>min_trx_id：m_ids中最小值</li><li>max_trx_id：给下一个事务的id值，也就是最大事务的id+1</li><li>creator_trx_id：创建该ReadView的事务ID</li></ul><p>当数据行的trx_id小于min_trx_id，说明该数据行对当前事务是可见的<br />当数据行的trx_id大于等于max_trx_id，说明该数据行对当前事务不可见<br />当数据行的trx_id在min_trx_id和max_trx_id之间，如果在m_ids中，说明该数据行对当前事务不可见，否则可见</p><h3 id="mysql的有哪几种引擎"><a class="markdownIt-Anchor" href="#mysql的有哪几种引擎"></a> MYSQL的有哪几种引擎？</h3><ul><li>InnoDB：InnoDB是MySQL的默认存储引擎，具有ACID事务支持、行级锁、外键约束等特性。它适用于高并发的读写操作，支持较好的数据完整性和并发控制。</li><li>MyISAM：MyISAM是MySQL的另一种常见的存储引擎，具有较低的存储空间和内存消耗，适用于大量读操作的场景。然而，MyISAM不支持事务、行级锁和外键约束，因此在并发写入和数据完整性方面有一定的限制。</li><li>Memory：Memory引擎将数据存储在内存中，适用于对性能要求较高的读操作，但是在服务器重启或崩溃时数据会丢失。它不支持事务、行级锁和外键约束。</li></ul><h3 id="mysql了解哪些日志"><a class="markdownIt-Anchor" href="#mysql了解哪些日志"></a> MYSQL了解哪些日志？</h3><ul><li>redo log 重做日志，是 InnoDB 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复，是循环写；</li><li>undo log 回滚日志，是 InnoDB 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。</li><li>bin log 二进制日志，是 Server 层生成的日志，主要用于数据备份和主从复制，是追加写；</li><li>relay log 中继日志，用于主从复制场景下，slave 通过 io 线程拷贝 master 的 bin log 后本地生成的日志</li><li>慢查询日志，用于记录执行时间过长的 SQL，需要设置阈值后手动开启</li></ul><h3 id="undolog和redolog的区别"><a class="markdownIt-Anchor" href="#undolog和redolog的区别"></a> undolog和redolog的区别？</h3><ul><li>redolog记录的是数据页的物理变化，发生故障时可用来同步数据</li><li>undolog记录的是逻辑日志，用于事务回滚和mvcc,通过逆操作恢复数据</li></ul><h3 id="介绍一下redo-log"><a class="markdownIt-Anchor" href="#介绍一下redo-log"></a> 介绍一下redo log?</h3><p>redo log用于mysql宕机时的恢复</p><ul><li>一般查询数据时，会把数据放到buffer pool中，后续查询可以在buffer pool中寻找</li><li>更新数据时，如果在buffer pool中完成了更新，就会把修改内容记录到redo log buffer中</li><li>最后清空redo log buffer，<strong>刷盘</strong>到redo log中</li></ul><p>如果没有redo log，每次直接把数据刷盘，这样性能会很差</p><h3 id="redo-log刷盘的时机"><a class="markdownIt-Anchor" href="#redo-log刷盘的时机"></a> redo log刷盘的时机</h3><p>一般以下几种情况会触发刷盘</p><ul><li>事务提交时</li><li>redo log buffer 快满时</li><li>后台线程周期性刷盘</li></ul><h3 id="介绍一下bin-log"><a class="markdownIt-Anchor" href="#介绍一下bin-log"></a> 介绍一下bin log？</h3><p>MySQL 在完成一条更新操作后，会生成一条 binlog<br />binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、MIXED，区别如下：</p><ul><li>STATEMENT：记录的内容是SQL语句原文，但是如果运用了<code>now()</code>这种函数，可能造成不一致</li><li>ROW：除了记录SQL语句，还记录了所有字段的具体数据</li><li>MIXED：是两种格式的混合，判断SQL语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式。</li></ul><h3 id="mysql怎么连表查询"><a class="markdownIt-Anchor" href="#mysql怎么连表查询"></a> MYSQL怎么连表查询？</h3><ul><li>内连接：返回两个表中有匹配关系的行</li><li>左外连接：返回左表所有的行，右表中没有匹配的行返回 NULL</li><li>右外连接：返回右表所有的行，左表中没有匹配的行返回 NULL</li><li>全外连接：返回两个表中所有的行，没有匹配的行返回 NULL</li></ul><h3 id="如何避免重复插入数据"><a class="markdownIt-Anchor" href="#如何避免重复插入数据"></a> 如何避免重复插入数据？</h3><ul><li>使用unique约束</li><li>使用insert … on duplicate key update，当key冲突时，执行update操作</li><li>使用insert ignore，忽略因key重复导致的错误</li></ul><h3 id="in和exists的区别"><a class="markdownIt-Anchor" href="#in和exists的区别"></a> in和exists的区别？</h3><ul><li>in用于检查左边的表达式存在于某结果集中的数据</li><li>exists不关心具体数据，只关心结果集是否为空</li></ul><h3 id="mysql的执行过程"><a class="markdownIt-Anchor" href="#mysql的执行过程"></a> mysql的执行过程？</h3><ul><li>连接器：身份认证和权限管理</li><li>查询缓存：尝试查询缓存，8.0版本移除</li><li>分析器：分析sql语句是否正确</li><li>优化器：优化sql语句，选择最优的执行计划</li><li>执行器：执行sql语句</li></ul><h3 id="sql查询语句的执行顺序"><a class="markdownIt-Anchor" href="#sql查询语句的执行顺序"></a> SQL查询语句的执行顺序？</h3><ul><li>from：指定要查询的表</li><li>on: 主表保留</li><li>join: 连接其他表</li><li>where: 对表进行筛选</li><li>group by: 分组</li><li>AGG FUNC：聚合函数（AVG,COUNT,MAX,MIN,SUM）</li><li>having: 对分组后的结果进行筛选</li><li>select: 选择要查询的列</li><li>distinct: 去重</li><li>order by: 对结果进行排序</li><li>limit: 限制返回结果的数量，分页</li></ul><h3 id="为什么innodb是默认存储引擎"><a class="markdownIt-Anchor" href="#为什么innodb是默认存储引擎"></a> 为什么InnoDB是默认存储引擎？</h3><p>InnoDB在事务支持、并发性能、崩溃恢复能力等方面具有良好特性：</p><ul><li>事务支持：支持事务的ACID特性，保证数据的一致性和完整性</li><li>并发性能：支持行级锁，而MyISAM只支持表级锁，锁粒度更小，并发性能更好</li><li>崩溃恢复：通过redolog实现崩溃恢复，保证数据的持久性</li></ul><h3 id="innodb和myisam的区别"><a class="markdownIt-Anchor" href="#innodb和myisam的区别"></a> InnoDB和MyISAM的区别？</h3><ul><li>事务：InnoDB支持事务，MyISAM不支持事务</li><li>索引结构：InnoDB使用聚簇索引，索引建立在主键上，MyISAM使用非聚簇索引</li><li>锁粒度：InnoDB支持行级锁，MyISAM支持表级锁</li><li>count效率：InnoDB执行count要做全表扫描，MyISAM用一个变量保存了整个表行数，count效率更高</li></ul><h3 id="索引的分类"><a class="markdownIt-Anchor" href="#索引的分类"></a> 索引的分类？</h3><ul><li>按数据结构分类：B+树索引、哈希索引、全文索引</li><li>按物理存储分类：聚簇索引、非聚簇索引</li><li>按字段特性分类: 分为主键索引、唯一索引、普通索引、前缀索引</li><li>按索引的数量分类：单列索引、联合索引</li></ul><h3 id="聚簇索引选取的依据是什么"><a class="markdownIt-Anchor" href="#聚簇索引选取的依据是什么"></a> 聚簇索引选取的依据是什么？</h3><ul><li>如果有主键，默认使用主键索引作为聚簇索引</li><li>如果没有主键，使用第一个唯一索引作为聚簇索引</li><li>如果都没有，innoDB会生成一个隐藏的自增ID作为聚簇索引</li></ul><h3 id="聚簇索引和非聚簇索引的区别"><a class="markdownIt-Anchor" href="#聚簇索引和非聚簇索引的区别"></a> 聚簇索引和非聚簇索引的区别？</h3><ul><li>数据存储：聚簇索引的叶子节点存储了数据行，非聚簇索引的叶子节点存储了指向数据行的指针或者主键</li><li>索引与数据的关系：聚簇索引可以直接查找到数据行，非聚簇索引需要先查找到主键，再通过主键回溯到聚簇索引中查找数据行，称为回表。</li><li>唯一性：聚簇索引建立在主键上是唯一的，非聚簇索引可以有多个</li><li>查询效率：对于需要回表的查询，聚簇索引效率更高，对于不需要回表的查询，非聚簇索引效率更高</li></ul><h3 id="b树的特性"><a class="markdownIt-Anchor" href="#b树的特性"></a> B+树的特性？</h3><ul><li>所有叶子节点都在同一层，叶子节点之间形成双向链表，便于范围查询和排序</li><li>非叶子节点不存储数据，只存储主键和子节点的指针</li><li>叶子节点储存实际的数据行</li><li>在插入、删除、更新后会进行平衡操作，保证树的高度相对稳定，每个节点最少有<code>M/2</code>个子节点，最多有<code>M</code>个子节点，M是树的阶数</li></ul><h3 id="b树和b树的区别"><a class="markdownIt-Anchor" href="#b树和b树的区别"></a> B+树和B树的区别？</h3><ul><li>B+树的非叶子节点不存储数据，而B树的非叶子节点会存储部分数据</li><li>B+树的叶子节点之间形成双向链表，便于范围查询和排序，B树叶子节点没有链表</li><li>B+树每次都要查到叶子节点，B树可能会在非叶子节点找到数据</li></ul><h3 id="为什么mysql不用跳表"><a class="markdownIt-Anchor" href="#为什么mysql不用跳表"></a> 为什么MYSQL不用跳表？</h3><p>B+树在3层时存储的数据可以达到千万级别，跳表要维护同样级别的数据需要的层数更多，导致性能下降。</p><h3 id="为什么自增id快一些为什么不用uuid"><a class="markdownIt-Anchor" href="#为什么自增id快一些为什么不用uuid"></a> 为什么自增ID快一些？为什么不用UUID？</h3><p>自增ID更快的原因：</p><ul><li>下一条记录会写入新的页中，提升了页面的利用率</li><li>新插入的记录一定会在原有最大ID的后面，便于定位和寻址</li><li>减少了页分裂</li></ul><p>不用UUID的原因：</p><ul><li>无序，每次插入数据可能插入到页面中间，导致页分裂</li><li>占用空间大，UUID是的长度更长，每个页能存放的记录数更少，导致树的高度更高，影响性能</li></ul><h3 id="什么是覆盖索引"><a class="markdownIt-Anchor" href="#什么是覆盖索引"></a> 什么是覆盖索引？</h3><p>覆盖索引是指<strong>索引包含了查询需要的所有字段，不需要回表查询</strong>，减少了IO操作，提升了查询性能。</p><h3 id="深度分页有什么优化方法"><a class="markdownIt-Anchor" href="#深度分页有什么优化方法"></a> 深度分页有什么优化方法？</h3><ul><li>使用范围查询：通过上一页最后一条记录的ID作为起始ID，但这种方式如果遇到不连续非自增的ID就不适用了</li><li>使用子查询：在子查询中通过主键索引快速定位到相应的数据ID，然后在主查询中，使用子查询的结果作为过滤条件，但子查询会生成临时表，在复杂场景下性能会下降</li><li>使用延迟关联：和子查询思想类似，不同的是通过内连接(inner join)将子查询的结果集成到主查询中，避免了产生临时表，所以性能会优于子查询</li><li>使用覆盖索引：通过覆盖索引来避免回表查询，提升性能，但是如果查询结果集很大（超过总数据的30%），mysql的查询优化器可能会选择全表扫描而不是使用索引</li></ul><h3 id="创建联合索引要注意什么"><a class="markdownIt-Anchor" href="#创建联合索引要注意什么"></a> 创建联合索引要注意什么？</h3><p><code>区分度=distinct(col)/count(*)</code></p><ul><li>建立联合索引时，要把区分度大(重复值少)的字段排在前面，这样可以过滤掉更多的数据，提升查询性能</li><li>如果区分度很小，比如性别字段，无论搜索哪一个值都会返回大量数据</li><li>MYSQL有一个查询优化器，如果某个值在表中的出现比例很高（超过30%），那么就会不走索引而是全表扫描</li></ul><h3 id="索引失效有那些情况"><a class="markdownIt-Anchor" href="#索引失效有那些情况"></a> 索引失效有那些情况？</h3><ul><li>使用左或者左右模糊匹配的时候</li><li>在查询中对索引列使用函数时</li><li>联合索引没有遵循最左匹配原则</li><li>范围查询<code>&lt; 和 &gt;</code>右边的字段，索引会失效，但是<code>&gt;=, &lt;=, between, like前缀匹配</code>右边的字段不会</li><li>查询字段发生类型转换</li></ul><h3 id="mysql如何定位慢查询"><a class="markdownIt-Anchor" href="#mysql如何定位慢查询"></a> mysql如何定位慢查询？</h3><ul><li>开源工具，如普罗米修斯、SkyWalking等发现比较慢的接口</li><li>使用慢查询日志，一般超过2秒就被视为慢查询</li></ul><h3 id="慢查询如何解决"><a class="markdownIt-Anchor" href="#慢查询如何解决"></a> 慢查询如何解决？</h3><ul><li>通过 explain 执行结果，查看 sql 是否走索引，如果不走索引，考虑增加索引。</li><li>可以通过建立联合索引，实现覆盖索引优化，减少回表，使用联合索引符合最左匹配原则，不然会索引失效</li><li>避免索引失效，比如不要用左模糊匹配、函数计算、表达式计算等等。</li><li>联表查询最好要以小表驱动大表，并且被驱动表的字段要有索引，当然最好通过冗余字段的设计，避免联表查询。</li><li>针对 limit n,y 深分页的查询优化，可以把 Limit 查询转换成某个位置的查询：select * from tb_sku where id&gt;20000 limit 10，该方案适用于主键自增的表，</li><li>将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开</li></ul><h3 id="索引的缺点"><a class="markdownIt-Anchor" href="#索引的缺点"></a> 索引的缺点</h3><ul><li>占用存储空间</li><li>创建和维护索引需要时间</li><li>索引会降低表的增删改的性能</li></ul><h3 id="什么时候适合建立索引"><a class="markdownIt-Anchor" href="#什么时候适合建立索引"></a> 什么时候适合建立索引？</h3><ul><li>字段有唯一性限制</li><li>经常用于where查询条件的字段</li><li>经常用order by、group by的字段</li></ul><h3 id="什么时候不需要索引"><a class="markdownIt-Anchor" href="#什么时候不需要索引"></a> 什么时候不需要索引？</h3><ul><li>where、group by、order by用不到的字段</li><li>字段存在大量重复值，区分度低</li><li>表数据很少，不需要创建索引</li><li>经常进行更新的字段不用建立索引</li></ul><h3 id="如何对索引进行优化"><a class="markdownIt-Anchor" href="#如何对索引进行优化"></a> 如何对索引进行优化？</h3><ul><li>前缀索引优化，前缀索引通过减少索引字段的长度，从而使索引页包含的索引键增多，提高查询效率</li><li>覆盖索引优化，减少回表操作</li><li>最好采用自增主键，减少页分裂</li><li>防止索引失效</li></ul><h3 id="事务特别多有哪些弊端"><a class="markdownIt-Anchor" href="#事务特别多有哪些弊端"></a> 事务特别多有哪些弊端？</h3><ul><li>如果一个事务特别多，锁定的资源也会很多，容易造成死锁和锁超时</li><li>事务回滚记录会占用大量空间，回滚时间长</li><li>执行时间长，容易造成主从延迟</li></ul><h3 id="mysql里有哪些锁"><a class="markdownIt-Anchor" href="#mysql里有哪些锁"></a> MYSQL里有哪些锁？</h3><ul><li>全局锁，主要用于全库逻辑备份</li><li>表级锁，包括表锁和元数据锁和意向锁</li><li>行级锁，包括：<ul><li>记录锁，锁住某条记录</li><li>间隙锁，锁定一个范围，不包括记录本身</li><li>next-key锁，记录锁和间隙锁的结合，锁定一个范围，包含记录本身，用于解决幻读</li></ul></li></ul><h3 id="mysql主从复制过程"><a class="markdownIt-Anchor" href="#mysql主从复制过程"></a> MYSQL主从复制过程？</h3><ul><li>主库将数据写入binlog</li><li>从库通过IO线程连接主库，向主库请求binlog</li><li>主库创建一个线程将binlog发送给从库</li><li>从库的IO线程将binlog写入relay log</li><li>从库读取relay log，进行数据同步</li></ul><h3 id="主从延迟有哪些解决方法"><a class="markdownIt-Anchor" href="#主从延迟有哪些解决方法"></a> 主从延迟有哪些解决方法？</h3><ul><li>强制走主库，对于资源密集型操作，直接在主库上执行</li></ul><h3 id="分库和分表的区别"><a class="markdownIt-Anchor" href="#分库和分表的区别"></a> 分库和分表的区别？</h3><p>分库将数据按照一定规则分布到不同的数据库中，分表是将单个表拆分成多个表</p><ul><li>垂直分库指的是将数据按照业务和功能维度划分到不同的数据库中，但仍然会有单表数据量过大的问题</li><li>水平分库指的是将同一张表按照一定规则分布到不同的数据库中，每个数据库中的表结构相同，但数据不同</li><li>垂直分表针对单表字段过多的问题，一般将单表中比较独立的字段或者不常用的字段拆分到不同的表中</li><li>水平分表是在同一个数据库内，把一张大数据量的表按一定规则，切分成多个结构完全相同表。</li></ul><h2 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h2><h3 id="redis的数据结构以及应用场景"><a class="markdownIt-Anchor" href="#redis的数据结构以及应用场景"></a> Redis的数据结构以及应用场景？</h3><h4 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h4><p>基本的key-value结构，应用场景有：</p><ul><li>缓存对象，有两种方式：<ul><li>直接缓存json字符串如<code>set user:1 &#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:18&#125;</code></li><li>使用Mset和Mget，如<code>mset user:1:name zhangsan user:1:age 18</code></li></ul></li><li>常规计数，比如点赞、阅读量、转发等,如<code>incr article:1:like</code></li><li>分布式锁，通过NX参数实现key不存在才插入，key不存在则插入成功（加锁成功），否则插入失败（加锁失败）</li></ul><h4 id="list"><a class="markdownIt-Anchor" href="#list"></a> List:</h4><p>简单的字符串列表，按照插入顺序排序，应用场景主要有消息队列</p><p>消息队列存取消息必须要满足三个需求，分别是<strong>消息保序、处理重复消息、消息可靠性</strong></p><ul><li>消息保序，通过lpush和rpop实现消息的先入先出，同时为了提高性能，可以使用BRPOP进行阻塞读取，也就是队列为空时自动阻塞</li><li>处理重复消息，需要为每个消息生成一个全局唯一ID，比如通过时间戳+计数器的方式生产全局唯一ID，然后将消息和全局唯一ID一起存入redis</li><li>为了保证消息可靠性，可以使用BRPOPLPUSH，每次取一个消息后，将消息放入一个备份队列，这样即使消费者没有读了消息没有成功处理，也可以从备份队列中重新读取消息</li></ul><p>List实现消费队列有什么缺陷？</p><ul><li>不允许多个消费者消费同一条消息</li><li>不支持消费组</li></ul><h4 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> Hash</h4><p>键值对集合key-field-value，应用场景有：</p><ul><li>缓存对象，通过HMSET进行缓存对象，如<code>hmset uid:1 name zhangsan age 18</code></li><li>购物车，一般以用户id为key，商品id为field，商品数量为value，如<code>hset cart:1 1001 2</code></li></ul><h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h4><p>无序且唯一的键值集合，应用场景有：</p><ul><li>点赞，以key为文章id，value为用户id，如<code>sadd article:1 uid:1</code></li><li>共同关注，以用户id为key，以用户关注的公众号id为value，通过sinter可以求不同用户的交集</li><li>抽奖，因为set的不可重复性，一个用户不会被重复抽中，可以将抽奖活动名作为key，所有用户名作为value，如果是允许重复中奖就使用srandmember，如果不允许重复中奖就使用spop</li></ul><h4 id="zset"><a class="markdownIt-Anchor" href="#zset"></a> zset</h4><p>比set多了一个排序属性score，主要包括member和score两个属性，member是唯一的，应用场景有：</p><ul><li>适合排序的场景，如排行榜，将用户id作为member，分数作为score，通过zadd添加分数，通过zrevrange获取排行榜</li></ul><h4 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> Bitmap</h4><p>一串连续的二进制数组，通过offset定位元素，应用场景有：</p><ul><li>用户签到，通过setbit设置用户签到，通过bitcount统计签到次数</li><li>判断登陆状态</li></ul><p>如何统计当月首次签到时间？<br />通过bitpos获取第一个为1的位置，即为首次签到时间<br /><code>bitpos uid:sign:100:202403 1</code></p><p>如何统计连续七天打卡的用户总数？<br />以每天的日期为key，以用户的id为offset，通过bitop AND将七天的bitmap进行按位与操作，如果某个位结果为1，说明这个用户连续七天打卡<br />然后通过bitcount统计七天连续打卡的用户总数</p><h4 id="hyperloglog"><a class="markdownIt-Anchor" href="#hyperloglog"></a> hyperloglog</h4><p>用于提供不精确的去重计数</p><h4 id="geo"><a class="markdownIt-Anchor" href="#geo"></a> GEO</h4><p>存储地理信息</p><h4 id="stream"><a class="markdownIt-Anchor" href="#stream"></a> Stream</h4><p>用于实现消息队列，支持消息持久化、全局唯一ID自动生成、消息确认机制、消费组等功能</p><h3 id="redis的string实现原理"><a class="markdownIt-Anchor" href="#redis的string实现原理"></a> redis的string实现原理</h3><p>String的底层数据结构主要是SDS（简单动态字符串），他有以下特点：</p><ul><li>不仅可以存储字符串，还可以存储二进制数据</li><li>获取字符串长度的时间复杂度是O(1)，len属性记录了长度</li><li>API更安全，拼接字符串不会发生缓冲区溢出</li></ul><h3 id="为什么redis用跳表而不是b树"><a class="markdownIt-Anchor" href="#为什么redis用跳表而不是b树"></a> 为什么Redis用跳表而不是B+树？</h3><ul><li>B+树目的是优化磁盘IO，通过降低树的高度来减少磁盘寻道次数，而Redis是基于内存的，更符合内存访问的局部性原理</li><li>跳表实现简单，而B+树节点分裂合并逻辑复杂</li><li>跳表插入删除效率更高，B+树插入删除需要维护平衡</li><li>跳表内存占用更紧凑，B+树索引页未填满可能存在内存碎片</li></ul><h3 id="跳表的层数是怎么设置的"><a class="markdownIt-Anchor" href="#跳表的层数是怎么设置的"></a> 跳表的层数是怎么设置的？</h3><p>跳表创建节点时，会随机生产一个0-1之间的随机数，如果小于某个0.25，则层数+1，直到生成的随机数大于阈值，层数的最大值是64</p><h3 id="redis的哈希表是怎么扩容的"><a class="markdownIt-Anchor" href="#redis的哈希表是怎么扩容的"></a> Redis的哈希表是怎么扩容的？</h3><p>主要分三步：</p><ul><li>创建新哈希表，一般大小为之前的2倍</li><li>将旧哈希表的数据重新迁移到新哈希表</li><li>释放旧哈希表，将新哈希表设置为当前哈希表</li></ul><p>注意，如果旧哈希表数据量非常大，迁移过程中可能就会导致Redis阻塞，影响性能，所以采用<strong>渐进式扩容</strong>，步骤如下：</p><ul><li>创建新哈希表，大小为旧哈希表的2倍</li><li>分多次迁移数据，期间如果有<strong>删改查</strong>请求，会先在旧哈希表操作，并将对应的数据迁移到新哈希表，如果数据已经迁移到新哈希表，就直接在新哈希表操作，<strong>增</strong>操作直接在新哈希表操作</li><li>迁移完成后，释放旧哈希表，将新哈希表设置为当前哈希表</li></ul><h3 id="redis为什么快"><a class="markdownIt-Anchor" href="#redis为什么快"></a> Redis为什么快？</h3><ul><li>基于内存，内存访问速度快</li><li>单线程，避免了多线程切换带来的开销</li><li>IO多路复用，一个线程处理多个IO流</li></ul><h3 id="redis哪里用到了多线程"><a class="markdownIt-Anchor" href="#redis哪里用到了多线程"></a> Redis哪里用到了多线程？</h3><p>Redis单线程一般指的是执行命令的线程是单线程，Redis6.0之后引入了多线程IO，主要用于网络IO，提升网络IO性能</p><h3 id="io多路复用怎么实现"><a class="markdownIt-Anchor" href="#io多路复用怎么实现"></a> IO多路复用怎么实现？</h3><ul><li>多个客户端与redis服务端建立连接时，服务端会将每个客户端的socket对应的FD注册到一个事件监听器中</li><li>事件监听器会监听所有的FD，当有FD有事件发生时，会通知事件处理器处理该事件</li><li>避免了服务端一直等待某个客户端数据的问题</li></ul><h3 id="如何实现redis的原子性"><a class="markdownIt-Anchor" href="#如何实现redis的原子性"></a> 如何实现Redis的原子性？</h3><ul><li>如果执行一条命令，由于redis是单线程的，所以是原子性的</li><li>如果执行两个命令，可以通过lua脚本</li><li>如果执行多个命令，可以通过事务，如果事务正常执行，通过multi和exec命令，可以保证多个命令的原子性，如果某一个操作执行失败，就无法保证原子性了</li></ul><h3 id="redis持久化之aof"><a class="markdownIt-Anchor" href="#redis持久化之aof"></a> Redis持久化之AOF？</h3><p>每执行一条写操作，就会将命令以追加写的方式写入AOF文件，当Redis重启时，会逐一执行AOF文件中的命令，恢复数据<br />有三种写回策略</p><ul><li>always：每次写操作都会同步写入AOF文件，保证数据的完整性</li><li>everysec：每次写操作执行完后，先将命令写入内核缓冲区，然后每隔一秒将内核缓冲区的数据写入AOF文件</li><li>no：每次写操作执行完后，将命令写入内核缓冲区，然后由操作系统决定何时将数据写入AOF文件</li></ul><table><thead><tr><th>写回策略</th><th>写回时机</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Always</td><td>同步写回</td><td>可靠性高、最大程度保证数据不丢失</td><td>每个写命令都要写回硬盘，性能开销大</td></tr><tr><td>Everysec</td><td>每秒写回</td><td>性能适中</td><td>宕机时会丢失1秒内的数据</td></tr><tr><td>No</td><td>由操作系统控制写回</td><td>性能好</td><td>宕机时丢失的数据可能会很多</td></tr></tbody></table><h3 id="aof重写机制"><a class="markdownIt-Anchor" href="#aof重写机制"></a> AOF重写机制？</h3><p>AOF文件会包含很多冗余或无效的命令，导致文件体积越来越大。AOF重写机制就是为了解决这个问题</p><ul><li>AOF重写不是基于旧的AOF文件进行修改，而是直接读取当前Redis数据库在内存中的状态，并为每个键值对生成最少的命令集合来恢复这个状态</li><li>一般主进程会fork一个子进程执行AOF重写</li><li>AOF重写期间，如果遇到有新的写操作，主进程会按照之前的策略写入到AOF中，同时将这些命令记录在AOF重写缓冲区中</li><li>子进程完成AOF重写后，主进程会将AOF重写缓冲区中的所有命令追加到子进程生成的AOF文件的末尾</li></ul><h3 id="redis持久化之rdb"><a class="markdownIt-Anchor" href="#redis持久化之rdb"></a> Redis持久化之RDB?</h3><p>将某一时刻的内存数据以二进制形式写入磁盘<br />Redis提供了save和bgsave两种方式生成RDB文件，他们的区别是是否在主进程中执行</p><ul><li>save会同步的执行保存操作，会阻塞主进程</li><li>bgsave会在后台子进程执行，不会阻塞主进程(异步)</li><li>RDB快照是全量快照，频繁执行会影响性能</li></ul><h3 id="bgsave时数据能被修改吗"><a class="markdownIt-Anchor" href="#bgsave时数据能被修改吗"></a> bgsave时，数据能被修改吗？</h3><p>答：可以。bgsave时，Redis会fork一个子进程，子进程会复制父进程的页表，但是指向同一个物理内存。<br />但是当父进程数据要被修改时，会发生写时复制，数据所在的物理内存会被复制一份，然后主进程在数据的副本上修改，子进程仍然把旧的数据写入RDB。<br />所以如果修改的数据过多，就会导致bgsave过程中内存占用过多。</p><h3 id="aof和rdb的优缺点"><a class="markdownIt-Anchor" href="#aof和rdb的优缺点"></a> AOF和RDB的优缺点？</h3><p>AOF</p><ul><li>优点：可靠性高，每次写操作都会写入AOF文件，即使服务器宕机，也只会丢失最后一次写操作，还可以通过选择合适的写回策略来平衡性能和可靠性</li><li>缺点：AOF文件体积更大，恢复速度慢，如果使用的是always策略，性能开销大</li></ul><p>RDB：</p><ul><li>优点：RDB文件体积小，恢复速度快</li><li>缺点：RDB是全量快照，如果宕机时，会丢失最后一次快照之后的数据，如果发生写时复制，会导致内存占用过多</li></ul><h3 id="讲讲redis的内存淘汰策略"><a class="markdownIt-Anchor" href="#讲讲redis的内存淘汰策略"></a> 讲讲Redis的内存淘汰策略？</h3><p>不进行数据淘汰的策略：</p><ul><li>noeviction，当内存不足时，不淘汰任何数据。有新的输入写入会报错通知禁止写入<br />进行数据淘汰的策略：</li><li>针对设置了过期时间的数据：<ul><li>volatile-random：随机淘汰设置了过期时间的数据</li><li>volatile-ttl：优先淘汰快过期的数据</li><li>volatile-lru：优先淘汰最久未使用的数据</li><li>volatile-lfu：优先淘汰最少使用的数据</li></ul></li><li>针对所有范围数据：<ul><li>allkeys-random：随机淘汰任意数据</li><li>allkeys-lru：优先淘汰最久未使用的数据</li><li>allkeys-lfu：优先淘汰最少使用的数据</li></ul></li></ul><h3 id="lru和lfu的缺点"><a class="markdownIt-Anchor" href="#lru和lfu的缺点"></a> LRU和LFU的缺点？</h3><ul><li>LRU主要淘汰最久未使用的数据，如果某些数据比较重要，而且在上一段时间内使用很频繁，如果有新数据到来，也容易被淘汰</li><li>LFU主要淘汰使用频率最低的数据，它需要维护逻辑访问次数，会增加一些计算开销，同时对于新来的数据，由于访问频率较低，可能很快就被淘汰</li></ul><h3 id="redis的过期删除策略"><a class="markdownIt-Anchor" href="#redis的过期删除策略"></a> Redis的过期删除策略？</h3><p>过期删除采用惰性删除和定期删除两种方式</p><ul><li>惰性删除：只有在使用key时，才会检查key是否过期，如果过期才删除</li><li>定期删除：每隔一段时间（每秒10次，可以在redis.conf配置），会随机抽取一些key（一般为20个）检查是否过期，如果过期就删除</li></ul><h3 id="为什么不立刻删除过期key"><a class="markdownIt-Anchor" href="#为什么不立刻删除过期key"></a> 为什么不立刻删除过期key？</h3><p>答：当过期的key很多时，立刻删除会占用一定CPU，影响性能</p><h3 id="redis全量同步"><a class="markdownIt-Anchor" href="#redis全量同步"></a> Redis全量同步？</h3><p>全量同步一般发生在下面的情况：</p><ul><li>第一次同步</li><li>从服务器数据丢失</li><li>主从数据差异太大</li></ul><p>全量同步的过程：</p><ul><li>从服务器发送同步请求</li><li>主服务器生成RDB文件，发送给从服务器</li><li>从服务器接收RDB文件，并载入数据</li><li>主服务器生成和传输RDB期间，写操作会记录在replication backlog中</li><li>从服务器载入完RDB后，主服务器将replication backlog发送给从服务器，从服务器执行这些命令，保证数据一致</li></ul><h3 id="redis增量同步"><a class="markdownIt-Anchor" href="#redis增量同步"></a> Redis增量同步？</h3><p>增量同步主要通过replication backlog和两个offset实现：<br />replication backlog实际上是一个环形数组，其中master offset记录了主服务器写的位置，slave offset记录了从服务器读的位置<br />如果主服务器写的太快，从服务器读的太慢（网络原因），那么slave offset就会被覆盖，这时候就会发生全量同步</p><h3 id="介绍一下redis哨兵机制"><a class="markdownIt-Anchor" href="#介绍一下redis哨兵机制"></a> 介绍一下Redis哨兵机制？</h3><p>哨兵机制主要用于监控Redis集群的状态，主要作用是<code>监控、故障转移、通知</code></p><ul><li>监控：哨兵会定时检查主从集群的状态</li><li>故障转移：当主服务器宕机时，哨兵会选举一个从服务器作为新的主服务器</li><li>通知：当主从集群状态发生变化时，哨兵会通知客户端</li></ul><h3 id="哨兵机制如何监控"><a class="markdownIt-Anchor" href="#哨兵机制如何监控"></a> 哨兵机制如何监控？</h3><p>首先哨兵会基于心跳检测来判断节点状态</p><ul><li>主观下线：如果某个哨兵发现某个节点长时间未响应，就会认为该节点主观下线</li><li>客观下线：当超过一定数量的哨兵认为某个节点主观下线，就会认为该节点客观下线</li></ul><h3 id="哨兵如何选择新的主服务器"><a class="markdownIt-Anchor" href="#哨兵如何选择新的主服务器"></a> 哨兵如何选择新的主服务器？</h3><ul><li>首先哨兵需要选出一个leader，当一个哨兵认为主节点主观下线了，它会请求其他哨兵选自己为leader,被请求的哨兵如果没有投过票，则当前哨兵票数+1，一般票数超过半数，则选举成功</li><li>leader会根据策略选出新的主节点<ul><li>首先排除故障的节点</li><li>选择优先级最大的节点</li><li>如果优先级相同，选择复制偏移量最大的节点</li><li>如果以上都相同，选择runid最小的节点</li></ul></li></ul><h3 id="介绍一下分片集群"><a class="markdownIt-Anchor" href="#介绍一下分片集群"></a> 介绍一下分片集群？</h3><p>redis分片集群主要用于解决单机内存有限的问题，通过分片将数据分布到多个节点中，提高了内存的使用率，提高了读写性能</p><p>分片集群一共有16384个槽，每个节点都包含若干个槽<br />当添加数据时，步骤如下：</p><ul><li>通过CRC16算法计算key的哈希值</li><li>将哈希值对16384取模，得到槽号</li></ul><p>如何将同一类数据固定的保存在同一个Redis节点？<br />答：使用<code>&#123;&#125;</code>将key中的部分字符串包裹，如<code>&#123;user:101&#125;:name</code>，这样只根据<code>user:101</code>来计算哈希值，保证<code>user:101</code>的数据都保存在同一个节点</p><h3 id="redis分布式锁的原理"><a class="markdownIt-Anchor" href="#redis分布式锁的原理"></a> Redis分布式锁的原理？</h3><h4 id="加锁"><a class="markdownIt-Anchor" href="#加锁"></a> 加锁</h4><p>Redis分布式锁主要用于控制某个资源在同一时刻只能被一个应用使用。<br />NX参数实现<strong>key不存在才插入</strong>，可以通过它实现分布式锁</p><ul><li>key不存在，则插入成功，表示加锁成功</li><li>key存在，则插入失败，表示加锁失败</li></ul><p>使用分布式锁的条件：</p><ul><li>加锁需要以原子操作完成，通过set 命令带上NX参数实现</li><li>锁需要设置过期时间，可以通过PX参数设置</li><li>锁需要区分不同的客户端，所以需要一个唯一ID来标识客户端</li></ul><p>所以一个加锁的命令如下：<br /><code>set lock_key 101 NX PX 30000</code></p><h4 id="解锁"><a class="markdownIt-Anchor" href="#解锁"></a> 解锁</h4><p>解锁需要两步操作：</p><ul><li>判断执行解锁操作的客户端就是加锁的客户端</li><li>删除lock_key</li></ul><p>由于是两个操作，为了保证原子性，一般用lua脚本实现</p><h3 id="redis实现的分布式锁有什么问题"><a class="markdownIt-Anchor" href="#redis实现的分布式锁有什么问题"></a> redis实现的分布式锁有什么问题？</h3><ul><li>锁的过期时间不好设置，过短可能任务没执行完就释放锁，过长可能影响性能</li><li>持有锁的客户端宕机，锁无法释放</li><li>时钟漂移，不同服务器的时钟可能不一致，导致锁的过期时间不准确</li><li>redis的分布式锁不可重入，redisson可以重入</li><li>主从模式下，某个客户端获得锁之后，主节点宕机，此时主节点的锁数据还没来得及同步到从节点，选出新的主节点后，另一个客户端可能会成功获取同一把锁，违背了分布式锁的互斥性</li></ul><h3 id="redis分布式锁的互斥性问题怎么解决"><a class="markdownIt-Anchor" href="#redis分布式锁的互斥性问题怎么解决"></a> redis分布式锁的互斥性问题怎么解决？</h3><p>之前说分布式锁主从模式下，主节点获得锁之后宕机，此时新的主节点仍然可以获取锁，导致两个线程获取同一把锁，这样可能就导致<strong>数据不一致</strong></p><p>要解决这个问题，可以考虑使用红锁</p><ul><li>红锁的思想是，在多个redis节点上加锁，只有多数节点加锁成功（但不持有锁），才算加锁成功</li></ul><p>红锁由于实现负责、性能开销大，所以一般不推荐使用，如果要保证强一致性，可以考虑使用zookeeper等分布式锁实现</p><h3 id="基于redis实现分布式锁如何自动续期"><a class="markdownIt-Anchor" href="#基于redis实现分布式锁如何自动续期"></a> 基于redis实现分布式锁如何自动续期？</h3><p>可以通过redisson实现，redisson提供了一个watch dog机制来监控和续期锁，watch dog的原理如下：</p><ul><li>加锁成功后，每隔10s，看门狗就会通过lua脚本进行续期，每次续期前先判断是否为持锁线程，是则将超时时间设置为30s</li><li>使用redisson时，只需要调用lock.lock()方法，watch dog会自动续期，如果设置了过期时间，就不会用到watch dog自动续期</li></ul><h3 id="什么是大key问题"><a class="markdownIt-Anchor" href="#什么是大key问题"></a> 什么是大Key问题？</h3><p>大Key问题指的是Redis中某个key的value过大，导致Redis处理这个key时，会占用大量的内存，影响Redis的性能</p><ul><li>高并发、低延迟场景中，超过10kb可能就构成大key</li><li>低并发、高容量场景中，超过100kb可能才构成大key</li></ul><p>一般会造成以下影响：</p><ul><li>内存占用过大</li><li>读写性能下降</li><li>可能阻塞其他操作</li><li>造成网络拥塞</li><li>造成主从延迟</li><li>造成Redis集群不均衡</li></ul><h3 id="如何解决大key问题"><a class="markdownIt-Anchor" href="#如何解决大key问题"></a> 如何解决大Key问题？</h3><ul><li>对大key进行拆分</li><li>对大key进行删除，要用异步删除</li><li>监控redis内存状态，及时发现大key</li><li>对过期数据定期进行清理</li></ul><h3 id="如何解决热key问题"><a class="markdownIt-Anchor" href="#如何解决热key问题"></a> 如何解决热key问题？</h3><p>热key指某个key的访问频率过高</p><p>解决方法：</p><ul><li>将热key复制并迁移到多个数据分片</li><li>使用读写分离架构，将热key读请求分发到多个从节点</li></ul><h3 id="缓存雪崩如何解决"><a class="markdownIt-Anchor" href="#缓存雪崩如何解决"></a> 缓存雪崩如何解决？</h3><p>缓存雪崩指的是大量key在同一时间失效，导致请求全部落到数据库上，引起数据库压力过大，甚至宕机</p><p>解决方法：</p><ul><li>随机设置不同的过期时间，避免同一时间大量key失效</li><li>添加降级或者限流策略，保护数据库避免宕机</li><li>使用多级缓存，如本地缓存等，分担redis的压力</li></ul><h3 id="如何设计秒杀场景处理高并发和超卖问题"><a class="markdownIt-Anchor" href="#如何设计秒杀场景处理高并发和超卖问题"></a> 如何设计秒杀场景处理高并发和超卖问题？</h3><ul><li>在数据库层面，查询时通过for update增加排他锁，其他线程无法删改数据，更新库存时添加判断，保证库存为正数</li><li>利用Redis分布式锁，同一个时间只有一个客户端能获得锁</li><li>利用分布式锁+分段缓存，将数据分段，每个段拥有独立的锁，避免锁的粒度过大</li><li>利用incr、decr的原子性+异步队列，步骤如下：<ul><li>初始化时，将库存数量写入Redis</li><li>用户请求时，通过decr预减库存，如果库存小于0，说明超卖，返回失败</li><li>将请求放入异步队列</li><li>从队列取出请求，更新数据库库存</li><li>用户端通过轮询判断是否秒杀成功</li></ul></li></ul><h3 id="如何处理重复下单问题"><a class="markdownIt-Anchor" href="#如何处理重复下单问题"></a> 如何处理重复下单问题？</h3><p>重复下单问题，本质上就是幂等性问题，高并发下单，高并发抢红包，高并发支付等都属于这类问题</p><h4 id="基础性解决方案"><a class="markdownIt-Anchor" href="#基础性解决方案"></a> 基础性解决方案</h4><ul><li>全局唯一ID，如UUID，雪花算法，业务字段+时间戳等</li><li>唯一索引（去重表），如果重复创建，数据库会抛出异常</li><li>版本号</li></ul><h4 id="综合性解决方案"><a class="markdownIt-Anchor" href="#综合性解决方案"></a> 综合性解决方案</h4><p><strong>一锁二判三更新</strong></p><ul><li>一锁：通过分布式锁，或者是分布式锁+分段锁</li><li>二判：进行幂等性判断如唯一ID、版本号等</li><li>三更新：更新数据</li></ul><h3 id="如何保证双写一致性"><a class="markdownIt-Anchor" href="#如何保证双写一致性"></a> 如何保证双写一致性？</h3><p>双写一致性指的是更新数据时，数据库和redis的数据要保持一致</p><ul><li>一般对于读操作，先从redis中读，如果命中直接返回，如果没有命中则查询数据库，写入缓存，并设置超时时间</li><li>对于写操作，采用延迟双删的策略，先更新数据库，再删除缓存</li></ul><p>为什么要删除两次？</p><ul><li>因为无论是先删除缓存再更新数据库，还是先更新数据库再删除缓存，都有可能出现脏数据的情况</li></ul><p>为什么要延时双删？</p><ul><li>一般数据库是主从模式，读写分离，需要延迟一会等数据同步到从节点，但延时的时间不好确定，所以仍然不能做到百分百一致性。</li></ul><p>有没有更好的方案？</p><ul><li>对于强一致性要求的场景，可以使用redis中的读写锁，但是性能会下降</li><li>对于最终一致性要求的场景<ul><li>可以使用异步消息队列，将删除缓存的消息放到消息队列中</li><li>还可以使用canal订阅binlog的方式，把canal作为一个从节点，监听binlog的变更，然后删除缓存</li></ul></li></ul><h2 id="介绍一下雪花算法"><a class="markdownIt-Anchor" href="#介绍一下雪花算法"></a> 介绍一下雪花算法？</h2><p>雪花算法是 64 位 的二进制，一共包含了四部分：</p><ul><li>1位是符号位，也就是最高位，始终是0，没有任何意义，因为要是唯一计算机二进制补码中就是负数，0才是正数。</li><li>41位是时间戳，具体到毫秒，41位的二进制可以使用69年，因为时间理论上永恒递增，所以根据这个排序是可以的。</li><li>10位是机器标识，可以全部用作机器ID，也可以用来标识机房ID + 机器ID，10位最多可以表示1024台机器。</li><li>12位是计数序列号，也就是同一台机器上同一时间，理论上还可以同时生成不同的ID，12位的序列号能够区分出4096个ID。</li></ul><h2 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h2><h3 id="什么是动态代理"><a class="markdownIt-Anchor" href="#什么是动态代理"></a> 什么是动态代理？</h3><p>动态代理是一种在运行时创建代理对象的机制，主要用于在不修改原始类的情况下对方法调用进行拦截和增强<br />主要分为两种类型：</p><ul><li>JDK动态代理：这种类型要求目标类必须实现至少一个接口。通过Proxy类和InvocationHandler接口实现，当通过代理对象调用方法时，会转发到由InvocationHandler接口的invoke()方法调用。</li><li>CGLIB动态代理：CGLIB可以在运行时动态生成一个目标类的子类，不需要目标类实现接口，而是通过继承的方式实现代理。</li><li>ASM代理：使用字节码编程，操作字节码指令</li><li>Byte-Buddy：也是字节码操作的类库，但通过API就能操作字节码，实现更加简单</li><li>Javassist：也是字节码操作的类库，相对于ASM，Javassist更加简单易用</li></ul><h3 id="jdk动态代理的实现步骤"><a class="markdownIt-Anchor" href="#jdk动态代理的实现步骤"></a> JDK动态代理的实现步骤？</h3><ul><li>定义一个接口，以及实现类xxxserviceImpl</li><li>定义一个动态代理类并实现InvocationHandler接口，重写invoke方法</li><li>通过Proxy.newProxyInstance方法创建代理对象，这样就可以调用代理对象的方法，实际上是调用了invoke方法</li></ul><h3 id="cglib动态代理的实现步骤"><a class="markdownIt-Anchor" href="#cglib动态代理的实现步骤"></a> CGLIB动态代理的实现步骤？</h3><p>Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p><ul><li>定义一个类，不需要实现接口</li><li>自定义一个类实现MethodInterceptor接口，重写intercept方法</li><li>通过Enhancer类的create方法创建代理对象</li></ul><h2 id="自定义注解的三个注解的含义"><a class="markdownIt-Anchor" href="#自定义注解的三个注解的含义"></a> 自定义注解的三个注解的含义？</h2><ul><li>@Retention：注解的生命周期，分为SOURCE、CLASS、RUNTIME<ul><li>SOURCE：编译器会丢弃该注解</li><li>CLASS：编译器会保留该注解，但 JVM 会丢弃该注解</li><li>RUNTIME：编译器和 JVM 都会保留该注解，可以通过反射获取</li></ul></li><li>@Target：注解的作用范围，分为TYPE、FIELD、METHOD、PARAMETER等<ul><li>TYPE：可以作用于类、接口、枚举等</li><li>FIELD：可以作用于属性</li><li>METHOD：可以作用于方法</li><li>PARAMETER：可以作用于参数</li></ul></li><li>@Documented：表示该注解会被包含在 Javadoc 中</li></ul><h2 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h2><h3 id="什么是aop"><a class="markdownIt-Anchor" href="#什么是aop"></a> 什么是AOP？</h3><p>AOP是将一些横切关注点如日志、事务、权限控制等与核心业务逻辑分离，通过动态代理等技术实现代码的复用和解耦，提高代码的可维护性和可扩展性。</p><h3 id="aop的一些术语有哪些"><a class="markdownIt-Anchor" href="#aop的一些术语有哪些"></a> AOP的一些术语有哪些？</h3><ul><li>横切关注点：多个类或者对象的公共行为，如日志、事务、权限控制等</li><li>切面：对横切关注点进行封装的类，一个切面是一个类</li><li>连接点：程序执行的某个特定的时刻，如方法的调用、异常的处理等</li><li>通知：在某个连接点要执行的操作</li><li>切点：一个切点是一个表达式，用来匹配连接点</li><li>织入：将切面和目标对象连接起来的过程</li></ul><h3 id="aop的通知都有哪些类型"><a class="markdownIt-Anchor" href="#aop的通知都有哪些类型"></a> AOP的通知都有哪些类型？</h3><ul><li>前置通知：在目标对象的方法调用前触发</li><li>后置通知：在目标对象的方法调用后触发</li><li>返回通知：目标对象的方法正常返回后触发</li><li>异常通知：目标对象的方法抛出异常后触发</li><li>环绕通知：手动控制触发的时机</li></ul><h3 id="aop的应用场景"><a class="markdownIt-Anchor" href="#aop的应用场景"></a> AOP的应用场景？</h3><ul><li>日志记录</li><li>性能统计</li><li>事务管理：如<code>@Transactional</code>注解就是基于AOP实现的</li><li>权限控制：利用 AOP 在目标方法执行前判断用户是否具备所需要的权限</li><li>接口限流</li></ul><h3 id="aop实现日志记录怎么做"><a class="markdownIt-Anchor" href="#aop实现日志记录怎么做"></a> AOP实现日志记录怎么做？</h3><ul><li>定义一个自定义的注解Log</li><li>定义一个切面类，通过切入点和通知指定什么时候进行日志记录</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span><br><span class="hljs-variable">@Aspect</span><br>public class LogAspect &#123;<br>  <span class="hljs-comment">// 切入点，所有被 Log 注解标注的方法</span><br>  <span class="hljs-variable">@Pointcut</span>(<span class="hljs-string">&quot;@annotation(cn.javaguide.annotation.Log)&quot;</span>)<br>  public void <span class="hljs-built_in">webLog</span>() &#123;<br>  &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 环绕通知</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-variable">@Around</span>(<span class="hljs-string">&quot;webLog()&quot;</span>)<br>  public Object <span class="hljs-built_in">doAround</span>(ProceedingJoinPoint joinPoint) throws Throwable &#123;<br>    <span class="hljs-comment">// 省略具体的处理逻辑</span><br>  &#125;<br><br>  <span class="hljs-comment">// 省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在需要记录日志的方法上添加@Log注解即可</li></ul><h2 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h2><h3 id="创建型模式"><a class="markdownIt-Anchor" href="#创建型模式"></a> 创建型模式</h3><ul><li>工厂模式：在父类中提供一个创建对象的方法，由子类决定实例化对象的类型。</li><li>抽象工厂模式：创建一系列相关对象，无需指定具体类</li><li>建造者模式：将多个简单对象一步步组装成为一个复杂的对象</li><li>原型模式：通过clone现有对象来创建新对象</li><li>单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点</li></ul><h3 id="结构型模式"><a class="markdownIt-Anchor" href="#结构型模式"></a> 结构型模式</h3><ul><li>适配器模式：将原本不兼容的接口通过适配修改做到统一</li><li>代理模式：为某些对象的访问提供代理，通过代理去控制原始对象的访问</li><li>装饰器模式：在不改变原有类的情况下，给类新增功能</li><li>桥接模式：将抽象部分与它的实现部分分离，比如A类中含有B类的接口，通过构造函数传递B类的实现</li><li>组合模式：将相似对象组合成可被调用的结构树对象</li><li>外观模式：为复杂的类或框架提供一个简单的接口</li><li>享元模式：共享通用对象，减少内存的使用，提升系统的访问效率</li></ul><h3 id="行为型模式"><a class="markdownIt-Anchor" href="#行为型模式"></a> 行为型模式</h3><ul><li>责任链模式：解决一组服务中的先后执行处理关系，将请求沿着处理链传递</li><li>命令模式：以数据驱动的方式将命令对象，可以使用构造函数的方式传递给调用者。调用者再提供相应的实现为命令执行提供操作方法。</li><li>迭代器模式：以相同的方式去遍历不同的数据结构元素</li><li>中介者模式：解决复杂功能应用之间的重复调用，在这中间添加一层中介者包装服务，对外提供简单、通用、易扩展的服务能力。</li><li>备忘录模式：以不破坏原对象为基础增加备忘录操作类，记录原对象的行为</li><li>观察者模式：定义一种订阅机制，当对象事件发生时，通知所有订阅者</li><li>状态模式：让对象在不同状态下有不同的行为</li><li>策略模式：定义一系列算法， 并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。</li><li>模板方法模式：通过在抽象类中定义抽象方法的执行顺序，并将抽象方法设定为只有子类实现，但不设计独立访问的方法</li><li>访问者模式：在稳定的数据结构下，增加易变的业务访问逻辑，即同一个事物不同视角下的访问信息不同</li></ul><h3 id="实现一个单例模式"><a class="markdownIt-Anchor" href="#实现一个单例模式"></a> 实现一个单例模式</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingleTon</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingleTon instance=<span class="hljs-literal">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleTon</span>()</span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title">getInstance</span>()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)&#123;<br>            synchronized(SingleTon.<span class="hljs-keyword">class</span>)&#123;<br>                <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)&#123;<br>                    instance=<span class="hljs-keyword">new</span> SingleTon();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过volatile关键字，禁止指令重排序，保证线程安全</li><li>synchronized加在方法内部，提升执行效率</li><li>第一次判断非null直接返回，避免每次都加锁</li><li>第二次判断是为了保证线程安全，避免重复创建对象</li></ul><h2 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h2><h3 id="消息队列怎么选型"><a class="markdownIt-Anchor" href="#消息队列怎么选型"></a> 消息队列怎么选型？</h3><p>几种常见的MQ对比如下：</p><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级</td><td>万级</td><td>10 万级</td><td>10 万级</td></tr><tr><td>时效性</td><td>毫秒级</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td></tr><tr><td>可用性</td><td>高（主从）</td><td>高（主从）</td><td>非常高（分布式）</td><td>非常高（分布式）</td></tr><tr><td>消息重复</td><td>至少一次</td><td>至少一次</td><td>至少一次 最多一次</td><td>至少一次最多一次</td></tr><tr><td>消息顺序性</td><td>有序</td><td>有序</td><td>有序</td><td>分区有序</td></tr><tr><td>支持主题数</td><td>千级</td><td>百万级</td><td>千级</td><td>百级，多了性能严重下滑</td></tr><tr><td>消息回溯</td><td>不支持</td><td>不支持</td><td>支持（按时间回溯）</td><td>支持（按offset回溯）</td></tr><tr><td>管理界面</td><td>普通</td><td>普通</td><td>完善</td><td>普通</td></tr></tbody></table><ul><li>对于大型秒杀场景，主要看吞吐量，选kafka和RocketMQ更好</li><li>如果做中台，对外提供能力，有很多主题接入，选RocketMQ和RabbitMQ</li><li>至于时效性，微妙和毫秒的差别并不大，加上网络的波动，在实际业务中反而不会作为重要的考量因素</li></ul><h3 id="消息队列的应用场景有哪些"><a class="markdownIt-Anchor" href="#消息队列的应用场景有哪些"></a> 消息队列的应用场景有哪些？</h3><ul><li>解耦：在多个系统之间进行解耦，将原本通过网络调用的方式改为通过消息队列进行异步调用</li><li>异步：一个操作如果分为多个步骤，可以把某些不需要同步的步骤放到消息队列中，比如下单后发送短信通知，修改用户积分等</li><li>削峰：比如秒杀场景，瞬间大量请求到来，可以先放入消息队列，然后系统根据自己的处理能力处理，同时跟进业务逻辑，给用户返回特定界面或稍后通知结果</li></ul><h3 id="消息丢失怎么解决"><a class="markdownIt-Anchor" href="#消息丢失怎么解决"></a> 消息丢失怎么解决？</h3><p>主要从生产者、MQ、消费者三个方面解决</p><ul><li>生产者：通过生产者确认机制，消息到达MQ后返回给生产者ack，返回异常可以考虑重发</li><li>MQ：RabbitMQ通过持久化消息或者懒队列，保证消息可靠性，kafka可以在多个节点保存消息的副本</li><li>消费者：通过消费者确认机制和失败重试机制，保证消费者的可靠性，如果达到重试次数，有3种处理方式：1. 丢弃消息，reject 2. 返回nack,消息重新入队列 3. 将消息发送到指定队列</li></ul><h3 id="消息队列的可靠性-顺序性怎么保证"><a class="markdownIt-Anchor" href="#消息队列的可靠性-顺序性怎么保证"></a> 消息队列的可靠性、顺序性怎么保证？</h3><p>可靠性：</p><ul><li>消息持久化</li><li>消费者确认机制</li><li>消费者失败重试机制</li></ul><p>顺序性：</p><ul><li>首先明确需要哪些业务需要保证顺序性，比如转账操作的顺序性</li><li>有的消息队列本身就支持顺序性，如kafka按照消息的key将消息分区，每个分区内的消息按照写入顺序被消费</li><li>此外，如果多个消费者消费同一个队列，或者多线程消费同一个分区，那么就无法保证顺序性了，可以使用单线程或者使用线程池对消息进行串行化处理</li></ul><h2 id="spring"><a class="markdownIt-Anchor" href="#spring"></a> Spring</h2><h3 id="spring的单例bean是线程安全的吗"><a class="markdownIt-Anchor" href="#spring的单例bean是线程安全的吗"></a> Spring的单例Bean是线程安全的吗？</h3><p>不是<br />Spring框架中有一个@Scope注解，默认就是单例的</p><ul><li>一般注入对象都是无状态（不可修改）的对象，没有线程安全问题</li><li>但是如果在Bean中定义了可修改的成员变量，就有可能出现线程安全问题</li></ul><h3 id="spring中的事务是如何实现的"><a class="markdownIt-Anchor" href="#spring中的事务是如何实现的"></a> Spring中的事务是如何实现的？</h3><p>Spring中提供两种事务实现方式，一种是编程式事务，一种是声明式事务</p><ul><li>编程式事务：通过TransactionTemplate实现，对业务代码有侵入性</li><li>声明式事务：通过AOP实现，对方法前后进行拦截，将事务处理逻辑织入到业务代码中</li></ul><h3 id="spring中事务的传播行为有哪些"><a class="markdownIt-Anchor" href="#spring中事务的传播行为有哪些"></a> Spring中事务的传播行为有哪些？</h3><p>支持当前事务的：</p><ul><li>required：如果当前没有事务，则新建事务，如果当前存在事务，则加入当前事务，默认传播级别</li><li>supports：如果当前没有事务，则以非事务方式执行，如果当前存在事务，则加入当前事务</li><li>mandatory：如果当前没有事务，则抛出异常，如果当前存在事务，则加入当前事务</li></ul><p>不支持当前事务的：</p><ul><li>requires_new：新建事务，如果当前存在事务，则挂起当前事务</li><li>not_supported：以非事务方式执行，如果当前存在事务，则挂起当前事务</li><li>never：以非事务方式执行，如果当前存在事务，则抛出异常</li><li>nested：如果当前没有事务，则新建事务，如果当前存在事务，则在嵌套事务中执行</li></ul><h3 id="事务失效的场景有哪些"><a class="markdownIt-Anchor" href="#事务失效的场景有哪些"></a> 事务失效的场景有哪些？</h3><ul><li>出现了未捕获的异常或者非受检异常比如RuntimeException (非受检异常是指在代码中可能出现的异常，但不需要显式地进行捕获或声明，比如空指针或者数组越界等)</li><li>事务的传播行为设置的不正确</li><li>多数据源情况下，事务管理没有正确配置</li><li>同一个类中方法内部调用</li><li>非public方法使用@Transactional注解会失效</li></ul><h3 id="为什么方法内部调用transactional注解会失效"><a class="markdownIt-Anchor" href="#为什么方法内部调用transactional注解会失效"></a> 为什么方法内部调用@Transactional注解会失效？</h3><p>答：@Transactional注解是基于AOP实现的，AOP又是通过动态代理来实现的，因为同一个类中方法内部调用时，是通过this调用的，this调用不会经过代理对象，所以代理对象的逻辑不会生效</p><h3 id="bean的生命周期"><a class="markdownIt-Anchor" href="#bean的生命周期"></a> Bean的生命周期？</h3><ul><li>通过构造函数实例化Bean</li><li>进行依赖注入</li><li>处理Aware接口</li><li>前置的BeanPostProcessor，用于处理Bean的初始化前的操作</li><li>初始化Bean，自定义init-method方法</li><li>后置的BeanPostProcessor，初始化后做一些增强</li><li>销毁Bean</li></ul><h3 id="bean的循环依赖怎么解决"><a class="markdownIt-Anchor" href="#bean的循环依赖怎么解决"></a> Bean的循环依赖怎么解决？</h3><p>循环依赖出现的原因是，如果A和B互相以来，当A到了依赖注入B的阶段，会去执行B的生命周期，此时B也要依赖注入A，这样就会造成循环依赖，这样导致双方都无法完成Bean的初始化。</p><p>通过三级缓存解决</p><ul><li>一级缓存：sigleton objects，单例池，存放走完生命周期的Bean</li><li>二级缓存：early singleton objects，存放半成品的Bean，生命周期还没走完</li><li>三级缓存：singleton factories，存放Bean的工厂，用来创建对象</li></ul><p>在A实例化后，会创建一个ObjectFactory，放入三级缓存中，当B需要注入A对象时，用A的ObjectFactory创建对象，并放入二级缓存，同时B获得A的对象后完成注入，然后B完成生命周期，放入单例池中，然后A也完成生命周期，放入单例池中</p><p>构造方法出现了循环依赖怎么办？<br />答：可以使用@Lazy注解，懒加载，等到需要使用的时候再去实例化对象，这样就不会出现循环依赖的问题了</p><h2 id="介绍一下cap和base理论"><a class="markdownIt-Anchor" href="#介绍一下cap和base理论"></a> 介绍一下CAP和BASE理论</h2><p>CAP分别对应了一致性、可用性和分区容错性</p><ul><li>一般分布式系统中都会涉及分区问题P</li><li>当分区出现时，一致性C和可用性A就无法同时满足</li></ul><p>BASE理论是CAP的一种解决思路，包括三个主要思想：</p><ul><li>基本可用性：系统在出现故障时，仍然可以提供部分服务</li><li>软状态：允许临时的不一致状态</li><li>最终一致性：系统在经过一段时间后，最终会达到一致状态</li></ul><h2 id="介绍一下tcc模式"><a class="markdownIt-Anchor" href="#介绍一下tcc模式"></a> 介绍一下TCC模式</h2><p>TCC是Try-Confirm-Cancel的缩写，是一种分布式事务解决方案</p><ul><li>Try：尝试执行，预留资源</li><li>Confirm：完成资源操作业务，try成功confirm一定要成功</li><li>Cancel：预留资源的释放，可理解为try反向操作</li></ul><p>与XA和AT模式不同的是，TCC模式每一步都需要代码手动实现</p><h2 id="定时任务有哪些实现方式"><a class="markdownIt-Anchor" href="#定时任务有哪些实现方式"></a> 定时任务有哪些实现方式？</h2><ul><li>单机定时任务：<ul><li>Timer</li><li>ScheduledThreadPoolExecutor</li><li>DelayQueue</li><li>spring task，也就是用@Scheduled注解实现的定时任务，支持cron表达式</li></ul></li><li>分布式定时任务：<ul><li>redis过期事件监听</li><li>redisson内置的延时队列</li><li>MQ的延时消息</li></ul></li><li>分布式任务调度框架<ul><li>Quartz，比较早的定时任务框架，缺点是不支持可视化管理，使用</li><li>xxl-job，使用广泛，开箱即用</li><li>power job，使用广泛，开箱即用</li></ul></li></ul><h2 id="认证授权"><a class="markdownIt-Anchor" href="#认证授权"></a> 认证授权</h2><h3 id="介绍一下rbac模型"><a class="markdownIt-Anchor" href="#介绍一下rbac模型"></a> 介绍一下RBAC模型？</h3><ul><li>RBAC意思是基于角色的权限访问控制（Role-Based Access Control）</li><li>在RBAC中，用户与角色、角色与权限之间，都构成了多对多的关系</li><li>一般在数据库中，RBAC模型除了有用户表、角色表、权限表外，还有用户角色表和角色权限表两张中间表</li></ul><h2 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h2><h3 id="负载均衡怎么分类"><a class="markdownIt-Anchor" href="#负载均衡怎么分类"></a> 负载均衡怎么分类？</h3><ul><li>服务端负载均衡：应用在系统外部请求和网关层之间，最常见的是四层负载均衡和七层负载均衡</li><li>客户端负载均衡：应用于系统内部的不同服务</li></ul><h3 id="四层负载均衡和七层负载均衡的区别"><a class="markdownIt-Anchor" href="#四层负载均衡和七层负载均衡的区别"></a> 四层负载均衡和七层负载均衡的区别？</h3><p>OSI模型从下到上共分为：</p><ul><li><p>物理层</p></li><li><p>数据链路层</p></li><li><p>网络层</p></li><li><p>传输层</p></li><li><p>会话层</p></li><li><p>表示层</p></li><li><p>应用层</p></li><li><p>四层负载均衡主要工作在OSI模型的第四层，也就是传输层，这一层主要是TCP和UDP协议，四层负载均衡主要是根据IP和端口进行负载均衡，不涉及具体的报文内容</p></li><li><p>七层负载均衡主要工作在OSI模型的第七层，也就是应用层，这一层主要是HTTP协议，七层负载均衡可以根据HTTP报文的内容进行负载均衡，执行七层负载均衡的设备被称为反向代理服务器</p></li><li><p>一般用LVS做四层负载均衡，用nginx做七层负载均衡</p></li></ul><h3 id="负载均衡算法有哪些"><a class="markdownIt-Anchor" href="#负载均衡算法有哪些"></a> 负载均衡算法有哪些？</h3><ul><li>随机，加权随机，两次随机</li><li>轮询，加权轮询，平滑的加权轮询</li><li>哈希，一致性哈希，普通哈希如果节点数量变化，会导致大部分节点哈希映射变化，一致性哈希将数据和节点都映射到一个环上，当增加或者删减节点的时候，请求会沿着环的顺时针方向找到第一个节点，也就是说，一致性哈希只会影响到相邻的后继节点，不会影响整个集群的哈希映射分布。<ul><li>但一致性哈希的问题是，如果节点分布不均匀，某个节点可能请求过多，导致负载不均衡，解决方法是增加虚拟节点，使分布更加均匀</li></ul></li><li>最少连接数、最少活跃连接数、最快响应等</li></ul><h3 id="七层负载均衡可以怎么做"><a class="markdownIt-Anchor" href="#七层负载均衡可以怎么做"></a> 七层负载均衡可以怎么做？</h3><ul><li>DNS解析：用户请求域名，DNS服务器解析成IP地址，返回给用户</li><li>Nginx反向代理：用户将请求发送到nginx，nginx根据负载均衡算法将请求转发到后端服务器</li></ul><h1 id="cs基础"><a class="markdownIt-Anchor" href="#cs基础"></a> CS基础</h1><h2 id="进程和线程的区别"><a class="markdownIt-Anchor" href="#进程和线程的区别"></a> 进程和线程的区别</h2><blockquote><p>进程是资源分配的基本单位，线程是资源调度的基本单位(轻量级进程)</p></blockquote><ul><li>多个线程共享地址空间/资源，而进程之间的地址空间/资源是独立的</li><li>一个线程只能属于一个进程，一个进程可以有多个线程</li><li>创建/撤销线程的系统开销明显小于进程</li></ul><h2 id="硬链接和软链接的区别"><a class="markdownIt-Anchor" href="#硬链接和软链接的区别"></a> 硬链接和软链接的区别</h2><h3 id="硬链接"><a class="markdownIt-Anchor" href="#硬链接"></a> 硬链接</h3><ul><li>在 Linux/类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。</li><li>硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删。</li><li>只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。</li><li>硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。</li><li><code>ln</code> 命令用于创建硬链接。</li></ul><h3 id="软链接符号链接"><a class="markdownIt-Anchor" href="#软链接符号链接"></a> 软链接（符号链接）</h3><ul><li>软链接和源文件的 inode 节点号不同，而是指向一个文件路径。</li><li>源文件删除后，软链接依然存在，但是指向的是一个无效的文件路径。</li><li>软连接类似于 Windows 系统中的快捷方式。</li><li>不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，软链接可以跨越文件系统。</li><li>ln -s 命令用于创建软链接</li></ul><h3 id="为什么硬连接不能跨文件系统"><a class="markdownIt-Anchor" href="#为什么硬连接不能跨文件系统"></a> 为什么硬连接不能跨文件系统？</h3><ul><li>硬链接是通过 inode 节点号建立连接的，而硬链接和源文件共享相同的 inode 节点号。</li><li>然而，每个文件系统都有自己的独立 inode 表，且每个 inode 表只维护该文件系统内的 inode。</li><li>如果在不同的文件系统之间创建硬链接，可能会导致 inode 节点号冲突的问题，即目标文件的 inode 节点号已经在该文件系统中被使用。</li></ul><h2 id="动态编译和静态编译"><a class="markdownIt-Anchor" href="#动态编译和静态编译"></a> 动态编译和静态编译</h2><h3 id="静态编译"><a class="markdownIt-Anchor" href="#静态编译"></a> 静态编译</h3><p>在编译时将程序与其所有依赖项（包括库）链接在一起，形成一个单独的可执行文件。这个可执行文件包含了所有代码和数据，因此它是一个完全独立的二进制文件。</p><p>静态编译启动速度快，不需要依赖外部库，但可执行文件体积较大。</p><h3 id="动态编译运行时编译"><a class="markdownIt-Anchor" href="#动态编译运行时编译"></a> 动态编译(运行时编译)</h3><p>在编译时只创建程序的框架，而不将所有依赖项包含在可执行文件中。实际的库文件是在运行时加载的，程序在需要时动态链接到这些库。</p><h2 id="tcp三次握手"><a class="markdownIt-Anchor" href="#tcp三次握手"></a> TCP三次握手</h2><h3 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h3><p>三次握手的过程如图：<br /><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" alt="三次握手" /></p><ul><li>一次握手:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&gt; 服务端，然后客户端进入 SYN_SEND 状态，等待服务端的确认；</li><li>二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 SYN_RECV 状态；</li><li>三次握手:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务端都进入ESTABLISHED 状态，完成 TCP 三次握手。</li></ul><h3 id="为什么要三次握手"><a class="markdownIt-Anchor" href="#为什么要三次握手"></a> 为什么要三次握手？</h3><p>三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><ul><li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li></ul><h3 id="第二次发送了ack为什么还要发送syn"><a class="markdownIt-Anchor" href="#第二次发送了ack为什么还要发送syn"></a> 第二次发送了ACK，为什么还要发送SYN？</h3><p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p><h3 id="三次握手过程可以携带数据吗"><a class="markdownIt-Anchor" href="#三次握手过程可以携带数据吗"></a> 三次握手过程可以携带数据吗？</h3><p>在 TCP 三次握手过程中，第三次握手是可以携带数据的(客户端发送完 ACK 确认包之后就进入 ESTABLISHED 状态了)</p><p>如果第三次握手的 ACK 确认包丢失，但是客户端已经开始发送携带数据的包，那么服务端在收到这个携带数据的包时，如果该包中包含了 ACK 标记，服务端会将其视为有效的第三次握手确认。这样，连接就被认为是建立的，服务端会处理该数据包，并继续正常的数据传输流程。</p><h2 id="tcp四次挥手"><a class="markdownIt-Anchor" href="#tcp四次挥手"></a> TCP四次挥手</h2><h3 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h3><p>TCP 四次挥手的过程如图：<br /><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png" alt="四次挥手" /></p><ul><li>第一次挥手：客户端发送一个 FIN（SEQ=x） 标志的数据包-&gt;服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 FIN-WAIT-1 状态。</li><li>第二次挥手：服务端收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包-&gt;客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。</li><li>第三次挥手：服务端发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。</li><li>第四次挥手：客户端发送 ACK (ACK=y+1)标志的数据包-&gt;服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li></ul><blockquote><p>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</p></blockquote><h3 id="为什么要四次挥手"><a class="markdownIt-Anchor" href="#为什么要四次挥手"></a> 为什么要四次挥手？</h3><p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后。</p><ul><li>第一次挥手：A 说“我没啥要说的了”</li><li>第二次挥手：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li><li>第三次挥手：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li><li>第四次挥手：A 回答“知道了”，这样通话才算结束</li></ul><h3 id="为什么服务端不把-ack-和-fin-一起发送变成三次挥手"><a class="markdownIt-Anchor" href="#为什么服务端不把-ack-和-fin-一起发送变成三次挥手"></a> 为什么服务端不把 ACK 和 FIN 一起发送，变成三次挥手？</h3><p>因为服务端收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务端到客户端的数据传送。</p><h3 id="第二次挥手服务端发送ack没有到达会怎么样"><a class="markdownIt-Anchor" href="#第二次挥手服务端发送ack没有到达会怎么样"></a> 第二次挥手服务端发送ACK没有到达会怎么样？</h3><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p><h3 id="为什么第四次挥手客户端要等待-2msl报文最长存活时间才进入closed状态"><a class="markdownIt-Anchor" href="#为什么第四次挥手客户端要等待-2msl报文最长存活时间才进入closed状态"></a> 为什么第四次挥手，客户端要等待 2MSL（报文最长存活时间）才进入CLOSED状态？</h3><p>第四次挥手时，客户端发送给服务端的 ACK 有可能丢失。</p><ul><li>如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN</li><li>如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</li></ul><h1 id="c"><a class="markdownIt-Anchor" href="#c"></a> C++</h1><h2 id="c中的static关键字"><a class="markdownIt-Anchor" href="#c中的static关键字"></a> c++中的static关键字</h2><p>加载顺序（面向对象）</p><ul><li>静态-&gt;非静态-&gt;构造方法</li><li>父类静态-子类静态-父类非静态-父类构造-子类非静态-子类构造</li></ul><p>静态成员变量(面向对象)</p><ul><li>所有对象共享,不属于某个对象，可以通过类名访问，也可通过对象访问</li><li>在编译阶段分配内存，分配在数据区（全局区）</li><li>类内声明，类外初始化(class::var)</li><li>sizeof不会计算静态成员变量</li></ul><p>静态成员函数(面向对象)</p><ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li><li>不含this指针(不能被实例使用)</li></ul><p>静态全局变量(面向过程)</p><ul><li>在数据区分配内存</li><li>未初始化会自动初始化为0</li><li>整个文件内可见，文件外不可见</li></ul><p>静态局部变量(面向过程)</p><ul><li>在数据区分配内存</li><li>一般在声明处初始化，未初始化会自动初始化为0</li><li>静态局部变量始终驻留在数据区，但他的作用域是局部作用域，当定义它的函数或语句块结束，其作用域随之结束</li></ul><blockquote><p>总结：静态变量具有全局变量的生命周期，但只能作用于自己的作用域。</p></blockquote><hr /><h2 id="c模板"><a class="markdownIt-Anchor" href="#c模板"></a> c++模板</h2><blockquote><p>模板是c++泛型编程的主要使用的技术</p></blockquote><p><strong>函数模板</strong></p><p>创建一个通用的函数，函数返回值类型和形参可以不指定，用一个虚拟的类型来表示</p><p>声明一个模板<code>template&lt;typename T&gt;</code>或者<code>template&lt;class T&gt;</code></p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">double</span> a=<span class="hljs-number">10.5</span>,b=<span class="hljs-number">20.00002</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;自动类型推导&quot;</span>&lt;&lt;endl;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,<span class="hljs-built_in">sum</span>(a,b));<br>cout&lt;&lt;<span class="hljs-string">&quot;显示指定类型&quot;</span>&lt;&lt;endl;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,<span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">double</span>&gt;(a,b));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>注意</p><ul><li>自动推导类型需要推导出一致的类型</li><li>函数模板使用时必须确定<code>T</code>的类型</li><li>普通函数和函数模板都可调用时，先调用普通函数</li><li>如果类型和函数模板更匹配，则优先调用函数模板</li></ul><p><strong>类模板</strong></p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">M</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>T name;<br>M age;<br><span class="hljs-built_in">person</span>(T a,M b):<span class="hljs-built_in">name</span>(a),<span class="hljs-built_in">age</span>(b)&#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;cndh&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>cout&lt;&lt;p.name&lt;&lt;endl;<br>cout&lt;&lt;p.age&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>类模板不能自动推导类型</li><li>类模板可以在模板参数列表中指定默认类型</li><li>类模板中定义的函数在调用时才创建</li></ul><hr /><h2 id="c深拷贝和浅拷贝的区别"><a class="markdownIt-Anchor" href="#c深拷贝和浅拷贝的区别"></a> c++深拷贝和浅拷贝的区别</h2><blockquote><p><strong>浅拷贝</strong> （默认方式）：将原对象的引用直接赋给新对象，只是原对象的一个引用。</p></blockquote><blockquote><p><strong>深拷贝</strong>： 创建一个新的对象，将原对象的各项属性拷贝过来，深拷贝会在堆中额外申请内存来储存数据，当数据成员中有指针时，必须要用深拷贝。</p></blockquote><ul><li>因为申请了新的内存，所以深拷贝改变新对象的属性对原对象没有影响，但是浅拷贝会影响</li><li>当成员中有指针时，必须用深拷贝。因为浅拷贝的新指针和旧指针都指向同一块内存，在新对象和旧对象析构时，已经释放的内存会被再次释放，这时会出现错误。</li></ul><hr /><h2 id="c多态"><a class="markdownIt-Anchor" href="#c多态"></a> c++多态</h2><p>编译时多态：</p><ul><li>编译器多态是通过函数重载和模板实现的。在编译时，根据函数的参数类型或模板参数类型，编译器会选择合适的函数或模板实例化。</li><li>编译器多态是在编译时确定函数调用，因此它的性能较高。</li><li>编译器多态不需要使用虚函数和基类指针或引用，可以直接根据函数的参数类型或模板参数类型来确定函数调用。</li></ul><p>运行时多态：</p><ul><li>运行时多态是通过继承和虚函数实现的。当基类的指针或引用指向派生类对象时，通过虚函数的动态绑定，可以在运行时确定要调用的函数实现。</li><li>运行时多态需要使用虚函数和基类指针或引用来实现，这样可以在运行时根据实际对象的类型来确定调用哪个函数。</li><li>运行时多态在运行时才能确定具体的函数调用，因此它的性能相对较低。</li></ul><p><em><strong>override的作用</strong></em></p><p>保证在派生类中声明的重载函数，与基类的虚函数有相同的签名，核心作用就是用于编译期代码检查。</p><p><em><strong>final</strong></em></p><p>阻止类的进一步派生和虚函数的进一步重写，同时也是一种名为去虚拟化的优化技巧，相当于把运行期多态转换为了编译期多态，提高了执行效率。</p><p><em><strong>多继承存在的问题</strong></em></p><p>命名冲突</p><p><em><strong>向上转型</strong></em></p><p>向上转型是子类指针转换成父类指针</p><p><code>Parent* p =new son();</code></p><p><em><strong>向下转型</strong></em></p><p>因为父类指针不能操作子类独有的函数，即使父类指针指向子类的对象也不行，所以需要向下转型</p><p>向下转型有两种方式<code>dynamic_cast</code>和<code>static_cast</code>,前者更加安全一些</p><p>例如：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">Parent* pS<span class="hljs-keyword">on</span>=new S<span class="hljs-keyword">on</span>();<br>S<span class="hljs-keyword">on</span>* s=dynamic_cast<span class="hljs-variable">&lt;Son*&gt;</span>(pS<span class="hljs-keyword">on</span>);<br></code></pre></td></tr></table></figure><hr /><h2 id="虚函数与纯虚函数"><a class="markdownIt-Anchor" href="#虚函数与纯虚函数"></a> 虚函数与纯虚函数</h2><p><strong>虚函数</strong><br />在类中声明时前面带有virtual关键字的函数，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">example</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>纯虚函数</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">在虚函数后面加`=<span class="hljs-number">0</span>`<br><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">example</span>()</span> = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>虚函数可以在父类中实现，也可以被子类重写实现，是实现运行时多态的方式之一</li><li>纯虚函数不可以在父类实现，必须由子类重写</li><li>含有纯虚函数的类被称为抽象类，抽象类不能实例化</li><li>抽象类的子类如果要实例化，则必须重写纯虚函数</li></ul><p><strong>虚函数怎么实现的？真的更慢吗？</strong></p><ul><li>虚函数是通过虚函数表实现的，每个类都有自己的虚表，对象的首地址处存放有指向虚表的指针。</li><li>当具体调用哪个虚函数可以在编译期间确定的时候，虚函数不一定更慢。</li></ul><h2 id="c智能指针"><a class="markdownIt-Anchor" href="#c智能指针"></a> c++智能指针</h2><p><strong>内存泄漏</strong>：</p><ul><li><p>指因某些原因造成程序未能释放已不再使用的内存。内存泄漏并不是内存消失了，而是由于程序设计的问题，失去对某块内存的控制，导致无法利用该块内存。</p></li><li><p>内存泄漏会导致程序响应越来越慢，甚至崩溃</p></li><li><p>一般有2种内存泄漏，一种是堆区分配的内存没有及时释放，一种是套接字、文件描述符等没有释放，2种情形都会导致资源的浪费</p></li></ul><p><strong>RALL</strong></p><ul><li>RAII（Resource Acquisition Is Initialization）是一种将对象生命周期和资源绑定的技术</li><li>对象创建时获取资源，析构时释放资源</li></ul><p>智能指针就具有RALL的特性</p><p><strong>auto_ptr</strong></p><p>c++98中就已经提供了智能指针auto_ptr</p><p>例如：<code>auto_ptr&lt;int&gt; p(new int)</code>就相当于 <code>int * p=new int</code></p><p>auto_ptr的局限性：</p><ul><li>拷贝或者赋值会导致原指针变为<code>NULL</code>，如<code>p1=p2</code>后，<code>p2变成了NULL</code></li><li>不支持对象数组的内存管理</li></ul><p><strong>unique_ptr</strong></p><p>不能直接进行赋值或者拷贝构造，如：<code>p1 = p2</code>和<code>unique_ptr&lt;int&gt; p1(p2)</code></p><p>如果要强行执行的话要加上<code>move</code>，如：<code>p1 = std::move(p2)</code>和<code>unique_ptr&lt;int&gt; p1(std::move(p2))</code></p><p><strong>shared_ptr</strong></p><p>通过<strong>引用计数</strong>(<code>use_count()</code>)的方式来实现多个<code>shared_ptr</code>对象之间共享资源</p><ul><li>shared_ptr在其内部，给每个资源都有一份计数表，用来记录该份资源被几个指针共享</li><li>在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一</li><li>如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源</li><li>如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了</li></ul><p>注意：两个对象交叉使用<strong>shared_ptr</strong>(互相获得对方的share指针),会导致内存泄漏</p><p><strong>weak_ptr</strong></p><p>专门为了解决上面的<strong>shared_ptr</strong>的问题，不支持RALL，不释放资源，不增加或减少引用计数</p><p>具体参考<a href="https://blog.csdn.net/cpp_learner/article/details/118912592?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166191088916782414982504%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166191088916782414982504&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118912592-null-null.142%5Ev42%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=c%2B%2B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4187">相关链接</a></p><hr /><h2 id="const-和-volatile辨析"><a class="markdownIt-Anchor" href="#const-和-volatile辨析"></a> const 和 volatile辨析</h2><p><strong>const</strong></p><ul><li>被const修饰的变量被视为一个常量，使得变量具有只读属性</li><li>const修饰的变量不是一个真正的只读变量，它只是告诉编译器该变量<strong>不能出现在赋值符号的左边</strong></li></ul><p><em><strong>const修饰指针变量有以下3种情况</strong></em></p><ol><li>const 修饰指针指向的内容，则内容为不可变量。</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const int *p <span class="hljs-operator">=</span> <span class="hljs-number">8</span><span class="hljs-comment">; //指向的内容8不可变</span><br>*p<span class="hljs-operator">=</span><span class="hljs-number">6</span><span class="hljs-comment">; //错误</span><br></code></pre></td></tr></table></figure><ol start="2"><li>const 修饰指针，则指针不可变</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a=<span class="hljs-number">8</span>;<br><span class="hljs-built_in">int</span>* <span class="hljs-keyword">const</span> p = &amp;a;<br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-built_in">int</span>  b = <span class="hljs-number">7</span>;<br>p = &amp;b; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><ol start="3"><li>const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。</li></ol><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a = <span class="hljs-number">8</span>, b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> * <span class="hljs-keyword">const</span>  p = &amp;a;<br>*p=<span class="hljs-number">1</span>; <span class="hljs-comment">//错误</span><br>p=&amp;b; <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure><p><em><strong>const 修饰对象和成员函数</strong></em></p><ul><li>被const修饰的对象(常对象)或者成员函数(常函数)内不能修改类的成员变量，如果要修改需要给对应的成员变量加mutable关键字</li><li>常对象只能修改常函数</li></ul><p><strong>volatile</strong></p><p>本意为易变的，有以下特点</p><ul><li>volatile指出变量是随时可能变化的，每次使用需要重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。</li><li>被volatile修饰的变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</li></ul><blockquote><p><em><strong>一个变量可以同时被const和volatile修饰吗？</strong></em></p></blockquote><p>可以。const volatile表示一个变量在程序编译期不能被修改且不能被优化；在程序运行期，每次必须从内存中加载变量的值。</p><h2 id="null-和-nullptr的区别是什么为什么引入nulllptr"><a class="markdownIt-Anchor" href="#null-和-nullptr的区别是什么为什么引入nulllptr"></a> NULL 和 nullptr的区别是什么，为什么引入nulllptr？</h2><ul><li>主流编译器中，<code>NULL</code>实际上是一个整数常量，被定义为 0，在 C++11 之前，当我们想要将一个指针初始化为空时，我们通常使用 NULL；</li><li><code>nullptr</code> 是 C++11 中引入的新的关键字，专门用于表示空指针，它不是整数类型，而是特殊的指针类型<code>nullptr_t</code>。</li></ul><p><em><strong>引入nullptr的原因</strong></em></p><ol><li>NULL是整数类型，用户调用foo(NULL)的时候，不能区分调用的是foo(int)还是foo(int*)函数；</li><li>主流编译器中NULL值为0，通过0表示一个无效地址，但是有的架构下，0地址有特定用途，而<code>nullptr</code>指向的永远是一个无效地址。</li></ol><h2 id="git-fetch和git-pull的区别"><a class="markdownIt-Anchor" href="#git-fetch和git-pull的区别"></a> git fetch和git pull的区别</h2><ul><li>git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</li><li>而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</li></ul><blockquote><p>git 连接/添加远程仓库<br />git remote add 仓库名 地址</p></blockquote><h2 id="delete是怎样知道数组长度的"><a class="markdownIt-Anchor" href="#delete是怎样知道数组长度的"></a> delete[]是怎样知道数组长度的？</h2><p>没有标准实现，一种常见的实现方法是，申请内存时，会在返回的指针前面存放这段内存的大小，调用delete[]的时候，就可以知道数组长度了。</p><h2 id="程序是从main-函数开始执行的吗"><a class="markdownIt-Anchor" href="#程序是从main-函数开始执行的吗"></a> 程序是从main 函数开始执行的吗？</h2><p>不是，程序在执行前，会经历一个从磁盘加载程序到内存的过程，这个过程会执行非静态全局变量的初始化。</p><h1 id="python"><a class="markdownIt-Anchor" href="#python"></a> python</h1><h2 id="python的垃圾回收机制"><a class="markdownIt-Anchor" href="#python的垃圾回收机制"></a> python的垃圾回收机制</h2><blockquote><p>python采用的是<strong>引用计数</strong>为主，<strong>标记—清除</strong>和<strong>分代收集</strong>为辅的策略。</p></blockquote><p><strong>引用计数</strong><br />每个对象维护一个字段来记录对象被引用的次数，当新的引用指向该对象的时候，引用计数的值加1,当某个引用失效时，引用计数值减一。当引用计数的值为0时，会释放占用的内存空间。</p><p>缺点：</p><ul><li>需要额外的空间维护引用次数</li><li>对象的循环引用会导致内存泄漏</li></ul><p>引用计数增加的情况：</p><ul><li>对象被创建，例如 a = 23</li><li>对象被引用，例如 b = a</li><li>对象被作为参数，传入到一个函数中，例如 fun(a)</li><li>对象被作为一个元素，存储在容器中</li></ul><p>引用计数减少的情况：</p><ul><li>对象的别名被显式销毁，例如 del a</li><li>对象的别名被赋予新的对象，例如 a = 24</li><li>一个对象离开它的作用域，例如 f 的函数执行完毕时，func函数中的局部变量</li><li>对象所在的容器被销毁，或从容器中删除对象</li></ul><p><strong>分代回收</strong></p><ul><li><p>分代回收是一种以空间换时间的方式，Python将内存根据对象的存活时间划分为不同的集合，每一个集合称为一个代，Python将内存分为了3“代”，分别代表<strong>年轻代</strong>（第0代）、<strong>中年代</strong>（第1代）、<strong>老年代</strong>（第2代），它们对应的是3个链表，它们的垃圾收集频率随着对象的存活时间的增大而减小</p></li><li><p>新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾回收机制就会被触发，把那些可以被回收的对象被回收掉，而那些不会被回收的对象就会被移动到中年代，依次类推， 老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期中。</p></li></ul><p><strong>标记–清除</strong></p><p>是一种基于追踪回收（tracking GC）技术实现的垃圾回收算法。它分为两个阶段：</p><ol><li>标记阶段，GC会把所有的活动对象打上标记</li><li>把那些没有标记的对象（非活动对象）进行回收</li></ol><p><strong>如何判断哪些是活动对象，哪些是非活动对象？</strong></p><p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从跟对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。</p><h1 id="deep-learning"><a class="markdownIt-Anchor" href="#deep-learning"></a> deep learning</h1><h2 id="判别模型和生成模型"><a class="markdownIt-Anchor" href="#判别模型和生成模型"></a> 判别模型和生成模型</h2><p>判别模型：直接学习条件概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(y|x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><br />生成模型：学习联合概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，然后可以计算条件概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(y|x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>以及其他信息，需要的数据量较大</p><p>简单说，要判断一个苹果是好是坏，判别模型会直接给出是好的概率和是坏的概率，而生成模型分别学习出两种苹果各自对应的模型，然后将要预测的苹果的特征分别输入不同模型，然后比较两个模型输出概率的大小，选出合适的类别</p><p>判别模型：</p><ul><li>感知机</li><li>k近邻</li><li>决策树</li><li>逻辑思蒂回归</li><li>svm</li><li>boosting</li><li>最大熵模型</li></ul><p>生成模型：</p><ul><li>朴素贝叶斯</li><li>混合高斯模型</li><li>隐马尔可夫模型</li></ul><h2 id="转置卷积和空洞卷积"><a class="markdownIt-Anchor" href="#转置卷积和空洞卷积"></a> 转置卷积和空洞卷积</h2><p><em><strong>转置卷积</strong></em></p><blockquote><p>在语义分割中，会使用卷积层进行特征提取，然后通过转置卷积做上采样，恢复为原先的尺寸，这样才可以对原来的图像中每个像素都进行分类。<strong>转置卷积不是卷积的逆运算</strong></p></blockquote><p>基本步骤：</p><ul><li>在特征图<strong>中间</strong>(元素和元素之间)填充s-1行，s为步长</li><li>在特征图<strong>四周</strong>填充k-p-1行，k为卷积核大小，p为padding</li><li>将kernel上下、左右翻转（中心对称，顺时针旋转180度）</li><li>做kernel_size不变，s和p均为1的卷积即可</li></ul><p><em><strong>空洞卷积</strong></em></p><ul><li>在卷积核相邻元素之间插入0,具体插入膨胀率(dilation rate)-1个0，然后再做卷积</li><li>主要目的是扩大感受野</li></ul><h2 id="数据集不平衡的处理方式"><a class="markdownIt-Anchor" href="#数据集不平衡的处理方式"></a> 数据集不平衡的处理方式</h2><ol><li>数据增广<ul><li>进行一定的旋转缩放</li><li>RGB三通道提取三张图片</li><li>高斯模糊</li></ul></li><li>人工合成数据</li><li>给每种类别赋予权值，样本少的类别权值可以大一些，样本多的类别权值小一些</li></ol><h2 id="tensorflow和pytorch的区别"><a class="markdownIt-Anchor" href="#tensorflow和pytorch的区别"></a> tensorflow和pytorch的区别</h2><ol><li>tf是谷歌开源的深度学习框架，pytorch是facebook开源的深度学习框架</li><li>在tf1.0时，tf只支持静态的计算图，而pytorch支持动态的计算图，但是tf2.0也支持动态计算图了</li><li>tf的api更详细更丰富，pytorch的代码更简洁</li><li>tf有tensorboard这样的可视化工具，但实际上现在pytorch也能使用tensorboard</li></ol><h2 id="transformer中的位置编码"><a class="markdownIt-Anchor" href="#transformer中的位置编码"></a> transformer中的位置编码</h2><blockquote><p>为什么需要位置编码？</p></blockquote><ul><li>位置和词语的顺序是任何语言的重要组成部分。它们定义了语法，从而决定了句子的实际语义。循环神经网络（RNN）本质上考虑了词语的顺序；它们按照顺序逐个解析句子中的词语。这样可以将词语的顺序整合到RNN的主干中。</li><li>Transformer架构放弃了循环机制，转而采用<strong>多头自注意机制</strong>，大大加快训练时间。从理论上讲，它可以捕捉到句子中更长的依赖关系。由于句子中的<strong>每个词语同时通过Transformer的编码器/解码器，模型本身对于每个词语的位置/顺序没有任何概念。</strong></li></ul><blockquote><p>位置编码的计算？</p></blockquote><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mover accent="true"><msub><mi>p</mi><mi>t</mi></msub><mo stretchy="true">→</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><msup><mo stretchy="false">)</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>:</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>k</mi></msub><mi mathvariant="normal">.</mi><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mtext> </mtext></mrow><mi>i</mi><mo>=</mo><mn>2</mn><mi>k</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>k</mi></msub><mi mathvariant="normal">.</mi><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mtext> </mtext></mrow><mi>i</mi><mo>=</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\left.\overrightarrow{p_t}^{(i)}=f(t)^{(i)}:=\left\{\begin{array}{ll}\sin(\omega_k.t),&amp;\mathrm{if~}i=2k\\\cos(\omega_k.t),&amp;\mathrm{if~}i=2k+1\end{array}\right.\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9525600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span class="svg-align" style="top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.23046em;"><span style="top:-3.40546em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mspace nobreak"> </span></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">i</span><span class="mord mathrm" style="margin-right:0.07778em;">f</span><span class="mspace nobreak"> </span></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中，t代表位置，i代表维度。p代表第t个位置，第i个维度的值。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\omega_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的计算如下：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>ω</mi><mi>k</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1000</mn><msup><mn>0</mn><mrow><mn>2</mn><mi>k</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\omega_k=\frac1{10000^{2k/d}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.0254399999999997em;vertical-align:-0.704em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2960000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.814em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">/</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.704em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>有以下特点：</p><ul><li>奇数维度之间或者偶数维度之间周期不同。</li><li>除了表示绝对位置信息外，还可以很好的表示相对位置信息。给定k,存在一个固定的与k相关的线性变换矩阵，从而由pos的位置编码线性变换而得到pos+k的位置编码。这个相对位置信息可能可以被模型发现而利用。因为绝对位置信息只保证了各个位置不一样，但是并不是像0,1,2这样的有明确前后关系的编码。</li></ul><blockquote><p>CV中使用位置编码</p></blockquote><p>与nlp中类似，cv中的每个像素和patch也有自己的位置信息，通常cv中位置编码有以下两种：</p><ul><li>绝对位置编码：一般是可学习的，实现非常简洁，初始化一个形状和经过patch_embedding后的输出x相同的参数，然后直接加到x上，在训练阶段一起训练，有点像加了一个可学习的bias，VIT中使用的就是这种方式。</li><li>相对位置编码：绝对位置编码是在patch_embedding之后，计算自注意力(Q,K,V)之前，而相对位置编码是在计算自注意力的时候加入的，如下式</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Attention</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>SoftMax</mtext><mo stretchy="false">(</mo><mfrac><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><msqrt><mi>d</mi></msqrt></mfrac><mo>+</mo><mi>B</mi><mo stretchy="false">)</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\text{Attention}(Q,K,V)=\text{SoftMax}(\frac{QK^T}{\sqrt{d}}+B)V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Attention</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.448331em;vertical-align:-0.93em;"></span><span class="mord text"><span class="mord">SoftMax</span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.17778em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.93222em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">d</span></span></span><span style="top:-2.89222em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.10777999999999999em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p><p>在swin transformer中，将二维位置信息转换为一维位置信息，然后去根据相对位置偏移表查询具体的值，位置偏移表的值是训练出来的，在文章中，相对位置编码效果好于绝对位置编码。具体参考<a href="https://blog.csdn.net/qq_43733107/article/details/127077056">这里</a></p><blockquote><p>为什么往往小数据集上卷积效果好于tranformer?</p></blockquote><ul><li>在小数据集上，相比卷积transformer缺少内在偏置，因此需要加入相对位置编码来解决这个问题，而对于特大数据集，transformer就可以学习到卷积的内在偏置，即这也是为什么在小数据集上transformer的效果不如卷积，而在大数据集上，transformer效果优于卷积。</li></ul><h2 id="自注意力和注意力的区别"><a class="markdownIt-Anchor" href="#自注意力和注意力的区别"></a> 自注意力和注意力的区别</h2><p>注意力机制的查询和键是不同来源的，而自注意力机制的查询和键则都是来自于同一组的元素，如对于一张图片，q和k都来自于这张图片的patch或者特征。</p><blockquote><p>个人对于DETR的decoder中的q，k,v的理解</p></blockquote><p>query是每张图设置的预测的proposals的数量，例如一张图的gt有20个bbox，然后query为100，那么网络会产生100个proposals，然后用匈牙利算法求得100个query和20个bbox的最优匹配</p><p>对于decoder的多头注意力，我理解的是kv来自encoder是因为encoder中将图像的特征进行了编码，然后由于需要产生100个proposals，所以就用外部的q来计算encoder产生的k的权重信息，比如qk^T-&gt;[16,100,32]*[16,32,576]=[16,100,576]，这里[100,576]代表了100个query在576个特征上的权重或者相似度信息，然后乘v[16,576,32]，输出是[16,100,32]，reshape为[100,2,256]，encoder的输出[576,2,256]经过decoder后映射为[100,2,256]，因此加入的query可能是为了学习encoder的输出中的特征信息，然后将特征的维度降到100，然后从这100个proposals中取匹配最佳的gt。</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/08/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/08/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a></li><li><a href="#%E9%80%92%E5%BD%92%E7%9A%84%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9%E7%9A%84%E7%A5%96%E5%85%88">递归的查找节点的祖先</a></li><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li></ul><!-- /TOC --><h3 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h3><blockquote><p>通过一个数组来保存各个节点的祖先，所有连通的节点的祖先相同，常用于解决最小生成树，图的连通性等问题</p></blockquote><h3 id="递归的查找节点的祖先"><a class="markdownIt-Anchor" href="#递归的查找节点的祖先"></a> 递归的查找节点的祖先</h3><p>首先假设有<code>N</code>个节点，定义一个数组<code>vset[N]</code>记录所有节点的祖先，<code>vset[N]初始化为-1</code></p><p>定义一个<code>find</code>函数来查找祖先</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> <span class="hljs-keyword">find</span>(<span class="hljs-keyword">int</span> a)<br>&#123;<br>    <span class="hljs-keyword">if</span>(vset[a]==-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        vset[a]=<span class="hljs-keyword">find</span>(vset[a]);<br>        <span class="hljs-keyword">return</span> vset[a];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p>有<code>n</code>条道路，<code>m</code>个村庄,计算出使所有村庄连通的最低成本</p><p>输入n,m，然后输入n行，每一行输入u,v,w表示两个村庄的编号和道路成本</p><p>输出使所有村庄连通的最低成本</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1000</span>;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; vi;<br><span class="hljs-type">int</span> vset[<span class="hljs-number">1000</span>];<br><span class="hljs-function">vector&lt;vi&gt; <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-number">1000</span>,vi(<span class="hljs-number">3</span>))</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(vset[a]==<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        vset[a]=<span class="hljs-built_in">find</span>(vset[a]);<br>        <span class="hljs-keyword">return</span> vset[a];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(vset,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(vset));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;e[i][<span class="hljs-number">0</span>]&gt;&gt;e[i][<span class="hljs-number">1</span>]&gt;&gt;e[i][<span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(e.<span class="hljs-built_in">begin</span>(),e.<span class="hljs-built_in">end</span>(),[](vi a,vi b)&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>]&lt;b[<span class="hljs-number">2</span>];<br>    &#125;);<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(vi&amp; t: e)<br>    &#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">find</span>(t[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> y=<span class="hljs-built_in">find</span>(t[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span>(x!=y)<br>        &#123;<br>            ++cnt;<br>            ans+=t[<span class="hljs-number">2</span>];<br>            vset[x]=y;<br>            <span class="hljs-keyword">if</span>(cnt==n<span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重排链表</title>
    <link href="/2022/08/25/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/08/25/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8">重排链表</a></li><li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">反转链表</a></li><li><a href="#%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8">合并链表</a></li><li><a href="#%E9%A2%98%E8%A7%A3">题解</a></li></ul><!-- /TOC --><h3 id="重排链表"><a class="markdownIt-Anchor" href="#重排链表"></a> 重排链表</h3><blockquote><p>来源于leetcode上的一道题 <a href="https://leetcode.cn/problems/reorder-list/">重排链表</a>，因为这到题涉及到许多链表的知识，正好拿来复习一下</p></blockquote><p>题目描述</p><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：<br /><code>L0 → L1 → … → Ln - 1 → Ln</code></p><p>请将其重新排列后变为：</p><p><code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</code></p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><ul><li>先找到链表的中点</li><li>将链表后半段反转</li><li>将前后两端重新合并</li></ul><h3 id="找到链表中点快慢指针"><a class="markdownIt-Anchor" href="#找到链表中点快慢指针"></a> 找到链表中点（快慢指针）</h3><blockquote><p>设置两个指针，其中快的指针每次移动2次，慢指针移动一次，当快指针到达尾部，慢指针的位置就是中点</p></blockquote><p>代码：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autoit">ListNode* middleNode(ListNode* head) &#123;<br>        ListNode *low=head<span class="hljs-comment">;</span><br>        ListNode *fast=head<span class="hljs-comment">;</span><br>        //如果有偶数个节点，以下条件找到的是右侧中点<br>        //如果要找左侧中点，改为：fast-&gt;<span class="hljs-keyword">next</span>!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;<span class="hljs-keyword">next</span>-&gt;<span class="hljs-keyword">next</span>!=<span class="hljs-literal">NULL</span>即可<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;<span class="hljs-keyword">next</span>!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            low=low-&gt;<span class="hljs-keyword">next</span><span class="hljs-comment">;</span><br>            fast=fast-&gt;<span class="hljs-keyword">next</span>-&gt;<span class="hljs-keyword">next</span><span class="hljs-comment">;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> low<span class="hljs-comment">;</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h3><blockquote><p>其实反转链表可以用线性表做，时间复杂度差不多，但这里还是回归链表操作</p></blockquote><p>代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ListNode* reverseList(ListNode* head) &#123;<br>        ListNode* <span class="hljs-attribute">pre</span>=<span class="hljs-literal">NULL</span>;<br>        ListNode* <span class="hljs-attribute">l</span>=head;<br>        <span class="hljs-keyword">while</span>(l!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            ListNode* <span class="hljs-attribute">tmp</span>=l-&gt;next;<br>            l-&gt;<span class="hljs-attribute">next</span>=pre;<br>            <span class="hljs-attribute">pre</span>=l;<br>            <span class="hljs-attribute">l</span>=tmp;<br>        &#125;<br>        return pre;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="合并链表"><a class="markdownIt-Anchor" href="#合并链表"></a> 合并链表</h3><blockquote><p>将l1和l2交错合并</p></blockquote><p>代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void merge(ListNode* l1,ListNode* l2)<br>&#123;<br>    <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">NULL</span>&amp;&amp;l2!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        ListNode* <span class="hljs-attribute">l1t</span>=l1-&gt;next;<br>        ListNode* <span class="hljs-attribute">l2t</span>=l2-&gt;next;<br>        l1-&gt;<span class="hljs-attribute">next</span>=l2;<br>        <span class="hljs-attribute">l1</span>=l1t;<br>        l2-&gt;<span class="hljs-attribute">next</span>=l1;<br>        <span class="hljs-attribute">l2</span>=l2t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void reorderList(ListNode* head) &#123;<br>    ListNode* <span class="hljs-attribute">mid</span>=middleNode(head);<br>    ListNode* <span class="hljs-attribute">l1</span>=head;<br>    ListNode* <span class="hljs-attribute">l2</span>=mid-&gt;next;<br>    mid-&gt;<span class="hljs-attribute">next</span>=<span class="hljs-literal">NULL</span>;<br>    ListNode* <span class="hljs-attribute">r</span>=reverseList(l2);<br>    merge(l1,r);<br>&#125;<br>ListNode* reverseList(ListNode* head) &#123;<br>    ListNode* <span class="hljs-attribute">pre</span>=<span class="hljs-literal">NULL</span>;<br>    ListNode* <span class="hljs-attribute">l</span>=head;<br>    <span class="hljs-keyword">while</span>(l!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        ListNode* <span class="hljs-attribute">tmp</span>=l-&gt;next;<br>        l-&gt;<span class="hljs-attribute">next</span>=pre;<br>        <span class="hljs-attribute">pre</span>=l;<br>        <span class="hljs-attribute">l</span>=tmp;<br>    &#125;<br>    return pre;<br>&#125;<br>ListNode* middleNode(ListNode* head) &#123;<br>    ListNode *<span class="hljs-attribute">low</span>=head;<br>    ListNode <span class="hljs-number">*fa</span><span class="hljs-attribute">st</span>=head;<br>    <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;next-&gt;next!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-attribute">low</span>=low-&gt;next;<br>        <span class="hljs-attribute">fast</span>=fast-&gt;next-&gt;next;<br>    &#125;<br>    return low;<br>&#125;<br>void merge(ListNode* l1,ListNode* l2)<br>&#123;<br>    <br>    <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">NULL</span>&amp;&amp;l2!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        ListNode* <span class="hljs-attribute">l1t</span>=l1-&gt;next;<br>        ListNode* <span class="hljs-attribute">l2t</span>=l2-&gt;next;<br>        l1-&gt;<span class="hljs-attribute">next</span>=l2;<br>        <span class="hljs-attribute">l1</span>=l1t;<br>        l2-&gt;<span class="hljs-attribute">next</span>=l1;<br>        <span class="hljs-attribute">l2</span>=l2t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>差分与前缀和</title>
    <link href="/2022/08/24/%E5%B7%AE%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2022/08/24/%E5%B7%AE%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E5%89%8D%E7%BC%80%E5%92%8C">前缀和</a></li><li><a href="#%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">一维前缀和</a></li><li><a href="#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">二维前缀和</a></li><li><a href="#%E4%BE%8B%E9%A2%98">例题</a></li><li><a href="#%E5%B7%AE%E5%88%86">差分</a></li><li><a href="#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86">一维差分</a></li><li><a href="#%E4%BE%8B%E9%A2%98-1">例题</a></li><li><a href="#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86">二维差分</a></li><li><a href="#%E4%BE%8B%E9%A2%98-2">例题</a></li></ul><!-- /TOC --><h3 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h3><blockquote><p>前缀和指的是序列的前n项和</p></blockquote><h3 id="一维前缀和"><a class="markdownIt-Anchor" href="#一维前缀和"></a> 一维前缀和</h3><p>先看一个例题：<br />输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。<br />如果使用暴力枚举，时间复杂度为 <code>O(n*m)</code>,但是使用前缀和的话，时间复杂度可降为 <code>O(n)</code><br />input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>6<br>10<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>;<br><span class="hljs-type">int</span> a[N]; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n,m,l,r;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>cin&gt;&gt;a[i];<br>a[i]+=a[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>cin&gt;&gt;l&gt;&gt;r;<br>cout&lt;&lt;a[r]-a[l<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维前缀和"><a class="markdownIt-Anchor" href="#二维前缀和"></a> 二维前缀和</h3><p>每一个元素<code>a[i][j]</code>表示左上角和第<code>i</code>行，第<code>j</code>列围成的元素之和</p><p>更新方式： <code>a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]</code></p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><p>输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。<br />对于每个询问输出子矩阵中所有数的和</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">17<br>27<br>21<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int N=1e3;<br>int a<span class="hljs-comment">[N]</span><span class="hljs-comment">[N]</span>; <br>int main()<br>&#123;<br>int n,m,q;<br>int x1,y1,x2,y2;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>for(int i=1;i&lt;=n;++i)<br>&#123;<br>for(int j=1;j&lt;=m;++j)<br>&#123;<br>cin&gt;&gt;a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>;<br>a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>+=a<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>+a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>-a<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>;<br>&#125;<br>&#125;<br>while(q--)<br>&#123;<br>cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br>cout&lt;&lt;a<span class="hljs-comment">[x2]</span><span class="hljs-comment">[y2]</span>-a<span class="hljs-comment">[x1-1]</span><span class="hljs-comment">[y2]</span>-a<span class="hljs-comment">[x2]</span><span class="hljs-comment">[y1-1]</span>+a<span class="hljs-comment">[x1-1]</span><span class="hljs-comment">[y1-1]</span>&lt;&lt;endl;<br>&#125;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="差分"><a class="markdownIt-Anchor" href="#差分"></a> 差分</h3><blockquote><p>可以看作前缀和的逆运算</p></blockquote><h3 id="一维差分"><a class="markdownIt-Anchor" href="#一维差分"></a> 一维差分</h3><p>常用于给数组的某个区间段<code>[l,r]</code>加上某个数<code>c</code>，可以减小时间复杂度</p><ul><li>先构造差分数组：<code>b[i]=a[i]-a[i-1]</code></li><li>构造好之后 <code>b[l]+=c</code>,<code>b[r+1]-=c</code></li><li>然后根据<code>b[i]+=b[i-1]</code>计算前缀和数组，就是最终答案</li></ul><h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3><p>输入一个长度为n的整数序列。<br />接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。<br />请你输出进行完所有操作后的序列。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>;<br><span class="hljs-type">int</span> a[N],b[N]; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n,m,l,r,c;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>cin&gt;&gt;a[i];<br>b[i]=a[i]-a[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>b[l]+=c;<br>b[r+<span class="hljs-number">1</span>]-=c;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>b[i]+=b[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维差分"><a class="markdownIt-Anchor" href="#二维差分"></a> 二维差分</h3><p>常用于给某个子矩阵的每个元素加上 c</p><ul><li>二维差分数组的构造：<br /><code>b[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]</code></li><li>修改差分数组：  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">b<span class="hljs-comment">[x1]</span><span class="hljs-comment">[y1]</span>+=c;<br>b<span class="hljs-comment">[x1]</span><span class="hljs-comment">[y2+1]</span>-=c;<br>b<span class="hljs-comment">[x2+1]</span><span class="hljs-comment">[y1]</span>-=c;<br>b<span class="hljs-comment">[x2+1]</span><span class="hljs-comment">[y2+1]</span>+=c;<br></code></pre></td></tr></table></figure></li><li>生成前缀和数组：<br /><code>b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];</code></li></ul><h3 id="例题-3"><a class="markdownIt-Anchor" href="#例题-3"></a> 例题</h3><p>输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。<br />每个操作都要将选中的子矩阵中的每个元素的值加上c。<br />请你将进行完所有操作后的矩阵输出。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int <span class="hljs-symbol">N</span>=<span class="hljs-number">1e3</span>;<br>int a[<span class="hljs-symbol">N</span>][<span class="hljs-symbol">N</span>],b[<span class="hljs-symbol">N</span>][<span class="hljs-symbol">N</span>]; <br>int main()<br>&#123;<br>int n,m,q;<br>int x1,y1,x2,y2,c;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>for(int j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br>cin&gt;&gt;a[i][j];<br>b[i][j]=a[i][j]-a[i<span class="hljs-number">-1</span>][j]-a[i][j<span class="hljs-number">-1</span>]+a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;<br>while(q--)<br>&#123;<br>cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;<br>b[x1][y1]+=c;<br>b[x1][y2+<span class="hljs-number">1</span>]-=c;<br>b[x2+<span class="hljs-number">1</span>][y1]-=c;<br>b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]+=c;<br>&#125;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>for(int j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>b[i][j]+=b[i<span class="hljs-number">-1</span>][j]+b[i][j<span class="hljs-number">-1</span>]-b[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>&#125;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>for(int j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>cout&lt;&lt;b[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>cout&lt;&lt;endl;<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速幂矩阵幂</title>
    <link href="/2022/08/23/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9F%A9%E9%98%B5%E5%B9%82/"/>
    <url>/2022/08/23/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9F%A9%E9%98%B5%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BE%8B1-%E5%BF%AB%E9%80%9F%E5%B9%82">例1 快速幂</a></li><li><a href="#%E4%BE%8B2-%E7%9F%A9%E9%98%B5%E5%B9%82">例2 矩阵幂</a></li></ul><!-- /TOC --><blockquote><p><strong>快速幂</strong> 快速幂常用于计算指数非常大的幂，核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。</p></blockquote><p><em>直接看例题</em></p><h3 id="例1-快速幂"><a class="markdownIt-Anchor" href="#例1-快速幂"></a> 例1 快速幂</h3><p>输入三个数字a,b,c,输出 a^b <strong>mod</strong> c<br />input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">10</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a,b,c;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ksm</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br>a=a%c;<br><span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>)<br>ans=(ans*a)%c;<br>a=(a*a)%c;<br>b/=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>cout&lt;&lt;<span class="hljs-built_in">ksm</span>()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例2-矩阵幂"><a class="markdownIt-Anchor" href="#例2-矩阵幂"></a> 例2 矩阵幂</h3><p>描述<br />给定一个n*n的矩阵，输出矩阵的k次方</p><p>输入描述<br />有多组输入，第一行输入n和k<br />后面n行输入矩阵元素<br />2&lt;=n&lt;=10,1&lt;=k&lt;=5<br />输出描述<br />每组输入输出矩阵的k次方<br />input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">3</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">153 </span><span class="hljs-number">96</span><br><span class="hljs-symbol">108 </span><span class="hljs-number">81</span><br><span class="hljs-symbol">1216 </span><span class="hljs-number">1248</span> <span class="hljs-number">708</span><br><span class="hljs-symbol">1089 </span><span class="hljs-number">927</span> <span class="hljs-number">504</span><br><span class="hljs-symbol">1161 </span><span class="hljs-number">1151</span> <span class="hljs-number">739</span><br><span class="hljs-symbol">47 </span><span class="hljs-number">29</span> <span class="hljs-number">41</span> <span class="hljs-number">22</span> <span class="hljs-number">16</span><br><span class="hljs-symbol">147 </span><span class="hljs-number">103</span> <span class="hljs-number">73</span> <span class="hljs-number">116</span> <span class="hljs-number">94</span><br><span class="hljs-symbol">162 </span><span class="hljs-number">108</span> <span class="hljs-number">153</span> <span class="hljs-number">168</span> <span class="hljs-number">126</span><br><span class="hljs-symbol">163 </span><span class="hljs-number">67</span> <span class="hljs-number">112</span> <span class="hljs-number">158</span> <span class="hljs-number">122</span><br><span class="hljs-symbol">152 </span><span class="hljs-number">93</span> <span class="hljs-number">93</span> <span class="hljs-number">111</span> <span class="hljs-number">97</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">M</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> row;<br>    <span class="hljs-built_in">int</span> col;<br>    <span class="hljs-built_in">int</span> m[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];<br>    M(<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> c):row(r),col(c)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;col;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==j)<br>                    m[i][j]=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    m[i][j]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;      <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">input</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;col;++j)<br>                cin&gt;&gt;m[i][j];<br>        &#125; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;col;++j)<br>                cout&lt;&lt;m[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>            cout&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    M <span class="hljs-keyword">operator</span>* (<span class="hljs-keyword">const</span> M&amp; t) <span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-function">M <span class="hljs-title">ans</span>(<span class="hljs-params">row,t.col</span>)</span>;<br>        memset(ans.m,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(ans.m));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;t.col;++j)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;k&lt;col;++k)<br>                &#123;<br>                    ans.m[i][j]+=m[i][k]*t.m[k][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function">M <span class="hljs-title">ksm</span>(<span class="hljs-params">M a,<span class="hljs-built_in">int</span> k</span>)</span><br>&#123;<br>    <span class="hljs-function">M <span class="hljs-title">ans</span>(<span class="hljs-params">a.row,a.col</span>)</span>;<br>    <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(k%<span class="hljs-number">2</span>)<br>            ans=ans*a;<br>        a=a*a;<br>        k/=<span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans; <br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> n,k;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;k)<br>    &#123;<br>        <span class="hljs-function">M <span class="hljs-title">a</span>(<span class="hljs-params">n,n</span>)</span>;<br>        a.input();<br>        M ans=ksm(a,k);<br>        ans.output();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最短路</title>
    <link href="/2022/08/22/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2022/08/22/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E4%BE%8B1-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF-%E6%B4%9B%E8%B0%B7p4779">例1 单源最短路 洛谷p4779</a></li><li><a href="#spfa">SPFA</a></li><li><a href="#dijkstra%E6%99%AE%E9%80%9A%E7%89%88">Dijkstra普通版</a></li><li><a href="#dijkstra%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88ac">Dijkstra堆优化版(AC)</a><ul><li><a href="#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AD%98%E5%9B%BE">链式前向星存图</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li></ul></li><li><a href="#%E4%BE%8B2-%E6%9C%80%E5%A4%9A%E7%BB%8F%E8%BF%87k%E6%9D%A1%E8%BE%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF">例2 最多经过k条边的最短路</a></li><li><a href="#bellmanford">Bellmanford</a></li><li><a href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E8%A7%A3%E6%9C%80%E7%9F%AD%E8%B7%AF">并查集解最短路</a></li></ul><!-- /TOC --><h3 id="例1-单源最短路-洛谷p4779"><a class="markdownIt-Anchor" href="#例1-单源最短路-洛谷p4779"></a> 例1 单源最短路 洛谷p4779</h3><p>题目描述</p><p>给定一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 条有向边的带非负权图，请你计算从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 出发，到每个点的距离。</p><p>数据保证你能从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 出发到任意点。</p><p>输入格式</p><p>第一行为三个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">n, m, s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span></span></span></span>。<br />第二行起 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行三个非负整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i, v_i, w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，表示从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 有一条权值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的有向边。</p><p>输出格式</p><p>输出一行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个空格分隔的非负整数，表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> 到每个点的距离。</p><p>样例输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>提示</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq n \leq 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1 \leq m \leq 2\times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \leq u_i, v_i\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>w</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">0 \leq w_i \leq 10 ^ 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>,</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mo>∑</mo><msub><mi>w</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">0 \leq \sum w_i \leq 10 ^ 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。</p><h3 id="spfa"><a class="markdownIt-Anchor" href="#spfa"></a> SPFA</h3><blockquote><p>此题用spfa会超时,这里写的代码弱化了数据范围，存图也直接用二维数组了，主要是复习spfa的思路</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,s;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> mp[N][N];<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> vis[N]; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(mp,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(mp));<br><span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dist));<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br>dist[s]=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> u,v,w;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>&#123;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>mp[u][v]=w;<br>&#125;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(s);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>vis[t]=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">if</span>(dist[i]&gt;dist[t]+mp[t][i])<br>&#123;<br>dist[i]=dist[t]+mp[t][i];<br><span class="hljs-keyword">if</span>(!vis[i])<br>&#123;<br>vis[i]=<span class="hljs-literal">true</span>;<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br>&#125;<br>&#125;<br>&#125; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cout&lt;&lt;dist[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dijkstra普通版"><a class="markdownIt-Anchor" href="#dijkstra普通版"></a> Dijkstra普通版</h3><blockquote><p>此题用普通Dijkstra会超时,这里写的代码弱化了数据范围，存图也直接用二维数组了，主要是复习dj的思路</p></blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs excel">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>,m,s;<br>const <span class="hljs-built_in">int</span> <span class="hljs-built_in">N</span>=<span class="hljs-number">1</span>e4+<span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> mp[<span class="hljs-built_in">N</span>][<span class="hljs-built_in">N</span>];<br><span class="hljs-built_in">int</span> dist[<span class="hljs-built_in">N</span>];<br>bool vis[<span class="hljs-built_in">N</span>]; <br><span class="hljs-built_in">int</span> main()<br>&#123;<br>memset(mp,<span class="hljs-number">0</span>x3f,sizeof(mp));<br>memset(dist,<span class="hljs-number">0</span>x3f,sizeof(dist));<br>cin&gt;&gt;<span class="hljs-built_in">n</span>&gt;&gt;m&gt;&gt;s;<br>dist[s]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> u,v,w;<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>&#123;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>mp[u][v]=w;<br>&#125;<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">n</span>;++i)<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>=-<span class="hljs-number">1</span>;<br>for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-built_in">n</span>;++j)<br>&#123;<br><span class="hljs-built_in">if</span>(!vis[j]&amp;&amp;(<span class="hljs-built_in">t</span>==-<span class="hljs-number">1</span>||dist[<span class="hljs-built_in">t</span>]&gt;dist[j]))<br><span class="hljs-built_in">t</span>=j;<br>&#125;<br>vis[<span class="hljs-built_in">t</span>]=<span class="hljs-built_in">true</span>;<br>for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-built_in">n</span>;++j)<br>&#123;<br>dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[<span class="hljs-built_in">t</span>]+mp[<span class="hljs-built_in">t</span>][j]);<br>&#125;<br>&#125;<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">n</span>;++i)<br>cout&lt;&lt;dist[i]&lt;&lt;&#x27; &#x27;;<br>cout&lt;&lt;endl;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dijkstra堆优化版ac"><a class="markdownIt-Anchor" href="#dijkstra堆优化版ac"></a> Dijkstra堆优化版(AC)</h3><h4 id="链式前向星存图"><a class="markdownIt-Anchor" href="#链式前向星存图"></a> 链式前向星存图</h4><p>题目中给的节点数很多，属于稀疏图，二维数组无法存储，所以需要使用<strong>链式前向星</strong>存储，方法如下：</p><p>定义一个数组<code>head[]</code>,<code>head[a]</code>表示以a为起始点的最后一条边的序号</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span>：表示边的序号</p><p>结构体<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>d</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">edge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span></span></span></span>，存储边</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> edge<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">to</span>;<span class="hljs-comment">//这条边指向的点 </span><br><span class="hljs-built_in">int</span> next;<span class="hljs-comment">//这条边的邻边的序号 </span><br><span class="hljs-built_in">int</span> w;<span class="hljs-comment">//这条边的权值 </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>加边，如果是无向图，交换u和v再add一次即可</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hsp">void add(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> w)<br>&#123;<br>++<span class="hljs-keyword">cnt</span><span class="hljs-comment">;</span><br>e[<span class="hljs-keyword">cnt</span>].to=v<span class="hljs-comment">;</span><br>e[<span class="hljs-keyword">cnt</span>].w=w<span class="hljs-comment">;</span><br>e[<span class="hljs-keyword">cnt</span>].next=head[u]<span class="hljs-comment">;</span><br>head[u]=<span class="hljs-keyword">cnt</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>遍历以a为起点的所有边</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=head[a];i!=0;<span class="hljs-attribute">i</span>=edge[i].next)<br></code></pre></td></tr></table></figure><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,s;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> head[N];<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-comment">//边 </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br><span class="hljs-type">int</span> to;<span class="hljs-comment">//这条边指向的点 </span><br><span class="hljs-type">int</span> next;<span class="hljs-comment">//这条边的邻边的序号 </span><br><span class="hljs-type">int</span> w;<span class="hljs-comment">//这条边的权值 </span><br>&#125;e[<span class="hljs-number">2</span>*N];<br><span class="hljs-comment">//优先级队列的节点</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w;<br><span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> nn,<span class="hljs-type">int</span> ww):<span class="hljs-built_in">n</span>(nn),<span class="hljs-built_in">w</span>(ww)&#123;&#125;<br><span class="hljs-comment">//重载运算符&lt;，为了建立小顶堆 </span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> node&amp; t) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> w&gt;t.w;<br>&#125;<br>&#125;; <br><span class="hljs-comment">//加边 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>++cnt;<br>e[cnt].to=v;<br>e[cnt].w=w;<br>e[cnt].next=head[u];<br>head[u]=cnt;<br>&#125;<br>priority_queue&lt;node&gt; q;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br><span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>dis[s]=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> u,v,w;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>&#123;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br><span class="hljs-built_in">add</span>(u,v,w);<br>&#125;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(s,<span class="hljs-number">0</span>));<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>node t=q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>u=t.n;<br><span class="hljs-keyword">if</span>(!vis[u])<br>&#123;<br>vis[u]=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)<br>&#123;<br>v=e[i].to;<br>w=e[i].w;<br><span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)<br>&#123;<br>dis[v]=dis[u]+w;<br><span class="hljs-keyword">if</span>(!vis[v])<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(v,dis[v]));<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>cout&lt;&lt;dis[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例2-最多经过k条边的最短路"><a class="markdownIt-Anchor" href="#例2-最多经过k条边的最短路"></a> 例2 最多经过k条边的最短路</h3><p>描述<br />给定 n 个点，m条有向边，起点s，终点d，最大边数k</p><p>第一行输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>d</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n,m,s,d,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span><br />后面m行输入m条边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i,v_i,w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>输出从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>最多经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>条边时的最短路径<br />input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">100</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">100</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">500</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">200<br></code></pre></td></tr></table></figure><h3 id="bellmanford"><a class="markdownIt-Anchor" href="#bellmanford"></a> Bellmanford</h3><blockquote><p>Bellmanford常用于解决此类有边数限制的最短路</p></blockquote><p>代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-type">int</span> n,m,s,d,k;<br><span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;<br>const <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">100</span>][N];<br><span class="hljs-type">bool</span> vis[N];<br>struct edge<br>&#123;<br><span class="hljs-type">int</span> u,v,w;<br>//edge(<span class="hljs-type">int</span> uu,<span class="hljs-type">int</span> vv,<span class="hljs-type">int</span> ww):u(uu),v(vv),w(ww)&#123;&#125;<br>&#125;e[N];<br><span class="hljs-type">int</span> main()<br>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d&gt;&gt;k;<br>memset(dp,<span class="hljs-number">0x3f</span>,sizeof(dp));<br>dp[<span class="hljs-number">0</span>][s]=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> u,v,w;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>&#123;<br>cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>e[i].u=u;<br>e[i].v=v;<br>e[i].w=w;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br>u=e[j].u;<br>v=e[j].v;<br>w=e[j].w;<br>dp[i][v]=min(dp[i][v],dp[i<span class="hljs-number">-1</span>][u]+w);<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> ans=inf;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i)<br>&#123;<br>ans=min(dp[i][d],ans);<br>&#125; <br><span class="hljs-keyword">if</span>(ans==inf)<br>cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并查集解最短路"><a class="markdownIt-Anchor" href="#并查集解最短路"></a> 并查集解最短路</h3><p>先看一个例题</p><p><a href="https://www.nowcoder.com/practice/a29d0b5eb46b4b90bfa22aa98cf5ff17?tpId=40&amp;tqId=21438&amp;rp=1&amp;ru=/ta/kaoyan&amp;qru=/ta/kaoyan&amp;difficulty=&amp;judgeStatus=&amp;tags=/question-ranking">最短路径</a></p><p><strong>描述</strong></p><p>N个城市，标号从0到N-1，M条道路，第K条道路（K从0开始）的长度为2^K，求编号为0的城市到其他城市的最短距离</p><p><strong>输入描述</strong></p><p>第一行两个正整数N（2&lt;=N&lt;=100）M(M&lt;=500),表示有N个城市，M条道路 接下来M行两个整数，表示相连的两个城市的编号</p><p><strong>输出描述</strong></p><p>N-1行，表示0号城市到其他城市的最短路，如果无法到达，输出-1，数值太大的以MOD 100000 的结果输出。</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">8<br>9<br>11<br></code></pre></td></tr></table></figure><blockquote><p>思路：对于这道题，第k条边的长度为2^k，也就是说，第k条边会比前面所有边的和还要大。所以用并查集来做，当新加入边的两个端点u和v不连通时，这条边就是u到v的最短距离，因为后续如果再次出现以uv为端点的边，一定会比当前长度长。加入uv边后，更新两端点各自连通子图中各点间的距离即可。</p></blockquote><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">102</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e5</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">int</span> mp[N][N];<br><span class="hljs-type">int</span> vset[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ksm</span><span class="hljs-params">(ll a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br>    a=a%c;<br>    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>)<br>            ans=(ans*a)%c;<br>        a=(a*a)%c;<br>        b/=<span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(vset[a]==<span class="hljs-number">-1</span>)<br><span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">else</span><br>&#123;<br>vset[a]=<span class="hljs-built_in">find</span>(vset[a]);<br><span class="hljs-keyword">return</span> vset[a];<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(vset,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(vset));<br>    <span class="hljs-built_in">memset</span>(mp,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(mp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>    mp[i][i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> u,v,w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;m;++k)<br>    &#123;<br>        cin&gt;&gt;u&gt;&gt;v;<br>        <span class="hljs-type">int</span> x=<span class="hljs-built_in">find</span>(u);<br>        <span class="hljs-type">int</span> y=<span class="hljs-built_in">find</span>(v);<br>        <span class="hljs-comment">//当两点不连通的时候才加入该边，此时该边是u到v的最短边</span><br><span class="hljs-keyword">if</span>(x!=y)<br>&#123;<br>w=<span class="hljs-built_in">ksm</span>(<span class="hljs-number">2</span>,k,mod);<br><span class="hljs-comment">//更新两个连通子图间各点的距离 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)==x)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(j)==y)<br>&#123;<br>mp[i][j]=mp[j][i]=(mp[i][u]+w+mp[v][j])%mod;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//连接两个连通子图</span><br>vset[x]=y; <br>&#125; <br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)<br>    cout&lt;&lt;mp[<span class="hljs-number">0</span>][i]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2022/08/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%80%9D%E8%B7%AF">思路</a></li><li><a href="#%E4%BE%8B%E9%A2%98101%E8%83%8C%E5%8C%85">例题1：01背包</a></li><li><a href="#%E4%BE%8B%E9%A2%982%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">例题2：完全背包</a></li></ul><!-- /TOC --><blockquote><p><em><strong>背包问题</strong></em> 是经典的一类动态规划类型的题目，一般是有n种物品，每个物品有对应的价值w，然后背包体积为V，求能装入的物品的最大价值。</p></blockquote><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><p>设 <strong>dp[i][j]</strong> 为前 i 个物品，背包容量为 j 的最大价值。</p><p>那么考虑第i个物品是否放入，有两种情况：</p><ul><li>如果不放，那么等同于前 <strong>i−1</strong> 个物品，容量为j的背包的最优方案。</li><li>如果放，那么等同于前 <strong>i−1</strong> 个物品，容量为 <strong>j−v[i]</strong> 的背包的最优方案，再加上第i个物品的价值。</li></ul><p>那么可以得到转移方程：</p><p><em><strong>dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i])</strong></em></p><p>最终的答案就是 <strong>dp[n][V]</strong></p><p>观察到dp数组，第i行仅跟上一行有关系，故可以压缩一维，为了防止dp[i−1][j−v[i]]被覆盖掉，第二维度须<strong>反向枚举</strong>。</p><h4 id="例题101背包"><a class="markdownIt-Anchor" href="#例题101背包"></a> 例题1：01背包</h4><p>你有一个背包，最多能容纳的体积是V，现在有n个物品，第i个物品的体积为vi,价值为wi。</p><ol><li>求这个背包至多能装多大价值的物品？</li><li>若背包恰好装满，求至多能装多大价值的物品？</li></ol><p>输入第一行n,V<br />后面n行，输入第i件物品的体积vi和价值wi<br />输出：两个问题的答案，各占一行，如果无解输出0</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">14<br>9<br></code></pre></td></tr></table></figure><p>题解：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int n,V;<br>const int N=1005;<br>int v<span class="hljs-comment">[N]</span>,w<span class="hljs-comment">[N]</span>;<br>int dp<span class="hljs-comment">[N]</span>;<br>int main()<br>&#123;<br>    cin&gt;&gt;n&gt;&gt;V;<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;v<span class="hljs-comment">[i]</span>;<br>        cin&gt;&gt;w<span class="hljs-comment">[i]</span>;<br>    &#125;<br>    //不要求装满<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        for(int j=V;j&gt;=v<span class="hljs-comment">[i]</span>;--j)<br>            dp<span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[j-v<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>);<br>    &#125;<br>    cout&lt;&lt;dp<span class="hljs-comment">[V]</span>&lt;&lt;endl;<br>    <br>    //要求装满<br>    memset(dp,-0x3f,sizeof(dp));<br>    dp<span class="hljs-comment">[0]</span>=0;<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        for(int j=V;j&gt;=v<span class="hljs-comment">[i]</span>;--j)<br>            dp<span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[j-v<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>);<br>    &#125;<br>    if(dp<span class="hljs-comment">[V]</span>&gt;0)<br>        cout&lt;&lt;dp<span class="hljs-comment">[V]</span>&lt;&lt;endl;<br>    else<br>        cout&lt;&lt;0&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例题2完全背包"><a class="markdownIt-Anchor" href="#例题2完全背包"></a> 例题2：完全背包</h4><p>描述与例题1相同，不过每种物品有<strong>任意</strong>个</p><p>input:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">13</span><br><span class="hljs-symbol">13 </span><span class="hljs-number">189</span><br><span class="hljs-symbol">17 </span><span class="hljs-number">360</span><br><span class="hljs-symbol">19 </span><span class="hljs-number">870</span><br><span class="hljs-symbol">14 </span><span class="hljs-number">184</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">298</span><br><span class="hljs-symbol">16 </span><span class="hljs-number">242</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">596<br>189<br></code></pre></td></tr></table></figure><p>题解：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs inform7">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int n,V;<br>const int N=1005;<br>int v<span class="hljs-comment">[N]</span>,w<span class="hljs-comment">[N]</span>;<br>int dp<span class="hljs-comment">[N]</span>;<br>int main()<br>&#123;<br>    cin&gt;&gt;n&gt;&gt;V;<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;v<span class="hljs-comment">[i]</span>;<br>        cin&gt;&gt;w<span class="hljs-comment">[i]</span>;<br>    &#125;<br>    //不要求装满<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        for(int j=v<span class="hljs-comment">[i]</span>;j&lt;=V;++j)<br>            dp<span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[j-v<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>);<br>    &#125;<br>    cout&lt;&lt;dp<span class="hljs-comment">[V]</span>&lt;&lt;endl;<br>    <br>    //要求装满<br>    memset(dp,-0x3f,sizeof(dp));<br>    dp<span class="hljs-comment">[0]</span>=0;<br>    for(int i=1;i&lt;=n;++i)<br>    &#123;<br>        for(int j=v<span class="hljs-comment">[i]</span>;j&lt;=V;++j)<br>            dp<span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[j-v<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>);<br>    &#125;<br>    if(dp<span class="hljs-comment">[V]</span>&gt;0)<br>        cout&lt;&lt;dp<span class="hljs-comment">[V]</span>&lt;&lt;endl;<br>    else<br>        cout&lt;&lt;0&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯</title>
    <link href="/2022/08/22/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2022/08/22/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><em><strong>回溯</strong></em>  核心思想和dfs相似，主要通过递归寻找可行解</p></blockquote><!-- TOC --><ul><li><a href="#%E4%BE%8B%E9%A2%981">例题1:</a></li><li><a href="#%E4%BE%8B%E9%A2%982">例题2:</a></li></ul><!-- /TOC --><h3 id="例题1"><a class="markdownIt-Anchor" href="#例题1"></a> 例题1:</h3><p>给定一个数组a[]和target的值，找出数组中可以使数字和为target的不同组合，输出所有符合要求的组合</p><ul><li>数组中数字可以重复使用</li><li>1,1,5和1,5,1视为一种方式<br />input:</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>题解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,target;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; vi;<br><span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(N)</span></span>;<br>vi tmp;<br>vector&lt;vi&gt; ans; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bk</span><span class="hljs-params">(<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(idx==n)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)<br>    &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">bk</span>(idx+<span class="hljs-number">1</span>,target);<br>    <span class="hljs-keyword">if</span>(target&gt;=a[idx])<br>    &#123;<br>        tmp.<span class="hljs-built_in">push_back</span>(a[idx]);<br>        <span class="hljs-built_in">bk</span>(idx,target-a[idx]);<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;target;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>cin&gt;&gt;a[i];<br><br>    <span class="hljs-built_in">bk</span>(<span class="hljs-number">0</span>,target);<br>    <span class="hljs-keyword">for</span>(vi&amp; t:ans)<br>    &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> tt :t)<br>    cout&lt;&lt;tt&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题2"><a class="markdownIt-Anchor" href="#例题2"></a> 例题2:</h3><p>给定一个数组a[]和target的值，找出数组中可以使数字和为target的不同组合，输出所有符合要求的组合</p><ul><li>数组中每个数字最多使用一次</li><li>1,1,5和1,5,1视为一种方式<br />input:</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>题解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,target;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; vi;<br><span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(N)</span></span>;<br>vi tmp;<br>vector&lt;vi&gt; ans; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bk</span><span class="hljs-params">(<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(idx==n)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)<br>    &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=idx;i&lt;n;++i)<br>    &#123;<br>    <span class="hljs-keyword">if</span>(target&gt;=a[i])<br>    &#123;<br>    <span class="hljs-keyword">if</span>(i&gt;idx&amp;&amp;a[i]==a[i<span class="hljs-number">-1</span>])<br>    <span class="hljs-keyword">continue</span>;<br>    tmp.<span class="hljs-built_in">push_back</span>(a[i]);<br>    <span class="hljs-built_in">bk</span>(i+<span class="hljs-number">1</span>,target-a[i]);<br>    tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;target;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>cin&gt;&gt;a[i];<br><br>    <span class="hljs-built_in">bk</span>(<span class="hljs-number">0</span>,target);<br>    <span class="hljs-keyword">for</span>(vi&amp; t:ans)<br>    &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> tt :t)<br>    cout&lt;&lt;tt&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kmp算法</title>
    <link href="/2022/08/21/kmp%E7%AE%97%E6%B3%95/"/>
    <url>/2022/08/21/kmp%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><em><strong>kmp</strong></em> 算法的核心思想：当匹配失败时，主串指针不回退，而是根据 <em><strong>next</strong></em> 数组，从适当的位置重新匹配，相比于暴力匹配，跳过了不可能匹配成功的部分，大大提升了效率</p></blockquote><blockquote><p><em><strong>next</strong></em> 数组每个位置的值表示前缀集合和后缀集合交集中,最长元素的长度</p></blockquote><pre><code class="hljs">        p:    a b a b a b c a    next[i]:  0 0 1 2 3 4 0 1</code></pre><p>例题:</p><p>给你两个字符串 s 和 p ，请你在 s 字符串中找出 p 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。</p><p>input:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abacdf</span><br><span class="hljs-attribute">acd</span><br></code></pre></td></tr></table></figure><p>output:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p>题解</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>const int <span class="hljs-attribute">N</span>=1e5;<br>int nxt[N];<br>void get_next(string p)<br>&#123;<br>int <span class="hljs-attribute">len</span>=p.size();<br>int <span class="hljs-attribute">i</span>=1,j=0;<br><span class="hljs-keyword">while</span>(i&lt;len)<br>&#123;<br><span class="hljs-keyword">if</span>(p[i]==p[j])<br>&#123;<br>nxt[i]=j+1;<br>++i;<br>++j;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-attribute">j</span>==0)<br>&#123;<br>nxt[i]=0;<br>++i;<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-attribute">j</span>=nxt[j-1];<br>&#125;<br>&#125; <br>int main()<br>&#123;<br>string s,p;<br>cin&gt;&gt;s&gt;&gt;p;<br>int <span class="hljs-attribute">m</span>=s.size(),n=p.size();<br>int <span class="hljs-attribute">ans</span>=-1;<br><br><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0,j=0;i&lt;m;++i)<br>&#123;<br><span class="hljs-keyword">while</span>(j&gt;0&amp;&amp;s[i]!=p[j])<br><span class="hljs-attribute">j</span>=nxt[j-1];<br><span class="hljs-keyword">if</span>(s[i]==p[j])<br>++j;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">j</span>==n)<br><span class="hljs-attribute">ans</span>=i-j+1;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>return 0;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经</title>
    <link href="/2022/08/21/%E9%9D%A2%E7%BB%8F/"/>
    <url>/2022/08/21/%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#2022%E4%B8%AA%E4%BA%BA%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%A2%84%E6%8E%A8%E5%85%8D%E8%AE%B0%E5%BD%95">2022个人夏令营/预推免记录😢</a><ul><li><a href="#%E5%90%89%E5%A4%A7ai">吉大ai</a></li><li><a href="#%E8%A5%BF%E4%BA%A4cs">西交cs</a></li><li><a href="#%E5%8D%8E%E7%A7%91%E7%BD%91%E5%AE%89">华科网安</a></li><li><a href="#%E5%8C%97%E9%82%AE">北邮</a></li><li><a href="#%E5%9B%BD%E9%98%B2%E7%A7%91%E5%A4%A7%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B">国防科大系统工程</a></li><li><a href="#%E6%B5%99%E8%BD%AF">浙软</a></li><li><a href="#%E5%8D%97%E5%A4%A7cs">南大cs</a></li><li><a href="#%E5%8C%97%E8%88%AAai">北航ai</a></li><li><a href="#%E4%B8%9C%E5%8D%97cs">东南cs</a></li></ul></li><li><a href="#%E9%A2%84%E6%8E%A8%E5%85%8D">预推免</a><ul><li><a href="#%E5%A4%8D%E6%97%A6">复旦</a></li><li><a href="#%E8%A5%BF%E4%BA%A4">西交</a></li><li><a href="#%E5%93%88%E5%B7%A5%E5%A4%A7">哈工大</a></li><li><a href="#%E5%8C%97%E8%88%AAai-1">北航ai</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul><!-- /TOC --><h2 id="2022个人夏令营预推免记录"><a class="markdownIt-Anchor" href="#2022个人夏令营预推免记录"></a> 2022个人夏令营/预推免记录😢</h2><h3 id="吉大ai"><a class="markdownIt-Anchor" href="#吉大ai"></a> 吉大ai</h3><ul><li>自我介绍</li><li>英文翻译</li><li>抽题目回答</li></ul><p>我抽到的是关于聚类的：</p><ul><li>什么是聚类</li><li>聚类和分类区别</li><li>聚类的性能指标</li><li>层次聚类方法有哪些？</li><li><em>后两个也是关于层次聚类的，忘了。。。</em></li></ul><h3 id="西交cs"><a class="markdownIt-Anchor" href="#西交cs"></a> 西交cs</h3><p>夏令营没有优营，没有考核，先报名然后团队内部面试（聊天）</p><h3 id="华科网安"><a class="markdownIt-Anchor" href="#华科网安"></a> 华科网安</h3><p>有机试，5道题，150min,题目记不清了，难度中等，机试成绩不计入总成绩，仅作为参考<br />面试就自我介绍，然后聊聊天，最后优营40人，大概1/3</p><h3 id="北邮"><a class="markdownIt-Anchor" href="#北邮"></a> 北邮</h3><p>入营未参加</p><h3 id="国防科大系统工程"><a class="markdownIt-Anchor" href="#国防科大系统工程"></a> 国防科大系统工程</h3><p>入营未参加</p><h3 id="浙软"><a class="markdownIt-Anchor" href="#浙软"></a> 浙软</h3><p>入营选择方向，一共八个方向，每个方向会布置任务，做完提交即可，按完成质量评优营</p><p>时间紧，随便做了下就交了，最后普通营员</p><h3 id="南大cs"><a class="markdownIt-Anchor" href="#南大cs"></a> 南大cs</h3><ul><li><p><strong>笔试</strong><br />很多要计算的题，题量挺大的<br /><strong>数据结构</strong>：排序算法性能，希尔排序序列、红黑树、b树、最短路径算法(dijkstra,bellford,floyd)、最小生成树、线性探测、优先级队列、汉诺塔问题、还有好几个读程序的题<br /><strong>计组</strong>：组相联映射、cache和主存给定命中率计算时间、想不起来了。。。<br />os：linux终端退出的符号，jvm，进程通信、一些语言特性（rust，ruby，scala），访管指令，还有一堆指令。。<br /><strong>计网</strong>：无类寻址，拥塞窗口、数据链路层、ip协议、后面记的不清楚了。。。。</p></li><li><p><strong>面试</strong><br />先英文介绍merge sort，问一些项目问题，然后问了个数学题（怎么在球面上确定一点？），然后问了下生活上的兴趣之类的</p></li></ul><h3 id="北航ai"><a class="markdownIt-Anchor" href="#北航ai"></a> 北航ai</h3><p>今年是第二届夏令营，入营120/1000，优营60</p><ul><li>先英文自我介绍</li><li>政治：谈谈科教兴国的理解</li><li>聊聊项目</li><li>因为我在下午，可能是老师累了把，没有问专业课，最后优营了</li></ul><p>北航和老师聊，问了些问题，都是比较底层的细节问题，<br />还记得的有：</p><ul><li>python 垃圾回收机制</li><li>c++ 智能指针的原理</li><li>如何判断链表有没有环</li></ul><h3 id="东南cs"><a class="markdownIt-Anchor" href="#东南cs"></a> 东南cs</h3><p>入营318人</p><ul><li>面试<ul><li>3分钟自我介绍</li><li>英文问题：cv的相关任务、参加的实践活动</li><li>聊聊天，没有问专业课</li></ul></li></ul><hr /><hr /><hr /><h2 id="预推免"><a class="markdownIt-Anchor" href="#预推免"></a> 预推免</h2><h3 id="复旦"><a class="markdownIt-Anchor" href="#复旦"></a> 复旦</h3><p>机试：给3道题，2个小时的时间，自己做不用oj，然后做完把解题思路和代码提交就行了</p><p>感觉题都挺难的，数据规模也很大，我也刷了一段时间题，感觉难度有OI提高组级别吧，也可能是我tcl😢</p><p>英语：上来先自我介绍，然后让我介绍自己专业，学了什么。前面说的还行，后面几个问题也没准备，就说的磕磕绊绊。。。</p><p>面试：问得不是特别难，基本都答上来了。就是深度学习的一些基础知识还有数据结构的一些算法和复杂度，问得倒是很细，代码细节都问，但不难。</p><p>结果：候补第1。然后中午有老师打电话过来说那边夏令营会空出来几个名额，基本会候补到。</p><h3 id="西交"><a class="markdownIt-Anchor" href="#西交"></a> 西交</h3><p>面试和夏令营一样，没问什么专业课，感觉类似于聊天。</p><h3 id="哈工大"><a class="markdownIt-Anchor" href="#哈工大"></a> 哈工大</h3><p>报的是卓越工程师学院的人工智能，开始报名的很早，竞争相对没那么激烈。本来打算报本部和哈深的，后面给忘了😄</p><p>这个预推免体验不是很好，具体的就不多说了，反正各个环节安排的不是很合理，甚至面试的时候问题还没回答完，就被打断然后被要求退出会议了。</p><p>结果：第二天出结果了，通过了，要签承诺书什么的。</p><h3 id="北航ai-2"><a class="markdownIt-Anchor" href="#北航ai-2"></a> 北航ai</h3><p>最想去的学校，感觉夏令营优营也没什么优势。预推免还问的挺难的，比如问<em>广义的特征向量</em>，图形学里面的点云的什么公式之类的，感觉都很难😢😢😢😢</p><p>26日下午3点半收到拟录取邮件了</p><p>最后还是北航😄</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>感觉自己水平很一般，就是运气好了一点吧，希望别被buaa的大佬们碾压了。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
