<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>日期计算</title>
    <link href="/2022/08/29/%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97/"/>
    <url>/2022/08/29/%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>先来看一道题</p><p>输入一年中的一天，输出这一天是星期几</p><p>input:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">14 </span>October <span class="hljs-number">2001</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">Sunday</span></code></pre></div><p>用以下公式计算天数：</p><p>$S&#x3D;X-1+(X-1)&#x2F;4-(X-1)&#x2F;100+(X-1)&#x2F;400+C$</p><p>其中，<code>X</code>是年份，<code>C</code>表示这一天是这一年的第<code>C</code>天</p><p>计算出<code>S</code>后用<code>S%7</code>判断星期几即可</p><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// S=X-1+(X-1)/4-(X-1)/100+(X-1)/400+C</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isrun</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(n%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>&amp;&amp;n%<span class="hljs-number">100</span>||n%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> d,y;    string m;    vector&lt;pair&lt;string,<span class="hljs-type">int</span>&gt;&gt; mon=&#123;&#123;<span class="hljs-string">&quot;January&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;February&quot;</span>,<span class="hljs-number">28</span>&#125;,    &#123;<span class="hljs-string">&quot;March&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;April&quot;</span>,<span class="hljs-number">30</span>&#125;,&#123;<span class="hljs-string">&quot;May&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;June&quot;</span>,<span class="hljs-number">30</span>&#125;,&#123;<span class="hljs-string">&quot;July&quot;</span>,<span class="hljs-number">31</span>&#125;,    &#123;<span class="hljs-string">&quot;August&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;September&quot;</span>,<span class="hljs-number">30</span>&#125;,&#123;<span class="hljs-string">&quot;October&quot;</span>,<span class="hljs-number">31</span>&#125;,&#123;<span class="hljs-string">&quot;November&quot;</span>,<span class="hljs-number">30</span>&#125;,                                  &#123;<span class="hljs-string">&quot;December&quot;</span>,<span class="hljs-number">31</span>&#125;&#125;;    <span class="hljs-keyword">while</span>(cin&gt;&gt;d&gt;&gt;m&gt;&gt;y)    &#123;        <span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isrun</span>(y))            flag=<span class="hljs-number">1</span>;        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=mon.<span class="hljs-built_in">begin</span>();it!=mon.<span class="hljs-built_in">end</span>();++it)        &#123;            <span class="hljs-keyword">if</span>(it-&gt;first!=m)                   sum+=it-&gt;second;            <span class="hljs-keyword">else</span>                <span class="hljs-keyword">break</span>;        &#125;        sum=sum+d+flag;        <span class="hljs-type">int</span> s=y<span class="hljs-number">-1</span>+(y<span class="hljs-number">-1</span>)/<span class="hljs-number">4</span>-(y<span class="hljs-number">-1</span>)/<span class="hljs-number">100</span>+(y<span class="hljs-number">-1</span>)/<span class="hljs-number">400</span>+sum;        <span class="hljs-keyword">switch</span>(s%<span class="hljs-number">7</span>)        &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                 cout&lt;&lt;<span class="hljs-string">&quot;Sunday&quot;</span>&lt;&lt;endl;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                 cout&lt;&lt;<span class="hljs-string">&quot;Monday&quot;</span>&lt;&lt;endl;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                 cout&lt;&lt;<span class="hljs-string">&quot;Tuesday&quot;</span>&lt;&lt;endl;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:                 cout&lt;&lt;<span class="hljs-string">&quot;Wednesday&quot;</span>&lt;&lt;endl;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:                 cout&lt;&lt;<span class="hljs-string">&quot;Thursday&quot;</span>&lt;&lt;endl;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:                 cout&lt;&lt;<span class="hljs-string">&quot;Friday&quot;</span>&lt;&lt;endl;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:                 cout&lt;&lt;<span class="hljs-string">&quot;Saturday&quot;</span>&lt;&lt;endl;                <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="/2022/08/27/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/08/27/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><blockquote><p>能把对区间的修改、查询的时间复杂度由 O(n) 变为 O(logn)</p></blockquote><p>线段树实际上也是一种二叉树，每个节点用一个结构体<code>node</code>保存</p><div class="code-wrapper"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">node</span><span class="hljs-title">&#123;</span><span class="hljs-title">int</span> l,r,sum;&#125;</code></pre></div><p>其中，<code>l</code>和<code>r</code>表示线段的左右端点，<code>sum</code>表示线段的和</p><p>如果用数组存储，一棵二叉树，左孩子下标为<code>2*i</code>，右孩子下标为<code>2*i+1</code><br>因此，每一个节点的<code>sum</code>值为：<code>tree[i].sum=tree[2*i].sum+tree[2*i+1].sum</code></p><h4 id="递归建树"><a href="#递归建树" class="headerlink" title="递归建树"></a>递归建树</h4><div class="code-wrapper"><pre><code class="hljs stan"><span class="hljs-type">void</span> build(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)&#123;<span class="hljs-comment">//i:当前节点编号 l:左端点 r:右端点 </span>tree[i].l=l;tree[i].r=r;<span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><span class="hljs-keyword">if</span>(l==r)&#123;tree[i].<span class="hljs-built_in">sum</span>=<span class="hljs-type">array</span>[l];<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;build(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span>build(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span><span class="hljs-comment">//更新线段和 </span>tree[i].<span class="hljs-built_in">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-built_in">sum</span>+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-built_in">sum</span>;&#125;</code></pre></div><h3 id="类型一：单点修改，区间查询"><a href="#类型一：单点修改，区间查询" class="headerlink" title="类型一：单点修改，区间查询"></a>类型一：单点修改，区间查询</h3><p>单点修改：给第<code>idx</code>个数加<code>k</code><br>区间查询：输出区间[x,y]内所有数的和</p><h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> mod1(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> idx,<span class="hljs-built_in">int</span> k)&#123;<span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)&#123;tree[i].<span class="hljs-keyword">sum</span>+=k;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(idx&lt;=mid)mod1(<span class="hljs-number">2</span>*i,idx,k);<span class="hljs-keyword">else</span>mod1(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,idx,k);<span class="hljs-comment">//更新线段和</span>tree[i].<span class="hljs-keyword">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span>+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>;&#125;</code></pre></div><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">//区间查询</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query1</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//如果当前区间完全被查询区间包括，返回当前区间的和 </span><span class="hljs-keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)<span class="hljs-keyword">return</span> tree[i].sum;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//如果左孩子区间与查询区间相交，进入左子树 </span><span class="hljs-keyword">if</span>(l&lt;=mid)res+=<span class="hljs-built_in">query1</span>(<span class="hljs-number">2</span>*i,l,r);<span class="hljs-comment">//如果右孩子区间与查询区间相交，进入右子树</span><span class="hljs-keyword">if</span>(r&gt;mid)res+=<span class="hljs-built_in">query1</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r); <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1</a></p><p><strong>题目描述</strong></p><p>如题，已知一个数列，你需要进行下面两种操作：</p><ul><li><p>将某一个数加上 $x$</p></li><li><p>求出某区间每一个数的和</p></li></ul><p><strong>输入格式</strong></p><p>第一行包含两个正整数 $n,m$，分别表示该数列数字的个数和操作的总个数。   </p><p>第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。</p><p>接下来 $m$ 行每行包含 $3$ 个整数，表示一个操作，具体如下：</p><ul><li><p><code>1 x k</code>  含义：将第 $x$ 个数加上 $k$</p></li><li><p><code>2 x y</code>  含义：输出区间 $[x,y]$ 内每个数的和</p></li></ul><p><strong>输出格式</strong></p><p>输出包含若干行整数，即为所有操作 $2$ 的结果。</p><p>input:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> -<span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs">1416</code></pre></div><p><strong>【数据范围】</strong></p><p>对于 $30%$ 的数据，$1 \le n \le 8$，$1\le m \le 10$；<br>对于 $70%$ 的数据，$1\le n,m \le 10^4$；<br>对于 $100%$ 的数据，$1\le n,m \le 5\times 10^5$。</p><p>ac代码</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">2</span>;<span class="hljs-type">int</span> nums[N];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<span class="hljs-type">int</span> l,r,sum;&#125;tree[<span class="hljs-number">4</span>*N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//i:当前节点编号 l:左端点 r:右端点 </span>tree[i].l=l;tree[i].r=r;<span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><span class="hljs-keyword">if</span>(l==r)&#123;tree[i].sum=nums[l];<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span><span class="hljs-built_in">build</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span><span class="hljs-comment">//更新线段和 </span>tree[i].sum=tree[<span class="hljs-number">2</span>*i].sum+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].sum;&#125;<span class="hljs-comment">//单点修改 </span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mod1</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> k)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)&#123;tree[i].sum+=k;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-type">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(idx&lt;=mid)<span class="hljs-built_in">mod1</span>(<span class="hljs-number">2</span>*i,idx,k);<span class="hljs-keyword">else</span><span class="hljs-built_in">mod1</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,idx,k);<span class="hljs-comment">//更新线段和</span>tree[i].sum=tree[<span class="hljs-number">2</span>*i].sum+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].sum;&#125;<span class="hljs-comment">//区间查询</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query1</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//如果当前区间完全被查询区间包括，返回当前区间的和 </span><span class="hljs-keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)<span class="hljs-keyword">return</span> tree[i].sum;<span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//如果左孩子区间与查询区间相交，进入左子树 </span><span class="hljs-keyword">if</span>(l&lt;=mid)res+=<span class="hljs-built_in">query1</span>(<span class="hljs-number">2</span>*i,l,r);<span class="hljs-comment">//如果右孩子区间与查询区间相交，进入右子树</span><span class="hljs-keyword">if</span>(r&gt;mid)res+=<span class="hljs-built_in">query1</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r); <span class="hljs-keyword">return</span> res;&#125; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)cin&gt;&gt;nums[i];<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<span class="hljs-type">int</span> op,a,b;<span class="hljs-keyword">while</span>(m--)&#123;cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<span class="hljs-built_in">mod1</span>(<span class="hljs-number">1</span>,a,b);<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)cout&lt;&lt;<span class="hljs-built_in">query1</span>(<span class="hljs-number">1</span>,a,b)&lt;&lt;endl;&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="类型二：区间修改，单点查询"><a href="#类型二：区间修改，单点查询" class="headerlink" title="类型二：区间修改，单点查询"></a>类型二：区间修改，单点查询</h3><p>区间修改：给区间<code>[a,b]</code>每个数加k<br>单点查询：查询第<code>x</code>个数的值</p><p>思路：把修改区间所覆盖的区间加k，然后单点查询时从上到下将所有k相加</p><h4 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h4><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)&#123;<span class="hljs-comment">//完全在区间内，+k </span><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)&#123;tree[i].<span class="hljs-keyword">sum</span>+=k;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//落在左区间 </span><span class="hljs-keyword">if</span>(l&lt;=mid)<span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<span class="hljs-comment">//落在右区间 </span><span class="hljs-keyword">if</span>(r&gt;mid)<span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);&#125;</code></pre></div><h4 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h4><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> x)&#123;<span class="hljs-comment">//从上到下计算所有k的和 </span><span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<span class="hljs-keyword">return</span> tree[i].<span class="hljs-keyword">sum</span>;<span class="hljs-built_in">int</span> res=tree[i].<span class="hljs-keyword">sum</span>;<span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x&lt;=mid)res+=query(<span class="hljs-number">2</span>*i,x);<span class="hljs-keyword">else</span>res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,x);<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.com.cn/problem/P3368">P3368 树状数组 2</a></p><p><strong>题目描述</strong></p><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li><p>将某区间每一个数加上 $x$；</p></li><li><p>求出某一个数的值。</p></li></ol><p><strong>输入格式</strong></p><p>第一行包含两个整数 $N$、$M$，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 $N$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i $ 项的初始值。</p><p>接下来 $M$ 行每行包含 $2$ 或 $4$个整数，表示一个操作，具体如下：</p><p>操作 $1$： 格式：<code>1 x y k</code> 含义：将区间 $[x,y]$ 内每个数加上 $k$；</p><p>操作 $2$： 格式：<code>2 x</code> 含义：输出第 $x$ 个数的值。</p><p><strong>输出格式</strong></p><p>输出包含若干行整数，即为所有操作 $2$ 的结果。</p><p>input:</p><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-number">5</span> <span class="hljs-number">5</span><span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">2</span>;<span class="hljs-built_in">int</span> nums[N];struct node&#123;<span class="hljs-built_in">int</span> l,r,<span class="hljs-keyword">sum</span>;&#125;tree[<span class="hljs-number">4</span>*N];<span class="hljs-keyword">void</span> build(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)&#123;tree[i].l=l;tree[i].r=r;tree[i].<span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>; <span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><span class="hljs-keyword">if</span>(l==r)<span class="hljs-keyword">return</span>; <span class="hljs-built_in">int</span> mid=(l+r)/<span class="hljs-number">2</span>;build(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span>build(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span>&#125;<span class="hljs-comment">//区间修改</span><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)&#123;<span class="hljs-comment">//完全在区间内，+k </span><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)&#123;tree[i].<span class="hljs-keyword">sum</span>+=k;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//落在左区间 </span><span class="hljs-keyword">if</span>(l&lt;=mid)<span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<span class="hljs-comment">//落在右区间 </span><span class="hljs-keyword">if</span>(r&gt;mid)<span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);&#125; <span class="hljs-comment">//单点查询</span><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> x)&#123;<span class="hljs-comment">//从上到下计算所有k的和 </span><span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<span class="hljs-keyword">return</span> tree[i].<span class="hljs-keyword">sum</span>;<span class="hljs-built_in">int</span> res=tree[i].<span class="hljs-keyword">sum</span>;<span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x&lt;=mid)res+=query(<span class="hljs-number">2</span>*i,x);<span class="hljs-keyword">else</span>res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,x);<span class="hljs-keyword">return</span> res;&#125; <span class="hljs-built_in">int</span> main()&#123;<span class="hljs-built_in">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;<span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)cin&gt;&gt;nums[i];build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<span class="hljs-built_in">int</span> op,a,b,c;<span class="hljs-keyword">while</span>(m--)&#123;cin&gt;&gt;op;<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)&#123;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<span class="hljs-keyword">mod</span>(<span class="hljs-number">1</span>,a,b,c);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)&#123;cin&gt;&gt;a;cout&lt;&lt;query(<span class="hljs-number">1</span>,a)+nums[a]&lt;&lt;endl; &#125;&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125; <span class="hljs-number">2</span> <span class="hljs-number">4</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs">610</code></pre></div><p><strong>数据规模与约定</strong></p><p>对于 $30%$ 的数据：$N\le8$，$M\le10$；</p><p>对于 $70%$ 的数据：$N\le 10000$，$M\le10000$；</p><p>对于 $100%$ 的数据：$1 \leq N, M\le 500000$，$1 \leq x, y \leq n$，保证任意时刻序列中任意元素的绝对值都不大于 $2^{30}$。</p><p>ac代码：</p><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">2</span>;<span class="hljs-built_in">int</span> nums[N];struct node&#123;<span class="hljs-built_in">int</span> l,r,<span class="hljs-keyword">sum</span>;&#125;tree[<span class="hljs-number">4</span>*N];<span class="hljs-keyword">void</span> build(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)&#123;tree[i].l=l;tree[i].r=r;tree[i].<span class="hljs-keyword">sum</span>=<span class="hljs-number">0</span>; <span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><span class="hljs-keyword">if</span>(l==r)<span class="hljs-keyword">return</span>; <span class="hljs-built_in">int</span> mid=(l+r)/<span class="hljs-number">2</span>;build(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span>build(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span>&#125;<span class="hljs-comment">//区间修改</span><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)&#123;<span class="hljs-comment">//完全在区间内，+k </span><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)&#123;tree[i].<span class="hljs-keyword">sum</span>+=k;<span class="hljs-keyword">return</span> ;&#125;<span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//落在左区间 </span><span class="hljs-keyword">if</span>(l&lt;=mid)<span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<span class="hljs-comment">//落在右区间 </span><span class="hljs-keyword">if</span>(r&gt;mid)<span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);&#125; <span class="hljs-comment">//单点查询</span><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> x)&#123;<span class="hljs-comment">//从上到下计算所有k的和 </span><span class="hljs-keyword">if</span>(tree[i].l==tree[i].r)<span class="hljs-keyword">return</span> tree[i].<span class="hljs-keyword">sum</span>;<span class="hljs-built_in">int</span> res=tree[i].<span class="hljs-keyword">sum</span>;<span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x&lt;=mid)res+=query(<span class="hljs-number">2</span>*i,x);<span class="hljs-keyword">else</span>res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,x);<span class="hljs-keyword">return</span> res;&#125; <span class="hljs-built_in">int</span> main()&#123;<span class="hljs-built_in">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;<span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)cin&gt;&gt;nums[i];build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<span class="hljs-built_in">int</span> op,a,b,c;<span class="hljs-keyword">while</span>(m--)&#123;cin&gt;&gt;op;<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)&#123;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<span class="hljs-keyword">mod</span>(<span class="hljs-number">1</span>,a,b,c);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)&#123;cin&gt;&gt;a;cout&lt;&lt;query(<span class="hljs-number">1</span>,a)+nums[a]&lt;&lt;endl; &#125;&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="类型三：-区间修改，区间查询"><a href="#类型三：-区间修改，区间查询" class="headerlink" title="类型三： 区间修改，区间查询"></a>类型三： 区间修改，区间查询</h3><p>需要定义一个懒标记，然后每次修改或查询需要进行<code>pushdown</code> </p><p>pushdown步骤：</p><ul><li>当前节点懒标记不为0时，给左右子节点的懒标记加上父亲的懒标记</li><li>更新左右子节点的sum</li><li>父节点的懒标记置0<div class="code-wrapper"><pre><code class="hljs inform7">void pushdown(int i)&#123;if(tree<span class="hljs-comment">[i]</span>.lz)&#123;tree<span class="hljs-comment">[2*i]</span>.lz+=tree<span class="hljs-comment">[i]</span>.lz;tree<span class="hljs-comment">[2*i+1]</span>.lz+=tree<span class="hljs-comment">[i]</span>.lz;int mid=tree<span class="hljs-comment">[i]</span>.l+tree<span class="hljs-comment">[i]</span>.r&gt;&gt;1;tree<span class="hljs-comment">[2*i]</span>.sum+=tree<span class="hljs-comment">[i]</span>.lz*(mid-tree<span class="hljs-comment">[i]</span>.l+1);tree<span class="hljs-comment">[2*i+1]</span>.sum+=tree<span class="hljs-comment">[i]</span>.lz*(tree<span class="hljs-comment">[i]</span>.r-mid);tree<span class="hljs-comment">[i]</span>.lz=0;&#125;&#125;</code></pre></div></li></ul><h4 id="区间修改-1"><a href="#区间修改-1" class="headerlink" title="区间修改"></a>区间修改</h4><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)&#123;<span class="hljs-comment">//区间被完全包括，更新sum，lz </span><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)&#123;tree[i].<span class="hljs-keyword">sum</span>+=k*(tree[i].r-tree[i].l+<span class="hljs-number">1</span>);tree[i].lz+=k;<span class="hljs-keyword">return</span>;&#125;pushdown(i);<span class="hljs-built_in">int</span> mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(l&lt;=mid)<span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<span class="hljs-keyword">if</span>(r&gt;mid)<span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);<span class="hljs-comment">//更新和</span>tree[i].<span class="hljs-keyword">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span> +tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>;&#125;</code></pre></div><h4 id="区间查询-1"><a href="#区间查询-1" class="headerlink" title="区间查询"></a>区间查询</h4><div class="code-wrapper"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)&#123;//区间被完全包括，返回<span class="hljs-built_in">sum</span> <span class="hljs-built_in">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)return tree[i].<span class="hljs-built_in">sum</span>;pushdown(i);<span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span>=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-built_in">if</span>(l&lt;=<span class="hljs-built_in">mid</span>)res+=query(<span class="hljs-number">2</span>*i,l,r);<span class="hljs-built_in">if</span>(r&gt;<span class="hljs-built_in">mid</span>)res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r);return res;&#125;</code></pre></div><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.com.cn/problem/P3372">P3372【模板】线段树 1</a></p><p><strong>题目描述</strong></p><p>如题，已知一个数列，你需要进行下面两种操作：</p><ol><li>将某区间每一个数加上 $k$。</li><li>求出某区间每一个数的和。</li></ol><p><strong>输入格式</strong></p><p>第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。</p><p>第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。</p><p>接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：</p><ol><li><code>1 x y k</code>：将区间 $[x, y]$ 内每个数加上 $k$。</li><li><code>2 x y</code>：输出区间 $[x, y]$ 内每个数的和。</li></ol><p><strong>输出格式</strong><br>输出包含若干行整数，即为所有操作 2 的结果。</p><p>input:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs">11820</code></pre></div><p><strong>提示</strong></p><p>对于 $30%$ 的数据：$n \le 8$，$m \le 10$。<br>对于 $70%$ 的数据：$n \le {10}^3$，$m \le {10}^4$。<br>对于 $100%$ 的数据：$1 \le n, m \le {10}^5$。</p><p>保证任意时刻数列中所有元素的绝对值之和 $\le {10}^{18}$。</p><p>ac代码：</p><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;typedef <span class="hljs-built_in">long</span> <span class="hljs-built_in">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">2</span>;<span class="hljs-built_in">int</span> nums[N];struct node&#123;ll l,r,<span class="hljs-keyword">sum</span>,lz;&#125;tree[<span class="hljs-number">4</span>*N];<span class="hljs-keyword">void</span> build(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)&#123; tree[i].l=l;tree[i].r=r;tree[i].lz=<span class="hljs-number">0</span>;<span class="hljs-comment">//如果是叶子节点，赋值并返回 </span><span class="hljs-keyword">if</span>(l==r)&#123;tree[i].<span class="hljs-keyword">sum</span>=nums[l];<span class="hljs-keyword">return</span>;&#125;ll mid=(l+r)/<span class="hljs-number">2</span>;build(<span class="hljs-number">2</span>*i,l,mid);<span class="hljs-comment">//建左子树 </span>build(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//建右子树 </span><span class="hljs-comment">//更新线段和 </span>tree[i].<span class="hljs-keyword">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span>+tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>;&#125;<span class="hljs-keyword">void</span> pushdown(<span class="hljs-built_in">int</span> i)&#123;<span class="hljs-keyword">if</span>(tree[i].lz)&#123;tree[<span class="hljs-number">2</span>*i].lz+=tree[i].lz;tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].lz+=tree[i].lz;ll mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span>+=tree[i].lz*(mid-tree[i].l+<span class="hljs-number">1</span>);tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>+=tree[i].lz*(tree[i].r-mid);tree[i].lz=<span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-keyword">void</span> <span class="hljs-keyword">mod</span>(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k)&#123;<span class="hljs-comment">//区间被完全包括，更新sum，lz </span><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)&#123;tree[i].<span class="hljs-keyword">sum</span>+=k*(tree[i].r-tree[i].l+<span class="hljs-number">1</span>);tree[i].lz+=k;<span class="hljs-keyword">return</span>;&#125;pushdown(i);ll mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(l&lt;=mid)<span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i,l,r,k);<span class="hljs-keyword">if</span>(r&gt;mid)<span class="hljs-keyword">mod</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r,k);<span class="hljs-comment">//更新和</span>tree[i].<span class="hljs-keyword">sum</span>=tree[<span class="hljs-number">2</span>*i].<span class="hljs-keyword">sum</span> +tree[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>].<span class="hljs-keyword">sum</span>;&#125;ll query(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r)&#123;<span class="hljs-comment">//区间被完全包括，返回sum </span><span class="hljs-keyword">if</span>(l&lt;=tree[i].l&amp;&amp;r&gt;=tree[i].r)<span class="hljs-keyword">return</span> tree[i].<span class="hljs-keyword">sum</span>;pushdown(i);ll mid=tree[i].l+tree[i].r&gt;&gt;<span class="hljs-number">1</span>;ll res=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(l&lt;=mid)res+=query(<span class="hljs-number">2</span>*i,l,r);<span class="hljs-keyword">if</span>(r&gt;mid)res+=query(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,l,r);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-built_in">int</span> main()&#123;<span class="hljs-built_in">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;<span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)cin&gt;&gt;nums[i];build(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<span class="hljs-built_in">int</span> op,a,b,c;<span class="hljs-keyword">while</span>(m--)&#123;cin&gt;&gt;op;<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)&#123;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<span class="hljs-keyword">mod</span>(<span class="hljs-number">1</span>,a,b,c);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)&#123;cin&gt;&gt;a&gt;&gt;b;cout&lt;&lt;query(<span class="hljs-number">1</span>,a,b)&lt;&lt;endl;&#125;&#125; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进制转换与大阶乘</title>
    <link href="/2022/08/27/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%A4%A7%E9%98%B6%E4%B9%98/"/>
    <url>/2022/08/27/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%A4%A7%E9%98%B6%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><blockquote><p>下面的模板可用于36以内进制任意转换</p></blockquote><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>将M进制的数X转换为N进制的数输出。<br>输入的第一行包括两个整数：M和N(2&lt;&#x3D;M,N&lt;&#x3D;36)。<br>下面的一行输入一个数X，X是M进制的数，现在要求你将M进制的数X转换成N进制的数输出。</p><p>input:</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">36</span> <span class="hljs-number">9</span><span class="hljs-attribute">XYZZA765</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs">10374545654665</code></pre></div><p>代码：</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><span class="hljs-keyword">using</span> namespace std;string convert(string s,<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;    <span class="hljs-type">int</span> len=s.size();    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;    string res;    <span class="hljs-keyword">while</span>(i&lt;len)    &#123;#<span class="hljs-keyword">include</span>&lt;bits/stdc++.h&gt;<span class="hljs-keyword">using</span> namespace std;<span class="hljs-type">int</span> a[<span class="hljs-number">100000</span>];<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n;    cin&gt;&gt;n;     <span class="hljs-type">int</span> ws=<span class="hljs-number">1</span>;    a[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)    &#123;        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;ws;++j)        &#123;            <span class="hljs-type">int</span> t=i*a[j]+k;            k=t/<span class="hljs-number">10</span>;            a[j]=t%<span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">while</span>(k)        &#123;            a[ws]=k%<span class="hljs-number">10</span>;            k/=<span class="hljs-number">10</span>;            ++ws;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ws<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;<span class="hljs-comment">--i)</span>        cout&lt;&lt;a[i];    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;)        &#123;            <span class="hljs-keyword">if</span>(s[j]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[j]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)                tmp1=s[j]-<span class="hljs-string">&#x27;0&#x27;</span>;            <span class="hljs-keyword">else</span>                tmp1=s[j]-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">10</span>;            <span class="hljs-type">int</span> t=k*a+tmp1;            k=t%b;            tmp2=t/b;            <span class="hljs-keyword">if</span>(tmp2&lt;=<span class="hljs-number">9</span>)                s[j]=tmp2+<span class="hljs-string">&#x27;0&#x27;</span>;            <span class="hljs-keyword">else</span>                s[j]=tmp2<span class="hljs-number">-10</span>+<span class="hljs-string">&#x27;A&#x27;</span>;                    &#125;        <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">9</span>)            res+=k+<span class="hljs-string">&#x27;0&#x27;</span>;        <span class="hljs-keyword">else</span>            res+=k<span class="hljs-number">-10</span>+<span class="hljs-string">&#x27;A&#x27;</span>;        <span class="hljs-keyword">while</span>(s[i]==<span class="hljs-string">&#x27;0&#x27;</span>)            ++i;    &#125;    reverse(res.<span class="hljs-keyword">begin</span>(),res.<span class="hljs-keyword">end</span>());    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> m,n;    string s;    cin&gt;&gt;m&gt;&gt;n;    cin&gt;&gt;s;    cout&lt;&lt;convert(s,m,n)&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="大阶乘"><a href="#大阶乘" class="headerlink" title="大阶乘"></a>大阶乘</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p> 输入一个正整数N，输出N的阶乘<br> N&lt;&#x3D;1000</p><p> input:</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-number">1000</span></code></pre></div><p> output:</p><div class="code-wrapper"><pre><code class="hljs">402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</code></pre></div><p>代码</p><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span>using namespace std;int a[100000];int main()&#123;    int n;    cin&gt;&gt;n;     int <span class="hljs-attribute">ws</span>=1;    a[0]=1;    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=2;i&lt;=n;++i)    &#123;        int <span class="hljs-attribute">k</span>=0;        <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=0;j&lt;ws;++j)        &#123;            int <span class="hljs-attribute">t</span>=i*a[j]+k;            <span class="hljs-attribute">k</span>=t/10;            a[j]=t%10;        &#125;        <span class="hljs-keyword">while</span>(k)        &#123;            a[ws]=k%10;            k/=10;            ++ws;        &#125;    &#125;    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=ws-1;i&gt;=0;--i)        cout&lt;&lt;a[i];    return 0;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常见问题</title>
    <link href="/2022/08/26/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/26/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="c-中的static关键字"><a href="#c-中的static关键字" class="headerlink" title="c++中的static关键字"></a>c++中的static关键字</h2><p>加载顺序（面向对象）</p><ul><li>静态-&gt;非静态-&gt;构造方法</li><li>父类静态-子类静态-父类非静态-父类构造-子类非静态-子类构造</li></ul><p>静态成员变量(面向对象)</p><ul><li>所有对象共享,不属于某个对象，可以通过类名访问，也可通过对象访问</li><li>在编译阶段分配内存，分配在数据区（全局区）</li><li>类内声明，类外初始化(class::var)</li><li>sizeof不会计算静态成员变量</li></ul><p>静态成员函数(面向对象)</p><ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul><p>静态全局变量(面向过程)</p><ul><li>在数据区分配内存</li><li>未初始化会自动初始化为0</li><li>整个文件内可见，文件外不可见</li></ul><p>静态局部变量(面向过程)</p><ul><li>在数据区分配内存 </li><li>一般在声明处初始化，未初始化会自动初始化为0</li><li>静态局部变量始终驻留在数据区，但他的作用域是局部作用域，当定义它的函数或语句块结束，其作用域随之结束</li></ul><blockquote><p>总结：静态变量具有全局变量的生命周期，但只能作用于自己的作用域。</p></blockquote><hr><h2 id="c-模板"><a href="#c-模板" class="headerlink" title="c++模板"></a>c++模板</h2><blockquote><p>模板是c++泛型编程的主要使用的技术</p></blockquote><p><strong>函数模板</strong></p><p>创建一个通用的函数，函数返回值类型和形参可以不指定，用一个虚拟的类型来表示</p><p>声明一个模板<code>template&lt;typename T&gt;</code>或者<code>template&lt;class T&gt;</code></p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(T a,T b)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> a+b;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">double</span> a=<span class="hljs-number">10.5</span>,b=<span class="hljs-number">20.00002</span>;cout&lt;&lt;<span class="hljs-string">&quot;自动类型推导&quot;</span>&lt;&lt;endl;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>,<span class="hljs-built_in">sum</span>(a,b));cout&lt;&lt;<span class="hljs-string">&quot;显示指定类型&quot;</span>&lt;&lt;endl;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,<span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">double</span>&gt;(a,b));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>注意</p><ul><li>自动推导类型需要推导出一致的类型</li><li>函数模板使用时必须确定<code>T</code>的类型</li><li>普通函数和函数模板都可调用时，先调用普通函数</li><li>如果类型和函数模板更匹配，则优先调用函数模板</li></ul><p><strong>类模板</strong></p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">M</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<span class="hljs-keyword">public</span>:T name;M age;<span class="hljs-built_in">person</span>(T a,M b):<span class="hljs-built_in">name</span>(a),<span class="hljs-built_in">age</span>(b)&#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;cndh&quot;</span>,<span class="hljs-number">18</span>)</span></span>;cout&lt;&lt;p.name&lt;&lt;endl;cout&lt;&lt;p.age&lt;&lt;endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>注意：</p><ul><li>类模板不能自动推导类型</li><li>类模板可以在模板参数列表中指定默认类型</li><li>类模板中定义的函数在调用时才创建</li></ul><hr><h2 id="c-深拷贝和浅拷贝的区别"><a href="#c-深拷贝和浅拷贝的区别" class="headerlink" title="c++深拷贝和浅拷贝的区别"></a>c++深拷贝和浅拷贝的区别</h2><blockquote><p><strong>浅拷贝</strong> （默认方式）：将原对象的引用直接赋给新对象，只是原对象的一个引用。</p></blockquote><blockquote><p><strong>深拷贝</strong>： 创建一个新的对象，将原对象的各项属性拷贝过来，深拷贝会在堆中额外申请内存来储存数据，当数据成员中有指针时，必须要用深拷贝。</p></blockquote><ul><li>因为申请了新的内存，所以深拷贝改变新对象的属性对原对象没有影响，但是浅拷贝会影响</li><li>当成员中有指针时，必须用深拷贝。因为浅拷贝的新指针和旧指针都指向同一块内存，在新对象和旧对象析构时，已经释放的内存会被再次释放，这时会出现错误。</li></ul><hr><h2 id="c-智能指针"><a href="#c-智能指针" class="headerlink" title="c++智能指针"></a>c++智能指针</h2><p><strong>内存泄漏</strong>：</p><ul><li><p>指因某些原因造成程序未能释放已不再使用的内存。内存泄漏并不是内存消失了，而是由于程序设计的问题，失去对某块内存的控制，导致无法利用该块内存。</p></li><li><p>内存泄漏会导致程序响应越来越慢，甚至崩溃</p></li><li><p>一般有2种内存泄漏，一种是堆区分配的内存没有及时释放，一种是套接字、文件描述符等没有释放，2种情形都会导致资源的浪费</p></li></ul><p><strong>RALL</strong></p><ul><li>RAII（Resource Acquisition Is Initialization）是一种将对象生命周期和资源绑定的技术</li><li>对象创建时获取资源，析构时释放资源</li></ul><p>智能指针就具有RALL的特性</p><p><strong>auto_ptr</strong></p><p>c++98中就已经提供了智能指针auto_ptr</p><p>例如：<code>auto_ptr&lt;int&gt; p(new int)</code>就相当于 <code>int * p=new int</code></p><p>auto_ptr的局限性：</p><ul><li>拷贝或者赋值会导致原指针变为<code>NULL</code>，如<code>p1=p2</code>后，<code>p2变成了NULL</code></li><li>不支持对象数组的内存管理</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/08/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/08/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><blockquote><p>通过一个数组来保存各个节点的祖先，所有连通的节点的祖先相同，常用于解决最小生成树，图的连通性等问题</p></blockquote><h3 id="递归的查找节点的祖先"><a href="#递归的查找节点的祖先" class="headerlink" title="递归的查找节点的祖先"></a>递归的查找节点的祖先</h3><p>首先假设有<code>N</code>个节点，定义一个数组<code>vset[N]</code>记录所有节点的祖先，<code>vset[N]初始化为-1</code></p><p>定义一个<code>find</code>函数来查找祖先</p><div class="code-wrapper"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> <span class="hljs-keyword">find</span>(<span class="hljs-keyword">int</span> a)&#123;    <span class="hljs-keyword">if</span>(vset[a]==-<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">else</span>    &#123;        vset[a]=<span class="hljs-keyword">find</span>(vset[a]);        <span class="hljs-keyword">return</span> vset[a];    &#125;&#125;</code></pre></div><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>有<code>n</code>条道路，<code>m</code>个村庄,计算出使所有村庄连通的最低成本</p><p>输入n,m，然后输入n行，每一行输入u,v,w表示两个村庄的编号和道路成本</p><p>输出使所有村庄连通的最低成本</p><p>input:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs">3</code></pre></div><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1000</span>;<span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; vi;<span class="hljs-type">int</span> vset[<span class="hljs-number">1000</span>];<span class="hljs-function">vector&lt;vi&gt; <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-number">1000</span>,vi(<span class="hljs-number">3</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(vset[a]==<span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">else</span>    &#123;        vset[a]=<span class="hljs-built_in">find</span>(vset[a]);        <span class="hljs-keyword">return</span> vset[a];    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n,m;    cin&gt;&gt;n&gt;&gt;m;    <span class="hljs-built_in">memset</span>(vset,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(vset));    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)    &#123;        cin&gt;&gt;e[i][<span class="hljs-number">0</span>]&gt;&gt;e[i][<span class="hljs-number">1</span>]&gt;&gt;e[i][<span class="hljs-number">2</span>];    &#125;    <span class="hljs-built_in">sort</span>(e.<span class="hljs-built_in">begin</span>(),e.<span class="hljs-built_in">end</span>(),[](vi a,vi b)&#123;        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>]&lt;b[<span class="hljs-number">2</span>];    &#125;);    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(vi&amp; t: e)    &#123;        <span class="hljs-type">int</span> x=<span class="hljs-built_in">find</span>(t[<span class="hljs-number">0</span>]);        <span class="hljs-type">int</span> y=<span class="hljs-built_in">find</span>(t[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">if</span>(x!=y)        &#123;            ++cnt;            ans+=t[<span class="hljs-number">2</span>];            vset[x]=y;            <span class="hljs-keyword">if</span>(cnt==n<span class="hljs-number">-1</span>)                <span class="hljs-keyword">break</span>;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重排链表</title>
    <link href="/2022/08/25/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/08/25/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h3><blockquote><p>来源于leetcode上的一道题 <a href="https://leetcode.cn/problems/reorder-list/">重排链表</a>，因为这到题涉及到许多链表的知识，正好拿来复习一下</p></blockquote><p>题目描述</p><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：<br><code>L0 → L1 → … → Ln - 1 → Ln</code></p><p>请将其重新排列后变为：</p><p><code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</code></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>先找到链表的中点</li><li>将链表后半段反转</li><li>将前后两端重新合并</li></ul><h3 id="找到链表中点（快慢指针）"><a href="#找到链表中点（快慢指针）" class="headerlink" title="找到链表中点（快慢指针）"></a>找到链表中点（快慢指针）</h3><blockquote><p>设置两个指针，其中快的指针每次移动2次，慢指针移动一次，当快指针到达尾部，慢指针的位置就是中点</p></blockquote><p>代码：</p><div class="code-wrapper"><pre><code class="hljs autoit">ListNode* middleNode(ListNode* head) &#123;        ListNode *low=head<span class="hljs-comment">;</span>        ListNode *fast=head<span class="hljs-comment">;</span>        //如果有偶数个节点，以下条件找到的是右侧中点        //如果要找左侧中点，改为：fast-&gt;<span class="hljs-keyword">next</span>!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;<span class="hljs-keyword">next</span>-&gt;<span class="hljs-keyword">next</span>!=<span class="hljs-literal">NULL</span>即可        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;<span class="hljs-keyword">next</span>!=<span class="hljs-literal">NULL</span>)        &#123;            low=low-&gt;<span class="hljs-keyword">next</span><span class="hljs-comment">;</span>            fast=fast-&gt;<span class="hljs-keyword">next</span>-&gt;<span class="hljs-keyword">next</span><span class="hljs-comment">;</span>        &#125;        <span class="hljs-keyword">return</span> low<span class="hljs-comment">;</span>    &#125;</code></pre></div><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><blockquote><p>其实反转链表可以用线性表做，时间复杂度差不多，但这里还是回归链表操作</p></blockquote><p>代码：</p><div class="code-wrapper"><pre><code class="hljs routeros">ListNode* reverseList(ListNode* head) &#123;        ListNode* <span class="hljs-attribute">pre</span>=<span class="hljs-literal">NULL</span>;        ListNode* <span class="hljs-attribute">l</span>=head;        <span class="hljs-keyword">while</span>(l!=<span class="hljs-literal">NULL</span>)        &#123;            ListNode* <span class="hljs-attribute">tmp</span>=l-&gt;next;            l-&gt;<span class="hljs-attribute">next</span>=pre;            <span class="hljs-attribute">pre</span>=l;            <span class="hljs-attribute">l</span>=tmp;        &#125;        return pre;    &#125;</code></pre></div><h3 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h3><blockquote><p>将l1和l2交错合并</p></blockquote><p>代码：</p><div class="code-wrapper"><pre><code class="hljs routeros">void merge(ListNode* l1,ListNode* l2)&#123;    <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">NULL</span>&amp;&amp;l2!=<span class="hljs-literal">NULL</span>)    &#123;        ListNode* <span class="hljs-attribute">l1t</span>=l1-&gt;next;        ListNode* <span class="hljs-attribute">l2t</span>=l2-&gt;next;        l1-&gt;<span class="hljs-attribute">next</span>=l2;        <span class="hljs-attribute">l1</span>=l1t;        l2-&gt;<span class="hljs-attribute">next</span>=l1;        <span class="hljs-attribute">l2</span>=l2t;    &#125;&#125;</code></pre></div><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><div class="code-wrapper"><pre><code class="hljs routeros">void reorderList(ListNode* head) &#123;    ListNode* <span class="hljs-attribute">mid</span>=middleNode(head);    ListNode* <span class="hljs-attribute">l1</span>=head;    ListNode* <span class="hljs-attribute">l2</span>=mid-&gt;next;    mid-&gt;<span class="hljs-attribute">next</span>=<span class="hljs-literal">NULL</span>;    ListNode* <span class="hljs-attribute">r</span>=reverseList(l2);    merge(l1,r);&#125;ListNode* reverseList(ListNode* head) &#123;    ListNode* <span class="hljs-attribute">pre</span>=<span class="hljs-literal">NULL</span>;    ListNode* <span class="hljs-attribute">l</span>=head;    <span class="hljs-keyword">while</span>(l!=<span class="hljs-literal">NULL</span>)    &#123;        ListNode* <span class="hljs-attribute">tmp</span>=l-&gt;next;        l-&gt;<span class="hljs-attribute">next</span>=pre;        <span class="hljs-attribute">pre</span>=l;        <span class="hljs-attribute">l</span>=tmp;    &#125;    return pre;&#125;ListNode* middleNode(ListNode* head) &#123;    ListNode *<span class="hljs-attribute">low</span>=head;    ListNode <span class="hljs-number">*fa</span><span class="hljs-attribute">st</span>=head;    <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;next-&gt;next!=<span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-attribute">low</span>=low-&gt;next;        <span class="hljs-attribute">fast</span>=fast-&gt;next-&gt;next;    &#125;    return low;&#125;void merge(ListNode* l1,ListNode* l2)&#123;        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">NULL</span>&amp;&amp;l2!=<span class="hljs-literal">NULL</span>)    &#123;        ListNode* <span class="hljs-attribute">l1t</span>=l1-&gt;next;        ListNode* <span class="hljs-attribute">l2t</span>=l2-&gt;next;        l1-&gt;<span class="hljs-attribute">next</span>=l2;        <span class="hljs-attribute">l1</span>=l1t;        l2-&gt;<span class="hljs-attribute">next</span>=l1;        <span class="hljs-attribute">l2</span>=l2t;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>差分与前缀和</title>
    <link href="/2022/08/24/%E5%B7%AE%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <url>/2022/08/24/%E5%B7%AE%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><blockquote><p>前缀和指的是序列的前n项和</p></blockquote><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p>先看一个例题：<br>输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。<br>如果使用暴力枚举，时间复杂度为 <code>O(n*m)</code>,但是使用前缀和的话，时间复杂度可降为 <code>O(n)</code><br>input:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">4</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs">3610</code></pre></div><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>;<span class="hljs-type">int</span> a[N]; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n,m,l,r;cin&gt;&gt;n&gt;&gt;m;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;cin&gt;&gt;a[i];a[i]+=a[i<span class="hljs-number">-1</span>];&#125;<span class="hljs-keyword">while</span>(m--)&#123;cin&gt;&gt;l&gt;&gt;r;cout&lt;&lt;a[r]-a[l<span class="hljs-number">-1</span>]&lt;&lt;endl;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>每一个元素<code>a[i][j]</code>表示左上角和第<code>i</code>行，第<code>j</code>列围成的元素之和</p><p>更新方式： <code>a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]</code></p><p>即下图中：紫色区域+绿色区域-红色区域</p><p><img src="https://img-blog.csdnimg.cn/20201214201734653.png"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。<br>对于每个询问输出子矩阵中所有数的和</p><p>input:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><span class="hljs-symbol">3 </span><span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs">172721</code></pre></div><p>代码：</p><div class="code-wrapper"><pre><code class="hljs inform7">#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e3;int a<span class="hljs-comment">[N]</span><span class="hljs-comment">[N]</span>; int main()&#123;int n,m,q;int x1,y1,x2,y2;cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;for(int i=1;i&lt;=n;++i)&#123;for(int j=1;j&lt;=m;++j)&#123;cin&gt;&gt;a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>;a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>+=a<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>+a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>-a<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>;&#125;&#125;while(q--)&#123;cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;cout&lt;&lt;a<span class="hljs-comment">[x2]</span><span class="hljs-comment">[y2]</span>-a<span class="hljs-comment">[x1-1]</span><span class="hljs-comment">[y2]</span>-a<span class="hljs-comment">[x2]</span><span class="hljs-comment">[y1-1]</span>+a<span class="hljs-comment">[x1-1]</span><span class="hljs-comment">[y1-1]</span>&lt;&lt;endl;&#125;return 0;&#125;</code></pre></div><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><blockquote><p>可以看作前缀和的逆运算</p></blockquote><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><p>常用于给数组的某个区间段<code>[l,r]</code>加上某个数<code>c</code>，可以减小时间复杂度</p><ul><li>先构造差分数组：<code>b[i]=a[i]-a[i-1]</code></li><li>构造好之后 <code>b[l]+=c</code>,<code>b[r+1]-=c</code></li><li>然后根据<code>b[i]+=b[i-1]</code>计算前缀和数组，就是最终答案</li></ul><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>输入一个长度为n的整数序列。<br>接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。<br>请你输出进行完所有操作后的序列。</p><p>input:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span></code></pre></div><p>代码：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>;<span class="hljs-type">int</span> a[N],b[N]; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> n,m,l,r,c;cin&gt;&gt;n&gt;&gt;m;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;cin&gt;&gt;a[i];b[i]=a[i]-a[i<span class="hljs-number">-1</span>];&#125;<span class="hljs-keyword">while</span>(m--)&#123;cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;b[l]+=c;b[r+<span class="hljs-number">1</span>]-=c;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)b[i]+=b[i<span class="hljs-number">-1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>常用于给某个子矩阵的每个元素加上 c</p><ul><li>二维差分数组的构造：<br>  <code>b[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]</code></li><li>修改差分数组：  <div class="code-wrapper"><pre><code class="hljs inform7">b<span class="hljs-comment">[x1]</span><span class="hljs-comment">[y1]</span>+=c;b<span class="hljs-comment">[x1]</span><span class="hljs-comment">[y2+1]</span>-=c;b<span class="hljs-comment">[x2+1]</span><span class="hljs-comment">[y1]</span>-=c;b<span class="hljs-comment">[x2+1]</span><span class="hljs-comment">[y2+1]</span>+=c;</code></pre></div></li><li>生成前缀和数组：<br>  <code>b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];</code></li></ul><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p>输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。<br>每个操作都要将选中的子矩阵中的每个元素的值加上c。<br>请你将进行完所有操作后的矩阵输出。</p><p>input:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span></code></pre></div><p>代码：</p><div class="code-wrapper"><pre><code class="hljs prolog">#include&lt;bits/stdc++.h&gt;using namespace std;const int <span class="hljs-symbol">N</span>=<span class="hljs-number">1e3</span>;int a[<span class="hljs-symbol">N</span>][<span class="hljs-symbol">N</span>],b[<span class="hljs-symbol">N</span>][<span class="hljs-symbol">N</span>]; int main()&#123;int n,m,q;int x1,y1,x2,y2,c;cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;for(int i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;for(int j=<span class="hljs-number">1</span>;j&lt;=m;++j)&#123;cin&gt;&gt;a[i][j];b[i][j]=a[i][j]-a[i<span class="hljs-number">-1</span>][j]-a[i][j<span class="hljs-number">-1</span>]+a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];&#125;&#125;while(q--)&#123;cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;b[x1][y1]+=c;b[x1][y2+<span class="hljs-number">1</span>]-=c;b[x2+<span class="hljs-number">1</span>][y1]-=c;b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]+=c;&#125;for(int i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;for(int j=<span class="hljs-number">1</span>;j&lt;=m;++j)b[i][j]+=b[i<span class="hljs-number">-1</span>][j]+b[i][j<span class="hljs-number">-1</span>]-b[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];&#125;for(int i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;for(int j=<span class="hljs-number">1</span>;j&lt;=m;++j)cout&lt;&lt;b[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;cout&lt;&lt;endl;&#125;return <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速幂矩阵幂</title>
    <link href="/2022/08/23/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9F%A9%E9%98%B5%E5%B9%82/"/>
    <url>/2022/08/23/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9F%A9%E9%98%B5%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>快速幂</strong> 快速幂常用于计算指数非常大的幂，核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。</p></blockquote><p><em>直接看例题</em></p><h3 id="例1-快速幂"><a href="#例1-快速幂" class="headerlink" title="例1 快速幂"></a>例1 快速幂</h3><p>输入三个数字a,b,c,输出 a^b <strong>mod</strong> c<br>input:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">10</span> <span class="hljs-number">10</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs">4</code></pre></div><p>代码</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> a,b,c;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ksm</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;a=a%c;<span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>)ans=(ans*a)%c;a=(a*a)%c;b/=<span class="hljs-number">2</span>;&#125;<span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;cout&lt;&lt;<span class="hljs-built_in">ksm</span>()&lt;&lt;endl;&#125;</code></pre></div><h3 id="例2-矩阵幂"><a href="#例2-矩阵幂" class="headerlink" title="例2 矩阵幂"></a>例2 矩阵幂</h3><p>描述<br>给定一个n*n的矩阵，输出矩阵的k次方</p><p>输入描述<br>有多组输入，第一行输入n和k<br>后面n行输入矩阵元素<br>2&lt;&#x3D;n&lt;&#x3D;10,1&lt;&#x3D;k&lt;&#x3D;5<br>输出描述<br>每组输入输出矩阵的k次方<br>input:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><span class="hljs-symbol">9 </span><span class="hljs-number">8</span><span class="hljs-symbol">9 </span><span class="hljs-number">3</span><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><span class="hljs-symbol">4 </span><span class="hljs-number">8</span> <span class="hljs-number">4</span><span class="hljs-symbol">9 </span><span class="hljs-number">3</span> <span class="hljs-number">0</span><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">7</span><span class="hljs-symbol">5 </span><span class="hljs-number">2</span><span class="hljs-symbol">4 </span><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span><span class="hljs-symbol">8 </span><span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><span class="hljs-symbol">9 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><span class="hljs-symbol">7 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">153 </span><span class="hljs-number">96</span><span class="hljs-symbol">108 </span><span class="hljs-number">81</span><span class="hljs-symbol">1216 </span><span class="hljs-number">1248</span> <span class="hljs-number">708</span><span class="hljs-symbol">1089 </span><span class="hljs-number">927</span> <span class="hljs-number">504</span><span class="hljs-symbol">1161 </span><span class="hljs-number">1151</span> <span class="hljs-number">739</span><span class="hljs-symbol">47 </span><span class="hljs-number">29</span> <span class="hljs-number">41</span> <span class="hljs-number">22</span> <span class="hljs-number">16</span><span class="hljs-symbol">147 </span><span class="hljs-number">103</span> <span class="hljs-number">73</span> <span class="hljs-number">116</span> <span class="hljs-number">94</span><span class="hljs-symbol">162 </span><span class="hljs-number">108</span> <span class="hljs-number">153</span> <span class="hljs-number">168</span> <span class="hljs-number">126</span><span class="hljs-symbol">163 </span><span class="hljs-number">67</span> <span class="hljs-number">112</span> <span class="hljs-number">158</span> <span class="hljs-number">122</span><span class="hljs-symbol">152 </span><span class="hljs-number">93</span> <span class="hljs-number">93</span> <span class="hljs-number">111</span> <span class="hljs-number">97</span></code></pre></div><p>代码：</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<span class="hljs-keyword">class</span> <span class="hljs-title">M</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> row;    <span class="hljs-built_in">int</span> col;    <span class="hljs-built_in">int</span> m[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];    M(<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> c):row(r),col(c)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;col;++j)            &#123;                <span class="hljs-keyword">if</span>(i==j)                    m[i][j]=<span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span>                    m[i][j]=<span class="hljs-number">0</span>;            &#125;        &#125;          &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">input</span>()</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;col;++j)                cin&gt;&gt;m[i][j];        &#125;     &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span>()</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;col;++j)                cout&lt;&lt;m[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;            cout&lt;&lt;endl;        &#125;    &#125;    M <span class="hljs-keyword">operator</span>* (<span class="hljs-keyword">const</span> M&amp; t) <span class="hljs-keyword">const</span>    &#123;        <span class="hljs-function">M <span class="hljs-title">ans</span>(<span class="hljs-params">row,t.col</span>)</span>;        memset(ans.m,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(ans.m));        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;t.col;++j)            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;k&lt;col;++k)                &#123;                    ans.m[i][j]+=m[i][k]*t.m[k][j];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;<span class="hljs-function">M <span class="hljs-title">ksm</span>(<span class="hljs-params">M a,<span class="hljs-built_in">int</span> k</span>)</span>&#123;    <span class="hljs-function">M <span class="hljs-title">ans</span>(<span class="hljs-params">a.row,a.col</span>)</span>;    <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(k%<span class="hljs-number">2</span>)            ans=ans*a;        a=a*a;        k/=<span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> ans; &#125;<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;    <span class="hljs-built_in">int</span> n,k;    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;k)    &#123;        <span class="hljs-function">M <span class="hljs-title">a</span>(<span class="hljs-params">n,n</span>)</span>;        a.input();        M ans=ksm(a,k);        ans.output();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最短路</title>
    <link href="/2022/08/22/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2022/08/22/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>最短路</strong>也是常见的题目，下面根据例题来复习一下最短路的几种解法</p></blockquote><p>[toc]</p><h3 id="例1：单源最短路（标准版）洛谷p4779"><a href="#例1：单源最短路（标准版）洛谷p4779" class="headerlink" title="例1：单源最短路（标准版）洛谷p4779"></a>例1：单源最短路（标准版）洛谷p4779</h3><p>题目描述</p><p>给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。</p><p>数据保证你能从 $s$ 出发到任意点。</p><p>输入格式</p><p>第一行为三个正整数 $n, m, s$。<br>第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$，表示从 $u_i$ 到 $v_i$ 有一条权值为 $w_i$ 的有向边。</p><p>输出格式</p><p>输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。</p><p>样例输入 #1</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span></code></pre></div><p>样例输出 #1</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span></code></pre></div><p>提示</p><p>$1 \leq n \leq 10^5$；</p><p>$1 \leq m \leq 2\times 10^5$；</p><p>$s &#x3D; 1$；</p><p>$1 \leq u_i, v_i\leq n$；</p><p>$0 \leq w_i \leq 10 ^ 9$,</p><p>$0 \leq \sum w_i \leq 10 ^ 9$。</p><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><blockquote><p>此题用spfa会超时,这里写的代码弱化了数据范围，存图也直接用二维数组了，主要是复习spfa的思路</p></blockquote><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> n,m,s;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">1</span>;<span class="hljs-type">int</span> mp[N][N];<span class="hljs-type">int</span> dist[N];<span class="hljs-type">bool</span> vis[N]; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">memset</span>(mp,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(mp));<span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dist));cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;dist[s]=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> u,v,w;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;mp[u][v]=w;&#125;queue&lt;<span class="hljs-type">int</span>&gt; q;q.<span class="hljs-built_in">push</span>(s);<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();vis[t]=<span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<span class="hljs-keyword">if</span>(dist[i]&gt;dist[t]+mp[t][i])&#123;dist[i]=dist[t]+mp[t][i];<span class="hljs-keyword">if</span>(!vis[i])&#123;vis[i]=<span class="hljs-literal">true</span>;q.<span class="hljs-built_in">push</span>(i);&#125;&#125;&#125;&#125; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)cout&lt;&lt;dist[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;cout&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="Dijkstra普通版"><a href="#Dijkstra普通版" class="headerlink" title="Dijkstra普通版"></a>Dijkstra普通版</h3><blockquote><p>此题用普通Dijkstra会超时,这里写的代码弱化了数据范围，存图也直接用二维数组了，主要是复习dj的思路</p></blockquote><div class="code-wrapper"><pre><code class="hljs excel">#include&lt;bits/stdc++.h&gt;using namespace std;<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>,m,s;const <span class="hljs-built_in">int</span> <span class="hljs-built_in">N</span>=<span class="hljs-number">1</span>e4+<span class="hljs-number">1</span>;<span class="hljs-built_in">int</span> mp[<span class="hljs-built_in">N</span>][<span class="hljs-built_in">N</span>];<span class="hljs-built_in">int</span> dist[<span class="hljs-built_in">N</span>];bool vis[<span class="hljs-built_in">N</span>]; <span class="hljs-built_in">int</span> main()&#123;memset(mp,<span class="hljs-number">0</span>x3f,sizeof(mp));memset(dist,<span class="hljs-number">0</span>x3f,sizeof(dist));cin&gt;&gt;<span class="hljs-built_in">n</span>&gt;&gt;m&gt;&gt;s;dist[s]=<span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> u,v,w;for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;mp[u][v]=w;&#125;for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">n</span>;++i)&#123;<span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>=-<span class="hljs-number">1</span>;for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-built_in">n</span>;++j)&#123;<span class="hljs-built_in">if</span>(!vis[j]&amp;&amp;(<span class="hljs-built_in">t</span>==-<span class="hljs-number">1</span>||dist[<span class="hljs-built_in">t</span>]&gt;dist[j]))<span class="hljs-built_in">t</span>=j;&#125;vis[<span class="hljs-built_in">t</span>]=<span class="hljs-built_in">true</span>;for(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-built_in">n</span>;++j)&#123;dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[<span class="hljs-built_in">t</span>]+mp[<span class="hljs-built_in">t</span>][j]);&#125;&#125;for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">n</span>;++i)cout&lt;&lt;dist[i]&lt;&lt;&#x27; &#x27;;cout&lt;&lt;endl;    return <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="Dijkstra堆优化版-AC"><a href="#Dijkstra堆优化版-AC" class="headerlink" title="Dijkstra堆优化版(AC)"></a>Dijkstra堆优化版(AC)</h3><h4 id="链式前向星存图"><a href="#链式前向星存图" class="headerlink" title="链式前向星存图"></a>链式前向星存图</h4><p>题目中给的节点数很多，属于稀疏图，二维数组无法存储，所以需要使用<strong>链式前向星</strong>存储，方法如下：</p><p>定义一个数组<code>head[]</code>,<code>head[a]</code>表示以a为起始点的最后一条边的序号</p><p>$cnt$：表示边的序号</p><p>结构体$edge$，存储边</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> edge&#123;<span class="hljs-built_in">int</span> <span class="hljs-keyword">to</span>;<span class="hljs-comment">//这条边指向的点 </span><span class="hljs-built_in">int</span> next;<span class="hljs-comment">//这条边的邻边的序号 </span><span class="hljs-built_in">int</span> w;<span class="hljs-comment">//这条边的权值 </span>&#125;;</code></pre></div><p>加边</p><div class="code-wrapper"><pre><code class="hljs hsp">void add(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> w)&#123;++<span class="hljs-keyword">cnt</span><span class="hljs-comment">;</span>e[<span class="hljs-keyword">cnt</span>].to=v<span class="hljs-comment">;</span>e[<span class="hljs-keyword">cnt</span>].w=w<span class="hljs-comment">;</span>e[<span class="hljs-keyword">cnt</span>].next=head[u]<span class="hljs-comment">;</span>head[u]=<span class="hljs-keyword">cnt</span><span class="hljs-comment">;</span>&#125;</code></pre></div><p>遍历以a为起点的所有边</p><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=head[a];i!=0;<span class="hljs-attribute">i</span>=edge[i].next)</code></pre></div><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> n,m,s;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> head[N];<span class="hljs-type">bool</span> vis[N];<span class="hljs-type">int</span> dis[N];<span class="hljs-type">int</span> cnt;<span class="hljs-comment">//边 </span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> to;<span class="hljs-comment">//这条边指向的点 </span><span class="hljs-type">int</span> next;<span class="hljs-comment">//这条边的邻边的序号 </span><span class="hljs-type">int</span> w;<span class="hljs-comment">//这条边的权值 </span>&#125;e[<span class="hljs-number">2</span>*N];<span class="hljs-comment">//优先级队列的节点</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<span class="hljs-type">int</span> n;<span class="hljs-type">int</span> w;<span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> nn,<span class="hljs-type">int</span> ww):<span class="hljs-built_in">n</span>(nn),<span class="hljs-built_in">w</span>(ww)&#123;&#125;<span class="hljs-comment">//重载运算符&lt;，为了建立小顶堆 </span><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> node&amp; t) <span class="hljs-type">const</span>&#123;<span class="hljs-keyword">return</span> w&gt;t.w;&#125;&#125;; <span class="hljs-comment">//加边 </span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span><span class="hljs-function"></span>&#123;++cnt;e[cnt].to=v;e[cnt].w=w;e[cnt].next=head[u];head[u]=cnt;&#125;priority_queue&lt;node&gt; q;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));dis[s]=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> u,v,w;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<span class="hljs-built_in">add</span>(u,v,w);&#125;q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(s,<span class="hljs-number">0</span>));<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;node t=q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();u=t.n;<span class="hljs-keyword">if</span>(!vis[u])&#123;vis[u]=<span class="hljs-literal">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[u];i;i=e[i].next)&#123;v=e[i].to;w=e[i].w;<span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)&#123;dis[v]=dis[u]+w;<span class="hljs-keyword">if</span>(!vis[v])q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(v,dis[v]));&#125;&#125;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)cout&lt;&lt;dis[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="例2：最多经过k条边的最短路"><a href="#例2：最多经过k条边的最短路" class="headerlink" title="例2：最多经过k条边的最短路"></a>例2：最多经过k条边的最短路</h3><p>描述<br>给定 n 个点，m条有向边，起点s，终点d，最大边数k</p><p>第一行输入$n,m,s,d,k$<br>后面m行输入m条边 $u_i,v_i,w_i$</p><p>输出从$s$到$d$最多经过$k$条边时的最短路径<br>input:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">100</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">100</span><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">500</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs">200</code></pre></div><h3 id="Bellmanford"><a href="#Bellmanford" class="headerlink" title="Bellmanford"></a>Bellmanford</h3><blockquote><p>Bellmanford常用于解决此类有边数限制的最短路</p></blockquote><p>代码：</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-meta">#include&lt;bits/stdc++.h&gt;</span><span class="hljs-keyword">using</span> namespace std;<span class="hljs-type">int</span> n,m,s,d,k;<span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;const <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> dp[<span class="hljs-number">100</span>][N];<span class="hljs-type">bool</span> vis[N];struct edge&#123;<span class="hljs-type">int</span> u,v,w;//edge(<span class="hljs-type">int</span> uu,<span class="hljs-type">int</span> vv,<span class="hljs-type">int</span> ww):u(uu),v(vv),w(ww)&#123;&#125;&#125;e[N];<span class="hljs-type">int</span> main()&#123;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d&gt;&gt;k;memset(dp,<span class="hljs-number">0x3f</span>,sizeof(dp));dp[<span class="hljs-number">0</span>][s]=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> u,v,w;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;e[i].u=u;e[i].v=v;e[i].w=w;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)&#123;u=e[j].u;v=e[j].v;w=e[j].w;dp[i][v]=min(dp[i][v],dp[i<span class="hljs-number">-1</span>][u]+w);&#125;&#125;<span class="hljs-type">int</span> ans=inf;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;++i)&#123;ans=min(dp[i][d],ans);&#125; <span class="hljs-keyword">if</span>(ans==inf)cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<span class="hljs-keyword">else</span>cout&lt;&lt;ans&lt;&lt;endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2022/08/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/08/22/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p><em><strong>背包问题</strong></em> 是经典的一类动态规划类型的题目，一般是有n种物品，每个物品有对应的价值w，然后背包体积为V，求能装入的物品的最大价值。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>设 <strong>dp[i][j]</strong> 为前 i 个物品，背包容量为 j 的最大价值。</p><p>那么考虑第i个物品是否放入，有两种情况：</p><ul><li>如果不放，那么等同于前 <strong>i−1</strong> 个物品，容量为j的背包的最优方案。</li><li>如果放，那么等同于前 <strong>i−1</strong> 个物品，容量为 <strong>j−v[i]</strong> 的背包的最优方案，再加上第i个物品的价值。</li></ul><p>那么可以得到转移方程：</p><p><em><strong>dp[i][j]&#x3D;max(dp[i−1][j],dp[i−1][j−v[i]]+w[i])</strong></em></p><p>最终的答案就是 <strong>dp[n][V]</strong></p><p>观察到dp数组，第i行仅跟上一行有关系，故可以压缩一维，为了防止dp[i−1][j−v[i]]被覆盖掉，第二维度须<strong>反向枚举</strong>。</p><h4 id="例题1：01背包"><a href="#例题1：01背包" class="headerlink" title="例题1：01背包"></a>例题1：01背包</h4><p>你有一个背包，最多能容纳的体积是V，现在有n个物品，第i个物品的体积为vi,价值为wi。</p><ol><li>求这个背包至多能装多大价值的物品？</li><li>若背包恰好装满，求至多能装多大价值的物品？</li></ol><p>输入第一行n,V<br>后面n行，输入第i件物品的体积vi和价值wi<br>输出：两个问题的答案，各占一行，如果无解输出0</p><p>input:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><span class="hljs-symbol">2 </span><span class="hljs-number">10</span><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">4</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs">149</code></pre></div><p>题解：</p><div class="code-wrapper"><pre><code class="hljs inform7">#include&lt;bits/stdc++.h&gt;using namespace std;int n,V;const int N=1005;int v<span class="hljs-comment">[N]</span>,w<span class="hljs-comment">[N]</span>;int dp<span class="hljs-comment">[N]</span>;int main()&#123;    cin&gt;&gt;n&gt;&gt;V;    for(int i=1;i&lt;=n;++i)    &#123;        cin&gt;&gt;v<span class="hljs-comment">[i]</span>;        cin&gt;&gt;w<span class="hljs-comment">[i]</span>;    &#125;    //不要求装满    for(int i=1;i&lt;=n;++i)    &#123;        for(int j=V;j&gt;=v<span class="hljs-comment">[i]</span>;--j)            dp<span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[j-v<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>);    &#125;    cout&lt;&lt;dp<span class="hljs-comment">[V]</span>&lt;&lt;endl;        //要求装满    memset(dp,-0x3f,sizeof(dp));    dp<span class="hljs-comment">[0]</span>=0;    for(int i=1;i&lt;=n;++i)    &#123;        for(int j=V;j&gt;=v<span class="hljs-comment">[i]</span>;--j)            dp<span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[j-v<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>);    &#125;    if(dp<span class="hljs-comment">[V]</span>&gt;0)        cout&lt;&lt;dp<span class="hljs-comment">[V]</span>&lt;&lt;endl;    else        cout&lt;&lt;0&lt;&lt;endl;    return 0;&#125;</code></pre></div><h4 id="例题2：完全背包"><a href="#例题2：完全背包" class="headerlink" title="例题2：完全背包"></a>例题2：完全背包</h4><p>描述与例题1相同，不过每种物品有<strong>任意</strong>个</p><p>input:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">13</span><span class="hljs-symbol">13 </span><span class="hljs-number">189</span><span class="hljs-symbol">17 </span><span class="hljs-number">360</span><span class="hljs-symbol">19 </span><span class="hljs-number">870</span><span class="hljs-symbol">14 </span><span class="hljs-number">184</span><span class="hljs-symbol">6 </span><span class="hljs-number">298</span><span class="hljs-symbol">16 </span><span class="hljs-number">242</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs">596189</code></pre></div><p>题解：</p><div class="code-wrapper"><pre><code class="hljs inform7">#include&lt;bits/stdc++.h&gt;using namespace std;int n,V;const int N=1005;int v<span class="hljs-comment">[N]</span>,w<span class="hljs-comment">[N]</span>;int dp<span class="hljs-comment">[N]</span>;int main()&#123;    cin&gt;&gt;n&gt;&gt;V;    for(int i=1;i&lt;=n;++i)    &#123;        cin&gt;&gt;v<span class="hljs-comment">[i]</span>;        cin&gt;&gt;w<span class="hljs-comment">[i]</span>;    &#125;    //不要求装满    for(int i=1;i&lt;=n;++i)    &#123;        for(int j=v<span class="hljs-comment">[i]</span>;j&lt;=V;++j)            dp<span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[j-v<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>);    &#125;    cout&lt;&lt;dp<span class="hljs-comment">[V]</span>&lt;&lt;endl;        //要求装满    memset(dp,-0x3f,sizeof(dp));    dp<span class="hljs-comment">[0]</span>=0;    for(int i=1;i&lt;=n;++i)    &#123;        for(int j=v<span class="hljs-comment">[i]</span>;j&lt;=V;++j)            dp<span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[j]</span>,dp<span class="hljs-comment">[j-v<span class="hljs-comment">[i]</span>]</span>+w<span class="hljs-comment">[i]</span>);    &#125;    if(dp<span class="hljs-comment">[V]</span>&gt;0)        cout&lt;&lt;dp<span class="hljs-comment">[V]</span>&lt;&lt;endl;    else        cout&lt;&lt;0&lt;&lt;endl;    return 0;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯</title>
    <link href="/2022/08/22/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2022/08/22/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><em><strong>回溯</strong></em>  核心思想和dfs相似，主要通过递归寻找可行解</p></blockquote><h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1:"></a>例题1:</h3><p>给定一个数组a[]和target的值，找出数组中可以使数字和为target的不同组合，输出所有符合要求的组合</p><ul><li>数组中数字可以重复使用</li><li>1,1,5和1,5,1视为一种方式<br>input:<div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span></code></pre></div></li></ul><p>output:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span></code></pre></div><p>题解</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> n,target;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; vi;<span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(N)</span></span>;vi tmp;vector&lt;vi&gt; ans; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bk</span><span class="hljs-params">(<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> target)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(idx==n)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)    &#123;        ans.<span class="hljs-built_in">push_back</span>(tmp);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-built_in">bk</span>(idx+<span class="hljs-number">1</span>,target);    <span class="hljs-keyword">if</span>(target&gt;=a[idx])    &#123;        tmp.<span class="hljs-built_in">push_back</span>(a[idx]);        <span class="hljs-built_in">bk</span>(idx,target-a[idx]);        tmp.<span class="hljs-built_in">pop_back</span>();    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;cin&gt;&gt;n&gt;&gt;target;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)cin&gt;&gt;a[i];    <span class="hljs-built_in">bk</span>(<span class="hljs-number">0</span>,target);    <span class="hljs-keyword">for</span>(vi&amp; t:ans)    &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> tt :t)    cout&lt;&lt;tt&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;    cout&lt;&lt;endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2:"></a>例题2:</h3><p>给定一个数组a[]和target的值，找出数组中可以使数字和为target的不同组合，输出所有符合要求的组合</p><ul><li>数组中每个数字最多使用一次</li><li>1,1,5和1,5,1视为一种方式<br>input:<div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">8</span><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span></code></pre></div></li></ul><p>output:</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">7</span><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span><span class="hljs-symbol">2 </span><span class="hljs-number">6</span><span class="hljs-symbol">7 </span><span class="hljs-number">1</span></code></pre></div><p>题解</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">int</span> n,target;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; vi;<span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(N)</span></span>;vi tmp;vector&lt;vi&gt; ans; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bk</span><span class="hljs-params">(<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> target)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(idx==n)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)    &#123;        ans.<span class="hljs-built_in">push_back</span>(tmp);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=idx;i&lt;n;++i)    &#123;    <span class="hljs-keyword">if</span>(target&gt;=a[i])    &#123;    <span class="hljs-keyword">if</span>(i&gt;idx&amp;&amp;a[i]==a[i<span class="hljs-number">-1</span>])    <span class="hljs-keyword">continue</span>;    tmp.<span class="hljs-built_in">push_back</span>(a[i]);    <span class="hljs-built_in">bk</span>(i+<span class="hljs-number">1</span>,target-a[i]);    tmp.<span class="hljs-built_in">pop_back</span>();    &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;cin&gt;&gt;n&gt;&gt;target;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)cin&gt;&gt;a[i];    <span class="hljs-built_in">bk</span>(<span class="hljs-number">0</span>,target);    <span class="hljs-keyword">for</span>(vi&amp; t:ans)    &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> tt :t)    cout&lt;&lt;tt&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;    cout&lt;&lt;endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kmp算法</title>
    <link href="/2022/08/21/kmp%E7%AE%97%E6%B3%95/"/>
    <url>/2022/08/21/kmp%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><em><strong>kmp</strong></em> 算法的核心思想：当匹配失败时，主串指针不回退，而是根据 <em><strong>next</strong></em> 数组，从适当的位置重新匹配，相比于暴力匹配，跳过了不可能匹配成功的部分，大大提升了效率</p></blockquote><blockquote><p><em><strong>next</strong></em> 数组每个位置的值表示前缀集合和后缀集合交集中,最长元素的长度</p></blockquote><div class="code-wrapper"><pre><code class="hljs">        p:    a b a b a b c a    next[i]:  0 0 1 2 3 4 0 1</code></pre></div><p>例题:</p><p>给你两个字符串 s 和 p ，请你在 s 字符串中找出 p 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。</p><p>input:</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">abacdf</span><span class="hljs-attribute">acd</span></code></pre></div><p>output:</p><div class="code-wrapper"><pre><code class="hljs">2</code></pre></div><p>题解</p><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span>using namespace std;const int <span class="hljs-attribute">N</span>=1e5;int nxt[N];void get_next(string p)&#123;int <span class="hljs-attribute">len</span>=p.size();int <span class="hljs-attribute">i</span>=1,j=0;<span class="hljs-keyword">while</span>(i&lt;len)&#123;<span class="hljs-keyword">if</span>(p[i]==p[j])&#123;nxt[i]=j+1;++i;++j;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-attribute">j</span>==0)&#123;nxt[i]=0;++i;&#125;<span class="hljs-keyword">else</span><span class="hljs-attribute">j</span>=nxt[j-1];&#125;&#125; int main()&#123;string s,p;cin&gt;&gt;s&gt;&gt;p;int <span class="hljs-attribute">m</span>=s.size(),n=p.size();int <span class="hljs-attribute">ans</span>=-1;<span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=0,j=0;i&lt;m;++i)&#123;<span class="hljs-keyword">while</span>(j&gt;0&amp;&amp;s[i]!=p[j])<span class="hljs-attribute">j</span>=nxt[j-1];<span class="hljs-keyword">if</span>(s[i]==p[j])++j;<span class="hljs-keyword">if</span>(<span class="hljs-attribute">j</span>==n)<span class="hljs-attribute">ans</span>=i-j+1;&#125;cout&lt;&lt;ans&lt;&lt;endl;return 0;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经</title>
    <link href="/2022/08/21/%E9%9D%A2%E7%BB%8F/"/>
    <url>/2022/08/21/%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="2022个人夏令营-x2F-预推免记录😢"><a href="#2022个人夏令营-x2F-预推免记录😢" class="headerlink" title="2022个人夏令营&#x2F;预推免记录😢"></a>2022个人夏令营&#x2F;预推免记录😢</h2><h3 id="吉大ai"><a href="#吉大ai" class="headerlink" title="吉大ai"></a>吉大ai</h3><ul><li>自我介绍</li><li>英文翻译</li><li>抽题目回答</li></ul><p>我抽到的是关于聚类的：</p><ul><li>什么是聚类 </li><li>聚类和分类区别 </li><li>聚类的性能指标 </li><li>层次聚类方法有哪些？</li><li><em>后两个也是关于层次聚类的，忘了。。。</em></li></ul><h3 id="西交cs"><a href="#西交cs" class="headerlink" title="西交cs"></a>西交cs</h3><p>夏令营没有优营，没有考核，先报名然后团队内部面试（聊天）</p><h3 id="华科网安"><a href="#华科网安" class="headerlink" title="华科网安"></a>华科网安</h3><p>有机试，5道题，150min,题目记不清了，难度中等，机试成绩不计入总成绩，仅作为参考<br>面试就自我介绍，然后聊聊天，最后优营40人，大概1&#x2F;3</p><h3 id="南大cs"><a href="#南大cs" class="headerlink" title="南大cs"></a>南大cs</h3><ul><li><p><strong>笔试</strong><br>很多要计算的题，题量挺大的<br><strong>数据结构</strong>：排序算法性能，希尔排序序列、红黑树、b树、最短路径算法(dijkstra,bellford,floyd)、最小生成树、线性探测、优先级队列、汉诺塔问题、还有好几个读程序的题<br><strong>计组</strong>：组相联映射、cache和主存给定命中率计算时间、想不起来了。。。<br>os：linux终端退出的符号，jvm，进程通信、一些语言特性（rust，ruby，scala），访管指令，还有一堆指令。。<br><strong>计网</strong>：无类寻址，拥塞窗口、数据链路层、ip协议、后面记的不清楚了。。。。</p></li><li><p><strong>面试</strong><br>先英文介绍merge sort，问一些项目问题，然后问了个数学题（怎么在球面上确定一点？），然后问了下生活上的兴趣之类的</p></li></ul><h3 id="北航ai"><a href="#北航ai" class="headerlink" title="北航ai"></a>北航ai</h3><p>今年是第二届夏令营，入营120&#x2F;1000，优营60</p><ul><li>先英文自我介绍</li><li>政治：谈谈科教兴国的理解</li><li>聊聊项目</li><li>因为我在下午，可能是老师累了把，没有问专业课，最后优营了</li></ul><p>北航和老师聊，问了些问题，都是比较底层的细节问题，<br>还记得的有：</p><ul><li>python 垃圾回收机制</li><li>c++ 智能指针的原理</li><li>如何判断链表有没有环</li></ul><h3 id="东南cs"><a href="#东南cs" class="headerlink" title="东南cs"></a>东南cs</h3><p>入营318人</p><ul><li>面试<ul><li>3分钟自我介绍</li><li>英文问题：cv的相关任务、参加的实践活动</li><li>聊聊天，没有问专业课</li></ul></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
