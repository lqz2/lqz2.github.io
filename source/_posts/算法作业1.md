---
title: 算法作业1
date: 2023-09-25 12:37:10
categories: 机试
math: true
tags:
---
<!-- TOC -->

- [出现最多的元素](#出现最多的元素)
- [寄包裹](#寄包裹)
- [翻转对](#翻转对)

<!-- /TOC -->
## 出现最多的元素
**题目描述**
提供一个包含 n 个元素的数组，要求返回其中出现次数大于半数（大于 ⌊n/2⌋）的元素。假设数组中一定存在这样的元素。

Input:
```
2 2 1 1 1 2 2 5
```
Output:
```
2
```
**思路**
这道题要求找出现次数大于半数的数，例如数组有`n`个数，那么就返回唯一的出现次数大于`n/2`的数，也就是出现次数最多的数。

首先想到的思路是用哈系表记录每个出现次数，然后遍历找到出现次数最多的数。

这里还可以用投票法，因为由题目已知这里的出现次数最多的数，它所出现的次数是大于`n/2`的，也就是说其他数的出现次数之和也小于它的出现次数。因此，可以维护两个变量cnt和candidate(初始都为0)，然后遍历数组，当cnt为0时更新candidate，然后如果`num==candidate`，则cnt加1，否则减1。这样，最后的candidate即出现最多的数。由于这道题输出是唯一的(出现次数大于`n/2`)，所以可以用投票法解决。


代码(附哈系表解法)：
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
    vector<int> v;
    int a;
    while (scanf("%d", &a) != EOF)
        v.push_back(a);
    int cnt = 0, cand = 0;
    for (int c : v)
    {
        if (cnt == 0)
            cand = c;
        cnt += c == cand ? 1 : -1;
    }
    cout << cand << endl;
    return cand;
}
// int main()
// {
//     vector<int> v;
//     int a;
//     while (scanf("%d", &a) != EOF)
//         v.push_back(a);
//     int n = v.size();
//     unordered_map<int, int> m;
//     for (int i = 0; i < n; i++)
//         ++m[v[i]];

//     int max = 0, res = 0;

//     for (auto it = m.begin(); it != m.end(); it++)
//     {
//         if (it->second > max)
//         {
//             max = it->second;
//             res = it->first;
//         }
//     }
//     cout << res;
//     return res;
// }
```

## 寄包裹
**题目描述**
现在有 n 个不同的包裹，需要寄给 n 个不同的地址，请编程求出每个包裹都送错地址的情况共有多少种。


Input:

```
5
```

Output:

```
44
```

**思路**
这道题属于错排问题，关于错排问题，有公式$D(n)=(n-1)(D(n-1)+D(n-2)) $，参考[这里](https://zhuanlan.zhihu.com/p/466098489)

代码:
```
#include <bits/stdc++.h>
using namespace std;
int f(int a)
{
    if (a == 1)
        return 0;
    else if (a == 2)
        return 1;
    else
        return (a - 1) * (f(a - 1) + f(a - 2));
}
int main()
{
    int n;
    cin >> n;
    cout << f(n);
    return 0;
}
```
## 翻转对
**题目描述**
现在有 n 个不同的包裹，需要寄给 n 个不同的地址，请编程求出每个包裹都送错地址的情况共有多少种。
给定一个数组nums，如果 i < j 且 nums[i] > 3*nums[j] 我们就将 (i, j) 称作一个重要翻转对。

你需要返回给定数组中的重要翻转对的数量。

**思路**
这道题是求逆序对数的小变形，求逆序对的主要思想是归并排序，对于已经有序的区间`[l,mid]`和`[mid+1,r]`，当`nums[i]>3*nums[j]`，说明`[i,mid]`区间的元素都大于`3*nums[j]`，因此逆序对数增加`mid-i+1`，其余部分进行归并排序即可。

代码:
```
#include <bits/stdc++.h>
using namespace std;
int cnt;
vector<int> num;
void merge(int l, int mid, int r)
{
    if (l >= r)
        return;
    int nl = mid - l + 1, nr = r - mid;
    vector<int> al(nl), ar(nr);
    for (int i = 0; i < nl; ++i)
        al[i] = num[l + i];
    for (int i = 0; i < nr; ++i)
        ar[i] = num[mid + 1 + i];
    int i = l, j = mid + 1;
    while (i <= mid && j <= r)
    {
        if (num[i] > 3 * num[j])
        {
            cnt += mid - i + 1;
            ++j;
        }
        else
            ++i;
    }
    i = 0;
    j = 0;
    while (i < nl && j < nr)
    {
        if (al[i] <= ar[j])
            num[l++] = al[i++];
        else
            num[l++] = ar[j++];
    }
    while (i < nl)
        num[l++] = al[i++];
    while (j < nr)
        num[l++] = ar[j++];
}
void mergesort(int l, int r)
{
    if (l < r)
    {
        int mid = l + r >> 1;
        mergesort(l, mid);
        mergesort(mid + 1, r);
        merge(l, mid, r);
    }
}

int main()
{
    int a;
    while (scanf("%d", &a) != EOF)
        num.push_back(a);
    int n = num.size();
    mergesort(0, n - 1);
    cout << cnt << endl;
    return 0;
}
```