---
title: 破解保险箱
date: 2023-01-10 10:43:28
categories: 机试
math: true
tags:
---
<!-- TOC -->

- [破解保险箱](#破解保险箱)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 破解保险箱
[原题](https://leetcode.cn/problems/cracking-the-safe/description/)

### 题目描述
There is a safe protected by a password. The password is a sequence of n digits where each digit can be in the range [0, k - 1].

The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the most recent n digits that were entered each time you type a digit.

For example, the correct password is "345" and you enter in "012345":
After typing 0, the most recent 3 digits is "0", which is incorrect.
After typing 1, the most recent 3 digits is "01", which is incorrect.
After typing 2, the most recent 3 digits is "012", which is incorrect.
After typing 3, the most recent 3 digits is "123", which is incorrect.
After typing 4, the most recent 3 digits is "234", which is incorrect.
After typing 5, the most recent 3 digits is "345", which is correct and the safe unlocks.
Return any string of minimum length that will unlock the safe at some point of entering it.

example：
```
Input: n = 2, k = 2
Output: "01100"
Explanation: For each possible password:
- "00" is typed in starting from the 4th digit.
- "01" is typed in starting from the 1st digit.
- "10" is typed in starting from the 3rd digit.
- "11" is typed in starting from the 2nd digit.
Thus "01100" will unlock the safe. "01100", "10011", and "11001" would also unlock the safe.
```

### 思路

这题很大一部分难度在于读题，中文题目描述实在是太偷懒了，差评!!!:angry:
所以这里题目描述给英文的:cat:

题意是说，给一个k值，然后有一个n位的密码，密码的每一位来自`0~k-1`之间，需要返回一个字符串，该字符串的后n位是可能的密码。

那么密码到底是怎么规定的呢？ 密码其实是n位数字的任意排列，比如`k=5,n=3`，如果3位取的是`012`，那么密码可能就是`000,001,002,010,011,012,021,022...,222`;如果3位取的是`123`,那么密码可能是`111,112,113,121,122,123....`，对于`k=5,n=3`的情况,n每一位都可以取`0,1,2,3,4`,所以满足条件的密码一共有$k^n$个

要返回的是一个字符串，包含了所有可能的密码，所以可以通过构造密码组成答案
通过代码可以更好的理解思路 ~~(其实是不想打字了:dog:)~~
### 代码
```
class Solution {
public:
    unordered_set<string> st;
    string crackSafe(int n, int k) {
        int cnt=pow(k,n);
        string ans(n,'0');
        st.insert(ans);
        string t=ans;
        for(int i=0;i<cnt-1;++i)
        {
            t.erase(0,1);
            for(int j=k-1;j>=0;--j)
            {
                t+=j+'0';
                if(!st.count(t))
                {
                    st.insert(t);
                    ans+=j+'0';
                    break;
                }
                else
                    t.pop_back();
            }
        }
        return ans;
    }
};
```