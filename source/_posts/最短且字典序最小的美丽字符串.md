---
title: 最短且字典序最小的美丽字符串
date: 2023-10-16 22:17:57
categories: 机试
math:
tags:
---
<!-- TOC -->

- [最短且字典序最小的美丽字符串](#最短且字典序最小的美丽字符串)
    - [**题目描述**](#题目描述)
    - [**思路**](#思路)
    - [**代码**](#代码)
- [找出满足差值条件的下标](#找出满足差值条件的下标)
    - [**题目描述**](#题目描述-1)
    - [**思路**](#思路-1)

<!-- /TOC -->
## 最短且字典序最小的美丽字符串
[原题](https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/)

### **题目描述**
给你一个二进制字符串 s 和一个正整数 k 。

如果 s 的某个子字符串中 1 的个数恰好等于 k ，则称这个子字符串是一个 美丽子字符串 。

令 len 等于 最短 美丽子字符串的长度。

返回长度等于 len 且字典序 最小 的美丽子字符串。如果 s 中不含美丽子字符串，则返回一个 空 字符串。

对于相同长度的两个字符串 a 和 b ，如果在 a 和 b 出现不同的第一个位置上，a 中该位置上的字符严格大于 b 中的对应字符，则认为字符串 a 字典序 大于 字符串 b 。

例如，"abcd" 的字典序大于 "abcc" ，因为两个字符串出现不同的第一个位置对应第四个字符，而 d 大于 c 。

e.g.
```
输入：s = "1011", k = 2
输出："11"
解释：示例中共有 3 个美丽子字符串：
1. 子字符串 "1011" 。
2. 子字符串 "1011" 。
3. 子字符串 "1011" 。
最短美丽子字符串的长度是 2 。
长度为 2 且字典序最小的美丽子字符串是子字符串 "11" 。 
```


### **思路**
此题主要使用双指针加滑动窗口解决，定义两个指针`l,r`，然后用cnt统计`1`的个数，用r遍历字符串，如果当前元素是`1`那么`cnt++`，然后开始缩小窗口，当`cnt>k||s[l]=='0'`时，`--l`，此时如果`cnt==k`，如果当前子串`l~r`之间的子串小于res的长度，或者长度相等字典序小于res，那么更新res为当前子串。
### **代码**
```
class Solution {
public:
    string shortestBeautifulSubstring(string s, int k) {
        if(count(s.begin(),s.end(),'1')<k)
            return "";
        int n=s.size();
        int l=0,r=0;
        string res=s;
        int cnt=0;
        for(r=0;r<n;++r)
        {   
            cnt+=s[r]-'0';
            while(cnt>k||s[l]=='0')
            {
                cnt-=s[l]-'0';
                ++l;
            }
            if(cnt==k)
            {
                string t=s.substr(l,r-l+1);
                if(t.size()<res.size()||t.size()==res.size()&&t<res)
                    res=t;
            }
        }
        return res;
    }
};
```

## 找出满足差值条件的下标
[原题](https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/description/)
### **题目描述**
给你一个下标从 0 开始、长度为 n 的整数数组 nums ，以及整数 indexDifference 和整数 valueDifference 。

你的任务是从范围 [0, n - 1] 内找出  2 个满足下述所有条件的下标 i 和 j ：

abs(i - j) >= indexDifference 且
abs(nums[i] - nums[j]) >= valueDifference
返回整数数组 answer。如果存在满足题目要求的两个下标，则 answer = [i, j] ；否则，answer = [-1, -1] 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。

注意：i 和 j 可能 相等，请实现O(n)时间复杂度的算法。

e.g.
```
输入：nums = [5,1,4,1], indexDifference = 2, valueDifference = 4
输出：[0,3]
解释：在示例中，可以选择 i = 0 和 j = 3 。
abs(0 - 3) >= 2 且 abs(nums[0] - nums[3]) >= 4 。
因此，[0,3] 是一个符合题目要求的答案。
[3,0] 也是符合题目要求的答案。
```
### **思路**
这道题要求用O(n)时间复杂度实现，自己没有想到，参考大佬的解法恍然大悟。
可以记录**之前的间隔index_gap的元素中最大值和最小值下标**，然后与当前值nums[j]对比如果`max-nums[j]>=valueDifference`或者`nums[j]-min>=valueDifference`，那么即可返回对应的最大/最小值下标和当前下标j
**代码**
```
class Solution {
public:
    vector<int> findIndices(vector<int>& nums, int indexDifference, int valueDifference) {
        int n=nums.size();
        int mx_idx=0,mn_idx=0;
        int i;
        for(int j=indexDifference;j<n;++j)
        {
            i=j-indexDifference;
            if(nums[i]>nums[mx_idx])
                mx_idx=i;
            if(nums[i]<nums[mn_idx])
                mn_idx=i;
            if(nums[mx_idx]-nums[j]>=valueDifference)
                return {mx_idx,j};
            if(nums[j]-nums[mn_idx]>=valueDifference)
                return {mn_idx,j};
        }
        return {-1,-1};
    }
};
```
