---
title: 线段树
date: 2022-08-27 16:13:35
categories: 机试
math: true
tags:
---
<!-- TOC -->

- [线段树](#线段树)
    - [递归建树](#递归建树)
- [类型一：单点修改，区间查询](#类型一单点修改区间查询)
    - [单点修改](#单点修改)
    - [区间查询](#区间查询)
    - [例题](#例题)
- [类型二：区间修改，单点查询](#类型二区间修改单点查询)
    - [区间修改](#区间修改)
    - [单点查询](#单点查询)
    - [例题](#例题-1)
- [类型三： 区间修改，区间查询](#类型三-区间修改区间查询)
    - [区间修改](#区间修改-1)
    - [区间查询](#区间查询-1)
    - [例题](#例题-2)

<!-- /TOC -->
### 线段树
>能把对区间的修改、查询的时间复杂度由 O(n) 变为 O(logn)

线段树实际上也是一种二叉树，每个节点用一个结构体`node`保存
```
struct node
{
	int l,r,sum;
}
```
其中，`l`和`r`表示线段的左右端点，`sum`表示线段的和

如果用数组存储，一棵二叉树，左孩子下标为`2*i`，右孩子下标为`2*i+1`
因此，每一个节点的`sum`值为：`tree[i].sum=tree[2*i].sum+tree[2*i+1].sum`

#### 递归建树

```
void build(int i,int l,int r)
{
//	i:当前节点编号 l:左端点 r:右端点 
	tree[i].l=l;
	tree[i].r=r;
	//如果是叶子节点，赋值并返回 
	if(l==r)
	{	
		tree[i].sum=array[l];
		return;
	}
	int mid=(l+r)/2;
	build(2*i,l,mid);//建左子树 
	build(2*i+1,mid+1,r);//建右子树 
	//更新线段和 
	tree[i].sum=tree[2*i].sum+tree[2*i+1].sum;
}
```
### 类型一：单点修改，区间查询

单点修改：给第`idx`个数加`k`
区间查询：输出区间[x,y]内所有数的和

#### 单点修改
```
void mod1(int i,int idx,int k)
{
	if(tree[i].l==tree[i].r)
	{
		tree[i].sum+=k;
		return;
	}
	int mid=tree[i].l+tree[i].r>>1;
	if(idx<=mid)
		mod1(2*i,idx,k);
	else
		mod1(2*i+1,idx,k);
	//更新线段和
	tree[i].sum=tree[2*i].sum+tree[2*i+1].sum;	
}
```
#### 区间查询
```
//区间查询
int query1(int i,int l,int r)
{
	//如果当前区间完全被查询区间包括，返回当前区间的和 
	if(tree[i].l>=l&&tree[i].r<=r)
		return tree[i].sum;
	int res=0;
	int mid=tree[i].l+tree[i].r>>1;
	//如果左孩子区间与查询区间相交，进入左子树 
	if(l<=mid)
		res+=query1(2*i,l,r);
	//如果右孩子区间与查询区间相交，进入右子树
	if(r>mid)
		res+=query1(2*i+1,l,r);
	 return res;
} 
```
#### 例题
[P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

**题目描述**

如题，已知一个数列，你需要进行下面两种操作：

- 将某一个数加上 $x$

- 求出某区间每一个数的和

**输入格式**

第一行包含两个正整数 $n,m$，分别表示该数列数字的个数和操作的总个数。   
 
第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。

接下来 $m$ 行每行包含 $3$ 个整数，表示一个操作，具体如下：

- `1 x k`  含义：将第 $x$ 个数加上 $k$

- `2 x y`  含义：输出区间 $[x,y]$ 内每个数的和

**输出格式**

输出包含若干行整数，即为所有操作 $2$ 的结果。

input:

```
5 5
1 5 4 2 3
1 1 3
2 2 5
1 3 -1
1 4 2
2 1 4
```

output:

```
14
16
```

**【数据范围】**

对于 $30\%$ 的数据，$1 \le n \le 8$，$1\le m \le 10$；   
对于 $70\%$ 的数据，$1\le n,m \le 10^4$；   
对于 $100\%$ 的数据，$1\le n,m \le 5\times 10^5$。

ac代码
```
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+2;
int nums[N];
struct node
{
	int l,r,sum;
}tree[4*N];
void build(int i,int l,int r)
{
//	i:当前节点编号 l:左端点 r:右端点 
	tree[i].l=l;
	tree[i].r=r;
	//如果是叶子节点，赋值并返回 
	if(l==r)
	{	
		tree[i].sum=nums[l];
		return;
	}
	int mid=(l+r)/2;
	build(2*i,l,mid);//建左子树 
	build(2*i+1,mid+1,r);//建右子树 
	//更新线段和 
	tree[i].sum=tree[2*i].sum+tree[2*i+1].sum;
}
//单点修改 
void mod1(int i,int idx,int k)
{
	if(tree[i].l==tree[i].r)
	{
		tree[i].sum+=k;
		return;
	}
	int mid=tree[i].l+tree[i].r>>1;
	if(idx<=mid)
		mod1(2*i,idx,k);
	else
		mod1(2*i+1,idx,k);
	//更新线段和
	tree[i].sum=tree[2*i].sum+tree[2*i+1].sum;	
}
//区间查询
int query1(int i,int l,int r)
{
	//如果当前区间完全被查询区间包括，返回当前区间的和 
	if(tree[i].l>=l&&tree[i].r<=r)
		return tree[i].sum;
	int res=0;
	int mid=tree[i].l+tree[i].r>>1;
	//如果左孩子区间与查询区间相交，进入左子树 
	if(l<=mid)
		res+=query1(2*i,l,r);
	//如果右孩子区间与查询区间相交，进入右子树
	if(r>mid)
		res+=query1(2*i+1,l,r);
	 return res;
} 
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		cin>>nums[i];
	build(1,1,n);
	int op,a,b;
	while(m--)
	{
		cin>>op>>a>>b;
		if(op==1)
			mod1(1,a,b);
		else if(op==2)
			cout<<query1(1,a,b)<<endl;
	} 
	return 0;
} 
```

### 类型二：区间修改，单点查询

区间修改：给区间`[a,b]`每个数加k
单点查询：查询第`x`个数的值

思路：把修改区间所覆盖的区间加k，然后单点查询时从上到下将所有k相加

#### 区间修改
```
void mod(int i,int l,int r,int k)
{
	//完全在区间内，+k 
	if(l<=tree[i].l&&r>=tree[i].r)
	{
		tree[i].sum+=k;
		return ;
	}
	int mid=tree[i].l+tree[i].r>>1;
	//落在左区间 
	if(l<=mid)
		mod(2*i,l,r,k);
	//落在右区间 
	if(r>mid)
		mod(2*i+1,l,r,k);
} 
```
#### 单点查询
```
int query(int i,int x)
{
	//从上到下计算所有k的和 
	if(tree[i].l==tree[i].r)
		return tree[i].sum;
	int res=tree[i].sum;
	int mid=tree[i].l+tree[i].r>>1;
	if(x<=mid)
		res+=query(2*i,x);
	else
		res+=query(2*i+1,x);
	return res;	
} 
```
#### 例题

[P3368 树状数组 2](https://www.luogu.com.cn/problem/P3368)

**题目描述**

如题，已知一个数列，你需要进行下面两种操作：

1. 将某区间每一个数加上 $x$；

2. 求出某一个数的值。

**输入格式**

第一行包含两个整数 $N$、$M$，分别表示该数列数字的个数和操作的总个数。

第二行包含 $N$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i $ 项的初始值。

接下来 $M$ 行每行包含 $2$ 或 $4$个整数，表示一个操作，具体如下：

操作 $1$： 格式：`1 x y k` 含义：将区间 $[x,y]$ 内每个数加上 $k$；

操作 $2$： 格式：`2 x` 含义：输出第 $x$ 个数的值。

**输出格式**

输出包含若干行整数，即为所有操作 $2$ 的结果。

input:
```
5 5
1 5 4 2 3
1 2 4 2
2 3
1 1 5 -1
1 3 5 7
2 4
```
output:
```
6
10
```
**代码**
```
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+2;
int nums[N];
struct node
{
	int l,r,sum;
}tree[4*N];
void build(int i,int l,int r)
{
	tree[i].l=l;
	tree[i].r=r;
	tree[i].sum=0; 
	//如果是叶子节点，赋值并返回 
	if(l==r)
		return; 
	int mid=(l+r)/2;
	build(2*i,l,mid);//建左子树 
	build(2*i+1,mid+1,r);//建右子树 
}

//区间修改
void mod(int i,int l,int r,int k)
{
	//完全在区间内，+k 
	if(l<=tree[i].l&&r>=tree[i].r)
	{
		tree[i].sum+=k;
		return ;
	}
	int mid=tree[i].l+tree[i].r>>1;
	//落在左区间 
	if(l<=mid)
		mod(2*i,l,r,k);
	//落在右区间 
	if(r>mid)
		mod(2*i+1,l,r,k);
} 
//单点查询
int query(int i,int x)
{
	//从上到下计算所有k的和 
	if(tree[i].l==tree[i].r)
		return tree[i].sum;
	int res=tree[i].sum;
	int mid=tree[i].l+tree[i].r>>1;
	if(x<=mid)
		res+=query(2*i,x);
	else
		res+=query(2*i+1,x);
	return res;	
} 
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		cin>>nums[i];
	build(1,1,n);
	int op,a,b,c;
	while(m--)
	{
		cin>>op;
		if(op==1)
		{
			cin>>a>>b>>c;
			mod(1,a,b,c);
		}
		else if(op==2)
		{
			cin>>a;
			cout<<query(1,a)+nums[a]<<endl; 
		}
	} 
	return 0;
} 
```


**数据规模与约定**

对于 $30\%$ 的数据：$N\le8$，$M\le10$；

对于 $70\%$ 的数据：$N\le 10000$，$M\le10000$；

对于 $100\%$ 的数据：$1 \leq N, M\le 500000$，$1 \leq x, y \leq n$，保证任意时刻序列中任意元素的绝对值都不大于 $2^{30}$。

ac代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+2;
int nums[N];
struct node
{
	int l,r,sum;
}tree[4*N];
void build(int i,int l,int r)
{
	tree[i].l=l;
	tree[i].r=r;
	tree[i].sum=0; 
	//如果是叶子节点，赋值并返回 
	if(l==r)
		return; 
	int mid=(l+r)/2;
	build(2*i,l,mid);//建左子树 
	build(2*i+1,mid+1,r);//建右子树 
}

//区间修改
void mod(int i,int l,int r,int k)
{
	//完全在区间内，+k 
	if(l<=tree[i].l&&r>=tree[i].r)
	{
		tree[i].sum+=k;
		return ;
	}
	int mid=tree[i].l+tree[i].r>>1;
	//落在左区间 
	if(l<=mid)
		mod(2*i,l,r,k);
	//落在右区间 
	if(r>mid)
		mod(2*i+1,l,r,k);
} 
//单点查询
int query(int i,int x)
{
	//从上到下计算所有k的和 
	if(tree[i].l==tree[i].r)
		return tree[i].sum;
	int res=tree[i].sum;
	int mid=tree[i].l+tree[i].r>>1;
	if(x<=mid)
		res+=query(2*i,x);
	else
		res+=query(2*i+1,x);
	return res;	
} 
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		cin>>nums[i];
	build(1,1,n);
	int op,a,b,c;
	while(m--)
	{
		cin>>op;
		if(op==1)
		{
			cin>>a>>b>>c;
			mod(1,a,b,c);
		}
		else if(op==2)
		{
			cin>>a;
			cout<<query(1,a)+nums[a]<<endl; 
		}
	} 
	return 0;
} 
```
### 类型三： 区间修改，区间查询

需要定义一个懒标记，然后每次修改或查询需要进行`pushdown` 

pushdown步骤：

* 当前节点懒标记不为0时，给左右子节点的懒标记加上父亲的懒标记
* 更新左右子节点的sum
* 父节点的懒标记置0
```
void pushdown(int i)
{
	if(tree[i].lz)
	{
		tree[2*i].lz+=tree[i].lz;
		tree[2*i+1].lz+=tree[i].lz;
		int mid=tree[i].l+tree[i].r>>1;
		tree[2*i].sum+=tree[i].lz*(mid-tree[i].l+1);
		tree[2*i+1].sum+=tree[i].lz*(tree[i].r-mid);
		tree[i].lz=0;	
	}
}
```
#### 区间修改
```
void mod(int i,int l,int r,int k)
{
	//区间被完全包括，更新sum，lz 
	if(l<=tree[i].l&&r>=tree[i].r)
	{
		tree[i].sum+=k*(tree[i].r-tree[i].l+1);
		tree[i].lz+=k;
		return;
	}
	pushdown(i);
	int mid=tree[i].l+tree[i].r>>1;
	if(l<=mid)
		mod(2*i,l,r,k);
	if(r>mid)
		mod(2*i+1,l,r,k);
	//更新和
	tree[i].sum=tree[2*i].sum +tree[2*i+1].sum;
}
```
#### 区间查询
```
int query(int i,int l,int r)
{
	//区间被完全包括，返回sum 
	if(l<=tree[i].l&&r>=tree[i].r)
		return tree[i].sum;
	pushdown(i);
	int mid=tree[i].l+tree[i].r>>1;
	int res=0;
	if(l<=mid)
		res+=query(2*i,l,r);
	if(r>mid)
		res+=query(2*i+1,l,r);
	return res;
}
```
#### 例题

[P3372【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

**题目描述**

如题，已知一个数列，你需要进行下面两种操作：

1. 将某区间每一个数加上 $k$。
2. 求出某区间每一个数的和。

**输入格式**

第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。

第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。

接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：

1. `1 x y k`：将区间 $[x, y]$ 内每个数加上 $k$。
2. `2 x y`：输出区间 $[x, y]$ 内每个数的和。

**输出格式**
输出包含若干行整数，即为所有操作 2 的结果。

input:
```
5 5
1 5 4 2 3
2 2 4
1 2 3 2
2 3 4
1 1 5 1
2 1 4
```

output:
```
11
8
20
```

**提示**

对于 $30\%$ 的数据：$n \le 8$，$m \le 10$。  
对于 $70\%$ 的数据：$n \le {10}^3$，$m \le {10}^4$。  
对于 $100\%$ 的数据：$1 \le n, m \le {10}^5$。

保证任意时刻数列中所有元素的绝对值之和 $\le {10}^{18}$。

ac代码：
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+2;
int nums[N];
struct node
{
	ll l,r,sum,lz;
}tree[4*N];
void build(int i,int l,int r)
{ 
	tree[i].l=l;
	tree[i].r=r;
	tree[i].lz=0;
	//如果是叶子节点，赋值并返回 
	if(l==r)
	{	
		tree[i].sum=nums[l];
		return;
	}
	ll mid=(l+r)/2;
	build(2*i,l,mid);//建左子树 
	build(2*i+1,mid+1,r);//建右子树 
	//更新线段和 
	tree[i].sum=tree[2*i].sum+tree[2*i+1].sum;
}
void pushdown(int i)
{
	if(tree[i].lz)
	{
		tree[2*i].lz+=tree[i].lz;
		tree[2*i+1].lz+=tree[i].lz;
		ll mid=tree[i].l+tree[i].r>>1;
		tree[2*i].sum+=tree[i].lz*(mid-tree[i].l+1);
		tree[2*i+1].sum+=tree[i].lz*(tree[i].r-mid);
		tree[i].lz=0;	
	}
}
void mod(int i,int l,int r,int k)
{
	//区间被完全包括，更新sum，lz 
	if(l<=tree[i].l&&r>=tree[i].r)
	{
		tree[i].sum+=k*(tree[i].r-tree[i].l+1);
		tree[i].lz+=k;
		return;
	}
	pushdown(i);
	ll mid=tree[i].l+tree[i].r>>1;
	if(l<=mid)
		mod(2*i,l,r,k);
	if(r>mid)
		mod(2*i+1,l,r,k);
	//更新和
	tree[i].sum=tree[2*i].sum +tree[2*i+1].sum;
}
ll query(int i,int l,int r)
{
	//区间被完全包括，返回sum 
	if(l<=tree[i].l&&r>=tree[i].r)
		return tree[i].sum;
	pushdown(i);
	ll mid=tree[i].l+tree[i].r>>1;
	ll res=0;
	if(l<=mid)
		res+=query(2*i,l,r);
	if(r>mid)
		res+=query(2*i+1,l,r);
	return res;
}
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		cin>>nums[i];
	build(1,1,n);
	int op,a,b,c;
	while(m--)
	{
		cin>>op;
		if(op==1)
		{
			cin>>a>>b>>c;
			mod(1,a,b,c);
		}
		else if(op==2)
		{
			cin>>a>>b;
			cout<<query(1,a,b)<<endl;
		}
	} 
	return 0;
} 
```
