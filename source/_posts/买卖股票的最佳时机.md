---
title: 买卖股票的最佳时机
date: 2023-04-14 07:51:03
categories: 机试
math:
tags:
---
<!-- TOC -->

- [买卖股票的最佳时机](#买卖股票的最佳时机)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 买卖股票的最佳时机
[原题](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)
### 题目描述
给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

e.g.
```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```
### 思路
动态规划,用`buy[i][j]`表示第`i`天时发生`j`笔交易时的最大利润，且此时持有股票，同理`sell[i][j]`表示此时维持有股票，然后分类讨论。

对于`buy[i][j]`:

* 若前一天本就持有股票，那么等于`buy[i-1][j]`
* 若前一天不持有股票，那今天需买入股票，那么等于`sell[i-1][j]-prices[i]`

对于`sell[i][j]`:

* 若前一天不持有股票，那么等于`sell[i-1][j]`
* 若前一天持有股票，那今天需卖出股票，那么等于`buy[i-1][j-1]+prices[i]`

最后的答案应该是卖出所有股票后的最大值，所以返回sell[n-1]的最大值
### 代码
```
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n=prices.size();
        k=min(k,n/2);
        if(n==0)
            return 0;
        vector<vector<int>> buy(n,vector<int>(k+1));
        vector<vector<int>> sell(n,vector<int>(k+1));
        buy[0][0]=-prices[0];
        sell[0][0]=0;
        for(int i=1;i<=k;++i)
            buy[0][i]=sell[0][i]=-1e6;
        for(int i=1;i<n;++i)
        {
            buy[i][0]=max(buy[i-1][0],sell[i-1][0]-prices[i]);
            for(int j=1;j<=k;++j)
            {
                buy[i][j]=max(buy[i-1][j],sell[i-1][j]-prices[i]);
                sell[i][j]=max(sell[i-1][j],buy[i-1][j-1]+prices[i]);
            }
        }
        return *max_element(sell[n-1].begin(),sell[n-1].end());
    }
};
```