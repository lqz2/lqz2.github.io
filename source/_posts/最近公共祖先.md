---
title: 最近公共祖先
date: 2024-05-17 10:05:44
categories: 机试
math:
tags:
---
## 最近公共祖先
<!-- TOC -->

- [最近公共祖先](#最近公共祖先)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
[原题](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)
### 题目描述
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。

e.g.
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```
### 思路
之前统计过最近公共祖先的模板(https://lqz2.github.io/2023/06/13/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88LCA/)，但是比较繁琐。一种简洁的思路是，分别从左右子树搜索p和q，当前节点为空或者当前节点等于p或q时返回当前节点，如果p和q分别在左右子树中(左右子树返回均不为空)，那么当前节点就是LCA，如果p和q在左右子树其中一棵上(左右子树返回有一个为空)，那么直接返回非空的子树。
### 代码
```
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root||root==p||root==q)
            return root;
        TreeNode* l=lowestCommonAncestor(root->left,p,q);
        TreeNode* r=lowestCommonAncestor(root->right,p,q);
        if(l&&r)
            return root;
        return l?l:r;
    }
};
```