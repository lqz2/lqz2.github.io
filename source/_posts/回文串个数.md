---
title: 回文串个数
date: 2022-11-13 15:56:17
categories: 机试
math:
tags:
---
<!-- TOC -->

- [回文子串](#回文子串)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)
- [不重叠回文子字符串的最大数目](#不重叠回文子字符串的最大数目)
    - [题目描述](#题目描述-1)
    - [思路](#思路-1)
    - [代码](#代码-1)

<!-- /TOC -->
## 回文子串

[原题](https://leetcode.cn/problems/palindromic-substrings/description/)

### 题目描述
给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。

回文字符串 是正着读和倒过来读一样的字符串。

子字符串 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

示例
```
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```
### 思路

关于回文串数量问题一般用中心扩展法，即：
>枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。

关于回文中心的数量，有以下规律：

* 长度为`n`的字符串可以得到`2*n-1`组回文中心`[l,r]`
* 第`i`组回文中心的`l=i/2,r=i/2+i%2`;

从所有回文中心开始扩展，可以得到所有回文子串的数量
### 代码
```
class Solution {
public:
    int countSubstrings(string s) {
        int n=s.size();
        int ans=0;
        for(int i=0;i<2*n-1;++i)
        {
            int l=i/2;
            int r=l+i%2;
            while(l>=0&&r<n&&s[l]==s[r])
            {
                --l;
                ++r;
                ++ans;
            }
        }
        return ans;
    }
};
```
## 不重叠回文子字符串的最大数目

[原题](https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/description/)

### 题目描述
给你一个字符串 s 和一个 正 整数 k 。

从字符串 s 中选出一组满足下述条件且 不重叠 的子字符串：

每个子字符串的长度 至少 为 k 。
每个子字符串是一个 回文串 。
返回最优方案中能选择的子字符串的 最大 数目。

子字符串 是字符串中一个连续的字符序列。

示例
```
输入：s = "abaccdbbd", k = 3
输出：2
解释：可以选择 s = "abaccdbbd" 中斜体加粗的子字符串。"aba" 和 "dbbd" 都是回文，且长度至少为 k = 3 。
可以证明，无法选出两个以上的有效子字符串。
```
### 思路
主要思路是中心扩展法+dp

中心扩展法可参考上面的题，此题中用`dp[i]`表示`0～i-1`的子串中符合要求的子串个数，通过中心扩展法可得到若干回文中心，对于每一个回文中心，要更新l、r对应的dp值，即`dp[l+1]`和`dp[r+1]`。
* 对于`dp[l+1]`，要考虑是否加入`l`位置的字符，所以`dp[l+1]=max(dp[l+1],dp[l])`
* 对于`dp[r+1]`，因为`l~r`是个回文串，所以比较的是`0~l-1`和`0~r`这两段，`dp[r+1]=max(dp[r+1],dp[l]+1)`

最后`dp[n]`即最终答案
### 代码
```
class Solution {
public:
    int maxPalindromes(string s, int k) {
        int n=s.size();
        vector<int> dp(n+1,0);
        for(int i=0;i<2*n-1;++i)
        {
            int l=i/2;
            int r=l+i%2;
            dp[l+1]=max(dp[l+1],dp[l]);
            while(l>=0&&r<n&&s[l]==s[r])
            {
                if(r-l+1>=k)
                {
                    dp[r+1]=max(dp[r+1],dp[l]+1);
                }
                --l;
                ++r;
            }
        }
        return dp[n];
    }
};
```