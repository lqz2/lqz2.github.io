---
title: 耗时最短线路
date: 2025-04-10 09:45:46
categories: 机试
math:
tags:
---
## 耗时最短线路

<!-- TOC -->

- [耗时最短线路](#耗时最短线路)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->

[原题](https://oj.niumacode.com/training/63/problem/P1509)


### 题目描述
大湾区某城市地铁线路非常密集，乘客很难一眼看出选择哪条线路乘坐比较合适，为了解决这个问题，地铁公司希望你开发一个程序帮助乘客挑选合适的乘坐线路，使得乘坐时间最短，地铁公司可以提供的数据是各相邻站点之间的乘坐时间。

输入说明：
第一行:N，站点总数,3<=N<=20.
第二行:乘宫的出发和到达站点。
第三行起:相邻站点之间的乘坐时间，每对站点一行，站点名称是单个小写字母，站点名一定包括出发和到
达站点，输入保证只有一个唯一解;
结束行:0000

输出说明：耗时最短的线路

```
输入：
12
a e
a b 2
b c 2
c d 2
d e 2
f b 3
b g 3
g h 2
h i 3
j h 2
h e 3
e k 2
k i 4
0000

输出：
a b c d e
```
### 思路
常规堆优化的dijkstra，不过节点数目很少，所以二维数组存图即可，由于要输出路径，所以需要一个前驱数组来存储前驱节点，每次松弛成功后同步更新前驱节点即可
### 代码
```
#include<bits/stdc++.h>
using namespace std;

int mp[26][26];
int dis[26];
bool vis[26];
int pre[26];
struct node{
    int n;
    int w;
    node(int nn,int ww):n(nn),w(ww){}
    bool operator < (const node& t) const{
        return w>t.w;
    }
};

priority_queue<node> pq;
int main(){
    int n;
    cin>>n;
    char s, d;
    cin>>s>>d;
    memset(dis,0x3f,sizeof(dis));
    memset(mp,0x3f,sizeof(mp));
    memset(pre,-1,sizeof(pre));
    dis[s-'a']=0;
    while(1){
        string s1,s2;
        int jl;
        cin>>s1;
        if(s1=="0000")
            break;
        cin>>s2>>jl;
        
        mp[s1[0]-'a'][s2[0]-'a']=jl;
    }
    
    pq.push(node(s-'a',0));
    while(!pq.empty()){
        node t=pq.top();
        pq.pop();
        int u=t.n;
        if(!vis[u]){
            vis[u]=true;
            for(int i=0;i<n;++i){
                if(dis[u]+mp[u][i]<dis[i]){
                    dis[i]=dis[u]+mp[u][i];
                    pre[i]=u;
                    if(!vis[i])
                        pq.push(node(i,dis[i]));
                }
            }
        }
    }
    int ans=d-'a';
    vector<int> v;
    v.push_back(ans);
    while(ans!=s-'a'){
        ans=pre[ans];
        v.push_back(ans);
    }
    reverse(v.begin(),v.end());
    for(int tt:v)
        cout<<char(tt+'a')<<' ';
}
```