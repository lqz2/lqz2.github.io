---
title: 常见排序算法
date: 2022-08-31 14:52:00
categories: 面试
math: true
tags:
---
<!-- TOC -->

- [插入排序](#插入排序)
- [希尔排序](#希尔排序)
- [基数排序（Radix Sort)](#基数排序radix-sort)
- [冒泡排序](#冒泡排序)
- [归并排序（Merge Sort）](#归并排序merge-sort)
- [堆排序](#堆排序)
- [桶排序（Bucket Sort）](#桶排序bucket-sort)
- [快速排序](#快速排序)

<!-- /TOC -->

>这篇博客主要总结一下常见排序算法及其时间复杂度

| 名称 | 平均时间复杂度 | 最好 | 最差 | 空间复杂度 | 稳定性 |
|:----:|:------------:|:---:|:---:|:---:|:---:|
|插入排序| $O(n^2)$ |$O(n)$|$O(n^2)$|$O(1)$|稳定| 
|希尔排序| $O(n^{1.3})$ |$O(n)$|$O(n^2)$|$O(1)$|不稳定| 
|基数排序| $O(n*k)$ |$O(n*k)$|$O(n*k)$|$O(k)$|稳定| 
|冒泡排序| $O(n^2)$ |$O(n)$|$O(n^2)$|$O(1)$|稳定| 
|归并排序| $O(nlogn)$ |$O(nlogn)$|$O(nlogn)$|$O(n)$|稳定| 
|堆排序| $O(nlogn)$ |$O(nlogn)$|$O(nlogn)$|$O(1)$|不稳定| 
|桶排序| $O(n+k)$ |$O(n+k)$|$O(n^2)$|$O(k)$|稳定| 
|快速排序| $O(nlogn)$ |$O(nlogn)$|$O(n^2)$|$O(1)$|不稳定| 
|选择排序| $O(n^2)$ |$O(n^2)$|$O(n^2)$|$O(1)$|不稳定| 

### 插入排序

>每次选择一个元素，并且将这个元素和前面元素进行比较，然后插入到合适的位置

```
void insert_sort(int arr[], int length)
{
    int i,j;
    for (i = 1; i < length; i++) {
        int tmp = arr[i];
        for (j = i; j > 0 && arr[j - 1] > tmp; j--) {
            arr[j] = arr[j - 1];
        }
        arr[j] = tmp;
    }
}
```

### 希尔排序

>插入排序的升级版，初始间隔*gap*为元素数目的一般，每次间隔*gap*个元素进行插入排序，直到gap为1

```
void shellSort(int arr[], int n) 
{ 
    for (int gap = n/2; gap > 0; gap /= 2) 
    { 
        for (int i = gap; i < n; i += 1) 
        { 
            int temp = arr[i]; 
            int j;             
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) 
                arr[j] = arr[j - gap]; 
            arr[j] = temp; 
        } 
    } 
}
```
### 基数排序（Radix Sort)
>将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程是将所有待比较数值统一为同样的数位长度，数位较短的数前面补零，然后从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

```
int getMax(int arr[], int n) 
{ 
    int mx = arr[0]; 
    for (int i = 1; i < n; i++) 
        if (arr[i] > mx) 
            mx = arr[i]; 
    return mx; 
} 

void countSort(int arr[], int n, int exp) 
{ 
    int output[n]; 
    int i, count[10] = {0}; 
  
    for (i = 0; i < n; i++) 
        count[ (arr[i]/exp)%10 ]++; 
  
    for (i = 1; i < 10; i++) 
        count[i] += count[i - 1]; //此时count[i]每位数字存放的位置，实际下标还要-1
  
    for (i = n - 1; i >= 0; i--) //从后往前保证稳定性
    { 
        output[count[ (arr[i]/exp)%10 ] - 1] = arr[i]; 
        count[ (arr[i]/exp)%10 ]--; 
    } 
  
    for (i = 0; i < n; i++) 
        arr[i] = output[i]; 
} 
  
void radixsort(int arr[], int n) 
{ 
    int m = getMax(arr, n); 
    for (int exp = 1; m/exp > 0; exp *= 10) 
        countSort(arr, n, exp); 
}
```
### 冒泡排序

>每次比较相邻两个元素大小，然后交换位置，每次将最大或最小的元素放到最后

```
void bubblesort(int arr[],int len)
{
	for(int i=0;i<len-1;++i)
	{
		for( int j=0;j<len-i-1;++j)
		{
			if(arr[j]>arr[j+1])
			{
				int t=arr[j];
				arr[j]=arr[j+1];
				arr[j+1]=t;
			}
		}
	}
}
```
### 归并排序（Merge Sort）

>主要思想是分治（Divide and Conquer），将数组不断分成两个部分，对分开的部分比较然后拼接

```
void merge(int arr[], int l, int m, int r) 
{ 
    int i, j, k; 
    int n1 = m - l + 1; 
    int n2 =  r - m; 

    int L[n1], R[n2]; 

    for (i = 0; i < n1; i++) 
        L[i] = arr[l + i]; 
    for (j = 0; j < n2; j++) 
        R[j] = arr[m + 1+ j]; 

    i = 0; 
    j = 0; 
    k = l; 
    while (i < n1 && j < n2) 
    { 
        if (L[i] <= R[j]) 
        { 
            arr[k] = L[i]; 
            i++; 
        } 
        else
        { 
            arr[k] = R[j]; 
            j++; 
        } 
        k++; 
    } 
  
    while (i < n1) 
    { 
        arr[k] = L[i]; 
        i++; 
        k++; 
    } 
  
    while (j < n2) 
    { 
        arr[k] = R[j]; 
        j++; 
        k++; 
    } 
} 
  
void mergeSort(int arr[], int l, int r) 
{ 
    if (l < r) 
    { 
        int m = l+r>>1; 
        mergeSort(arr, l, m); 
        mergeSort(arr, m+1, r); 
        merge(arr, l, m, r); 
    } 
}
```

### 堆排序
>主要是建立小顶堆或者大顶堆，排序的时候，每次取出堆顶元素，然后剩下元素重新建堆，~~建堆可以直接用STL的make_heap():smile:~~

```
void heapify(int arr[], int n, int i) 
{ 
    int maxv = i; 
    int l = 2*i + 1;  
    int r = 2*i + 2; 
    if (l < n && arr[l] > arr[maxv]) 
        maxv = l; 
    if (r < n && arr[r] > arr[maxv]) 
        maxv = r; 
    if (maxv != i) 
    { 
        swap(arr[i], arr[maxv]); 
        heapify(arr, n, maxv); 
    } 
}
void heapsort(int arr[],int len)
{
    //建堆
    for(int i=len/2-1;i>=0;--i)
        heapify(arr,len;i);
    //排序
    for(int i=len-1;i>=0;--i)
    {
        swap(arr[i],a[0]);//堆顶放到最后
        heapify(arr,i,0);//重新调整
    }
}
```
### 桶排序（Bucket Sort）

>将数组分到有限数量的桶中，再对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。

```
\\该代码只适合正数数组的排序
void bucketSort(float arr[], int n) 
{ 
    vector<float> b[n]; 

    for (int i=0; i<n; i++) 
    { 
       int bi = n*arr[i]; 
       b[bi].push_back(arr[i]); 
    } 
    for (int i=0; i<n; i++) 
       sort(b[i].begin(), b[i].end()); 
    int index = 0; 
    for (int i = 0; i < n; i++) 
        for (int j = 0; j < b[i].size(); j++) 
          arr[index++] = b[i][j]; 
}
```
### 快速排序

>核心思想也是分治，每次选择一个pivot(一般选第一个)，设置左右端点两个指针，每一趟调整将比pivot元素小的值放到左指针位置，比pivot元素大的值放到位置，这样左半部分就小于右半部分，然后递归，分别对左右两个部分进行快排
```
int adjust(int arr[],int l,int r)
{
	int t=arr[l];
	while(l<r)
	{
		while(l<r&&arr[r]>=t)
			--r;
		arr[l]=arr[r];
		while(l<r&&arr[l]<=t)
			++l;
		arr[r]=arr[l];
	}
	arr[l]=t;
	return l;
}
void quicksort(int arr[],int l,int r)
{
	if(l<r)
	{
		int pos=adjust(arr,l,r);
		quicksort(arr,l,pos);
		quicksort(arr,pos+1,r);
	}	
}
```
