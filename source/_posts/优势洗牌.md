---
title: 优势洗牌
date: 2022-10-09 16:04:29
categories: 机试
math:
tags:
---
<!-- TOC -->

- [优势洗牌](#优势洗牌)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->

## 优势洗牌

[题目链接](https://leetcode.cn/problems/advantage-shuffle/)

### 题目描述
给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] > nums2[i] 的索引 i 的数目来描述。

返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。

示例：
```
输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]
输出：[24,32,8,12]
```
### 思路

>题目有一个隐含条件是，当nums1中的某个数不大于于nums2的任意数时，该数对应nums2的较大的数。具体步骤如下，先将两个数组的下标根据数字的大小升序排序，然后当nums1中的数大于nums2的数，加入答案数组中，否则找到对应nums2中的较大数的对应位置，根据该位置加入答案数组中

### 代码
```
class Solution {
public:
    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
        int len = nums1.size();
        vector<int> ans(len),a(len),b(len);
        iota(a.begin(),a.end(),0);
        iota(b.begin(),b.end(),0);
        sort(a.begin(),a.end(),[&](int i,int j){
            return nums1[i]<nums1[j];
        });
        sort(b.begin(),b.end(),[&](int i,int j){
            return nums2[i]<nums2[j];
        });
        int l=0,r=len-1;
        for(int i=0;i<len;++i)
        {
            if(nums1[a[i]]>nums2[b[l]])
            {
                ans[b[l]]=nums1[a[i]];
                ++l;
            }
            else
            {
                ans[b[r]]=nums1[a[i]];
                --r;
            }

        }
        return ans;
    }
};
```