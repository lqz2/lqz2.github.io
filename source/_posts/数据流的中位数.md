---
title: 数据流的中位数
date: 2024-12-15 09:14:46
categories: 机试
math:
tags:
---
## 数据流的中位数

<!-- TOC -->

- [数据流的中位数](#数据流的中位数)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->

[原题](https://leetcode.cn/problems/find-median-from-data-stream/description/)

### 题目描述
中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

例如 arr = [2,3,4] 的中位数是 3 。
例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。
实现 MedianFinder 类:

MedianFinder() 初始化 MedianFinder 对象。

void addNum(int num) 将数据流中的整数 num 添加到数据结构中。

double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。

示例：
```
输入
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
输出
[null, null, null, 1.5, null, 2.0]
```
### 思路
主要思路是使用两个堆，一个大顶堆，一个小顶堆，大顶堆存放小于等于中位数的部分，小顶堆存放大于中位数的部分，当总数为奇数时，中位数是大顶堆的堆顶，当总数为偶数时，中位数是两个堆顶的平均值。
注意，两个堆的大小差不能超过1，所以在插入元素时，需要移动元素，保证两个堆的大小差不超过1。
### 代码
```
class MedianFinder {
public:
    priority_queue<int, vector<int>, less<int>> pqBig;
    priority_queue<int, vector<int>, greater<int>> pqSma;
    MedianFinder() {}
    
    void addNum(int num) {
        if(pqBig.empty()||num<=pqBig.top()){
            pqBig.push(num);
            if(pqSma.size()+1<pqBig.size()){
                pqSma.push(pqBig.top());
                pqBig.pop();
            }
        }else{
            pqSma.push(num);
            if(pqSma.size()>pqBig.size()){
                pqBig.push(pqSma.top());
                pqSma.pop();
            }
        }
    }
    
    double findMedian() {
        if(pqBig.size()==pqSma.size()){
            return (pqBig.top()+pqSma.top())/2.0;
        }
        return pqBig.top();
    }
};

```