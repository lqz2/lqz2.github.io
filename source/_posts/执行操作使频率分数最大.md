---
title: 执行操作使频率分数最大
date: 2023-12-17 21:17:16
categories: 机试
math:
tags:
---
## 执行操作使频率分数最大
[原题](https://leetcode.cn/problems/apply-operations-to-maximize-frequency-score/)
### 题目描述
给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。

你可以对数组执行 至多 k 次操作：

从数组中选择一个下标 i ，将 nums[i] 增加 或者 减少 1 。
最终数组的频率分数定义为数组中众数的 频率 。

请你返回你可以得到的 最大 频率分数。

众数指的是数组中出现次数最多的数。一个元素的频率指的是数组中这个元素的出现次数。

e.g.
```
输入：nums = [1,2,6,4], k = 3
输出：3
解释：我们可以对数组执行以下操作：
- 选择 i = 0 ，将 nums[0] 增加 1 。得到数组 [2,2,6,4] 。
- 选择 i = 3 ，将 nums[3] 减少 1 ，得到数组 [2,2,6,3] 。
- 选择 i = 3 ，将 nums[3] 减少 1 ，得到数组 [2,2,6,2] 。
元素 2 是最终数组中的众数，出现了 3 次，所以频率分数为 3 。
3 是所有可行方案里的最大频率分数。
```
### 思路
周赛第四题，思路是前缀和滑动窗口，想到了中位数和排序，但只想到二分没想到滑动窗口。
可以看作是将一个子区间内的所有数变成同一个值的曼哈顿距离之和，如升序子数组a1,a2,a3,a4,a5，如果要使得改动距离和最小应全部改为中位数，将这5个数全部变成a3，实际改动的距离和是：
d=a4-a3+a3-a2+a5-a3+a3-a1=a4+a5-(a1+a2)，也就是说，改动距离和等于中位数左边的数之和减去右边的数之和。
可以预处理成前缀和数组sum减小求和的复杂度。
对于子区间l~r
- 如果区间长为奇数，`d = sum[r + 1] - sum[mid + 1] - sum[mid] + sum[l]`;
- 如果区间长为偶数，`d = sum[r + 1] - 2 * sum[mid + 1] + sum[l]`

接下来遍历右端点，如果子区间距离和大于k，则缩小子数组长度(++l)，每次更新子区间最大长度即可。
### 代码
```
class Solution
{
public:
    int maxFrequencyScore(vector<int> &nums, long long k)
    {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<long long> sum(n + 1, 0);
        for (int i = 0; i < n; ++i)
            sum[i + 1] = sum[i] + nums[i];
        int l = 0, ans = 0;
        function<long long(int, int, int)> f = [&](int l, int mid, int r)
        {
            long long res = 0;
            int len = r - l + 1;
            if (len & 1)
                res = sum[r + 1] - sum[mid + 1] - sum[mid] + sum[l];
            else
                res = sum[r + 1] - 2 * sum[mid + 1] + sum[l];
            return res;
        };
        for (int r = 0; r < n; ++r)
        {
            while (f(l, (l + r) / 2, r) > k)
                ++l;
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```