---
title: 活字印刷
date: 2023-05-19 08:11:38
categories: 机试
math:
tags:
---

<!-- TOC -->

- [活字印刷](#活字印刷)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 活字印刷
[原题](https://leetcode.cn/problems/letter-tile-possibilities/description/)
### 题目描述
你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。

注意：本题中，每个活字字模只能使用一次。

e.g.
```
输入："AAB"
输出：8
解释：可能的序列为 "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA"。
```
### 思路
计数dp，用`dp[i][j]`表示前i种字符生成长度为j的字符串时，能得到的方案数，用二位数组v预处理组合数，用哈系表统计字符出现频率，当不选第i种字符时，`dp[i][j]=dp[i-1][j]`，当选中k个i字符时，需要从j中选出k个位置放置这些字符，其余位置就是用前`i-1`种字符构造长为`j-k`的字符串，即`dp[i][j]=dp[i-1][j-k]*v[j][k]`，最后把所有不同长度的方案数加起来即最终答案。
### 代码
```
class Solution {
public:
    int numTilePossibilities(string tiles) {
        unordered_map<char,int> mp;
        for(char &c:tiles)
            ++mp[c];
        int n=tiles.size(),m=mp.size();
        vector<vector<int>> v(n+1,vector<int>(n+1));
        for(int i=0;i<=n;++i)
        {
            v[i][0]=v[i][i]=1;
            for(int j=1;j<i;++j)
                v[i][j]=v[i-1][j-1]+v[i-1][j];
        }
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        dp[0][0]=1;
        int i=1;
        for(auto& it:mp)
        {
            for(int j=0;j<=n;++j)
            {
                for(int k=0;k<=j&&k<=it.second;++k)
                    dp[i][j]+=dp[i-1][j-k]*v[j][k];
            }
            ++i;
        }
        return accumulate(dp[m].begin()+1,dp[m].end(),0);
    }
};
```