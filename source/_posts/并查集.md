---
title: 并查集
date: 2022-08-26 09:48:40
categories: 机试
tags:
---
<!-- TOC -->

- [并查集](#并查集)
- [递归的查找节点的祖先](#递归的查找节点的祖先)
- [例题](#例题)

<!-- /TOC -->
### 并查集
>通过一个数组来保存各个节点的祖先，所有连通的节点的祖先相同，常用于解决最小生成树，图的连通性等问题

### 递归的查找节点的祖先

首先假设有`N`个节点，定义一个数组`vset[N]`记录所有节点的祖先，`vset[N]初始化为-1`

定义一个`find`函数来查找祖先

```
int find(int a)
{
    if(vset[a]==-1)
        return a;
    else
    {
        vset[a]=find(vset[a]);
        return vset[a];
    }
}
```

### 例题

有`n`条道路，`m`个村庄,计算出使所有村庄连通的最低成本

输入n,m，然后输入n行，每一行输入u,v,w表示两个村庄的编号和道路成本

输出使所有村庄连通的最低成本

input:
```
3 3
1 2 1
1 3 2
2 3 4
```

output:
```
3
```

代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N=1000;
typedef vector<int> vi;
int vset[1000];
vector<vi> e(1000,vi(3));
int find(int a)
{
    if(vset[a]==-1)
        return a;
    else
    {
        vset[a]=find(vset[a]);
        return vset[a];
    }
}

int main()
{
    int n,m;
    cin>>n>>m;
    memset(vset,-1,sizeof(vset));
    for(int i=1;i<=n;++i)
    {
        cin>>e[i][0]>>e[i][1]>>e[i][2];
    }
    sort(e.begin(),e.end(),[](vi a,vi b){
        return a[2]<b[2];
    });
    int ans=0,cnt=0;
    for(vi& t: e)
    {
        int x=find(t[0]);
        int y=find(t[1]);
        if(x!=y)
        {
            ++cnt;
            ans+=t[2];
            vset[x]=y;
            if(cnt==n-1)
                break;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
