---
title: 矩阵打印问题
date: 2023-10-19 12:27:30
categories: 机试
math:
tags:
---

<!-- TOC -->

- [矩阵打印问题](#矩阵打印问题)
    - [上三角阵](#上三角阵)
        - [题目描述](#题目描述)
        - [思路](#思路)
        - [代码](#代码)
    - [螺旋矩阵一](#螺旋矩阵一)
        - [题目描述](#题目描述-1)
        - [思路](#思路-1)
        - [代码](#代码-1)
    - [螺旋矩阵二](#螺旋矩阵二)
        - [题目描述](#题目描述-2)
        - [思路](#思路-2)
        - [代码](#代码-2)
    - [Z字型(蛇型)](#z字型蛇型)
        - [题目描述](#题目描述-3)
        - [思路](#思路-3)
        - [代码](#代码-3)

<!-- /TOC -->
## 矩阵打印问题


### 上三角阵
[原题](https://www.nowcoder.com/practice/649b210ef44446e3b1cd1be6fa4cab5e?tpId=37&tqId=21258&ru=/exam/oj)
#### 题目描述
输入描述：
输入正整数N（N不大于100）

输出描述：
输出一个N行的上三角矩阵

input
```
5
```
output
```
1 3 6 10
2 5 9
4 8
7
```
#### 思路
根据题目描述，输出上三角阵只用考虑右上方向，因此每输出一个数就`--i,++j`，超出上边界(i<0)时，将j置为0，然后更新i的起始点即可。
#### 代码
```
#include<bits/stdc++.h>
using namespace std;
int a[101][101];
int main()
{
    int n;
    cin>>n;
    int num=(n+1)*n/2;
    int cnt=0,i=0,j=0,pre=0,k=1;
    
    while(cnt<num)
    {
        a[i][j]=k++;
        ++cnt;
        --i;++j;
        if(i<0)
        {
            j=0;
            i=pre+1;
            pre=i;
        }
    }
    int nn=n;
    for(int i=0;i<n;++i)
    {
        for(int j=0;j<nn;++j)
            cout<<a[i][j]<<' ';
        --nn;
        cout<<endl;
    }
    return 0;
}
```

### 螺旋矩阵一
[原题](https://leetcode.cn/problems/spiral-matrix/description/)
#### 题目描述
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

e.g.
```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```
#### 思路
这道题首先要设置上下左右四个边界，然后按照上，右，下，左，四个边界打印，每便利完一个边界判断一下边界有没有越界
例如
```
for(int i=l;i<=r;++i)
    cout<<a[u][i];
if(++u>d) break;
```
#### 代码
```
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m=matrix.size(),n=matrix[0].size();
        int l=0,r=n-1,u=0,d=m-1;
        vector<int> ans;
        while(true)
        {
            for(int i=l;i<=r;++i)
                ans.push_back(matrix[u][i]);
            if(++u>d) break;
            for(int i=u;i<=d;++i)
                ans.push_back(matrix[i][r]);
            if(--r<l) break;
            for(int i=r;i>=l;--i)
                ans.push_back(matrix[d][i]);
            if(--d<u) break;
            for(int i=d;i>=u;--i)
                ans.push_back(matrix[i][l]);
            if(++l>r) break;
        }
        return ans;
    }
};
```

### 螺旋矩阵二
[原题](https://leetcode.cn/problems/spiral-matrix-iii/description/)
#### 题目描述
在 rows x cols 的网格上，你从单元格 (rStart, cStart) 面朝东面开始。网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。

你需要以顺时针按螺旋状行走，访问此网格中的每个位置。每当移动到网格的边界之外时，需要继续在网格之外行走（但稍后可能会返回到网格边界）。

最终，我们到过网格的所有 rows x cols 个空间。

按照访问顺序返回表示网格位置的坐标列表。
e.g.
```
输入：rows = 5, cols = 6, rStart = 1, cStart = 4
输出：[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]
```
#### 思路
这道题实际上是从中心向四周遍历螺旋方阵，然后输出在矩阵内的数。
首先根据起始点的坐标，初始化上下左右四个边界(起始点周围第一层数)，并初始化方向为右(0,1,2,3四个方向)
接下来分情况讨论：
* 如果方向向右且已经到达右边界，右边界+1，方向转为向下
* 如果方向向下且已经到达下边界，下边界+1，方向转为向左
* 如果方向向左且已经到达左边界，左边界-1，方向转为向上
* 如果方向向上且已经到达上边界，上边界-1，方向转为向右
* 根据当前方向更新坐标

打印时只需要判断当前坐标在矩阵内即可打印

#### 代码
```
class Solution {
public:
    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {
        int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
        int cnt=0,di=0;
        int i=rStart,j=cStart,l=cStart-1,r=cStart+1,u=rStart-1,d=rStart+1;
        vector<vector<int>> ans;
        while(cnt<rows*cols)
        {
            if(i>=0&&i<rows&&j>=0&&j<cols)
            {
                ans.push_back({i,j});
                ++cnt;
            }
            if(di==0&&j==r)
            {
                di=(di+1)%4;
                ++r;
            }
            if(di==1&&i==d)
            {
                di=(di+1)%4;
                ++d;
            }
            if(di==2&&j==l)
            {
                di=(di+1)%4;
                --l;
            }
            if(di==3&&i==u)
            {
                di=(di+1)%4;
                --u;
            }
            i+=dir[di][0];
            j+=dir[di][1];
        }
        return ans;
    }
};
```
### Z字型(蛇型)
[原题](https://www.acwing.com/problem/content/description/3211/)
#### 题目描述
对于下面的 4×4的矩阵，
```
1 5 3 9
3 7 5 6
9 4 6 4
7 3 1 3
```
对其进行 Z字形扫描后得到长度为16的序列：1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3。
请实现一个Z字形扫描的程序，给定一个 n×n的矩阵，输出对这个矩阵进行 Z字形扫描的结果。

input:
```
4
1 5 3 9
3 7 5 6
9 4 6 4
7 3 1 3
```
output:
```
1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3
```
#### 思路
一共有两种方向，右上或者左下，因此需要设置一个flag，当flag为true时表示右上，否则表示左下，初始化方向为右上。
* 每当坐标i,j在矩阵范围内，就打印该位置的值
* 每打印一个值，根据方向更改坐标i,j的值
* 如果i<0，i置为0，方向取反，如果j<0，j置为0，方向取反。

重复以上步骤，直到打印出所有元素
#### 代码
```
#include<bits/stdc++.h>
using namespace std;
const int N=501;
int a[N][N];
int main()
{
    int n;
    cin>>n;
     for(int i=0;i<n;++i)
    {
        for(int j=0;j<n;++j)
            cin>>a[i][j];
    }
    int i=0,j=0,cnt=0;
    //true 右上，false左下
    bool flag=true;
    while(cnt<n*n)
    {
        if(i<n&&j<n)
        {
            cout<<a[i][j]<<' ';
            ++cnt;
        }
        if(flag)
        {
            --i;++j;
        }
        else
        {
            ++i;--j;
        }
        if(i<0)
        {
            i=0;
            flag=!flag;
        }
        if(j<0)
        {
            j=0;
            flag=!flag;
        }
    }
    return 0;
}
```