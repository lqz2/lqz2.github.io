---
title: 二叉树构造
date: 2024-09-22 09:11:26
categories: 机试
math:
tags:
---

<!-- TOC -->

- [前序中序构造二叉树](#前序中序构造二叉树)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)
- [后序中序构造二叉树](#后序中序构造二叉树)
    - [题目描述](#题目描述-1)
    - [思路](#思路-1)
    - [代码](#代码-1)

<!-- /TOC -->
## 前序中序构造二叉树

[原题](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description)
### 题目描述
给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。
```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```
### 思路
首先用一个全局的哈希表记录inorder中各元素的下标，用idx表示在preorder中根节点的下标，idx初始为0。定义builder函数递归构建二叉树：
- 根据idx获取根节点的值rootVal
- 根据rootVal在哈希表中获取inoder中的下标index
- ++idx
- 构建左子树，builder(l,index-1,preorder,inorder);
- 构建右子树，builder(index+1,r,preorder,inorder);
### 代码
```
class Solution {
private:
    unordered_map<int,int> mp;
    int idx;
public:
    TreeNode* builder(int l,int r,vector<int>& preorder, vector<int>& inorder){
        if(l>r)
            return nullptr;
        int rootVal=preorder[idx];
        TreeNode* root=new TreeNode(rootVal);
        int index=mp[rootVal];
        idx++;
        root->left=builder(l,index-1,preorder,inorder);
        root->right=builder(index+1,r,preorder,inorder);
        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n=preorder.size();
        idx=0;
        for(int i=0;i<n;++i)
            mp[inorder[i]]=i;
        return builder(0,n-1,preorder,inorder);
    }
};
```
## 后序中序构造二叉树

[原题](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description)
### 题目描述

### 思路
整体思路与上面相同，注意idx初始化值(n-1)与构建顺序
- 根据idx获取根节点的值rootVal
- 根据rootVal在哈希表中获取inoder中的下标index
- --idx
- 构建右子树，builder(index+1,r,postorder,inorder);
- 构建左子树，builder(l,index-1,postorder,inorder);
### 代码
```
class Solution {
    unordered_map<int,int> mp;
    int idx;
public:
    TreeNode* builder(int l,int r,vector<int>& postorder, vector<int>& inorder){
        if(l>r)
            return nullptr;
        int rootVal=postorder[idx];
        TreeNode* root=new TreeNode(rootVal);
        int index=mp[rootVal];
        idx--;
        root->right=builder(index+1,r,postorder,inorder);
        root->left=builder(l,index-1,postorder,inorder);
        
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int n=postorder.size();
        idx=n-1;
        for(int i=0;i<n;++i)
            mp[inorder[i]]=i;
        return builder(0,n-1,postorder,inorder);
    }
};
```