---
title: 单调栈
date: 2022-09-13 08:56:35
categories: 机试
math: true
tags:
---
<!-- TOC -->

- [例1](#例1)
- [接雨水](#接雨水)

<!-- /TOC -->

### 例1

**题目描述**

给出项数为 $n$ 的整数数列 $a_{1 \dots n}$。

定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的**下标**，即 $f(i)=\min_{i<j\leq n, a_j > a_i} \{j\}$。若不存在，则 $f(i)=0$。

试求出 $f(1\dots n)$。

**输入格式**

第一行一个正整数 $n$。

第二行 $n$ 个正整数 $a_{1\dots n}$。

**输出格式**

一行 $n$ 个整数 $f(1\dots n)$ 的值。

input:

```
5
1 4 2 3 5
```
output:
```
2 5 4 5 0
```

**数据规模**

对于 $30\%$ 的数据，$n\leq 100$；

对于 $60\%$ 的数据，$n\leq 5 \times 10^3$ ；

对于 $100\%$ 的数据，$1 \le n\leq 3\times 10^6$，$1\leq a_i\leq 10^9$。

**代码：**
```
#include<bits/stdc++.h>
using namespace std;
const int N=3*1e6+1;
int a[N];
stack<int> st;
int f[N];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	for(int i=n;i>=1;--i)
	{
		while(!st.empty()&&a[i]>a[st.top()])
			st.pop();
		if(st.empty())
			f[i]=0;
		else
			f[i]=st.top();
		st.push(i);
	}
	for(int i=1;i<=n;++i)
		cout<<f[i]<<' ';
	return 0;
} 
```
### 接雨水

[原题](https://leetcode.cn/problems/trapping-rain-water/)

**题目描述**

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**输入输出**
第一行输入$n$表示柱子数量
第二行输入n个数
输出最多能接多少雨水

input:
```
6
4 2 0 3 2 5
```

output:
```
9
```

**代码**
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+1;
int a[N];
stack<int> st;
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	int ans=0;
    for(int i=1;i<=n;++i)
    {
        while(!st.empty()&&a[i]>a[st.top()])
        {
            int idx=st.top();
            st.pop();
            if(st.empty())
                break;
            int l=st.top();
            int h=min(a[i],a[l])-a[idx];
            int w=i-l-1;
            ans+=w*h;
        }
        st.push(i);
    }
    cout<<ans<<endl;
	return 0;
} 
```
