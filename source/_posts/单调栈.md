---
title: 单调栈
date: 2022-09-13 08:56:35
categories: 机试
math: true
tags:
---
<!-- TOC -->

- [例1](#例1)
    - [**题目描述**](#题目描述)
    - [**思路**](#思路)
    - [**代码：**](#代码)
- [柱状图中最大的矩形](#柱状图中最大的矩形)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)
- [接雨水](#接雨水)
    - [**题目描述**](#题目描述-1)
    - [**代码**](#代码)

<!-- /TOC -->

## 例1

###**题目描述**

给出项数为 $n$ 的整数数列 $a_{1 \dots n}$。

定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的**下标**，即 $f(i)=\min_{i<j\leq n, a_j > a_i} \{j\}$。若不存在，则 $f(i)=0$。

试求出 $f(1\dots n)$。

**输入格式**

第一行一个正整数 $n$。

第二行 $n$ 个正整数 $a_{1\dots n}$。

**输出格式**

一行 $n$ 个整数 $f(1\dots n)$ 的值。

input:

```
5
1 4 2 3 5
```
output:
```
2 5 4 5 0
```

**数据规模**

对于 $30\%$ 的数据，$n\leq 100$；

对于 $60\%$ 的数据，$n\leq 5 \times 10^3$ ；

对于 $100\%$ 的数据，$1 \le n\leq 3\times 10^6$，$1\leq a_i\leq 10^9$。

### **思路**
找到a[i]右边第一个比他大的数的下标，也就是说对于栈中的元素来说，栈顶元素小于等于a[i]的数要不断出栈，直到遇到栈顶元素大于a[i]，此时栈顶的元素就是第一个比a[i]大的数。

* 一般找a[i]右边比他大的数，要从右向左遍历
* a[i]左边比他大的数，要从左向右遍历
### **代码：**
```
#include<bits/stdc++.h>
using namespace std;
const int N=3*1e6+1;
int a[N];
stack<int> st;
int f[N];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	for(int i=n;i>=1;--i)
	{
		while(!st.empty()&&a[i]>a[st.top()])
			st.pop();
		if(st.empty())
			f[i]=0;
		else
			f[i]=st.top();
		st.push(i);
	}
	for(int i=1;i<=n;++i)
		cout<<f[i]<<' ';
	return 0;
} 
```

## 柱状图中最大的矩形
[原题](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

### 题目描述
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

e.g.
```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```
### 思路
这道题实际上需要找出`heights[i]`左侧和右侧第一个小于他的数，因此要分别记录左右两侧第一个小于heights[i]的数的下标。然后以`heights[i]`为高的矩形面积就为`(right[i]-left[i]-1)*heights[i]`
`left[i]和right[i]`与上一道例题类似，当栈顶元素大于heights[i]要不断出栈，直到栈顶元素小于heights[i]，分别向左向右遍历并更新两个单调栈即可。
### 代码
```
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n=heights.size();
        vector<int> left(n),right(n);//记录左侧和右侧第一个比他小的数
        stack<int> ls,rs;
        for(int i=0;i<n;++i)
        {
            while(!ls.empty()&&heights[ls.top()]>=heights[i])
                ls.pop();
            if(ls.empty())
                left[i]=-1;
            else
                left[i]=ls.top();
            ls.push(i);
        }
        for(int i=n-1;i>=0;--i)
        {
            while(!rs.empty()&&heights[rs.top()]>=heights[i])
                rs.pop();
            if(rs.empty())
                right[i]=n;
            else
                right[i]=rs.top();
            rs.push(i);
        }
        int ans=0;
        for(int i=0;i<n;++i)
        {
            ans=max(ans,(right[i]-left[i]-1)*heights[i]);
        }
        return ans;
    }
};
```
## 接雨水

[原题](https://leetcode.cn/problems/trapping-rain-water/)

### **题目描述**

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**输入输出**
第一行输入$n$表示柱子数量
第二行输入n个数
输出最多能接多少雨水

input:
```
6
4 2 0 3 2 5
```

output:
```
9
```

### **代码**
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+1;
int a[N];
stack<int> st;
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	int ans=0;
    for(int i=1;i<=n;++i)
    {
        while(!st.empty()&&a[i]>a[st.top()])
        {
            int idx=st.top();
            st.pop();
            if(st.empty())
                break;
            int l=st.top();
            int h=min(a[i],a[l])-a[idx];
            int w=i-l-1;
            ans+=w*h;
        }
        st.push(i);
    }
    cout<<ans<<endl;
	return 0;
} 
```
