---
title: 使序列递增的最小交换次数
date: 2022-10-18 10:22:26
categories: 机试
math:
tags:
---
<!-- TOC -->

- [使序列递增的最小交换次数](#使序列递增的最小交换次数)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 使序列递增的最小交换次数
### 题目描述
[原题](https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/)

我们有两个长度相等且不为空的整型数组 nums1 和 nums2 。在一次操作中，我们可以交换 nums1[i] 和 nums2[i]的元素。

例如，如果 nums1 = [1,2,3,8] ， nums2 =[5,6,7,4] ，你可以交换 i = 3 处的元素，得到 nums1 =[1,2,3,4] 和 nums2 =[5,6,7,8] 。
返回 使 nums1 和 nums2 严格递增 所需操作的最小次数 。

数组 arr 严格递增 且  arr[0] < arr[1] < arr[2] < ... < arr[arr.length - 1] 。
input:
```
4
1 3 5 4
1 2 3 7
```
output:
```
1
```
### 思路

`dp[i][0]`表示不交换 `i` 处元素时满足条件的最小操作次数，`dp[i][1]`表示交换 `i` 处元素时满足条件的最小操作次数

下面要分类讨论：

* 当nums1和nums都递增，且在`i`处交换后也都递增，那么在`i`处可换可不换
* 当nums1和nums都递增，但在`i`处交换后不递增，那么如果在`i`处交换，在`i-1`处也要交换
* 当nums1或nums2不递增，如果在`i`处交换，那么`i-1`处不交换，如果`i-1`处交换，`i`处不交换
### 代码
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5;
int a[N];
int b[N];
int dp[N][2];
int main()
{
	int n;
	cin>>n;
	for(int i=0;i<n;++i)
		cin>>a[i];
	for(int i=0;i<n;++i)
		cin>>b[i];
	dp[0][1]=1;
	for(int i=1;i<n;++i)
	{
		if((a[i-1]<a[i]&&b[i-1]<b[i])&&(a[i-1]<b[i]&&b[i-1]<a[i]))
		{
			dp[i][0]=min(dp[i-1][0],dp[i-1][1]);
			dp[i][1]=dp[i][0]+1;
		}
		else if(a[i-1]<a[i]&&b[i-1]<b[i])
		{
			dp[i][0]=dp[i-1][0];
			dp[i][1]=dp[i-1][1]+1;
		}
		else
		{
			dp[i][0]=dp[i-1][1];
			dp[i][1]=dp[i-1][0]+1;
		}
	}
	cout<<min(dp[n-1][0],dp[n-1][1]);
	return 0;
}
```
