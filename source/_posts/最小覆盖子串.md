---
title: 最小覆盖子串
date: 2024-10-05 09:51:32
categories: 机试
math:
tags:
---
## 最小覆盖子串

<!-- TOC -->

- [最小覆盖子串](#最小覆盖子串)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->

[原题](https://leetcode.cn/problems/minimum-window-substring/description/)


### 题目描述
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。


注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。

e.g.
```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```
### 思路
这道题主要思路是滑动窗口。创建两个哈希表用来统计s某区间内的子串是否能覆盖t。然后开始滑动窗口，不断扩充右边界，每当能覆盖时，收缩左边界，并更新答案即可。
### 代码
```
class Solution {
public:
    string minWindow(string s, string t) {
        int n=s.size();
        unordered_map<char,int> sp,tp;
        for(char c:t){
            ++tp[c];
        } 
        function<bool()> check=[&](){
            for(auto m:tp){
                if(m.second>sp[m.first])
                    return false;
            }
            return true;
        };
        int l=0,r=0;
        int res=INT_MAX,resl=-1,resr=-1;
        while(r<n){
            ++sp[s[r]];
            while(check()&&l<=r){
                int len=r-l+1;
                if(len<res){
                    res=len;
                    resl=l;
                    resr=r;
                }
                --sp[s[l]];
                ++l;
            }
            ++r;
        }
        return resl==-1? "":s.substr(resl,res);
    }
};
```