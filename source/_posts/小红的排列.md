---
title: 小红的排列
date: 2025-03-22 09:24:13
categories: 机试
math:
tags:
---
## 小红的排列

<!-- TOC -->

- [小红的排列](#小红的排列)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->



### 题目描述

小红给定一个数字x，现在她准备把其数位上的数字重新排列，例如x=213，重排后可以是`[123，132，231，312，321]`，但不能是213，因为其没有进行重排，又例如 10，仅存在`[1]`，重排后的数字忽略掉前导零。

现在请你帮助小红计算有多少个重排后的数字 y，使得其数位之和是一个质数。

```
输入描述：
第一行一个整数 T(1 < T < 10^5)，表示数据组数，对于每组数据格式为:一个整数 x(1 < x < 10^9)，表示给定的数字。

输出描述：
对于每组数据，每行输出一个整数，表示满足条件的数字个数。
```
### 思路
这道题不是很难，但是我一看到排列总想着用next_permutation，这样会超时。
这道题应该根据字符串的长度计算阶乘，即全排列的个数，然后再根据每一位出现的次数计算阶乘，对全排列去重。
比如：
```
假设输入的字符串是 "32413"，其中数字 "3" 出现了两次。

字符串长度为 5，所以 5! = 120
"3" 出现 2 次，所以 2! = 2
计算排列数： 120 / 2 = 60
```

### 代码
```
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
ll get(int n){
    ll res=1;
    for(int i=2;i<=n;++i)
        res=res*i;
    return res;
}

int main(){
	int T;
    cin>>T;
    while(T--){
        int x;
        cin>>x;
        string s=to_string(x);
        int sum=0;
        vector<int> cnt(10);
        for(char c:s){
            sum+=c-'0';
            ++cnt[c-'0'];
        }
        bool isZ=false;
        for(int i=2;i*i<=sum;++i){
            if(sum%i==0){
                isZ=true;
                break;
            }
        }
        if(isZ==true||sum==1){
            cout<<0<<endl;
            continue;
        }
        ll ans=get(s.size());
        for(int t:cnt){
            ans=ans/get(t);
        }
        cout<<ans-1<<endl;
    }
}
```