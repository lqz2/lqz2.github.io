---
title: 素数筛
date: 2022-09-25 09:52:47
categories: 机试
math: true
tags:
---

<!-- TOC -->

- [暴力](#暴力)
- [埃氏筛](#埃氏筛)
- [欧拉筛](#欧拉筛)
- [例题](#例题)

<!-- /TOC -->

**素数筛**
>找到1到n区间里的所有素数,通常有以下几种方法
### 暴力

最基本的方法，时间复杂度$O(n^2)$

### 埃氏筛

主要思想是通过一个`bool`类型的数组记录某数是否为素数，思路不难，直接看代码就行

**代码**

```
void getPrime(int n)
{
    for(int i=2;i<=n;++i)
        isPrime[i] = true;  //假设2-n都是素数
    for(int i=2;i<=n;++i)   //遍历2-n里面所有数
        if(isPrime[i])      //如果i是素数
            //i是素数的话，那么i的倍数肯定就不是合适
            //即 i*2，i*3 .....i*j肯定不是素数，注意边界i*j<=n
            for(int j=i;i*j<=n;++j)
                //n以内，且是i的倍数的数肯定不是素数，设为false
                isPrime[i*j] = false;
}
```
时间复杂度$O(logn)$
### 欧拉筛

在埃尼筛的基础上加以改进，需要维护一个`vis[]`数组判断是否被标记过，然后`prime[]`数组记录第几个素数是什么，比较好理解，看一道例题就行

### 例题

**题目描述**

Output the k-th prime number.

input:
```
7
```
output:
```
17
```
**代码**
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e6;
int cnt;
bool vis[N];
int prime[10000];
int main()
{
    int k;
    cin>>k;
    for(int i=2;i<=N;++i)
    {
        if(cnt==k)
            break;
        if(vis[i]==false)
            prime[++cnt]=i;
        for(int j=1;j<=cnt&&i*prime[j]<=N;++j)
        {
            vis[i*prime[j]]=true;
            if(i%prime[j]==0)
                break;
        }
    }
    cout<<prime[k]<<endl;
    return 0;
}
```


