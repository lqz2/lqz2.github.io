---
title: 最短路
date: 2022-08-22 20:48:57
categories: 机试
math: true
---
<!-- TOC -->

- [例1 单源最短路 洛谷p4779](#例1-单源最短路-洛谷p4779)
- [SPFA](#spfa)
- [Dijkstra普通版](#dijkstra普通版)
- [Dijkstra堆优化版(AC)](#dijkstra堆优化版ac)
    - [链式前向星存图](#链式前向星存图)
    - [代码](#代码)
- [例2 最多经过k条边的最短路](#例2-最多经过k条边的最短路)
- [Bellmanford](#bellmanford)
- [并查集解最短路](#并查集解最短路)

<!-- /TOC -->
### 例1 单源最短路 洛谷p4779

题目描述

给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。

数据保证你能从 $s$ 出发到任意点。

输入格式

第一行为三个正整数 $n, m, s$。
第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$，表示从 $u_i$ 到 $v_i$ 有一条权值为 $w_i$ 的有向边。

输出格式

输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。


样例输入

```
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4
```

样例输出

```
0 2 4 3
```

提示


$1 \leq n \leq 10^5$；

$1 \leq m \leq 2\times 10^5$；

$s = 1$；

$1 \leq u_i, v_i\leq n$；

$0 \leq w_i \leq 10 ^ 9$,

$0 \leq \sum w_i \leq 10 ^ 9$。

### SPFA
>此题用spfa会超时,这里写的代码弱化了数据范围，存图也直接用二维数组了，主要是复习spfa的思路
```
#include<bits/stdc++.h>
using namespace std;
int n,m,s;
const int N=1e4+1;
int mp[N][N];
int dist[N];
bool vis[N]; 
int main()
{
	memset(mp,0x3f,sizeof(mp));
	memset(dist,0x3f,sizeof(dist));
	cin>>n>>m>>s;
	dist[s]=0;
	int u,v,w;
	for(int i=1;i<=m;++i)
	{
		cin>>u>>v>>w;
		mp[u][v]=w;
	}
	queue<int> q;
	q.push(s);
	while(!q.empty())
	{
		int t=q.front();
		q.pop();
		vis[t]=false;
		for(int i=1;i<=n;++i)
		{
			if(dist[i]>dist[t]+mp[t][i])
			{
				dist[i]=dist[t]+mp[t][i];
				if(!vis[i])
				{
					vis[i]=true;
					q.push(i);
				}
			}
		}
	} 
	for(int i=1;i<=n;++i)
		cout<<dist[i]<<' ';
	cout<<endl;
    return 0;
}
```
### Dijkstra普通版
>此题用普通Dijkstra会超时,这里写的代码弱化了数据范围，存图也直接用二维数组了，主要是复习dj的思路
```
#include<bits/stdc++.h>
using namespace std;
int n,m,s;
const int N=1e4+1;
int mp[N][N];
int dist[N];
bool vis[N]; 
int main()
{
	memset(mp,0x3f,sizeof(mp));
	memset(dist,0x3f,sizeof(dist));
	cin>>n>>m>>s;
	dist[s]=0;
	int u,v,w;
	for(int i=1;i<=m;++i)
	{
		cin>>u>>v>>w;
		mp[u][v]=w;
	}
	for(int i=1;i<=n;++i)
	{
		int t=-1;
		for(int j=1;j<=n;++j)
		{
			if(!vis[j]&&(t==-1||dist[t]>dist[j]))
				t=j;
		}
		vis[t]=true;
		for(int j=1;j<=n;++j)
		{
			dist[j]=min(dist[j],dist[t]+mp[t][j]);
		}
	}
	for(int i=1;i<=n;++i)
		cout<<dist[i]<<' ';
	cout<<endl;
    return 0;
}
```
### Dijkstra堆优化版(AC)

#### 链式前向星存图
题目中给的节点数很多，属于稀疏图，二维数组无法存储，所以需要使用**链式前向星**存储，方法如下：


定义一个数组`head[]`,`head[a]`表示以a为起始点的最后一条边的序号


$cnt$：表示边的序号

结构体$edge$，存储边
```
struct edge
{
	int to;//这条边指向的点 
	int next;//这条边的邻边的序号 
	int w;//这条边的权值 
};
```

加边，如果是无向图，交换u和v再add一次即可
```
void add(int u,int v,int w)
{
	++cnt;
	e[cnt].to=v;
	e[cnt].w=w;
	e[cnt].next=head[u];
	head[u]=cnt;
}
```

遍历以a为起点的所有边
```
for(int i=head[a];i!=0;i=edge[i].next)
```
#### 代码
```
#include<bits/stdc++.h>
using namespace std;
int n,m,s;
const int N=1e5+5;
int head[N];
bool vis[N];
int dis[N];
int cnt;
//边 
struct edge
{
	int to;//这条边指向的点 
	int next;//这条边的邻边的序号 
	int w;//这条边的权值 
}e[2*N];
//优先级队列的节点
struct node
{
	int n;
	int w;
	node(int nn,int ww):n(nn),w(ww){}
	//重载运算符<，为了建立小顶堆 
	bool operator< (const node& t) const
	{
		return w>t.w;
	}
}; 
//加边 
void add(int u,int v,int w)
{
	++cnt;
	e[cnt].to=v;
	e[cnt].w=w;
	e[cnt].next=head[u];
	head[u]=cnt;
}
priority_queue<node> q;
int main()
{
	cin>>n>>m>>s;
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0;
	int u,v,w;
	for(int i=1;i<=m;++i)
	{
		cin>>u>>v>>w;
		add(u,v,w);
	}
	q.push(node(s,0));
	while(!q.empty())
	{
		node t=q.top();
		q.pop();
		u=t.n;
		if(!vis[u])
		{
			vis[u]=true;
			for(int i=head[u];i;i=e[i].next)
			{
				v=e[i].to;
				w=e[i].w;
				if(dis[v]>dis[u]+w)
				{
					dis[v]=dis[u]+w;
					if(!vis[v])
						q.push(node(v,dis[v]));
				}
			}
		}
	}
	for(int i=1;i<=n;++i)
		cout<<dis[i]<<' ';
	return 0;
}
```

### 例2 最多经过k条边的最短路
描述
给定 n 个点，m条有向边，起点s，终点d，最大边数k

第一行输入$n,m,s,d,k$
后面m行输入m条边 $u_i,v_i,w_i$

输出从$s$到$d$最多经过$k$条边时的最短路径
input:
```
3 3 1 3 2
1 2 100
2 3 100
1 3 500
```
output:
```
200
```
### Bellmanford
>Bellmanford常用于解决此类有边数限制的最短路

代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,m,s,d,k;
int inf=0x3f3f3f3f;
const int N=1e4+5;
int dp[100][N];
bool vis[N];
struct edge
{
	int u,v,w;
//	edge(int uu,int vv,int ww):u(uu),v(vv),w(ww){}
}e[N];
int main()
{
	cin>>n>>m>>s>>d>>k;
	memset(dp,0x3f,sizeof(dp));
	dp[0][s]=0;
	int u,v,w;
	for(int i=1;i<=m;++i)
	{
		cin>>u>>v>>w;
		e[i].u=u;
		e[i].v=v;
		e[i].w=w;
	}
	for(int i=1;i<=k;++i)
	{
		for(int j=1;j<=m;++j)
		{
			u=e[j].u;
			v=e[j].v;
			w=e[j].w;
			dp[i][v]=min(dp[i][v],dp[i-1][u]+w);
		}
	}
	int ans=inf;
	for(int i=1;i<=k;++i)
	{
		ans=min(dp[i][d],ans);
	} 
	if(ans==inf)
		cout<<-1<<endl;
	else
		cout<<ans<<endl;
	return 0;
}
```
### 并查集解最短路

先看一个例题

[最短路径](https://www.nowcoder.com/practice/a29d0b5eb46b4b90bfa22aa98cf5ff17?tpId=40&tqId=21438&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan&difficulty=&judgeStatus=&tags=/question-ranking)

**描述**

N个城市，标号从0到N-1，M条道路，第K条道路（K从0开始）的长度为2^K，求编号为0的城市到其他城市的最短距离

**输入描述**

第一行两个正整数N（2<=N<=100）M(M<=500),表示有N个城市，M条道路 接下来M行两个整数，表示相连的两个城市的编号

**输出描述**

N-1行，表示0号城市到其他城市的最短路，如果无法到达，输出-1，数值太大的以MOD 100000 的结果输出。

input:
```
4 4
1 2
2 3
1 3
0 1
```

output:

```
8
9
11
```
>思路：对于这道题，第k条边的长度为2^k，也就是说，第k条边会比前面所有边的和还要大。所以用并查集来做，当新加入边的两个端点u和v不连通时，这条边就是u到v的最短距离，因为后续如果再次出现以uv为端点的边，一定会比当前长度长。加入uv边后，更新两端点各自连通子图中各点间的距离即可。

代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N=102;
const int mod=1e5;
typedef long long ll;
int mp[N][N];
int vset[N];
int ksm(ll a,int b,int c)
{
    int ans=1;
    a=a%c;
    while(b>0)
    {
        if(b%2)
            ans=(ans*a)%c;
        a=(a*a)%c;
        b/=2;
    }
    return ans;
}
int find(int a)
{
	if(vset[a]==-1)
		return a;
	else
	{
		vset[a]=find(vset[a]);
		return vset[a];
	}
}
int main()
{
    int n,m;
    cin>>n>>m;
    memset(vset,-1,sizeof(vset));
    memset(mp,-1,sizeof(mp));
    for(int i=0;i<n;++i)
    	mp[i][i]=0;
    int u,v,w;
    for(int k=0;k<m;++k)
    {
        cin>>u>>v;
        int x=find(u);
        int y=find(v);
        //当两点不连通的时候才加入该边，此时该边是u到v的最短边
		if(x!=y)
		{
			w=ksm(2,k,mod);
			//更新两个连通子图间各点的距离 
			for(int i=0;i<n;++i)
			{
				if(find(i)==x)
				{
					for(int j=0;j<n;++j)
					{
						if(find(j)==y)
						{
							mp[i][j]=mp[j][i]=(mp[i][u]+w+mp[v][j])%mod;
						}
					}
				}
			}
			//连接两个连通子图
			vset[x]=y; 
		} 
    }

    for(int i=1;i<n;++i)
    	cout<<mp[0][i]<<endl;
    return 0;
}
```