---
title: 交换得到字典序最小的数组
date: 2023-11-26 18:34:51
categories: 机试
math:
tags:
---
<!-- TOC -->

- [交换得到字典序最小的数组](#交换得到字典序最小的数组)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 交换得到字典序最小的数组
[原题](https://leetcode.cn/problems/make-lexicographically-smallest-array-by-swapping-elements/description/)

### 题目描述
给你一个下标从 0 开始的 正整数 数组 nums 和一个 正整数 limit 。

在一次操作中，你可以选择任意两个下标 i 和 j，如果 满足 |nums[i] - nums[j]| <= limit ，则交换 nums[i] 和 nums[j] 。

返回执行任意次操作后能得到的 字典序最小的数组 。

如果在数组 a 和数组 b 第一个不同的位置上，数组 a 中的对应字符比数组 b 中的对应字符的字典序更小，则认为数组 a 就比数组 b 字典序更小。例如，数组 [2,10,3] 比数组 [10,2,3] 字典序更小，下标 0 处是两个数组第一个不同的位置，且 2 < 10 。

e.g.
```
输入：nums = [1,5,3,9,8], limit = 2
输出：[1,3,5,8,9]
解释：执行 2 次操作：
- 交换 nums[1] 和 nums[2] 。数组变为 [1,3,5,9,8] 。
- 交换 nums[3] 和 nums[4] 。数组变为 [1,3,5,8,9] 。
即便执行更多次操作，也无法得到字典序更小的数组。
注意，执行不同的操作也可能会得到相同的结果。
```
### 思路
主要思路是分组排序和二分。首先需要对数组进行排序，接下来将他们分组，分组的原则是组内升序且各个组之间，不存在任何一对可以交换的元素`(tmp[j]-tmp[i]>limit,j>i)`，然后用数组idx[]记录每个组的第一个元素在有序数组中的下标，offset[]记录偏移量。接下来遍历nums数组，每个元素先二分查找在有序数组中的下标j，然后再二分查找j属于哪个组，然后根据组内起始下标和组内偏移确定在有序数组中的下标，然后添加到ans中。总的来说，每次遍历元素放置的是元素所在组内能交换的较小值，因此保证了字典序较小。
### 代码
```
class Solution {
public:
    vector<int> lexicographicallySmallestArray(vector<int>& nums, int limit) {
        int n=nums.size();
        vector<int> tmp=nums;
        sort(tmp.begin(),tmp.end());
        vector<int> idx;
        idx.push_back(0);
        int t=0;
        for(int i=1;i<n;++i)
        {
            if(tmp[i]-tmp[t]>limit)
            {
                idx.push_back(i);
                t=i;
            }
        }
        int m=idx.size();
        vector<int> offset(m);
        vector<int> ans(n);
        for(int i=0;i<n;++i)
        {
            int j=upper_bound(tmp.begin(),tmp.end(),nums[i])-tmp.begin();
            int k=lower_bound(idx.begin(),idx.end(),j)-idx.begin();
            ans[i]=tmp[idx[k-1]+offset[k-1]];
            ++offset[k-1];
        }
        return ans;
    }
};
```