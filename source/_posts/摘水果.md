---
title: 摘水果
date: 2023-05-04 17:58:21
categories: 机试
math:
tags:
---
<!-- TOC -->

- [摘水果](#摘水果)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 摘水果
[原题](https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/description/)
### 题目描述
在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 fruits ，其中 fruits[i] = [positioni, amounti] 表示共有 amounti 个水果放置在 positioni 上。fruits 已经按 positioni 升序排列 ，每个 positioni 互不相同 。

另给你两个整数 startPos 和 k 。最初，你位于 startPos 。从任何位置，你可以选择 向左或者向右 走。在 x 轴上每移动 一个单位 ，就记作 一步 。你总共可以走 最多 k 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。

返回你可以摘到水果的 最大总数 。
e.g.
```
输入：fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4
输出：9
解释：
最佳路线为：
- 向右移动到位置 6 ，摘到 3 个水果
- 向右移动到位置 8 ，摘到 6 个水果
移动 3 步，共摘到 3 + 6 = 9 个水果
```
### 思路
枚举移动的区间`[left,right]`，用二分查找来确定移动区间，实际移动时，要么先向左移动`x`步，再向右移动`k-x`，要么先向右移动`x`步，再向左移动`k-x`步，通过前缀和来快速计算区间的水果数量，通过二分查找枚举移动区间的时候，要注意边界，最后更新最大值即可。
### 代码
```
class Solution {
public:
    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {
        int n=fruits.size();
        vector<int> sum(n+1);
        vector<int> idx(n);
        for(int i=0;i<n;++i)
        {
            sum[i+1]=sum[i]+fruits[i][1];
            idx[i]=fruits[i][0];
        }
        int res=0;
        int t=k/2;
        for(int x=0;x<=t;++x)
        {
            int offset=k-2*x;
            int left=startPos-x;
            int right=startPos+offset;
            int l=lower_bound(idx.begin(),idx.end(),left)-idx.begin();
            int r=upper_bound(idx.begin(),idx.end(),right)-idx.begin();
            res=max(res,sum[r]-sum[l]);
            right=startPos+x;
            left=startPos-offset;
            l=lower_bound(idx.begin(),idx.end(),left)-idx.begin();
            r=upper_bound(idx.begin(),idx.end(),right)-idx.begin();
            res=max(res,sum[r]-sum[l]);
        }
        return res;
    }
};
```