---
title: 乘积最大子数组
date: 2025-01-29 20:53:00
categories: 机试
math:
tags:
---
## 乘积最大子数组

<!-- TOC -->

- [乘积最大子数组](#乘积最大子数组)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)
    - [扩展](#扩展)

<!-- /TOC -->

[原题](https://leetcode.cn/problems/maximum-product-subarray/description)


### 题目描述
给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 
子数组
（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。
```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```
### 思路
这道题思路和**最大子数组的和**题目类似，都用动态规划的思路解决。需要注意的是，因为乘法的特性，所以在计算的时候需要同时维护一个最大值和最小值，因为最小值可能会变成最大值。
由于是连续的子数组，每次最大最小值只需要从`nums[i]`和`max * nums[i]`、`min * nums[i]`中取最大最小值即可，每次还要更新ans为ans和max中的最大值。

### 代码
```
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n=nums.size();
        int mx=nums[0],mn=nums[0];
        int ans=nums[0];
        for(int i=1;i<n;++i){
            int mxt=mx;
            mx=max({mx*nums[i],mn*nums[i],nums[i]});
            mn=min({mxt*nums[i],mn*nums[i],nums[i]});
            ans=max(ans,mx);
        }
        return ans;        
    }
};

```
### 扩展
如果把题目要求改为子序列，参考[一个小组的最大实力值](https://leetcode.cn/problems/maximum-strength-of-a-group/description/)，实际上思路也类似，也要维护最大和最小值
但是，这里包括选和不选两种情况
- 选，对应情况是`x,mx*x,mn*x`
- 不选，对应情况是`mx`或者`mn`

代码如下
```
class Solution {
public:
    long long maxStrength(vector<int>& nums) {
        int n=nums.size();
        long long mx=nums[0],mn=nums[0];
        for(int i=1;i<n;++i){
            long long x=nums[i];
            long long tmx=mx;
            mx=max({mx,x,mx*x,mn*x});
            mn=min({mn,x,tmx*x,mn*x});
        }
        return mx;
    }
};
```