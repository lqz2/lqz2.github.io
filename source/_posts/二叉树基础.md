---
title: 二叉树基础
date: 2024-12-29 18:58:35
categories: 机试
math: true
tags:
---
<!-- TOC -->

- [二叉树最大深度](#二叉树最大深度)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)
- [相同的树](#相同的树)
    - [题目描述](#题目描述-1)
    - [思路](#思路-1)
    - [代码](#代码-1)
- [对称二叉树](#对称二叉树)
    - [题目描述](#题目描述-2)
    - [思路](#思路-2)
    - [代码](#代码-2)
- [平衡二叉树](#平衡二叉树)
    - [题目描述](#题目描述-3)
    - [思路](#思路-3)
    - [代码](#代码-3)
- [二叉树右视图](#二叉树右视图)
    - [题目描述](#题目描述-4)
    - [思路](#思路-4)
    - [代码](#代码-4)
- [有序数组转为二叉搜索树](#有序数组转为二叉搜索树)
    - [题目描述](#题目描述-5)
    - [思路](#思路-5)
    - [代码](#代码-5)
- [验证二叉搜索树](#验证二叉搜索树)
    - [题目描述](#题目描述-6)
    - [思路](#思路-6)
    - [代码](#代码-6)
- [翻转二叉树](#翻转二叉树)
    - [题目描述](#题目描述-7)
    - [思路](#思路-7)
    - [代码](#代码-7)
- [二叉树的直径](#二叉树的直径)
    - [题目描述](#题目描述-8)
    - [思路](#思路-8)
    - [代码](#代码-8)
- [二叉树最大路径和](#二叉树最大路径和)
    - [题目描述](#题目描述-9)
    - [思路](#思路-9)
    - [代码](#代码-9)
- [不同的二叉搜索树的个数](#不同的二叉搜索树的个数)
    - [题目描述](#题目描述-10)
    - [思路](#思路-10)
    - [代码](#代码-10)

<!-- /TOC -->


## 二叉树最大深度
[原题](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

### 题目描述
给定一个二叉树 root ，返回其最大深度。

二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。
### 思路
二叉树入门题，最大深度等于左右子树最大深度加1，所以可以递归
### 代码
```
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root)
            return 0;
        return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
};
```
## 相同的树
[原题](https://leetcode.cn/problems/same-tree/description/)

### 题目描述
给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的
### 思路
当两个树的当前节点有一个为空：都为空返回true，否则返回false
否则，两个节点值相等，且递归左右子树也为true，才返回true
### 代码
```
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p||!q)
            return p==q;
        return p->val==q->val&& isSameTree(p->left,q->left)&& isSameTree(p->right,q->right);
    }
};
```

## 对称二叉树
[原题](https://leetcode.cn/problems/symmetric-tree/description/)

### 题目描述
给你一个二叉树的根节点 root ， 检查它是否轴对称。
### 思路
和相同的树类似，判断左右子树是否对称即可，判断过程与相同的树类似，但比较的是左子树的左节点和右子树的右节点，左子树的右节点和右子树的左节点
### 代码
```
class Solution {
public:
    bool func(TreeNode* l, TreeNode* r){
        if(!l||!r)
            return l==r;
        return l->val==r->val&&func(l->left,r->right)&&func(l->right,r->left);
    }
    bool isSymmetric(TreeNode* root) {
        return func(root->left,root->right);
    }
};
```

## 平衡二叉树
[原题](https://leetcode.cn/problems/balanced-binary-tree/)

### 题目描述
给定一个二叉树，判断它是否是平衡二叉树
  
### 思路
与求出二叉树的最大深度类似，只是在求左右子树的最大深度时，要判断左右子树的最大深度差是否大于1
### 代码
```
class Solution {
public:
    int depth(TreeNode *t){
        if(t==nullptr)
            return 0;
        int l=depth(t->left);
        if(l==-1)
            return -1;
        int r=depth(t->right);
        if(r==-1||abs(l-r)>1)
            return -1;
        return max(l,r)+1;
    }
    bool isBalanced(TreeNode* root) {
        return depth(root)!=-1;
    }
};
```

## 二叉树右视图
[原题](https://leetcode.cn/problems/binary-tree-right-side-view/description/)

### 题目描述
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
  
### 思路
设置一个表示当前深度的标记，当实际深度大于标记时，才将当前节点值加入结果中，递归时先递归右子树，再递归左子树
### 代码
```
class Solution {
public:
    int cur=0;
    void dfs(TreeNode* t, vector<int>& ans, int depth){
        if(t==nullptr)
            return;
        if(depth>cur){
            ans.push_back(t->val);
            ++cur;
        }
        dfs(t->right,ans,depth+1);
        dfs(t->left,ans,depth+1);
    }
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        dfs(root,ans,1);
        return ans;
    }
};
```

## 有序数组转为二叉搜索树
[原题](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)

### 题目描述
给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵平衡二叉搜索树。

### 思路
类似归并排序，每次取数组中间元素作为根节点，递归左右子树建立二叉搜索树
### 代码
```
class Solution {
public:
    TreeNode* dfs(vector<int>& nums, int l, int r){
        if(l==r)
            return nullptr;
        int mid=l+(r-l)/2;
        return new TreeNode(nums[mid],dfs(nums,l,mid),dfs(nums,mid+1,r));
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return dfs(nums,0,nums.size());
    }
};
```

## 验证二叉搜索树
[原题](https://leetcode.cn/problems/validate-binary-search-tree/description)

### 题目描述
给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
### 思路
按照中序遍历的顺序，设置一个值pre记录上一个节点的值，递归时判断当前节点值是否大于pre，如果小于等于pre，返回false，更新pre为当前节点值，递归左右子树
### 代码
```
class Solution {
public:
    long long pre=LLONG_MIN;
    bool isValidBST(TreeNode* root) {
        if(root==nullptr)
            return true;
        if(!isValidBST(root->left)||root->val<=pre)
            return false;
        pre=root->val;
        return isValidBST(root->right);
    }
};
```

## 翻转二叉树
[原题](https://leetcode.cn/problems/invert-binary-tree/description)

### 题目描述
给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。
### 思路
递归，先翻转左右子树，再交换左右子树的指针，返回当前节点
### 代码
```
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr)
            return nullptr;
        TreeNode* l=invertTree(root->left);
        TreeNode* r=invertTree(root->right);
        root->left=r;
        root->right=l;
        return root;
    }
};
```
## 二叉树的直径

[原题](https://leetcode.cn/problems/diameter-of-binary-tree/)

### 题目描述
给你一棵二叉树的根节点，返回该树的 直径 。

二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。

两节点之间路径的 长度 由它们之间边数表示。

### 思路
直径等于左右子树的最大深度之和，和求最大深度类似，递归时更新最大直径即可
### 代码
```
class Solution {
public:
    int depth(TreeNode* root, int &maxlen){
        if(root==nullptr)
            return 0;
        int l=depth(root->left, maxlen);
        int r=depth(root->right, maxlen);
        maxlen=max(l+r,maxlen);
        return max(l,r)+1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        int maxlen=-1;
        depth(root, maxlen);
        return maxlen;
    }
};
```
## 二叉树最大路径和

[原题](https://leetcode.cn/problems/binary-tree-maximum-path-sum)

### 题目描述
二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 
### 思路
最大路径和等于左子树最深路径和+右子树最深路径和+当前节点值
所以递归时返回当前节点向下的最深路径和，即`max(max(l,r)+root->val,0)`
同时更新最大路径和，即`max(l+r+root->val,ans)`
### 代码
```
class Solution {
public:
    int ans;
    int dfs(TreeNode* t){
        if(t==nullptr)
            return 0;
        int l=dfs(t->left);
        int r=dfs(t->right);
        ans=max(ans,l+r+t->val);
        return max(max(l,r)+t->val,0);
    }
    int maxPathSum(TreeNode* root) {
        ans=INT_MIN;
        dfs(root);
        return ans;
    }
};
```

## 不同的二叉搜索树的个数

[原题](https://leetcode.cn/problems/unique-binary-search-trees/)

### 题目描述
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
### 思路
对于从1～n的节点来说，每个节点i都可以作为根节点，左子树为1～i-1的节点，右子树为i+1～n的节点
所以，以i为根节点，长度为n的二叉搜索树的个数为左子树的个数乘以右子树的个数
即`dp[i] =dp[i-1]*dp[n-i]`
将这些情况累加起来即为长度为n的二叉搜索树的个数

实际上卡特兰数的计算方式也是这种方式
卡特兰数即解决：若一个序列的入栈序列为1,2,3,...,n，则有多少不同的出栈序列
公式为：
$$
C_0 = 1, \quad C_{n+1} = \frac{2(2n + 1)}{n + 2} C_n
$$

### 代码
```c++
class Solution {
public:
    int numTrees(int n) {
//        vector<int> dp(n + 1);
//        dp[0] = 1;
//        dp[1] = 1;
//        for(int i=2;i<=n;++i){
//            for(int j=1;j<=i;++j){
//                dp[i] += dp[j-1] * dp[i-j];
//            }
//        }
//        return dp[n];
         long ans=1;
         for(int i=0;i<n;++i){
             ans=ans*2*(2*i+1)/(i+2);
         }
         return ans;
    }
};
```