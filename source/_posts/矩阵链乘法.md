---
title: 矩阵链乘法
date: 2023-11-03 10:26:12
categories: 机试
math: true
tags:
---
## 矩阵链乘法

### 问题描述
矩阵乘法的计算复杂度与相乘顺序有关，可以通过适当的结合降低计算复杂度。
给你一系列的矩阵A1,A2,A3,......,An和一系列的整数P0,P1,P2......,Pn，每个矩阵 Ai 的规模为Pi-1 * Pi, 1 <=i < n。
现在，请你计算这些矩阵连乘所需要的最少的计算次数是多少？

### 思路
用d[i][j]表示相乘后矩阵$A_{ij}$的计算次数，对于i~j(1 <=i < j < n)的矩阵，可以在中间找到第k个矩阵进行切割，此时所需计算次数为d[i][k]+d[k+1][j]+$p_{i-1}p_{k}p_{j}$，可以遍历i~j之间所有k，找到使计算次数最小的k。递推关系如下：

* 若 i== j，d[i][j]==0 
* 若i < j, d[i][j]=din(d[i][k]+d[k+1][j]+p(i-1)p(k)p(j))， i <= k < j

经过以上步骤，可以找出i～j个矩阵相乘的子问题的最优解，该子问题包含j-i+1个矩阵，因此矩阵链的长度为l=j-i+1，为了求出总体的最优解，还需要遍历所有子链的长度l(1~n)

### 代码
```
void MATRIX_CHAIN_ORDER(int *p,int Length,int d[][M],int s[][M])
{
    //d保存最少计算次数，s保存划分位置(跟踪矩阵)
	int q,n=Length-1;
	for(int i=1;i<=n;i++) d[i][i]=0;
	for(int l=2;l<=n;l++) 	/* 矩阵链的长度 */
	{
		for(int i=1;i<=n-l+1;i++) 
		{
			int j=i+l-1;         /* 等价于 l=j-i+1 */
			d[i][j]=INT_MAX;
			for(int k=i;k<=j-1;k++)
			{
				q=d[i][k]+d[k+1][j]+p[i-1]*p[k]*p[j];
				if(q<d[i][j])
				{
					d[i][j]=q;
					s[i][j]=k;
				}
			}
		}
	}
}
```