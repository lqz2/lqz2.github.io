---
title: 匹配子序列的单词数
date: 2022-11-17 19:08:46
categories: 机试
math:
tags:
---
<!-- TOC -->

- [匹配子序列的单词数](#匹配子序列的单词数)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 匹配子序列的单词数
[原题](https://leetcode.cn/problems/number-of-matching-subsequences/description/)
### 题目描述

给定字符串 s 和字符串数组 words, 返回  words[i] 中是s的子序列的单词个数 。

字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。

例如， “ace” 是 “abcde” 的子序列。

示例：
```
输入: s = "dsahjpjauf", words = ["ahjpjau","ja","ahbwzgqnuk","tnmlanowax"]
输出: 2
```
### 思路

用`pair(i,j)`表示words中，第`i`个字符串的查询到了第`j`个字符，开始先将words中所有字符串的第一个字符放入对应queue中，然后遍历所有s中的字符，取出字符对应的queue，然后依次出队列，将对应words中的字符串的下标`j`增加1，如果`j`等于所在字符串的长度，说明该字符串符合要求。

### 代码
```

class Solution {
public:
    int numMatchingSubseq(string s, vector<string>& words) {
        int len=words.size();
        vector<queue<pair<int,int>>> v(26);
        for(int i=0;i<len;++i)
            v[words[i][0]-'a'].push({i,0});
        int ans=0;
        for(char& c:s)
        {
            auto& q=v[c-'a'];
            int n=q.size();
            while(n--)
            {
                int i=q.front().first;
                int j=q.front().second;
                q.pop();
                ++j;
                if(j==words[i].size())
                    ++ans;
                else
                    v[words[i][j]-'a'].push({i,j});                
            }
        }
        return ans;
    }
};
```