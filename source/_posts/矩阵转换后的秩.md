---
title: 矩阵转换后的秩
date: 2023-01-25 10:50:11
categories: 机试
math:
tags:
---
<!-- TOC -->

- [矩阵转换后的秩](#矩阵转换后的秩)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 矩阵转换后的秩
[原题](https://leetcode.cn/problems/rank-transform-of-a-matrix/description/)

### 题目描述
给你一个 m x n 的矩阵 matrix ，请你返回一个新的矩阵 answer ，其中 answer[row][col] 是 matrix[row][col] 的秩。

每个元素的 秩 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：

秩是从 1 开始的一个整数。
如果两个元素 p 和 q 在 同一行 或者 同一列 ，那么：
如果 p < q ，那么 rank(p) < rank(q)
如果 p == q ，那么 rank(p) == rank(q)
如果 p > q ，那么 rank(p) > rank(q)
秩 需要越 小 越好。
题目保证按照上面规则 answer 数组是唯一的。

示例：
```
输入：matrix = [[1,2],[3,4]]
输出：[[1,2],[2,3]]
解释：
matrix[0][0] 的秩为 1 ，因为它是所在行和列的最小整数。
matrix[0][1] 的秩为 2 ，因为 matrix[0][1] > matrix[0][0] 且 matrix[0][0] 的秩为 1 。
matrix[1][0] 的秩为 2 ，因为 matrix[1][0] > matrix[0][0] 且 matrix[0][0] 的秩为 1 。
matrix[1][1] 的秩为 3 ，因为 matrix[1][1] > matrix[0][1]， matrix[1][1] > matrix[1][0] 且 matrix[0][1] 和 matrix[1][0] 的秩都为 2 。
```
### 思路
这道题还是很麻烦的，要用到并查集+拓扑排序，看了题解也很勉强的写下来:cry:

主要的思路就是，用哈希表把每行相同元素的下标记录下来，然后用并查集把相同元素的下标连接起来，下面就是建图，我们希望构建这样的图，一条边`u->v`中，`u`是较小的元素的集合的`root`，`v`是较大的元素的集合的`root`，也就是说，建立的是不同集合间的拓扑图，然后通过拓扑排序，为每个集合的根节点设置它的 “秩”，然后把同一集合的元素的值设置为集合内根节点的值即可。
### 代码
```
class unionset
{
    vector<int> vset,sz;
public:
    unionset(int n)
    {
        vset=vector<int> (n);
        sz=vector<int> (n,1);
        iota(vset.begin(),vset.end(),0);
    }
    int find(int a)
    {
        if(vset[a]==a)
            return a;
        return vset[a]=find(vset[a]);
    }
    void con(int a,int b)
    {
        int x=find(a);
        int y=find(b);
        if(x!=y)
        {
            if(sz[x]>sz[y])
            {
                vset[y]=x;
                sz[x]+=sz[y];
            }
            else
            {
                vset[x]=y;
                sz[y]+=sz[x];
            }
        }
    }
};
class Solution {
public:
    vector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {
        int n=matrix.size(),m=matrix[0].size();
        unionset uset(n*m);
        for(int i=0;i<n;++i)
        {
            map<int,vector<int>> mp;
            for(int j=0;j<m;++j)
                mp[matrix[i][j]].emplace_back(i*m+j);
            for(auto &[num,vec]:mp)//将每行相同元素connect
            {
                for(int k=0;k+1<vec.size();++k)
                    uset.con(vec[k],vec[k+1]);
            }
        }
        for(int j=0;j<m;++j)
        {
            map<int,vector<int>> mp;
            for(int i=0;i<n;++i)
                mp[matrix[i][j]].emplace_back(i*m+j);
            for(auto &[num,vec]:mp)//将每列相同元素connect
            {
                for(int k=0;k+1<vec.size();++k)
                    uset.con(vec[k],vec[k+1]);
            }
        }
        vector<vector<int>> adj(n*m);
        vector<int> in(n*m);
        //建图
        for(int i=0;i<n;++i)
        {
            vector<pair<int,int>> v(m);
            for(int j=0;j<m;++j)
                v[j]={matrix[i][j],j};
            sort(v.begin(),v.end());
            for(int j=0;j+1<m;++j)
            {
                if(v[j].first!=v[j+1].first)
                {
                    int uu=uset.find(i*m+v[j].second);
                    int vv=uset.find(i*m+v[j+1].second);
                    adj[uu].emplace_back(vv);
                    ++in[vv];
                }
            }
        }
        for(int j=0;j<m;++j)
        {
            vector<pair<int,int>> v(n);
            for(int i=0;i<n;++i)
                v[i]={matrix[i][j],i};
            sort(v.begin(),v.end());
            for(int i=0;i+1<n;++i)
            {
                if(v[i].first!=v[i+1].first)
                {
                    int uu=uset.find(v[i].second*m+j);
                    int vv=uset.find(v[i+1].second*m+j);
                    adj[uu].emplace_back(vv);
                    ++in[vv];
                }
            }
        }
        vector<int> ans(n*m,1);
        queue<int> q;
        for(int i=0;i<n*m;++i)
        {
            if(uset.find(i)==i&&in[i]==0)
                q.emplace(i);
        }
        while(!q.empty())
        {
            int u=q.front();
            q.pop();
            for(int &v:adj[u])
            {
                ans[v]=max(ans[v],ans[u]+1);
                --in[v];
                if(in[v]==0)
                    q.emplace(v);
            }
        }
        vector<vector<int>> res(n,vector<int> (m));
        for(int i=0;i<n;++i)
        {
            for(int j=0;j<m;++j)
            {
                res[i][j]=ans[uset.find(i*m+j)];
            }
        }
        return res;
    }
};
```
