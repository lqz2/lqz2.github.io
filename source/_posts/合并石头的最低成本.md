---
title: 合并石头的最低成本
date: 2023-04-04 09:08:08
categories: 机试
math:
tags:
---
<!-- TOC -->

- [合并石头的最低成本](#合并石头的最低成本)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 合并石头的最低成本
[原题](https://leetcode.cn/problems/minimum-cost-to-merge-stones/description/)
### 题目描述
有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。

每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。

找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。
e.g.
```
输入：stones = [3,2,4,1], K = 2
输出：20
解释：
从 [3, 2, 4, 1] 开始。
合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。
合并 [4, 1]，成本为 5，剩下 [5, 5]。
合并 [5, 5]，成本为 10，剩下 [10]。
总成本 20，这是可能的最小值。
```
### 思路
用`dfs(i,j,p)`表示把第i堆到第j堆合并成p堆需要的最小成本，然后将原问题划分成子问题。比如有7堆石子，k=3，实际上要求的就是`dfs(0,6,1)`，而它又可以划分为`dfs(0,6,3)+0到6所有堆之和`，对于`dfs(0,6,3)`，按第一堆的合并方式也分为几种情况，比如`dfs(0,0,1)+dfs(1,6,2)`，`dfs(0,2,1)+dfs(3,6,2)`，`dfs(0,4,1)+dfs(5,6,2)`，取这些情况中最小的即可。
### 代码
```
class Solution {
public:
    int mergeStones(vector<int>& stones, int k) {
        int n=stones.size();
        if((n-1)%(k-1))
            return -1;
        vector<int> sum(n+1);
        for(int i=0;i<n;++i)
            sum[i+1]=sum[i]+stones[i];
        int m[n][n][k+1];
        memset(m,-1,sizeof(m));
        function<int(int,int,int)> dfs=[&](int i,int j,int p)->int
        {
            if(m[i][j][p]!=-1)
                return m[i][j][p];
            if(p==1)
            {
                if(i==j)
                    return 0;
                else
                    return dfs(i,j,k)+sum[j+1]-sum[i];
            }
            int res=INT_MAX;
            for(int t=i;t<j;t+=k-1)
            {
                res=min(res,dfs(i,t,1)+dfs(t+1,j,p-1));
            }
            m[i][j][p]=res;
            return res;
        };
        return dfs(0,n-1,1);
    }
};
```