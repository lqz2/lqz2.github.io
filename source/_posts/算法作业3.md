---
title: 算法作业3
date: 2023-11-15 17:07:49
categories: 机试
math:
tags:
---
<!-- TOC -->

- [书籍归档](#书籍归档)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)
- [停车场管理员](#停车场管理员)
    - [题目描述](#题目描述-1)
    - [思路](#思路-1)
    - [代码](#代码-1)
- [服务器配对](#服务器配对)
    - [题目描述](#题目描述-2)
    - [思路](#思路-2)
    - [代码](#代码-2)
- [哈夫曼编码](#哈夫曼编码)
    - [题目描述](#题目描述-3)
    - [思路](#思路-3)
    - [代码](#代码-3)

<!-- /TOC -->

## 书籍归档

### 题目描述
你是一名图书馆管理员，负责归档书籍。你有一个书架，它能承载一定量的重量。给定一个整数数组 books，其中 books[i] 表示第 i 本书的重量。书架的承重限制为 5000 单位。返回你最多可以归档的书籍数量。
input:
```
900 950 800 1000 700 800
```
output:
```
5
```

### 思路
比较简单，排序然后统计一下...

### 代码
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int a;
    vector<int> v;
    while (scanf("%d", &a) != EOF)
        v.push_back(a);
    sort(v.begin(), v.end());
    int ans = 0;
    int w = 5000;

    for (int i = 0; i < v.size(); ++i)
    {
        if (w >= v[i])
        {
            w -= v[i];
            ++ans;
        }
        else
            break;
    }
    cout << ans << endl;
    return 0;
}
```

## 停车场管理员

### 题目描述
你是一家购物中心的停车场管理员，需要安排各辆车的停车时段。每辆车的停车时段可以用一个时间数组来表示，数组中包括车辆进入和离开的时间 ，你的任务是确定购物中心所需的最小停车位数量。

e.g.
```
输入：0,30 5,10 15,20
输出：2
```

### 思路
定义一个数组，用每个时间段对数组进行填充，统计数组的最大值即可，注意填充是要左闭右开。

### 代码
```
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> PII;
int d[100];
int main()
{
    vector<PII> v;
    string s;
    int a, b;
    char c;
    getline(cin, s);
    stringstream ss(s);
    while (ss >> a >> c >> b)
        v.push_back({a, b});

    int ans = 0;
    for (PII p : v)
    {
        for (int i = p.first; i < p.second; ++i)
        {
            ++d[i];
            ans = max(ans, d[i]);
        }
    }
    cout << ans << endl;
    return 0;
}

```
## 服务器配对
### 题目描述
在一个大型的数据中心，服务器是成对安置的，以便进行数据镜像和冗余备份。每对服务器由一对连续的整数表示，如第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。由于配置错误，服务器的配对顺序被打乱了。现在，需要通过网络中的虚拟交换，重新配置服务器，使得每对服务器可以重新成对工作。虚拟交换可以在任意两台服务器之间进行，而不管它们的位置如何。返回最少交换次数，以便每对服务器可以重新配对工作。
e.g.
```
输入：1 3 4 0 2 5
输出：2
```
### 思路
用一个数组pos来记录每个元素的位置，然后遍历数组，对于每个元素a，和他配对的元素是a^1，如1配对0，2配对3，3配对2。遍历时只用遍历偶数下标i的元素，如果i+1元素无法配对，那么交换i+1位置的元素和配对元素，同时交换他们在pos数组中的位置。
### 代码
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int a;
    vector<int> v;
    while (cin >> a)
        v.push_back(a);
    int n = v.size();
    vector<int> pos(n);
    int ans = 0;
    for (int i = 0; i < n; ++i)
        pos[v[i]] = i;
    for (int i = 0; i < n; i += 2)
    {
        int match = v[i] ^ 1;
        if (v[i + 1] != match)
        {
            ++ans;
            swap(v[i + 1], v[pos[match]]);
            swap(pos[v[i + 1]], pos[v[pos[match]]]);
        }
    }
    cout << ans << endl;
    return ans;
}
```
## 哈夫曼编码

### 题目描述
请以霍夫曼编码方式压缩《傲慢与偏见》，为了将编码文本写入文件（以"wb"二进制模式写入文件）。
### 思路
用优先级队列模拟元素插入的过程，辅助建树，注意代码中文件读写的实现和建树过程。

### 代码
```
#include <bits/stdc++.h>
using namespace std;
struct Node
{
    char ch;
    int freq;
    Node *left, *right;
    Node(char c, int f, Node *l = nullptr, Node *r = nullptr) : ch(c), freq(f), left(l), right(r) {}
};

// 定义排序规则(小顶堆)
struct compare
{
    bool operator()(Node *l, Node *r)
    {
        return l->freq > r->freq;
    }
};

// 递归获取哈夫曼编码
void encode(Node *root, string str, map<char, string> &huffmanCode)
{
    if (root == nullptr)
        return;
    if (!root->left && !root->right)
        huffmanCode[root->ch] = str;
    encode(root->left, str + "0", huffmanCode);
    encode(root->right, str + "1", huffmanCode);
}

// 哈夫曼编码压缩，返回平均编码长度
double huffmanCompress(const string &filename)
{
    ifstream file(filename, ios::in);
    map<char, int> freq;
    char ch;
    long long cnt = 0;
    // 统计出现频率
    while (file.get(ch))
    {
        freq[ch]++;
        ++cnt;
    }

    priority_queue<Node *, vector<Node *>, compare> pq;
    // 初始化叶子节点
    for (auto it : freq)
        pq.push(new Node(it.first, it.second));
    // 构建哈夫曼树
    while (pq.size() != 1)
    {
        Node *left = pq.top();
        pq.pop();
        Node *right = pq.top();
        pq.pop();
        int sum = left->freq + right->freq;
        pq.push(new Node('\0', sum, left, right));
    }

    Node *root = pq.top();
    map<char, string> huffmanCode; // 保存每个字符对应的哈夫曼编码
    encode(root, "", huffmanCode);

    // 计算平均编码长度
    double avgLen = 0;
    for (auto it : huffmanCode)
        avgLen += it.second.size() * freq[it.first];
    avgLen /= cnt;

    file.clear();
    file.seekg(0);
    ofstream output("text.huff", ios::out | ios::binary);
    // 写入二进制文件
    char buffer = 0;
    int index = 0;
    while (file.get(ch))
    {
        for (char c : huffmanCode[ch])
        {
            if (c == '1')
                buffer |= (1 << (7 - index));
            index++;
            if (index == 8)
            {
                output << buffer;
                index = 0;
                buffer = 0;
            }
        }
    }

    file.close();
    output.close();
    return avgLen;
}
// 计算压缩比率
double getCompressRate(const string &filename)
{
    ifstream file(filename, ios::in);
    file.seekg(0, ios::end);
    double originSize = file.tellg(); // 返回文件字节数
    file.close();
    file.open("text.huff", ios::in);
    file.seekg(0, ios::end);
    double compressSize = file.tellg();
    file.close();
    return compressSize / originSize;
}

int main()
{
    cout << huffmanCompress("Pride and Prejudice.txt") << endl;
    cout << "Compress Rate: " << getCompressRate("Pride and Prejudice.txt") << endl;
    return 0;
}
```