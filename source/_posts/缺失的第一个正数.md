---
title: 缺失的第一个正数
date: 2024-12-21 09:21:48
categories:
math:
tags:
---
## 缺失的第一个正数

<!-- TOC -->

- [缺失的第一个正数](#缺失的第一个正数)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->

[原题](https://leetcode.cn/problems/first-missing-positive/description)


### 题目描述
给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
 
```
示例 1：

输入：nums = [1,2,0]
输出：3
解释：范围 [1,2] 中的数字都在数组中。
```
### 思路
这道题要找出不在数组中的最小正整数，对于一个数组(长度为n)，题目要求的数要么在`[1,n]`之间，要么是n+1。
所以可以对数组进行遍历，如果当前数`x`在`[1,n]`之间，那么将x所在位置进行标记，遍历结束后，如果`[1,n]`之间的数都被标记了，那么返回n+1，否则返回第一个没有被标记的数。

具体步骤如下：
- 将数组中的负数和0全部置为n+1
- 遍历数组，如果当前数`x`在`[1,n]`之间，那么将`nums[x-1]`进行取反，标记为负数，表示x已经出现过
- 再次遍历数组，找到第一个正数`nums[i]`，返回`i+1`，如果没有找到，返回`n+1`
### 代码
```
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n=nums.size();
        vector<int> v(n);
        for(int i=0;i<n;++i){
            if(nums[i]<=0){
                nums[i]=n+1;
            }
        }
        for(int i=0;i<n;++i){
            int t=abs(nums[i]);
            if(t<=n){
                nums[t-1]=-abs(nums[t-1]);
            }
        }
        for(int i=0;i<n;++i){
            if(nums[i]>0)
                return i+1;
        }
        return n+1;
    }
};
```