---
title: 添加硬币的最小数量
date: 2023-12-03 19:21:46
categories: 机试
math:
tags:
---
<!-- TOC -->

- [添加硬币的最小数量](#添加硬币的最小数量)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)
- [统计完全子字符串](#统计完全子字符串)
    - [题目描述](#题目描述-1)
    - [思路](#思路-1)
    - [代码](#代码-1)

<!-- /TOC -->
## 添加硬币的最小数量
[原题](https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/)
### 题目描述
给你一个下标从 0 开始的整数数组 coins，表示可用的硬币的面值，以及一个整数 target 。

如果存在某个 coins 的子序列总和为 x，那么整数 x 就是一个 可取得的金额 。

返回需要添加到数组中的 任意面值 硬币的 最小数量 ，使范围 [1, target] 内的每个整数都属于 可取得的金额 。

数组的 子序列 是通过删除原始数组的一些（可能不删除）元素而形成的新的 非空 数组，删除过程不会改变剩余元素的相对位置。

e.g.
```
输入：coins = [1,4,10,5,7,19], target = 19
输出：1
解释：只需要添加一枚面值为 2 的硬币，得到硬币数组 [1,2,4,5,7,10,19] 。
可以证明从 1 到 19 的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为 1 。
```
### 思路
周赛的第二题，自己没想到，靠gpt给了思路(~~tcl:cry:~~)

首先对所有coins升序排序，设当前可取得的最大值是maxnum(初始为0)。接下来遍历coins，下一个要取得的值应为maxnum+1，如果当前coin>maxnum+1，说明需要添加新的硬币，且新硬币的面值应当为maxnum+1，而maxnum也要更新：maxnum+=maxnum+1（原本已有硬币可以取得0~maxnum之间任意值，加入面值为maxnum+1的硬币后，上界也应当扩大maxnum+1），直到当前coin <= maxnum+1，此时说明不算当前coin已有硬币最大可以取到maxnum+1，那么算上coin后，maxnum更新为maxnum+=maxnum+coin。每次更新maxnum时都应检查maxnum>=target，如果满足那么直接返回加入的硬币数量，如果遍历完coins，maxnum依然小于target，那么继续maxnum+=maxnum+1，++ans。
### 代码
```
class Solution {
public:
    int minimumAddedCoins(vector<int>& coins, int target) {
        sort(coins.begin(), coins.end());
        int add = 0, max_num = 0;
        for (int c : coins)
        {
            while (c > max_num + 1)
            {
                ++add;
                max_num += max_num + 1;
                if (max_num >= target)
                    return add;
            }
            max_num += c;
            if (max_num >= target)
                return add;
        }
        while (max_num < target)
        {
            ++add;
            max_num += max_num + 1;
        }
        return add;
    }
};
```
## 统计完全子字符串
[原题](https://leetcode.cn/problems/count-complete-substrings/)
### 题目描述
给你一个字符串 word 和一个整数 k 。

如果 word 的一个子字符串 s 满足以下条件，我们称它是 完全字符串：

s 中每个字符 恰好 出现 k 次。
相邻字符在字母表中的顺序 至多 相差 2 。也就是说，s 中两个相邻字符 c1 和 c2 ，它们在字母表中的位置相差 至多 为 2 。
请你返回 word 中 完全 子字符串的数目。

子字符串 指的是一个字符串中一段连续 非空 的字符序列。

e.g.
```
输入：word = "igigee", k = 2
输出：3
解释：完全子字符串需要满足每个字符恰好出现 2 次，且相邻字符相差至多为 2 ：igigee, igigee, igigee 。
```
### 思路
周赛第三题，主要思路是分组加滑动窗口。

要求相邻字符差不大于2，那么当两个字符间大于2时，就可以在中间进行分割，这样将原始字符串划分成许多段，段内进行处理。

对于每一段，需要统计满足k次要求的子串个数，可以固定滑动窗口的大小为m*k，m是子串中字符种类，然后维护一个cnt数组记录每个字符出现次数，遍历所有滑窗，统计出滑窗内每个字符都出现k次的子串个数。

这道题时间复杂度要求比较高，检查函数定义在外部就超时了。。。
### 代码
```
class Solution {
public:
    int sub(string s,int k)
    {
        int res=0;
        int n=s.size();
        for(int m=1;m<=26 && m*k<=n;++m)
        {
            vector<int> cnt(26);
            function<bool()> check=[&]()
            {
                for(int i=0;i<26;++i)
                {
                    if(cnt[i]&&cnt[i]!=k)
                        return false;
                }
                return true;
            };
            for(int r=0;r<n;++r)
            {
                ++cnt[s[r]-'a'];
                int l=r-m*k+1;
                if(l>=0)
                {
                    if(check()) ++res;
                    --cnt[s[l]-'a'];
                }
            }
        }
        return res;
    }
    int countCompleteSubstrings(string word, int k) {
        int n=word.size();
        int pre_pos=0;
        int ans=0;
        for(int i=1;i<n;++i)
        {
            if(abs(word[i]-word[i-1])>2)
            {
                ans+=sub(word.substr(pre_pos,i-pre_pos),k);
                pre_pos=i;
            }
        }
        ans+=sub(word.substr(pre_pos,n-pre_pos),k);
        return ans;
    }
};
```