---
title: 二分图匹配
date: 2023-12-15 16:37:47
categories: 机试
math: true
tags:
---
## 二分图匹配
[原题]()

### 题目描述

给定一个二分图，其左部点的个数为 $n$，右部点的个数为 $m$，边数为 $e$，求其最大匹配的边数。

左部点从 $1$ 至 $n$ 编号，右部点从 $1$ 至 $m$ 编号。

#### 输入格式

输入的第一行是三个整数，分别代表 $n$，$m$ 和 $e$。

接下来 $e$ 行，每行两个整数 $u, v$，表示存在一条连接左部点 $u$ 和右部点 $v$ 的边。

#### 输出格式

输出一行一个整数，代表二分图最大匹配的边数。

#### 样例输入 #1

```
1 1 1
1 1
```

#### 样例输出 #1

```
1
```

#### 样例输入 #2

```
4 2 7
3 1
1 2
3 2
1 1
4 2
4 1
1 1
```

#### 样例输出 #2

```
2
```
#### 数据规模与约定

对于全部的测试点，保证：
- $1 \leq n, m \leq 500$。
- $1 \leq e \leq 5 \times 10^4$。
- $1 \leq u \leq n$，$1 \leq v \leq m$。
### 思路
主要用到匈牙利算法的思路，每次通过dfs尝试为左部分的点找一个匹配对象，找到则返回true，++ans。在二分图匹配中，匈牙利算法的主要思想是：
- 如果u要匹配的目标v还没有cp，那么直接匹配即match[v]=u
- 如果u发现v已经匹配了，则match[v]能找到新的就把v让给u(match[v]=u)，找不到就不让。
- 如果以前的不让步，u就去寻找下一个匹配。
- 如果u谁也匹配不上了，那就匹配失败，返回false。

dfs过程中，为了防止访问过的点循环访问，用一个数组vistime[]来记录访问状态，tag表示轮次，vistime[u]=tag，表示u节点在第tag轮已经被访问，已被访问的状态下直接返回false即可。

### 代码
```
#include <bits/stdc++.h>
using namespace std;
const int N = 1000;
vector<vector<int>> g(N);
vector<int> vistime(N), match(N);
int main()
{
    int n, m, e;
    cin >> n >> m >> e;
    int u, v;
    while (e--)
    {
        cin >> u >> v;
        g[u].push_back(v);
    }
    function<bool(int, int)> dfs = [&](int u, int tag)
    {
        if (vistime[u] == tag)
            return false;
        vistime[u] = tag;
        for (int v : g[u])
        {
            if (match[v] == 0 || dfs(match[v], tag))
            {
                match[v] = u;
                return true;
            }
        }
        return false;
    };
    int ans = 0;
    for (int i = 1; i <= n; ++i)
    {
        if (dfs(i, i))
            ++ans;
    }
    cout << ans << endl;
    return 0;
}
```
