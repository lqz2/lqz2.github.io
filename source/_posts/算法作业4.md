---
title: 算法作业4
date: 2023-12-11 17:23:39
categories: 机试
math:
tags:
---
<!-- TOC -->

- [猜疑链](#猜疑链)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)
- [农场灌溉](#农场灌溉)
    - [题目描述](#题目描述-1)
    - [思路](#思路-1)
    - [代码](#代码-1)
- [社交网络连接](#社交网络连接)
    - [题目描述](#题目描述-2)
    - [思路](#思路-2)
    - [代码](#代码-2)
- [物流规划师](#物流规划师)
    - [题目描述](#题目描述-3)
    - [思路](#思路-3)
    - [代码](#代码-3)

<!-- /TOC -->

## 猜疑链

### 题目描述
假设有n个文明，每个文明都有一个编号，从1到n。有一种传言，称这些文明中有一个掌握了强大的毁灭力量，被称为“黑暗森林之王”。

按照黑暗森林法则：

黑暗森林之王不相信任何其他文明。

每个文明（除了黑暗森林之王）都信任黑暗森林之王。

只有一个文明同时满足属性1和属性2。

如果黑暗森林之王存在并且可以确定其身份，请返回该黑暗森林之王的编号；否则，返回-1。


input:
```
1->3,2->3
```
output:
```
3
```

### 思路
统计每个节点的入度和出度，满足入度为n-1，出度为0的点就是黑暗之王

### 代码
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
    string s;
    cin >> s;
    stringstream ss(s);
    string t;
    vector<int> in(100);
    vector<int> out(100);
    int a, b, mx = 0;
    int ans = -1;
    while (getline(ss, t, ','))
    {
        int idx = t.find_first_of('-');
        a = stoi(t.substr(0, idx));
        b = stoi(t.substr(idx + 2, t.size() - idx - 2));
        mx = max(mx, max(a, b));
        in[b]++;
        out[a]++;
    }
    for (int i = 1; i <= mx; ++i)
    {
        if (out[i] == 0 && in[i] == mx - 1)
        {
            ans = i;
            break;
        }
    }
    cout << ans;
    return 0;
}
```

## 农场灌溉

### 题目描述
题目描述：在一个包含n个节点的农场中，节点之间通过水渠相连。给定一个整数n和一个数组pipes，其中pipes[i] = [ai, bi]表示农场中ai和bi之间有一条水渠。请返回农场中已连接水渠的数目。

e.g.
```
输入：0<->1,1<->2,3<->4

输出：2
```

### 思路
深度优先搜索(dfs)，标记访问过的节点，统计连通子图数量。

### 代码
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
    string s;
    cin >> s;
    stringstream ss(s);
    string t;
    vector<vector<int>> g(100);
    vector<int> vis(100);
    int a, b, mx = 0;
    int ans = 0;
    while (getline(ss, t, ','))
    {
        int idx = t.find_first_of('-');
        a = stoi(t.substr(0, idx - 1));
        b = stoi(t.substr(idx + 2, t.size() - idx));
        mx = max(mx, max(a, b));
        g[a].push_back(b);
        g[b].push_back(a);
    }
    function<void(int, int)> dfs = [&](int x, int p)
    {
        vis[x] = 1;
        for (int i : g[x])
        {
            if (i == p)
                continue;
            if (vis[i] == 0)
                dfs(i, x);
        }
    };
    for (int i = 0; i <= mx; ++i)
    {
        if (vis[i] == 0)
        {
            dfs(i, -1);
            ans++;
        }
    }
    cout << ans;
    return 0;
}

```
## 社交网络连接
### 题目描述
假设你是一位社交网络平台的技术总监，有 n 个用户在你的平台上注册。给定用户之间建立连接的成本，以及每个用户的编号，你的任务是设计算法找到以最低成本连接所有用户的方法。连接是双向的，每对用户之间至少有一条路径。如果无法连接所有用户，返回 -1。最小成本应该是所用全部连接成本的总和。
```
输入：1<->2 5,1<->3 6,2<->3 1

输出：6
```
### 思路
求解最小生成树，使用并查集，主要是定义find函数：
```
function<int(int)> find = [&](int x)
{
    return fa[x] == x ? x : fa[x] = find(fa[x]);
};
```
然后排序，不断加边，最后统计一下连通子图的个数，判断是否连通。
### 代码
```
#include <bits/stdc++.h>
using namespace std;
struct e
{
    int u, v, w;
    e(int u, int v, int w) : u(u), v(v), w(w) {}
    bool operator<(const e &o) const
    {
        return w < o.w;
    }
};
int main()
{
    string s;
    getline(cin, s);
    stringstream ss(s);
    string t;
    vector<e> edge;
    int a, b, c, mx = 0;
    int ans = 0;
    while (getline(ss, t, ','))
    {
        int idx1 = t.find_first_of('-');
        int idx2 = t.find_first_of(' ');
        a = stoi(t.substr(0, idx1 - 1));
        b = stoi(t.substr(idx1 + 2, idx2 - idx1 - 2));
        c = stoi(t.substr(idx2 + 1, t.size() - idx2 - 1));
        mx = max(mx, max(a, b));
        edge.emplace_back(e(a, b, c));
    }
    vector<int> fa(mx + 1);
    iota(fa.begin(), fa.end(), 0);
    function<int(int)> find = [&](int x)
    {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    };
    sort(edge.begin(), edge.end());
    int cnt = 0;
    for (e &t : edge)
    {
        int x = find(t.u), y = find(t.v);
        if (x != y)
        {
            fa[x] = y;
            ans += t.w;
            ++cnt;
        }
        if (cnt == mx - 1)
            break;
    }
    cnt = 0;
    for (int i = 1; i <= mx; ++i)
    {
        if (fa[i] == i)
            ++cnt;
    }
    if (cnt > 1)
        cout << -1;
    else
        cout << ans;
    return 0;
}
```
## 物流规划师

### 题目描述
假设你是一家货运公司的物流规划师，有 n 个城市作为货物的发货和收货点。给定城市之间的运输路径和每条路径的成功运输概率，以及每个城市的编号，你的任务是设计算法找到从发货城市到收货城市成功运输概率最大的路径。给定一个由 n 个城市和它们之间的运输路径组成的图，以及每条路径的成功运输概率。指定两个城市分别作为货物的发货点和收货点，你需要找到从发货城市到收货城市成功运输概率最大的路径，并返回该概率。如果不存在从发货城市到收货城市的路径，请返回 0。

起点为0，数字最大为终点。

e.g.
```
输入：0<->1 0.5,1<->2 0.5,0<->2 0.2

输出：0.25000(保留5位小数，其余直接舍掉)

解释：从起点0到终点2有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25
```
### 思路
单源最短路，使用最朴素的dijkstra，求最长路径即可。

### 代码
```
#include <bits/stdc++.h>
using namespace std;
double mp[100][100];
double dis[100];
bool vis[100];
int main()
{
    string s;
    getline(cin, s);
    stringstream ss(s);
    string t;
    int a, b, mx = 0;
    double c;
    while (getline(ss, t, ','))
    {
        int idx1 = t.find_first_of('-');
        int idx2 = t.find_first_of(' ');
        a = stoi(t.substr(0, idx1 - 1));
        b = stoi(t.substr(idx1 + 2, idx2 - idx1 - 2));
        c = stod(t.substr(idx2 + 1, t.size() - idx2 - 1));
        mx = max(mx, max(a, b));
        mp[a][b] = c;
        mp[b][a] = c;
    }
    memset(dis, -0x3f, sizeof(dis));
    dis[0] = 1.0;
    for (int i = 0; i <= mx; ++i)
    {
        int t = -1;
        for (int j = 0; j <= mx; ++j)
        {
            if (!vis[j] && (t == -1 || dis[j] > dis[t]))
                t = j;
        }
        vis[t] = true;
        for (int j = 0; j <= mx; ++j)
        {
            dis[j] = max(dis[j], dis[t] * mp[t][j]);
        }
    }
    printf("%.5lf", dis[mx]);
    return 0;
}
```