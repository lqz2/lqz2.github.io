---
title: 规划兼职工作
date: 2022-10-22 14:39:01
categories: 机试
math:
tags:
---
<!-- TOC -->

- [规划兼职工作](#规划兼职工作)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 规划兼职工作

### 题目描述
你打算利用空闲时间兼职来赚些零花钱

现在有若`n`条兼职信息，一条兼职信息包含`a,b,c`3个数据

`a`表示该兼职的开始时间
`b`表示该兼职的终止时间
`c`表示该兼职的收入

你在一个时间段内只能有1份兼职，也就是说上一份兼职的终止时间要满足小于等于下一份兼职的开始时间

请你算出你能获得的最大收入

输入第一行`n`，表示兼职个数
下面`n`行，每行3个数，表示`a,b,c`

input:
```
5
1 3 20
2 5 20
3 10 100
4 6 70
6 9 60
```

output:
```
150
```
### 思路

这道题可以用动态规划解决，先将所有兼职按照终止时间升序排序，`dp[i]`表示到第`i`份能获得的最大收益

* 当不选择第`i`份兼职，`dp[i]=dp[i-1]`
* 当选择第`i`份兼职，`dp[i]=dp[k]+profit[i]`，`k`是满足终止时间小于等于第`i`份兼职开始时间的第`k`份兼职

状态方程：`dp[i]=max(dp[i-1],dp[k]+profit[i])`;

关于`k`的确定，很多人是通过二分查找来确定`k`的，但我自己写的二分查找总是没法ac，所以就没用(tcl:cry::cry::cry:)
### 代码
```
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+1;
struct e
{
    int a,b,c;
    bool operator < (const e& t) const
    {
        return b<t.b;
    } 
}e[N];
int dp[N]; 
int main()
{
	int n;
	cin>>n;
	int k;
	for(int i=1;i<=n;++i)
	{
		cin>>e[i].a>>e[i].b>>e[i].c;
	}
	sort(e+1,e+n);
	for(int i=1;i<=n;++i)
	{
		k=i;
		while(e[k].b>e[i].a)
			--k;
		dp[i]=max(dp[i-1],dp[k]+e[i].c);
	}
	cout<<dp[n]<<endl;
	return 0;
}
```