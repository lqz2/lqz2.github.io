---
title: 最长达标子串
date: 2022-09-17 07:52:03
categories: 机试
math:
tags:
---

<!-- TOC -->

- [最长达标子串](#最长达标子串)
- [位操作练习](#位操作练习)

<!-- /TOC -->
### 最长达标子串

**题目描述**

给定一个字符串`s`，其中都是英文小写字母，如果`s`的子串中含有的每种字符都是偶数个，那么这样的子串就是达标子串，输出达标子串的最大长度。

input:
```
aababcdcdc
```
output:
```
8
```
**思路**

用一个数组记录当前的状态，`1`表示当前字母出现了奇数次，`0`表示当前字母出现了偶数次

例如：如果`s`一共有四个字母`abcd`，子串`a`的状态可记为`1000`，子串`aab`记为`0100`
,子串`abacd`记为`0111`

可以得出这样的结论：如果`i`处的状态与`i+k`处的状态相同，则`i~i+k`之间的子串中的每个字母都出现了偶数次

原理就是出现偶数次，不会改变某个字母的状态

所以，只需要记录每个状态序列最早出现的位置，然后当他再次出现时，最晚出现的位置减去最早出现的位置就是最长的达标子串。

**代码**
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
	string s;
	cin>>s;
	int len=s.size();
	unordered_map<int,int> mp;
	int status=0;
	int ans=0;
	mp[0]=-1;//初始化-1位置为0...00 32个0
	for(int i=0;i<len;++i)
	{
		//假设当前s[i]是'c',那么将1左移2位，然后和status异或
		//即可改变'c'处的状态 
		status=status^1<<s[i]-'a';
		if(mp.count(status))
			ans=max(ans,i-mp[status]);
		else
			mp[status]=i; 
	}
	cout<<ans<<endl; 
	return 0;
}
```

### 位操作练习

**题目描述**

给出两个不大于65535的非负整数，判断其中一个的16位二进制表示形式，是否能由另一个的16位二进制表示形式经过循环左移若干位而得到。 循环左移和普通左移的区别在于：最左边的那一位经过循环左移一位后就会被移到最右边去。比如： 1011 0000 0000 0001 经过循环左移一位后，变成 0110 0000 0000 0011, 若是循环左移2位，则变成 1100 0000 0000 0110

输入两个不大于65535的非负整数

如果能通过循环左移相等，输出`YES`,否则输出`NO`

input:
```
45057 49158
```
output:
```
YES
```

这个就不说了，直接看代码就行了

**代码**
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
	unsigned short a,b;
	cin>>a>>b;
	for(int i=0;i<16;++i)
	{
		if(a==b)
		{
			cout<<"YES"<<endl;
			break;
		}
		if(i==15)
			cout<<"NO"<<endl;
		a=a<<1 | a>>15&1;
	}
	return 0;
}
```

