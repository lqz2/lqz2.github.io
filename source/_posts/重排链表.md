---
title: 重排链表
date: 2022-08-25 10:56:56
categories: 机试
tags:
---
<!-- TOC -->

- [重排链表](#重排链表)
- [反转链表](#反转链表)
- [合并链表](#合并链表)
- [题解](#题解)

<!-- /TOC -->
### 重排链表

>来源于leetcode上的一道题 [重排链表](https://leetcode.cn/problems/reorder-list/)，因为这到题涉及到许多链表的知识，正好拿来复习一下

题目描述

给定一个单链表 L 的头节点 head ，单链表 L 表示为：
```L0 → L1 → … → Ln - 1 → Ln```

请将其重新排列后变为：

`L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …`

### 思路

* 先找到链表的中点
* 将链表后半段反转
* 将前后两端重新合并

### 找到链表中点（快慢指针）
>设置两个指针，其中快的指针每次移动2次，慢指针移动一次，当快指针到达尾部，慢指针的位置就是中点

代码：
```
ListNode* middleNode(ListNode* head) {
        ListNode *low=head;
        ListNode *fast=head;
        //如果有偶数个节点，以下条件找到的是右侧中点
        //如果要找左侧中点，改为：fast->next!=NULL&&fast->next->next!=NULL即可
        while(fast!=NULL&&fast->next!=NULL)
        {
            low=low->next;
            fast=fast->next->next;
        }
        return low;
    }
 ```

### 反转链表
>其实反转链表可以用线性表做，时间复杂度差不多，但这里还是回归链表操作

代码：
```
ListNode* reverseList(ListNode* head) {
        ListNode* pre=NULL;
        ListNode* l=head;
        while(l!=NULL)
        {
            ListNode* tmp=l->next;
            l->next=pre;
            pre=l;
            l=tmp;
        }
        return pre;
    }
```

### 合并链表

>将l1和l2交错合并

代码：
```
    void merge(ListNode* l1,ListNode* l2)
    {
        while(l1!=NULL&&l2!=NULL)
        {
            ListNode* l1t=l1->next;
            ListNode* l2t=l2->next;
            l1->next=l2;
            l1=l1t;
            l2->next=l1;
            l2=l2t;
        }
    }
```
### 题解
```
    void reorderList(ListNode* head) {
        ListNode* mid=middleNode(head);
        ListNode* l1=head;
        ListNode* l2=mid->next;
        mid->next=NULL;
        ListNode* r=reverseList(l2);
        merge(l1,r);
    }
    ListNode* reverseList(ListNode* head) {
        ListNode* pre=NULL;
        ListNode* l=head;
        while(l!=NULL)
        {
            ListNode* tmp=l->next;
            l->next=pre;
            pre=l;
            l=tmp;
        }
        return pre;
    }
    ListNode* middleNode(ListNode* head) {
        ListNode *low=head;
        ListNode *fast=head;
        while(fast->next!=NULL&&fast->next->next!=NULL)
        {
            low=low->next;
            fast=fast->next->next;
        }
        return low;
    }
    void merge(ListNode* l1,ListNode* l2)
    {
        
        while(l1!=NULL&&l2!=NULL)
        {
            ListNode* l1t=l1->next;
            ListNode* l2t=l2->next;
            l1->next=l2;
            l1=l1t;
            l2->next=l1;
            l2=l2t;
        }
    }
```
