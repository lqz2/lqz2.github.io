---
title: 无矛盾的最佳球队
date: 2023-03-22 08:07:24
categories: 机试
math:
tags:
---
<!-- TOC -->

- [无矛盾的最佳球队](#无矛盾的最佳球队)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 无矛盾的最佳球队
[原题](https://leetcode.cn/problems/best-team-with-no-conflicts/description/)
### 题目描述
假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 总和 。

然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 没有矛盾 的球队。如果一名年龄较小球员的分数 严格大于 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。

给你两个列表 scores 和 ages，其中每组 scores[i] 和 ages[i] 表示第 i 名球员的分数和年龄。请你返回 所有可能的无矛盾球队中得分最高那支的分数 。

e.g.
```
输入：scores = [1,3,5,10,15], ages = [1,2,3,4,5]
输出：34
解释：你可以选中所有球员。
```
### 思路
首先对所有人按照分数升序排序，`dp[i]`表示选择到第`i`名球员时的最大分数，对于球员`i`,需要找到`j`满足`j`的年龄小于`i`且`j<i`，并且`dp[j]`是所有`i`之前且年龄小于`i`的球员的最大分数，因此`dp[i]=dp[j]+score[i]`，然后更新答案即可。
### 代码
```
class Solution {
public:
    int bestTeamScore(vector<int>& scores, vector<int>& ages) {
        int n=scores.size();
        vector<pair<int,int>> v;
        for(int i=0;i<n;++i)
            v.push_back({scores[i],ages[i]});
        sort(v.begin(),v.end());
        int ans=0;
        vector<int> dp(n);
        for(int i=0;i<n;++i)
        {
            for(int j=i-1;j>=0;--j)
                if(v[j].second<=v[i].second)
                dp[i]=max(dp[i],dp[j]);
            
            dp[i]+=v[i].first;
            ans=max(ans,dp[i]);
        }
        return ans;
    }
};
```