---
title: 暑期整理
date: 2025-07-05 20:02:46
categories: 学习
math:
tags:
hide: true
---

<!-- TOC -->

- [分布式模型评测平台](#分布式模型评测平台)
    - [简介](#简介)
    - [主要功能](#主要功能)
    - [关键模块](#关键模块)
        - [调度方式](#调度方式)
            - [旧版调度方式](#旧版调度方式)
            - [新版调度方式](#新版调度方式)
        - [zookeeper的使用](#zookeeper的使用)
            - [基本信息](#基本信息)
            - [工作流程](#工作流程)
        - [任务状态流转](#任务状态流转)
        - [redis的使用](#redis的使用)

<!-- /TOC -->
# 分布式模型评测平台

## 简介
该平台主要用于将业务数据批量上传给大模型，通过大模型的能力完成判断是否存在违规行为、责任划分等业务内容，同时还可以根据大模型的返回结果，制定相应的评测规则，对大模型的判断结果进行打分，评价大模型的业务能力，平台的主要功能包括数据导入、任务创建、模型评测、工作流评测、自定义评测规则、结果导出等，可服务于企业内部多种业务需求。

## 主要功能
TODO:

## 关键模块
### 调度方式
#### 旧版调度方式
旧版调度模式下，主要的工作流程如下：
1. 新建评测任务
2. 定时任务扫描到新建的任务，然后开始处理
3. 处理每个任务时，首先可以从在线数据源中或者本地上传的评测集中获取数据，通过获取的数据构建众多tasks,然后将这些task写入到数据库中
4. 接下来，从模型的维度将task的id通过lpush添加到redis队列，其中redis的key是通过`modelName+index`设置的，index是模型对应的队列
5. 在应用启动时，会给模型评测的Diamond配置增加一个监听器，监听对应配置变更，当配置变化时，会给配置里的每个模型启动2个工作线程，提交到线程池，具体来说，实际上是一个模型对应2个redis队列，然后通过2个工作线程，分别从对应redis队列取出task来处理，也就是一个线程处理一个redis队列的tasks
6. 工作线程取出task后，先尝试获取锁，这里获取锁是主要通过一个lua脚本限流，因为大模型的api通常是有调用频率限制的，这里评测的数据可能很多，调用时需要限流。获取到锁之后，向对应模型发送请求，并获取请求结果，如果请求失败则进行3～5次的重试，请求成功后，将task结果更新到数据库中。

**存在的问题**：
旧版的调度方式下，一个模型默认分配两个队列，并且由两个工作线程处理，如果多个用户同时创建任务，可能会导致某个模型的队列排队的task过多，导致一些用户的任务长时间得不到处理。

#### 新版调度方式
新版调度方式与旧版调度方式相比，主要的区别在于：
- 新版的调度方式中，redis队列的key是`modelName+AK`，并且通过zookeeper对资源节点进行监听
- 每个`modelName+AK`都会对应一个zk资源节点，也对应一个存放task的redis队列，zk会根据资源节点创建对应的线程并提交，默认一个资源节点对应2个线程。
- 运行时，通过一个定时任务来判断redis队列是否为空，如果一段时间内redis队列为空，则删除对应的zk资源节点，释放资源，同时zk监听到资源节点被删除后，会自动关闭对应的线程。

### zookeeper的使用
在新的调度方式中，zookeeper主要用于管理模型的资源节点并实时创建和释放工作线程。实际使用中，主要通过使用CuratorFramework实现一些zk客户端的操作，包括创建节点、删除节点、监听节点变化等。


#### 基本信息
主要角色包括：master和slave

**master的职责：**
- 初始化leader信息：即在`leader_info/{master_host}`路径下创建一个临时节点，将leader的更新时间等信息写入到这个节点
- 设置分片信息：在`sharding_info_path`路径下创建一个临时节点，设置当前分片信息，实际上一个机器就是一个分片id，并对应当前机器的host
- 设置执行节点信息：这是实现资源动态调度的关键之一，这里拉取`node_info_path`下所有子节点的名称，然后拉取`election_assets`下所有子节点的名称（所有申请的`model+ak`资源），然后为每个节点的执行节点写入所有assets信息，执行节点路径为`node_executor_info_path/{node_host}`。
- 更新zk的选举状态：更新`election_status_path`节点的选举状态
- 更新自身选举状态：finish or not
- 关闭slave的监听器：因为master可能是由slave转过来的，所以需要关闭之前slave的监听器，如果有的话
- 更新集群稳定信息：在`leader_info/{host}`路径下更新集群稳定的时间
- 通过守护线程，同步集群节点信息、同步集群心跳检测信息、同步集群执行节点信息、监测集群稳定状态等


**salve职责：**
- 监听切片信息：添加一个监听器，主要从`sharding_info_path`路径下获取切片信息，获取到切片信息后，更新自身的切片信息，切片信息是一个ConcurrentSkipListMap，保证并发安全、有序性和`logn`的查询性能，key是切片id，value是切片对应的host
>监听步骤：
>1. 创建客户端的NodeCache对象cache，指定客户端和监听的路径
>2. 创建NodeCacheListener对象listener，重写其`nodeChanged`方法，定义监听到节点变化时的处理逻辑
>3. `cache.getListenable().addListener(listener)`将监听器添加
>4. `cache.start()`启动监听器
- 监听选举状态：添加一个监听器，主要从`election_status_path`路径下获取选举状态，获取到选举状态后，更新自身的选举状态


**守护线程基础知识：**
守护线程（Daemon Thread），也叫后台线程，是Java中的一种特殊线程。它在后台为其他非守护线程（即用户线程）提供通用服务，但它本身不属于程序中不可或缺的部分

守护线程与普通线程的核心区别是：当JVM中不存在任何一个正在运行的**非守护线程**时，JVM进程就会退出。
也就是说，只要还有任何一个非守护线程在运行，程序就不会终止。而当所有非守护线程都执行完毕后，JVM会强制终止所有仍在运行的守护线程，然后退出。守护线程拥有自动结束自己生命周期的特性，而非守护线程不具备。

一个非常典型的例子就是JVM的垃圾回收（GC）线程。GC线程就是一个守护线程，它在后台默默回收内存。如果GC线程是普通线程，那么即使我们的主业务逻辑（main线程等）已经全部执行完毕，只要GC线程还在运行，JVM就永远无法退出，这显然是不合理的。

总结一下就是：非守护线程结束后，jvm就会退出，jvm退出时，会终止所有守护线程

#### 工作流程
SpringBoot应用启动时，主要通过client服务执行每个节点的一系列流程：

1. 创建CuratorFramework客户端
2. 当前节点信息写入：在`node_info_path/{node_host}`路径下创建一个临时节点
3. 创建执行节点：在`node_executor_info_path/{node_host}`路径下创建一个执行节点，并启动监听器，这是动态调度的关键。该监听器监听到节点变化时，会执行以下操作：
    - 拉取当前执行节点`node_executor_info_path/{node_host}`下的所有资源名称，然后和旧的资源名称进行对比，找出新增的资源和删除的资源
    - 对于新增的资源，每个资源创建两个线程，提交到线程池
    - 对于删除的资源，关闭对应的线程，并从map中移除资源
4. leader选举：通过LeaderLatch的start启动自动选主，并监听当前客户端的选主状态，如果当前客户端是leader,则执行一系列操作，包括关闭之前的slave监听器、更新选举状态、设置分片信息、设置leader信息、启动守护线程任务等，如果已经不再是leader了，则更新选举状态并关闭守护线程任务，并执行作为slave的监听器。
5. 启动心跳检测：当前客户端每30s更新一下心跳信息，并打印日志
6. 监听node_info_path路径下的节点变化：添加一个监听器，监听子节点发生增删改时，执行以下操作：
    - 如过当前节点是leader, 执行更新分片信息、更新选举状态、更新执行节点信息等操作
    - 如果发生了重连，leader和slave都重新写入节点信息
7. 监听election_assets路径下的节点变化：添加一个监听器，监听子节点资源发生增删的情况，由master节点重新写入执行节点信息

### 任务状态流转
评测任务的状态流传主要是通过不同的定时任务实现的，不同的定时任务实现schedulerx的JavaProcessor接口，并重写process方法，来执行对应的处理逻辑，整体状态的流转如下：

- 评测任务创建，状态转为waiting,待执行状态
- 定时任务扫描待执行状态的评测任务，取最早的一个评测任务开始执行，执行时将评测任务对应的数据转为task导入到数据库，然后插入redis队列，完成后状态转为执行中，此时对应worker开始从redis队列取task并执行，如果有上游依赖任务，则将评测任务状态改为待重试。
- 定时任务扫描所有待重试状态的评测任务，执行时先查询该任务的上游依赖任务是否已经完成，如果完成可以执行导入数据库和redis队列的逻辑，如果上游任务未完成，且已经超过8小时都未完成，则将评测任务状态改为失败，否则继续等待上游任务完成。
- 当所有task都执行完成时，将评测任务状态改为待评分
- 定时任务扫描待评分状态的评测任务，取最早的一个评测任务开始执行，执行时将评测任务的每个task结果进行打分，打分规则由用户定义的js脚本决定，当所有task完成评分后，将评测任务状态改为待计算指标
- 定时任务扫描待计算指标的评测任务，取最早的一个评测任务开始执行，执行时统计所有task的准确率、完成率等指标，完成后将评测任务状态改为已完成
- 定时任务扫描所有已完成的任务，将所有task的结果导出到指定数据源中，将状态更改为导出完成

### redis的使用
在此项目中，redis主要有下面的用途：
- **存放模型评测任务的所有task：**用一个redis队列存放评测任务的task，队列的key是`modelName+AK`，通过lpush将task放入redis队列，每个机器会创建worker并通过rpop来从对应队列中取出task并消费
- **定时任务分布式锁：**因为有多个机器都要执行定时任务，为了确保同一时间只有一个机器在执行定时任务，所以使用redis的setnx命令来实现分布式锁，超时时间为10分钟，执行完定时任务后删除分布式锁。
- **作为评测任务查询的缓存：**因为每个task执行时，需要通过id查询评测任务信息，所以每次查询时，先从redis缓存中获取评测任务信息，如果没有则从数据库中查询，然后放入redis缓存中，设置过期时间为1小时，在更新时，先更新数据库，再删除redis缓存，降低数据不一致的风险。
- **更新任务执行进度：**因为每个评测任务对应很多task，为了及时更新task的执行进度，用redis的hash结构存储评测任务的进度信息，比如当前完成数量，成功数量，失败数量等等，key是评测任务的id, field是进度的名称，value是进度的值，使用hIncrement命令更新进度信息，当所有task都执行完后，通过hgetAll命令获取所有进度信息，更新评测任务的状态。
- **模型并发限流：**因为大模型的api通常有调用频率限制，所以在worker获取task时，通过lua脚本尝试获取锁，lua脚本中，主要将模型将当前worker线程的UUID和时间戳存在zset中，UUID作为member，时间戳作为score，每次获取锁时，先删除过期的member，然后判断当前member数量是否超过限制，如果超过限制则返回失败，否则添加当前member并返回成功，并发限制数可以通过diamond动态配置。









