---
title: 文本左右对齐
date: 2023-11-13 15:52:07
categories: 机试
math:
tags:
---
<!-- TOC -->

- [文本左右对齐](#文本左右对齐)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 文本左右对齐
[原题](https://leetcode.cn/problems/text-justification/description/?envType=study-plan-v2&envId=top-interview-150)
### 题目描述
给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。

你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ' ' 填充，使得每行恰好有 maxWidth 个字符。

要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。

文本的最后一行应为左对齐，且单词之间不插入额外的空格。

注意:

单词是指由非空格字符组成的字符序列。
每个单词的长度大于 0，小于等于 maxWidth。
输入单词数组 words 至少包含一个单词。

e.g.
```
输入: words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16
输出:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
```
### 思路
这道题不涉及什么算法，主要考察字符串处理能力。可以按行来处理，首先记录要加入每行的单词有哪些，可以遍历单词，累加遍历过的单词长度，如果加入下一个单词后总长度大于maxWidth，或者下一个单词是最后一个单词，那么就将现有区间的所有单词生成一行并返回。

对于空格，我们可以先统计每行总的空格数量spnum，然后计算每个字符串后跟的基本空格数`base_space=(wordnum==1)? spnum:spnum/(wordnum-1)`，还需额外的空格数为`extra_space=(wordnum==1)? 0:spnum%(wordnum-1);`，每个单词后面补的空格数为`string(base_space+((i-start)<extra_space),' ')`。在处理时要注意，如果是处理最后一行，则每个单词后面加一个空格就行，然后每行最后一个单词根据当前行的长度在后面补上对应数量的空格。
### 代码
```
class Solution {
public:
    string getline(vector<string>& words, int start,int end, int width,bool last)
    {
        int wordnum= end-start+1;
        int sum=0;
        for(int i=start;i<=end;++i)
            sum+=words[i].size();
        int spnum=width-sum;
        int base_space=(wordnum==1)? spnum:spnum/(wordnum-1);
        int extra_space=(wordnum==1)? 0:spnum%(wordnum-1);
        string res;
        for(int i=start;i<end;++i)
        {
            res+=words[i];
            if(last)
            {
                res+=' ';
                continue;
            }
            res+=string(base_space+((i-start)<extra_space),' ');
        }
        res+=words[end];
        res+=string(width-res.size(),' ');
        return res;
    }
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        int n=words.size();
        int sum=0;
        int start=0;
        vector<string> res;
        for(int i=0;i<n;++i)
        {
            sum+=words[i].size()+1;
            if(i+1==n||sum+words[i+1].size()>maxWidth)
            {
                res.push_back(getline(words,start,i,maxWidth,i+1==n));
                start=i+1;
                sum=0;
            }
        }
        return res;
    }      
};
```