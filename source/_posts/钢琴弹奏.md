---
title: 钢琴弹奏
date: 2025-03-28 09:59:19
categories: 机试
math:
tags:
---
## 钢琴弹奏

<!-- TOC -->

- [钢琴弹奏](#钢琴弹奏)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->

[原题](https://oj.niumacode.com/training/49/problem/P1466)


### 题目描述
游游有 26 个按键的琴，按下第一个按键可以奏出 a，第二个按键可以奏出 b ，…，第二十六个按键可以奏出z 。

现在给出了一个乐谱的演奏方式，由数字组成，包含[0,9] ，但由于不考虑空格致使游戏不允许输入的情况，例子如 s=12 ，表示先按下第一个按键，然后按第二个按键，也可能按下第十二个按键。而对于120，只能先按下第一个键，然后再按第二十个按键，因为不存在第零个按键。

现在请你帮助游游计算有多少种本质不同的合适演奏方式。

对于两种演奏方式，只要存在一个位置的按键不同则认为是不同的演奏方式，由于结果可能很大，请对 `10^9+7` 取模后输出。

输入描述
```
每个测试文件均包含多组测试数。第一行输入一个整数 T(1 <T <10 )代表数据组数,每组测试数据描述如下: 对于每一组测试数据: 第一行一个整数n (1 < n < 10^5)。 第二行一个长度为n 的字符串s ，保证输入仅含数字[0,9]
```
输出描述
```
输出共 T 行，每行一个整数，表示本质不同的合法演奏方式，结果对10^9+7取模。
```
### 思路
动态规划，令 dp[i] 表示前 i 个字符的合法演奏方式数：

- dp[0] = 1 表示空串有 1 种合法方法；
- 若 s[i-1] ≠ '0'，则 dp[i] += dp[i-1]；
- 若`i>1`时，如果由 s[i-2] 和 s[i-1] 组成的两位数在 [10，26] 范围内，dp[i] += dp[i-2]。
- 最后 dp[n] 就是答案，过程中都要对 10^9+7 取模。

### 代码
```
#include<bits/stdc++.h>
using namespace std;
using ll=long long ;
const ll M=1e9+7;
int main(){
    int T;
    cin>>T;
    int n;
    string s;
    while(T--){
        cin>>n;
        cin>>s;
        vector<ll> dp(n+1);
        dp[0]=1;
        for(int i=1;i<=n;++i){
            if(s[i-1]!='0')
                dp[i]=(dp[i]+dp[i-1])%M;
            if(i>1){
                int t=(s[i-2]-'0')*10+s[i-1]-'0';
                if(t>=10&&t<=26)
                    dp[i]=(dp[i]+dp[i-2])%M;
            }
        }
        cout<<dp[n]%M<<endl;
    }
    return 0;
}
```