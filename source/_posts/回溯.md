---
title: 回溯
date: 2022-08-22 09:54:48
categories: 机试
tags: 
---

> ***回溯***  核心思想和dfs相似，主要通过递归寻找可行解

<!-- TOC -->

- [例题1:](#例题1)
- [例题2:](#例题2)

<!-- /TOC -->
### 例题1:
给定一个数组a[]和target的值，找出数组中可以使数字和为target的不同组合，输出所有符合要求的组合
* 数组中数字可以重复使用
* 1,1,5和1,5,1视为一种方式
input:
```
3 8
2 3 5
```

output:
```
3 5
2 3 3
2 2 2 2
```

题解
```
#include<bits/stdc++.h>
using namespace std;
int n,target;
const int N=1e5+5;
typedef vector<int> vi;
vi a(N);
vi tmp;
vector<vi> ans; 
void bk(int idx,int target)
{
    if(idx==n)
        return;
    if(target==0)
    {
        ans.push_back(tmp);
        return;
    }
    bk(idx+1,target);
    if(target>=a[idx])
    {
        tmp.push_back(a[idx]);
        bk(idx,target-a[idx]);
        tmp.pop_back();
    }
}
int main()
{
	cin>>n>>target;
	for(int i=0;i<n;++i)
		cin>>a[i];
	
    bk(0,target);
    for(vi& t:ans)
    {
    	for(int tt :t)
    		cout<<tt<<' ';
    	cout<<endl;
    }
    return 0;
}
```
### 例题2:
给定一个数组a[]和target的值，找出数组中可以使数字和为target的不同组合，输出所有符合要求的组合
* 数组中每个数字最多使用一次
* 1,1,5和1,5,1视为一种方式
input:
```
7 8
10 1 2 7 6 1 5
```

output:
```
1 7
1 6 1
2 6
7 1
```

题解
```
#include<bits/stdc++.h>
using namespace std;
int n,target;
const int N=1e5+5;
typedef vector<int> vi;
vi a(N);
vi tmp;
vector<vi> ans; 
void bk(int idx,int target)
{
    if(idx==n)
        return;
    if(target==0)
    {
        ans.push_back(tmp);
        return;
    }
    for(int i=idx;i<n;++i)
    {
    	if(target>=a[i])
    	{
    		if(i>idx&&a[i]==a[i-1])
    			continue;
    		tmp.push_back(a[i]);
    		bk(i+1,target-a[i]);
    		tmp.pop_back();
    	}
    }
}
int main()
{
	cin>>n>>target;
	for(int i=0;i<n;++i)
		cin>>a[i];
	
    bk(0,target);
    for(vi& t:ans)
    {
    	for(int tt :t)
    		cout<<tt<<' ';
    	cout<<endl;
    }
    return 0;
}
```
