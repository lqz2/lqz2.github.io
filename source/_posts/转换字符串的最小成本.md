---
title: 转换字符串的最小成本
date: 2023-12-24 15:37:07
categories: 机试
math:
tags:
---
## 移除栅栏得到的最大正方形
[原题](https://leetcode.cn/problems/maximum-square-area-by-removing-fences-from-a-field/)
### 题目描述
有一个大型的 (m - 1) x (n - 1) 矩形田地，其两个对角分别是 (1, 1) 和 (m, n) ，田地内部有一些水平栅栏和垂直栅栏，分别由数组 hFences 和 vFences 给出。

水平栅栏为坐标 (hFences[i], 1) 到 (hFences[i], n)，垂直栅栏为坐标 (1, vFences[i]) 到 (m, vFences[i]) 。

返回通过 移除 一些栅栏（可能不移除）所能形成的最大面积的 正方形 田地的面积，或者如果无法形成正方形田地则返回 -1。

由于答案可能很大，所以请返回结果对 109 + 7 取余 后的值。

注意：田地外围两个水平栅栏（坐标 (1, 1) 到 (1, n) 和坐标 (m, 1) 到 (m, n) ）以及两个垂直栅栏（坐标 (1, 1) 到 (m, 1) 和坐标 (1, n) 到 (m, n) ）所包围。这些栅栏 不能 被移除。

e.g.
```
输入：m = 4, n = 3, hFences = [2,3], vFences = [2]
输出：4
解释：移除位于 2 的水平栅栏和位于 2 的垂直栅栏将得到一个面积为 4 的正方形田地。
```
### 思路
周赛第二题，当时以为很复杂，暴力会超时，以为有什么特殊做法，结束一看确实是暴力做的。
主要思路是用一个哈系表存储水平/垂直方向的栅栏之间的差值，这里以存储水平栅栏的差值为例，下来遍历垂直方向的栅栏的差值，如果有差值x在水平和垂直方向都存在，那么用x更新正方形最大边长e即可。

### 代码
```
class Solution
{
public:
    int maximizeSquareArea(int m, int n, vector<int> &hFences, vector<int> &vFences)
    {
        unordered_map<int, int> h;
        int mod = 1e9 + 7;
        hFences.push_back(1);
        hFences.push_back(m);
        vFences.push_back(1);
        vFences.push_back(n);
        sort(hFences.begin(), hFences.end());
        sort(vFences.begin(), vFences.end());
        int e = 0;
        for (int i = 0; i < hFences.size(); i++)
        {
            for (int j = i + 1; j < hFences.size(); j++)
                ++h[hFences[j] - hFences[i]];
        }
        for (int i = 0; i < vFences.size(); i++)
        {
            for (int j = i + 1; j < vFences.size(); j++)
            {
                if (h[vFences[j] - vFences[i]])
                    e = max(e, vFences[j] - vFences[i]);
            }
        }
        return e==0 ? -1:(long long)e * (long long)e % mod;
    }
};
```
## 转换字符串的最小成本
[原题](https://leetcode.cn/problems/minimum-cost-to-convert-string-i/)
### 题目描述
给你两个下标从 0 开始的字符串 source 和 target ，它们的长度均为 n 并且由 小写 英文字母组成。

另给你两个下标从 0 开始的字符数组 original 和 changed ，以及一个整数数组 cost ，其中 cost[i] 代表将字符 original[i] 更改为字符 changed[i] 的成本。

你从字符串 source 开始。在一次操作中，如果 存在 任意 下标 j 满足 cost[j] == z  、original[j] == x 以及 changed[j] == y 。你就可以选择字符串中的一个字符 x 并以 z 的成本将其更改为字符 y 。

返回将字符串 source 转换为字符串 target 所需的 最小 成本。如果不可能完成转换，则返回 -1 。

注意，可能存在下标 i 、j 使得 original[j] == original[i] 且 changed[j] == changed[i] 。

e.g.
```
输入：source = "abcd", target = "acbe", original = ["a","b","c","c","e","d"], changed = ["b","c","b","e","b","e"], cost = [2,5,5,1,2,20]
输出：28
解释：将字符串 "abcd" 转换为字符串 "acbe" ：
- 更改下标 1 处的值 'b' 为 'c' ，成本为 5 。
- 更改下标 2 处的值 'c' 为 'e' ，成本为 1 。
- 更改下标 2 处的值 'e' 为 'b' ，成本为 2 。
- 更改下标 3 处的值 'd' 为 'e' ，成本为 20 。
产生的总成本是 5 + 1 + 2 + 20 = 28 。
可以证明这是可能的最小成本。
```
### 思路
周赛第三题，本质上是求26个字母间的多源最短路，使用Floyd求得每两个字母互换的最小代价，然后遍历两个字符串，计算转换的最小代价，周赛第四题是这道题的升级版，[链接](https://leetcode.cn/problems/minimum-cost-to-convert-string-ii/description/)

### 代码
```
class Solution
{
public:
    long long minimumCost(string source, string target, vector<char> &original, vector<char> &changed, vector<int> &cost)
    {
        int n = source.size();
        long long ans = 0;
        int costmp[26][26];
        memset(costmp, 0x3f, sizeof(costmp));
        for (int i = 0; i < 26; ++i)
            costmp[i][i] = 0;
        for (int i = 0; i < original.size(); ++i)
        {
            int u = original[i] - 'a';
            int v = changed[i] - 'a';
            costmp[u][v] = min(costmp[u][v], cost[i]);
        }
        for (int k = 0; k < 26; ++k)
        {
            for (int i = 0; i < 26; ++i)
            {
                for (int j = 0; j < 26; ++j)
                {
                    if (costmp[i][k] + costmp[k][j] < costmp[i][j])
                        costmp[i][j] = costmp[i][k] + costmp[k][j];
                }
            }
        }
        for (int i = 0; i < n; ++i)
        {
            int u = source[i] - 'a';
            int v = target[i] - 'a';
            if (costmp[u][v] == 0x3f3f3f3f)
                return -1;
            ans += costmp[u][v];
        }
        return ans;
    }
};
```