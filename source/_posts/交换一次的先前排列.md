---
title: 交换一次的先前排列
date: 2023-04-03 08:13:17
categories: 机试
math:
tags:
---
<!-- TOC -->

- [交换一次的先前排列](#交换一次的先前排列)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 交换一次的先前排列
[原题](https://leetcode.cn/problems/previous-permutation-with-one-swap/description/)
### 题目描述
给你一个正整数数组 arr（可能存在重复的元素），请你返回可在 一次交换（交换两数字 arr[i] 和 arr[j] 的位置）后得到的、按字典序排列小于 arr 的最大排列。

如果无法这么操作，就请返回原数组。

e.g.
```
输入：arr = [1,9,4,6,7]
输出：[1,7,4,6,9]
解释：交换 9 和 7
```
### 思路
先从后往前，找到第一个降序排列的数`a[i]`，并可知他后面的数都是非递减排列的，再次从后往前遍历，找到第一个小于`a[i]`且下标尽可能小的数(重复数字取下标更小的)与`a[i]`交换即可。
### 代码
```
class Solution {
public:
    vector<int> prevPermOpt1(vector<int>& arr) {
        int n=arr.size();
        int i=n-2,j=n-1;
        for(i=n-2;i>=0;--i)
        {
            if(arr[i]>arr[i+1])
            {
                while(arr[j]>=arr[i]||arr[j]==arr[j-1])
                    --j;
                swap(arr[i],arr[j]);
                break;
            }
        }
        return arr;
    }
};
```