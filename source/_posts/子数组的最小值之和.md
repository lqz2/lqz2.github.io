---
title: 子数组的最小值之和
date: 2023-11-28 20:18:46
categories: 机试
math: true
tags:
---
<!-- TOC -->

- [子数组的最小值之和](#子数组的最小值之和)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 子数组的最小值之和
[原题](https://leetcode.cn/problems/sum-of-subarray-minimums/description/)
### 题目描述
给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。

由于答案可能很大，因此 返回答案模 10^9 + 7 。

e.g.
```
输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
```
### 思路
这道题主要还是用到单调栈的思想。我们需要计算每个以arr[i]为最小值的子数组最小值之和，例如 arr=[1,4,2,3,1]，其中2是子数组[2],[4,2],[2,3],[4,2,3]的最小值，那么2对答案的贡献就是8。因此，需要利用单调栈找到arr[i]左边第一个比他小的数的下标L，和右边第一个比他小的数的下标R，因为子数组要包括arr[i]，因此左端点可以是$L+1, L+2, ... i$共i-L个，右端点可以是$i，i+1, L+2，... R-1$共R-i个，因此以arr[i]为最小值的子数组对答案的贡献为(i-L)*(R-i)*arr[i]。

要注意的是，由于可能存在重复的数，因此每个arr[i]对应的左右边界不能重叠，否则会导致重复计算，所以左右边界要满足**左闭右开（左开右闭）**
### 代码
```
class Solution {
public:
    int sumSubarrayMins(vector<int>& arr) {
        int n=arr.size();
        stack<int> ls,rs;
        vector<int> left(n),right(n);
        for(int i=0;i<n;++i)
        {
            while(!ls.empty()&&arr[ls.top()]>=arr[i])
                ls.pop();
            left[i]=ls.empty() ? -1:ls.top();
            ls.push(i);
        }
        for(int i=n-1;i>=0;--i)
        {
            while(!rs.empty()&&arr[rs.top()]>arr[i])
                rs.pop();
            right[i]=rs.empty() ? n:rs.top();
            rs.push(i);
        }
        int mod=1e9+7;
        long long ans=0;
        for(int i=0;i<n;++i)
            ans+=((long long)(i-left[i])*(right[i]-i)*arr[i])%mod;
        return ans%mod;
    }
};
```

