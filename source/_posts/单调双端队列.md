---
title: 单调双端队列
date: 2022-10-26 11:14:14
categories: 机试
math: true
tags:
---
<!-- TOC -->

- [和至少为 K 的最短子数组](#和至少为-k-的最短子数组)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 和至少为 K 的最短子数组

### 题目描述
[题目链接](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)

给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。

子数组 是数组中 连续 的一部分。

示例
```
输入：nums = [2,-1,2], k = 3
输出：3
```
### 思路
这道题自己想的就是前缀和然后暴力，但TLE了，看了题解发现需要用单调双端队列对前缀和数组进行优化

主要做两处优化：

1. 弹出队首并更新答案

2. 弹出队尾，保证队列单调递增


[参考链接](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/solution/liang-zhang-tu-miao-dong-dan-diao-dui-li-9fvh/)
### 代码
```
class Solution {
public:
    int shortestSubarray(vector<int>& nums, int k) {
        int len=nums.size();
        vector<long long> a(len+1);
        for(int i=1;i<=len;++i)
            a[i]=nums[i-1]+a[i-1];
        int ans=INT_MAX;
        deque<int> q;
        for(int i=0;i<=len;++i)
        {
            while(!q.empty()&&a[i]-a[q.front()]>=k)
            {
                ans=min(ans,i-q.front());
                q.pop_front();
            }
            while(!q.empty()&&a[i]<=a[q.back()])
               q.pop_back();
            q.push_back(i);
        }
        return ans==INT_MAX ? -1 : ans;
    }
};
```