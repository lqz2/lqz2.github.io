---
title: 最大人工岛
date: 2022-10-25 10:31:52
categories: 机试
math:
tags:
---
<!-- TOC -->

- [最大人工岛](#最大人工岛)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)
- [最短的桥](#最短的桥)
    - [题目描述](#题目描述-1)
    - [思路](#思路-1)
    - [代码](#代码-1)

<!-- /TOC -->
## 最大人工岛


### 题目描述
[原题链接](https://leetcode.cn/problems/making-a-large-island/)

给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。

返回执行此操作后，grid 中最大的岛屿面积是多少？

岛屿 由一组上、下、左、右四个方向相连的 1 形成。

示例：
```
输入: grid = [[1, 1], [1, 0]]
输出: 4
解释: 将一格0变成1，岛屿的面积扩大为 4。
```
### 思路

主要思路是dfs，用dfs给不同的岛编号，用哈系表记录每个编号的岛的面积，然后遍历所有非岛屿部分，更新最大面积即可

### 代码
```
class Solution {
public:
    void dfs(int x,int y,int bh,vector<vector<int>>& grid,int m,int n)
    {
        if(grid[x][y]!=1)
            return;
        grid[x][y]=bh;
        if(x+1<m)
            dfs(x+1,y,bh,grid,m,n);
        if(y+1<n)
            dfs(x,y+1,bh,grid,m,n);
        if(x-1>=0)
            dfs(x-1,y,bh,grid,m,n);
        if(y-1>=0)
            dfs(x,y-1,bh,grid,m,n);
    }
    int largestIsland(vector<vector<int>>& grid) {
        int m=grid.size();
        int n=grid[0].size();
        unordered_map<int,int> mp;
        mp[0]=0;
        int ans=0;
        int bh=2;
        for(int i=0;i<m;++i)
        {
            for(int j=0;j<n;++j)
            {
                if(grid[i][j]==1)
                {
                    dfs(i,j,bh,grid,m,n);
                    ++bh;
                }
            }
        }
        for(int i=0;i<m;++i)
        {
            for(int j=0;j<n;++j)
            {
                if(grid[i][j]!=0)
                    ++mp[grid[i][j]];
            }
        }
        int flag=0;
        for(int i=0;i<m;++i)
        {
            for(int j=0;j<n;++j)
            {
                if(grid[i][j]==0)
                {
                    flag=1;
                    int t=0;
                    unordered_set<int> s;
                    if(i-1>=0)
                        s.insert(grid[i-1][j]);
                    if(j-1>=0)
                        s.insert(grid[i][j-1]);
                    if(i+1<m)
                        s.insert(grid[i+1][j]);
                    if(j+1<n)
                        s.insert(grid[i][j+1]);
                    for(auto it=s.begin();it!=s.end();++it)
                        t+=mp[*it];
                    ans=max(ans,t+1);
                }
            }
        }
        if(flag)
            return ans;
        else
            return m*n;
    }
};
```
## 最短的桥


### 题目描述
[原题链接](https://leetcode.cn/problems/shortest-bridge/)

给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。

岛 是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 。

你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。

返回必须翻转的 0 的最小数目。



示例：
```
输入：grid = [[0,1,0],[0,0,0],[0,0,1]]
输出：2
```
### 思路

这道题实际上是求两个岛之间的最短距离，主要思路是dfs标记其中一个岛，然后用bfs进行岛屿之间最短距离的求解

### 代码
```
class Solution {
public:
    queue<pair<int,int>> q;
    int n;
    void dfs(int x,int y,vector<vector<int>>& grid)
    {
        grid[x][y]=2;
        q.emplace(x,y);
        if(x-1>=0&&grid[x-1][y]==1)
            dfs(x-1,y,grid);
        if(x+1<n&&grid[x+1][y]==1)
            dfs(x+1,y,grid);
        if(y-1>=0&&grid[x][y-1]==1)
            dfs(x,y-1,grid);
        if(y+1<n&&grid[x][y+1]==1)
            dfs(x,y+1,grid);
    }
    void bfs(vector<vector<int>>& grid,int& step)
    {
        while(!q.empty())
        {
            int len=q.size();
            while(len--)
            {
                int x=q.front().first;
                int y=q.front().second;
                q.pop();
                if(x-1>=0&&grid[x-1][y]!=2)
                {
                    if(grid[x-1][y]==1)
                        return;
                    q.emplace(x-1,y);
                    grid[x-1][y]=2;
                }
                if(y-1>=0&&grid[x][y-1]!=2)
                {
                    if(grid[x][y-1]==1)
                        return;
                    q.emplace(x,y-1);
                    grid[x][y-1]=2;
                }
                if(x+1<n&&grid[x+1][y]!=2)
                {
                    if(grid[x+1][y]==1)
                        return;
                    q.emplace(x+1,y);
                    grid[x+1][y]=2;
                }
                if(y+1<n&&grid[x][y+1]!=2)
                {
                    if(grid[x][y+1]==1)
                        return;
                    q.emplace(x,y+1);
                    grid[x][y+1]=2;
                }
            }
            ++step;
        }
    }
    int shortestBridge(vector<vector<int>>& grid) {
        n=grid.size();
        int step=0;
        vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
        for(int i=0;i<n;++i)
        {
            for(int j=0;j<n;++j)
            {
                if(grid[i][j]==1)
                {
                    dfs(i,j,grid);
                    bfs(grid,step);
                    return step;
                }
            }
        }
        return -1;
    }
};
```