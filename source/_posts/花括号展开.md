---
title: 花括号展开
date: 2023-03-07 08:48:11
categories: 机试
math:
tags:
---

## 花括号展开
[原题](https://leetcode.cn/problems/brace-expansion-ii/)
### 题目描述
如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。
花括号展开的表达式可以看作一个由 花括号、逗号 和 小写英文字母 组成的字符串，定义下面几条语法规则：
如果只给出单一的元素 x，那么表达式表示的字符串就只有 `"x"`。`R(x) = {x}`
例如，表达式 `"a"` 表示字符串 `"a"`。
而表达式 `"w"` 就表示字符串 `"w"`。
当两个或多个表达式并列，以逗号分隔，我们取这些表达式中元素的并集。`R({e_1,e_2,...}) = R(e_1) ∪ R(e_2) ∪ ...`
例如，表达式 `"{a,b,c}"` 表示字符串 `"a",``"b"`,`"c"`。
而表达式 `"{{a,b},{b,c}}"` 也可以表示字符串 `"a"`,`"b"`,`"c"`。
要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。`R(e_1 + e_2) = {a + b for (a, b) in R(e_1) × R(e_2)}`
例如，表达式 `"{a,b}{c,d}"` 表示字符串 `"ac","ad","bc","bd"`。
表达式之间允许嵌套，单一元素与表达式的连接也是允许的。
例如，表达式 `"a{b,c,d}"` 表示字符串 `"ab","ac","ad"​​​​​​`。
例如，表达式 `"a{b,c}{d,e}f{g,h}"` 可以表示字符串 `"abdfg", "abdfh", "abefg", "abefh", "acdfg", "acdfh", "acefg", "acefh"`。
给出表示基于给定语法规则的表达式 expression，返回它所表示的所有字符串组成的有序列表。

e.g.
```
输入：expression = "{a,b}{c,{d,e}}"
输出：["ac","ad","ae","bc","bd","be"]
```
### 思路
这道题可以用类似中缀表达式求值的做法，把并列操作看作`+`，把组合操作看作`*`，需要建立两个栈，一个用来保存运算符，一个用来保存已有集合，然后分情况讨论：

* 如果当前字符为`{`，如果上一个字符为`}`或者字母，则运算符栈先加入`*`再加入`{`
* 如果当前字符为`,`，如果运算符栈顶为`*`，那么不断弹出元素并计算，直到栈顶不是`*`，然后加入`+`
* 如果为`}`，则不断弹出元素并计算，直到遇到`{`为止，并将左括号也弹出
* 如果为字母，如果上一个字符为`}`或者字母，则运算符栈先加入`*`，再将字母单独构造成一个集合，加入集合栈
### 代码
```
class Solution {
public:
    vector<char> op;
    vector<set<string>> e;
    //弹出栈顶两个元素并计算
    void compute()
    {
        int r=e.size()-1;
        int l=r-1;
        if(op.back()=='+')
            e[l].merge(e[r]);
        else
        {
            set<string> tmp;
            for(auto& a:e[l])
            {
                for(auto& b:e[r])
                    tmp.insert(a+b);
            }
            e[l]=move(tmp);
        }
    }
    vector<string> braceExpansionII(string expression) {
        vector<int> ans;
        
        int n=expression.size();
        for(int i=0;i<n;++i)
        {
            if(expression[i]=='{')
            {
                if(i>0&&(expression[i-1]=='}'||isalpha(expression[i-1])))
                    op.push_back('*');
                op.push_back('{');   
            }
            else if(expression[i]==',')
            {
                while(op.size()&&op.back()=='*')
                {
                    compute();
                    op.pop_back();
                    e.pop_back();
                }
                op.push_back('+');
            }
            else if(expression[i]=='}')
            {
                while(op.size()&&op.back()!='{')
                {
                    compute();
                    op.pop_back();
                    e.pop_back();
                }
                op.pop_back();
            }
            else
            {
                set<string> tmp;
                if(i>0&&(expression[i-1]=='}'||isalpha(expression[i-1])))
                    op.push_back('*');
                string s;
                s+=expression[i];
                tmp.insert(s);
                e.push_back(tmp);
            }
        }
        while(op.size())
        {
            compute();
            op.pop_back();
            e.pop_back();
        }
        return {e.back().begin(),e.back().end()};
    }
};
```