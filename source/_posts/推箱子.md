---
title: 推箱子
date: 2023-05-08 08:16:56
categories: 机试
math:
tags:
---
<!-- TOC -->

- [推箱子](#推箱子)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 推箱子
[原题](https://leetcode.cn/problems/minimum-moves-to-move-a-box-to-their-target-location/description/)
### 题目描述
推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。

游戏地图用大小为 m x n 的网格 grid 表示，其中每个元素可以是墙、地板或者是箱子。

现在你将作为玩家参与游戏，按规则将箱子 'B' 移动到目标位置 'T' ：

玩家用字符 'S' 表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。
地板用字符 '.' 表示，意味着可以自由行走。
墙用字符 '#' 表示，意味着障碍物，不能通行。 
箱子仅有一个，用字符 'B' 表示。相应地，网格上有一个目标位置 'T'。
玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。
玩家无法越过箱子。
返回将箱子推到目标位置的最小 推动 次数，如果无法做到，请返回 -1。

e.g.
```
输入：grid = [["#","#","#","#","#","#"],
             ["#","T","#","#","#","#"],
             ["#",".",".","B",".","#"],
             ["#",".","#","#",".","#"],
             ["#",".",".",".","S","#"],
             ["#","#","#","#","#","#"]]
输出：3
解释：我们只需要返回推箱子的次数。
```
### 思路
深度优先搜索(BFS)，通过`vis[px][py][bx][by]`记录当前箱子和人的位置是否被访问过，然后定义一个双端队列`deque<tuple<int,int,int,int>>`，每个元素记录人的位置、箱子的位置和当前推动距离，然后进行bfs，每次取出队首元素，如果箱子到达目的地则返回推动距离，否则先让人移动，当人移动到箱子位置时推动箱子(更新箱子位置)，如果推动后人和箱子当前位置未被访问，则将该状态加入队尾，如果人未移动到箱子位置并且当前二者位置未被访问，则将当前状态加入队首，重复上述步骤知道队列为空为止。
### 代码
```
class Solution {
int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
bool vis[20][20][20][20]={0};
public:
    int minPushBox(vector<vector<char>>& grid) {
        int m=grid.size(),n=grid[0].size();
        auto isvalid=[&](int x,int y)->bool{
            return x>=0&&x<m&&y>=0&&y<n&&grid[x][y]!='#';
        };
        int startx,starty,boxx,boxy,endx,endy;
        for(int i=0;i<m;++i)
        {
            for(int j=0;j<n;++j)
            {
                if(grid[i][j]=='S')
                {
                    startx=i;starty=j;
                }
                else if(grid[i][j]=='B')
                {
                    boxx=i;boxy=j;
                }
                else if(grid[i][j]=='T')
                {
                    endx=i;endy=j;
                }
            }
        }
        deque<tuple<int,int,int,int,int>> q;
        q.emplace_front(startx,starty,boxx,boxy,0);
        vis[startx][starty][boxx][boxy]=true;
        while(!q.empty())
        {
            auto [px,py,bx,by,d]=q.front();
            q.pop_front();
            if(bx==endx&&by==endy)
                return d;
            for(auto [dx,dy]:dir)
            {
                int npx=px+dx,npy=py+dy;
                if(!isvalid(npx,npy))
                    continue;
                if(npx==bx&&npy==by)
                {
                    int nbx=bx+dx,nby=by+dy;
                    if(!isvalid(nbx,nby)||vis[npx][npy][nbx][nby])
                        continue;
                    q.emplace_back(npx,npy,nbx,nby,d+1);
                    vis[npx][npy][nbx][nby]=true;
                }
                else if(!vis[npx][npy][bx][by])
                {
                    q.emplace_front(npx,npy,bx,by,d);
                    vis[npx][npy][bx][by]=true;
                }  
            }
        }
        return -1;
    }
};
```