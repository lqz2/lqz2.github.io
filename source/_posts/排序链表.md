---
title: 排序链表
date: 2024-12-25 10:35:33
categories: 机试
math:
tags:
---
## 排序链表

<!-- TOC -->

- [排序链表](#排序链表)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->

[原题](https://leetcode.cn/problems/sort-list/description)


### 题目描述
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
### 思路
这道题之前直接用Vector排序的:joy:，这次用归并排序实现。
- 先找到链表的中点
- 递归的对左右两部分进行归并排序，返回排序后左右两部分的头结点
- 合并两个有序链表
### 代码
```
class Solution {
public:
    ListNode* merge(ListNode* h1, ListNode* h2){
        ListNode* dummy=new ListNode(-1);
        ListNode* l=dummy,*l1=h1,*l2=h2;
        while(l1&&l2){
            if(l1->val<=l2->val){
                l->next=l1;
                l1=l1->next;
                l=l->next;
            }else{
                l->next=l2;
                l2=l2->next;
                l=l->next;
            }
        }
        l->next=l1==nullptr? l2:l1;
        return dummy->next;
    }
    ListNode* mergeSort(ListNode* head, ListNode* tail){
        if(head==nullptr)
            return head;
        if(head->next==tail){
            head->next=nullptr;
            return head;
        }
        ListNode *slow=head,*fast=head;
        while(fast->next!=tail&&fast->next->next!=tail){
            slow=slow->next;
            fast=fast->next->next;
        }
        ListNode *mid=slow->next;
        return merge(mergeSort(head,mid),mergeSort(mid,tail));        
    }
    ListNode* sortList(ListNode* head) {
        return mergeSort(head,nullptr);
    }
};
```