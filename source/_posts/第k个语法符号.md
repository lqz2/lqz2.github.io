---
title: 第k个语法符号
date: 2022-10-20 10:34:58
categories: 机试
math:
tags:
---

<!-- TOC -->

- [第k个语法符号](#第k个语法符号)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)
    - [位操作扩展](#位操作扩展)
- [扩展：求某个数二进制表示中1的个数](#扩展求某个数二进制表示中1的个数)
    - [思路](#思路-1)
    - [代码](#代码-1)

<!-- /TOC -->
## 第k个语法符号
### 题目描述

[原题链接](https://leetcode.cn/problems/k-th-symbol-in-grammar/)
我们构建了一个包含 n 行( 索引从 1  开始 )的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。

例如，对于 n = 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。
给定行数 n 和序数 k，返回第 n 行中第 k 个字符。（ k 从索引 1 开始）

示例：
```
输入: n = 2, k = 1
输出: 0
解释: 
第一行: 0 
第二行: 01
```
### 思路

这道题大致看上去不是很难，自己的思路就是中规中矩的算，没什么亮点(:cry:tcl)

看了评论区的一位大佬，瞬间的折服了，时间复杂度直接`O(1)`

大佬解这道题就是一句话：**对K-1做奇偶校验**
### 代码
下面放上大佬的代码：
```
class Solution {
public:
    int kthGrammar(int N, unsigned int K) 
    {
        K -= 1;
        K ^= K >> 1;
        K ^= K >> 2;
        K = (K & 0x11111111) * 0x11111111;
        return (K >> 28) & 1;
    }
};
```
第一眼看过去，我还是不会:cry:

于是仔细看了一番，下面我来解释一下
### 位操作扩展

大佬的话，翻译一下，就是求`K-1`对应的二进制数中，1的个数是奇数还是偶数，奇数返回1,偶数返回0

因为在奇偶校验中，常常需要需要判断一个数中1的个数，以确定奇偶校验位

也就是说，这道题的本质，就是判断`K-1`对应的二进制数中，1的个数是奇数还是偶数。(大佬太强了%%%)

关于代码呢，我主要参考了这篇博客  [*博客链接*](https://blog.csdn.net/u012028275/article/details/112596947)，说的非常详细，还带图示。

`K ^= K >> 1;`，作用就是相邻两位异或，判断每两位1的个数，奇数个1则为，否则为0，结果存在相邻2位的低位

`K ^= K >> 2;`，和上一步差不多，不过判断的是每4位的1的个数

`K & 0x11111111`，作用是每4位只取最低位，其他置0

`K * 0x11111111;`，作用是将整个32位的1的个数奇偶性压缩到最高4位，也就是28～31位

`(K >> 28) & 1;`，移到最低4位，解出1的个数的奇偶性

## 扩展：求某个数二进制表示中1的个数

位操作还可以求某个数二进制表示中1的个数

比如现在需要求一个无符号整形数的二进制数中1的个数
### 思路
其实和奇偶校验有点关系，求每2个数、每4个数、每8个数、每16个数的1的个数相加就好了

### 代码
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin>>n;
	//int n=0b0111100110011000000000000000001; 
	n=((n&0xaaaaaaaa)>>1)+(n&0x55555555); 
	n=((n&0xcccccccc)>>2)+(n&0x33333333);
	n=((n&0xf0f0f0f0)>>4)+(n&0x0f0f0f0f);
	n=((n&0xff00ff00)>>8)+(n&0x00ff00ff);
	n=((n&0xffff0000)>>16)+(n&0x0000ffff);
	cout<<n<<endl;
	return 0;
}
```