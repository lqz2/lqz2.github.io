---
title: 最大加号标志
date: 2022-11-09 11:29:12
categories: 机试
math:
tags:
---

<!-- TOC -->

- [最大加号标志](#最大加号标志)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 最大加号标志
[题目链接](https://leetcode.cn/problems/largest-plus-sign/description/)
### 题目描述
在一个 n x n 的矩阵 grid 中，除了在数组 mines 中给出的元素为 0，其他每个元素都为 1。mines[i] = [xi, yi]表示 grid[xi][yi] == 0

返回  grid 中包含 1 的最大的 轴对齐 加号标志的阶数 。如果未找到加号标志，则返回 0 。

一个 k 阶由 1 组成的 “轴对称”加号标志 具有中心网格 grid[r][c] == 1 ，以及4个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 0 也可能为 1 。

示例：
```
输入: n = 5, mines = [[4, 2]]
输出: 2
解释: 在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。
```
### 思路
>这道题属于动态规划，用`dp[i][j]`表示在`(i,j)`位置四个方向阶数的最小值，然后找到dp数组中的最大值即可。
注意：遍历时要先处理水平方向，再处理垂直方向，不然无法正确更新dp数组
### 代码
```
class Solution {
public:
    bool vis[250001];
    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {
        vector<vector<int>> dp(n,vector<int>(n,n));
        for(auto & t:mines)
            vis[t[0]*n+t[1]]=true;
        int count=0;
        int ans=0;
        for(int i=0;i<n;++i)
        {
            for(int j=0;j<n;++j)
            {
                if(vis[i*n+j])
                    count=0;
                else
                    ++count;
                dp[i][j]=min(dp[i][j],count);
            }
            count=0;
            for(int j=n-1;j>=0;--j)
            {
                if(vis[i*n+j])
                    count=0;
                else
                    ++count;
                dp[i][j]=min(dp[i][j],count);
            }
            count=0;
            
        }
        for(int j=0;j<n;++j)
        {
            for(int i=0;i<n;++i)
            {
                if(vis[i*n+j])
                    count=0;
                else
                    ++count;
                dp[i][j]=min(dp[i][j],count);
            }
            count=0;
            for(int i=n-1;i>=0;--i)
            {
                if(vis[i*n+j])
                    count=0;
                else
                    ++count;
                dp[i][j]=min(dp[i][j],count);
                ans=max(dp[i][j],ans);
            }
            count=0;
        }
        return ans;
    }
};
```