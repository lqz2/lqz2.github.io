---
title: 滑动窗口
date: 2022-11-11 09:52:00
categories: 机试
math:
tags:
---
<!-- TOC -->

- [长度为 K 子数组中的最大和](#长度为-k-子数组中的最大和)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)
- [区间子数组个数](#区间子数组个数)
    - [题目描述](#题目描述-1)
    - [思路](#思路-1)
    - [代码](#代码-1)

<!-- /TOC -->

>滑动窗口也是很典型的一类题，这里举个简单的例子回顾一下主要思想。~~(水篇博客:joy:)~~
## 长度为 K 子数组中的最大和
[题目链接](https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/)
### 题目描述
给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和：

子数组的长度是 k，且
子数组中的所有元素 各不相同 。
返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。

子数组 是数组中一段连续非空的元素序列。

### 思路
设置一个`hashset`，用`l`记录滑动窗口左端下标，然后遍历数组中的所有元素，分以下三种情况：
* 判断set中有没有该元素，有的话不断删除最左边的数直到没有该元素
* 窗口大小如果大于等于k，从左边删除一个元素，然后加入当前元素，更新最大和
* 窗口大小如果小于k，则加入当前元素，如果加入后窗口大小为k，更新最大和

### 代码
```
class Solution {
public:
    unordered_set<int> st;
    long long maximumSubarraySum(vector<int>& nums, int k) {
        int len=nums.size();
        long long sum=0;
        long long ans=0;
        int l=0;
        for(int i=0;i<len;++i)
        {
            while(st.count(nums[i]))
            {
                sum-=nums[l];
                st.erase(nums[l]);
                ++l;
            }
            if(i-l>=k)
            {
                sum-=nums[l];
                st.erase(nums[l]);
                ++l;
                sum+=nums[i];
                st.insert(nums[i]);
                ans=max(ans,sum);   
            }
            else
            {
                st.insert(nums[i]);
                sum+=nums[i];
                if(i-l==k-1)
                    ans=max(ans,sum);
            }
        }
        return ans;
    }
};
```
## 区间子数组个数
[题目链接](https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/description/)
### 题目描述
给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。

生成的测试用例保证结果符合 32-bit 整数范围。

示例
```
输入：nums = [2,1,4,3], left = 2, right = 3
输出：3
解释：满足条件的三个子数组：[2], [2, 1], [3]
```

### 思路
用l和r记录滑动窗口的左右端，然后从左到右遍历数组，如果当前元素符合要求，`r=i`，如果当前元素大于right，`r=i+1`,然后加上每次的结果`r-l+1`

### 代码
```
class Solution {
public:
    int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
        int len=nums.size();
        int l=0,r=-1;
        int ans=0;
        for(int i=0;i<len;++i)
        {
            if(nums[i]>=left&&nums[i]<=right)
                r=i;
            else if(nums[i]>right)
                l=i+1;
            ans+=max(0,r-l+1);
        }
        return ans;
    }
};
```