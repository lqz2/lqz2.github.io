---
title: 算法作业2
date: 2023-10-20 10:53:26
categories: 机试
math:
tags:
---
<!-- TOC -->

- [数“一”数](#数一数)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)
- [最大矩形](#最大矩形)
    - [题目描述](#题目描述-1)
    - [思路](#思路-1)
    - [代码](#代码-1)
- [正则表达式匹配](#正则表达式匹配)
    - [题目描述](#题目描述-2)
    - [思路](#思路-2)
    - [代码](#代码-2)

<!-- /TOC -->
## 数“一”数

### 题目描述
编写一个函数，输入一个整数 n，返回一个长度为 n + 1 的数组，其中每个元素表示对应整数二进制中 "1" 的数量。

input:
```
5
```
output:
```
[0, 1, 1, 2, 1, 2]
```

### 思路
可以用数组res保存每个数字的二进制表示的1的数量
* 对于偶数`a`，他的二进制表示中1的数量和`a/2`相同
* 对于奇数`a`,他的二进制表示中1的数量比`a/2`多1

因此有递推式：`res[i]=res[i>>1]+(i&1)`

### 代码
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin >> n;
    vector<int> res(n + 1);
    for (int i = 1; i <= n; ++i)
    {
        res[i] = res[i >> 1] + i & 1;
    }
    cout << '[';
    for (int i = 0; i <= n; ++i)
    {
        if (i != n)
            cout << res[i] << ", ";
        else
            cout << res[i];
    }
    cout << ']';
    return 0;
}
```

## 最大矩形
[原题](https://leetcode.cn/problems/maximal-rectangle/description/)
### 题目描述
给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

e.g.
```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：6
解释：最大矩形如上图所示。
```

### 思路
这道题需要用到单调栈，在[单调栈](https://lqz2.github.io/2022/09/13/%E5%8D%95%E8%B0%83%E6%A0%88/)中，通过单调栈，可以求得柱状图中的最大矩形。对于这道题，需要先把矩阵按每一行连续的1处理成柱状图，例如一行是`1 0 1 1 1`，处理后变成`1 0 1 2 3`。接下来，将每一列视为一个柱状图，这道题可以视为寻找所有列对应的柱状图中的最大子矩形，因此，需要遍历每列柱状图的最大子矩形，然后求得最大值后返回。

### 代码
```
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        int m=matrix.size(),n=matrix[0].size();
        vector<vector<int>> a(m,vector<int>(n));
        for(int i=0;i<m;++i)
        {
            for(int j=0;j<n;++j)
            {
                if(matrix[i][j]=='1')
                    a[i][j]=(j==0?0:a[i][j-1])+1;
            }
        }
        int res=0,area=0;
        for(int j=0;j<n;++j)
        {
            vector<int> up(m),down(m);
            stack<int> ust,dst;
            for(int i=0;i<m;++i)
            {
                while(!ust.empty()&&a[ust.top()][j]>=a[i][j])
                    ust.pop();
                up[i]=ust.empty()?-1:ust.top();
                ust.push(i);
            }
            for(int i=m-1;i>=0;--i)
            {
                while(!dst.empty()&&a[dst.top()][j]>=a[i][j])
                    dst.pop();
                down[i]=dst.empty()?m:dst.top();
                dst.push(i);
            }
            for(int i=0;i<m;++i)
            {
                area=a[i][j]*(down[i]-up[i]-1);
                res=max(res,area);
            }
        }
        return res;
    }
};

```
## 正则表达式匹配
[原题](https://leetcode.cn/problems/regular-expression-matching/)
### 题目描述
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

e.g.
```
输入：s = "aa", p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

输入：s = "ab", p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```
### 思路
用到动态规划的思想。用dp[i][j]表示s中前i个字符和p中前j个字符是否匹配,接下来分情况讨论
* 当s[i]和p[j]匹配时`(s[i-1]=p[j-1]或者p[j-1]=='.')`，`dp[i][j]=dp[i-1][j-1]`
* 否则，如果p[j]当前字符p[j-1]=='*'
    * 如果s[i]和p[j]的前一个字符匹配`(s[i-1]=p[j-2]或者p[j-2]=='.')`，此时可以匹配一个或多个s[i]，也可以不匹配s[i]，状态方程为`dp[i][j]=dp[i][j-2]||dp[i-1][j]`
    * 如果s[i]和p[j]的前一个字符不匹配，那么不匹配s[i]，`dp[i][j]=dp[i][j-2]`

总的状态方程如下：
$$
f[i][j]=\begin{cases}\mathrm{if}\left(p[j]\neq\right.^{*})=\begin{cases}f[i-1][j-1],&matches(s[i],p[j])\\\mathrm{false},&\mathrm{otherwise}&\end{cases}\\\mathrm{otherwise}=\begin{cases}f[i-1][j]\mathrm{~or~}f[i][j-2],&matches(s[i],p[j-1])\\f[i][j-2],&\mathrm{otherwise}&\end{cases}\end{cases}
$$
### 代码
```
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size(); 
        vector<vector<bool>> dp(m+1,vector<bool>(n+1,false));
        dp[0][0] = true;
        //初始化dp,匹配空串时,*可以消除前一个字符，因此状态与前前一个状态相等
        for(int j =2;j <=n ;j++)
        {
            if(p[j-1]=='*')
                dp[0][j]=dp[0][j-2];
        }
        function<bool(int,int)> match=[&](int i,int j){
            if(s[i-1]==p[j-1]||p[j-1]=='.')
                return true;
            return false;
        };
        for (int i = 1; i <= m; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                //如果当前s[i]和p[j]匹配,则与上一个状态相等
                if (match(i,j))
                        dp[i][j] = dp[i-1][j-1]; 
                else if (p[j - 1] == '*')//如果当前p[j]为*
                {
                    if(match(i,j-1))//如果*前面的字符可以匹配s[i]
                        //匹配0次：dp[i][j-2],相当于删除*前面的字符
                        //匹配1次或以上：dp[i-1][j]
                        dp[i][j]=dp[i][j-2]||dp[i-1][j];
                    else//相当于匹配了0次
                        dp[i][j]=dp[i][j-2];
                }      
            }
        }
        return dp[m][n];
    }
};
```

