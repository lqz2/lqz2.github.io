---
title: 不同的子序列
date: 2022-10-14 10:32:58
categories: 机试
math:
tags:
---

<!-- TOC -->

- [不同的子序列](#不同的子序列)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 不同的子序列

[题目链接](https://leetcode.cn/problems/distinct-subsequences-ii/)

### 题目描述
给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。

字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。

例如，"ace" 是 "abcde" 的一个子序列，但 "aec" 不是。

示例：
```
输入：s = "aba"
输出：6
解释：6 个不同的子序列分别是 "a", "b", "ab", "ba", "aa" 以及 "aba"。
```
### 思路
这是一道动态规划的题目，自己没想出来，看了题解才理解
核心的思想就是，*以当前字符结尾的不同子序列的个数=之前部分的个数+新增加的个数-重复序列个数*
其中，需要一个数组`recount[]`来记录每个字符带来的增加量，当某字符多次出现时，它带来的重复量就等于`recount[i]`

比如：对于序列 abcb

a : "", a           
**newcnt=1**

ab : "", a, b, ab   
**newcnt=2**

abc : "",a, b, ab, c, ac, bc, cc    
**newcnt=4**

abcb: "",a, b, ab, c, ac, bc, cc, ~~b~~, ~~ab~~, bb, abb, cb, acb, bcb, ccb
**newcnt=8, recount['b']=2**

根据以上例子，可得到下面的结论：

* newcnt=pre_cnt(上一个字符的个数)
* recount[x]=newcnt_x(字符x上一次出现带来的新增个数)

为了计算，在子集前面加了空串 `“”`，所以初始个数为1

### 代码

```
class Solution {
public:
    int distinctSubseqII(string s) {
        const int mod=1e9+7;
        int len=s.size();
        vector<int> recount(26,0);
        int ans=1;
        int newcnt;
        for(int i=0;i<len;++i)
        {
            newcnt=ans;
            ans=((ans+newcnt)%mod-recount[s[i]-'a']+mod)%mod;
            recount[s[i]-'a']=newcnt;
        }
        return ans-1;
    }
};
```
