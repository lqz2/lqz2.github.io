---
title: 配置中心和长轮询
date: 2025-07-21 14:54:01
categories: 学习
math:
tags:
---
<!-- TOC -->

- [配置中心和长轮询](#配置中心和长轮询)
    - [为什么要用配置中心？](#为什么要用配置中心)
    - [数据交互模式](#数据交互模式)
        - [推模式](#推模式)
        - [拉模式](#拉模式)
    - [长轮询和轮询](#长轮询和轮询)
    - [长轮询的基本原理](#长轮询的基本原理)
    - [挂起的三种方式](#挂起的三种方式)
        - [while循环](#while循环)
        - [通过wait和notify，配合`future.get(timeout)`实现：](#通过wait和notify配合futuregettimeout实现)
        - [schedule+AsyncContext实现：](#scheduleasynccontext实现)
    - [为什么用长轮询不用长连接？](#为什么用长轮询不用长连接)

<!-- /TOC -->
# 配置中心和长轮询
## 为什么要用配置中心？
传统的静态配置方式想要修改某个配置时，必须修改后重新启动上线，这样某些配置如果频繁改动，就会影响到线上业务的运行效率，配置中心就可以很好的解决这个问题。

配置中心最主要的能力就是配置的动态推送，可能很多人一位配置中心是通过长连接实现的，实际上主流的配置中心主要是通过长轮询的方式来实现配置的动态推送。

长连接和长轮询的主要区别是：
| 特性 | 长连接 (Long Connection) | 长轮询 (Long Polling) |
| :--- | :--- | :--- |
| **本质** | TCP 连接的复用，多个HTTP请求可以复用一个TCP长连接 | 应用层的请求响应模式|
| **服务端行为** | 快速响应请求，但保持 TCP 连接不关闭| 挂起请求，直到有数据更新或超时再响应|
| **实现方式** | 双方通过 HTTP 协议头 `Connection: keep-alive` 控制| 服务端通过编程逻辑实现请求挂起，与客户端无关 |
| **目的** | 减少 TCP 连接建立和断开的开销 | 降低轮询频率，模拟实时数据推送  |

## 数据交互模式
### 推模式
推模式指的是服务端主动向客户端推送数据更新，客户端无需频繁请求服务器。推模式通常使用 WebSocket 或 Server-Sent Events (SSE) 实现。缺点是客户端的消费能力有限时，可能会导致数据积压。

### 拉模式
拉模式指的是客户端主动向服务端发出请求，拉取数据，优点是不存在数据积压的问题，缺点是可能不够及时，拉取数据的频率不好确定。

## 长轮询和轮询
普通的轮询是每隔一定时间拉取一次数据，存在以下问题：
- **延迟性**：数据更新后需要等待下一个轮询周期才能获取到最新数据。
- **资源浪费**：即使没有数据更新，仍然会发送请求，浪费带宽和服务器资源。
- **轮询间隔**：需要合理设置轮询间隔，过短会增加服务器负担，过长会导致数据延迟。

而长轮询的方式是，如果服务端数据没有变更，服务端会挂起请求，直到数据变更或超时后再响应。这样可以有效减少请求次数和延迟。

## 长轮询的基本原理
一般长轮询各个部分的工作流程如下：
- 客户端发起长轮询：
    - 客户端发送 HTTP 请求到服务端，请求包含配置中心的地址和监听的dataId
- 服务端监听数据变化：
    - 服务端维护dataId和长轮询的映射关系，如果dataId对应的配置发生变化，则会为响应写入更新后的配置内容
    - 如果直到超时还没有数据变化，服务端会返回一个304响应，304代表“未改变”，并不代表错误
- 客户端处理响应：根据响应码做出相应处理，之后再次发起长轮询请求。

## 挂起的三种方式

### while循环
这是最朴素的实现方式，通过while循环不断检查数据是否变化，直到超时或数据变化为止。缺点是会浪费CPU资源。

### 通过wait和notify，配合`future.get(timeout)`实现：
- 当数据没有变更时，通过obj.wait()方法挂起当前线程，让出cpu资源，等待数据变更时通过obj.notifyAll()唤醒线程。
- 仅使用wait和notify的话，如果没有数据变更，线程会一直wait，为了达到超时效果，可以使用`future.get(timeout)`方法来设置超时时间。当抛出`TimeoutException`时，说明超时了，此时可以返回304响应。

>这种方式的缺点是，如果数据长时间没有变化，可能会不断的抛出异常，处理效率很低。

### schedule+AsyncContext实现：
Diamond中，采用这种更优雅的方式实现长轮询。

首先需要介绍一下AsyncContext：
AsyncContext是Servlet 3.0中引入的异步处理支持类。其主要作用是释放Servlet容器的线程，使其不必因等待耗时业务（如数据库操作、跨网络调用等）而一直处于阻塞状态。


具体来说，它的作用体现在以下几点：
- **线程解耦与资源释放**：允许Servlet线程将耗时的业务逻辑委派给一个独立的异步线程处理，而Servlet线程本身可以立即返回到容器中，去处理其他新的请求。这样可以先释放容器分配给请求的线程和相关资源，减轻系统负担。
- **提升并发能力**：通过避免Servlet线程长时间被占用，服务器可以用有限的线程处理更多的并发请求，从而显著提高应用的并发处理速度和整体性能，尤其是在高并发场景下非常有用 123。
- **延迟响应**：请求的响应将被延后，直到异步线程中的业务处理完成。异步线程可以直接生成响应数据，或者将请求转发给其他Servlet。

所以，为了不让长轮训一直占用servlet容器的线程，一般通过AsyncContext将请求交给异步线程处理，处理完成后通过asyncContext的`complete()`方法来结束请求。

整体流程如下：
- 首先，通过维护一个`ScheduledThreadPool`来执行不同任务。
- 当订阅者携带一个dataId来拉取数据时，先通过`startAsync()`创建一个AsyncContext对象，表示将请求转换为异步方式，然后会根据这个dataId创建一个worker，并将AsyncContext对象传给新建的worker，这个worker的run方法中，会通过schedule方法在一定时间后执行`sendResponse(null)`方法，发送超时响应，send之前需要先从队列中remove掉这个worker。
- 如果发生了数据变更，会创建一个执行数据变更的worker，这个worker中会根据dataId从队列中找出对应的woker，然后调用这个worker的`sendResponse(data)`方法，发送数据变更响应，同样，send之前需要先从队列中remove掉这个worker。
- `sendResponse`方法中，会向AsyncContext对象中写入数据，并调用`complete()`方法结束请求。

## 为什么用长轮询不用长连接？
- 长轮询实现更简单，通过HTTP协议即可实现，而HTTP使用十分广泛
- 大多数语言都支持HTTP的客户端
- 一些配置中心计划未来会改造为长连接，比如nacos