---
title: 甜点成本
date: 2022-12-04 09:14:14
categories: 机试
math:
tags:
---

## 甜点成本
[原题](https://leetcode.cn/problems/closest-dessert-cost/description/)

### 题目描述
你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则：

必须选择 一种 冰激凌基料。
可以添加 一种或多种 配料，也可以不添加任何配料。
每种类型的配料 最多两份 。
给你以下三个输入：

baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。
toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。
target ，一个整数，表示你制作甜点的目标价格。
你希望自己做的甜点总成本尽可能接近目标价格 target 。

返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。

示例
```
输入：baseCosts = [2,3], toppingCosts = [4,5,100], target = 18
输出：17
解释：考虑下面的方案组合（所有下标均从 0 开始）：
- 选择 1 号基料：成本 3
- 选择 1 份 0 号配料：成本 1 x 4 = 4
- 选择 2 份 1 号配料：成本 2 x 5 = 10
- 选择 0 份 2 号配料：成本 0 x 100 = 0
总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。
```
### 思路
这是一道背包问题的变种，可以把所有的方案分成两大类，总成本大于target的和总成本小于target的，我们要做的就是用一个变量res记录大于target的最小成本，然后对小于target的方案进行动态规划。

首先维护一个数组`can[]`,表示每个小于target的方案是否合法（即可以通过base或者配料组合得到的数值），先遍历basecosts，如果有x小于target的，则`can[x]=true`，大于target则更新res。然后开始动态规划，每个配料遍历两次，如果加上当前配料后成本大于target，则更新res，如果当前成本不合法，那么有可能减去当前配料后就合法了，所以据此更新当前的`can`

最后，只需要考虑在`res-target`的距离内，小于target的方案有没有合法的，因为如果大于这个距离，那么最接近target的方案就是res了。
### 代码

```
class Solution {
public:
    int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) {
        int b=*min_element(baseCosts.begin(),baseCosts.end());
        if(b>=target)
            return b;
        vector<bool> can(target+1,false);
        int res=2*target-b;
        for(int &t:baseCosts)
        {
            if(t<=target)
                can[t]=true;
            else
                res=min(res,t);
        }
        for(int& t:toppingCosts)
        {
            for(int i=0;i<2;++i)
            {
                for(int j=target;j>=0;--j)
                {
                    if(can[j]&&j+t>target)
                        res=min(res,j+t);
                    if(j-t>=0)
                        can[j]=can[j]|can[j-t];
                }
            }
        }
        for(int i=0;i<=res-target;++i)
        {
            if(can[target-i])
                return target-i;
        }
        return res;
    }
};
```