---
title: 细分图的可到达节点
date: 2022-11-26 11:06:03
categories: 机试
math:
tags:
---
<!-- TOC -->

- [细分图的可到达节点](#细分图的可到达节点)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 细分图的可到达节点
[原题](https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/description/)
### 题目描述
给你一个无向图（原始图），图中有 n 个节点，编号从 0 到 n - 1 。你决定将图中的每条边 细分 为一条节点链，每条边之间的新节点数各不相同。

图用由边组成的二维数组 edges 表示，其中 edges[i] = [ui, vi, cnti] 表示原始图中节点 ui 和 vi 之间存在一条边，cnti 是将边 细分 后的新节点总数。注意，cnti == 0 表示边不可细分。

要 细分 边 [ui, vi] ，需要将其替换为 (cnti + 1) 条新边，和 cnti 个新节点。新节点为 x1, x2, ..., xcnti ，新边为 [ui, x1], [x1, x2], [x2, x3], ..., [xcnti+1, xcnti], [xcnti, vi] 。

现在得到一个 新的细分图 ，请你计算从节点 0 出发，可以到达多少个节点？如果节点间距离是 maxMoves 或更少，则视为 可以到达 。

给你原始图和 maxMoves ，返回 新的细分图中从节点 0 出发 可到达的节点数 。

示例
```
输入：edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4
输出：23
```
### 思路

这道题看了一遍题没太看懂，本来想直接cv了:cry:，看了眼题解发现是最短路，就参考大佬灵茶山的题解写了，顺便复习一下堆优化的dijkstra和链式前向星存图

[链接](https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/solutions/1991509/tu-jie-zhuan-huan-cheng-dan-yuan-zui-dua-6l8o/)

* 首先需要进行一边dijkstra，求出0到其他点的最短路
* 遍历所有顶点，小于maxmoves则`++ans`
* 遍历所有边，设一条边的起点和终点为u和v，分别用maxmoves减去`dis[u]`和`dis[v]`得到a和b,这条边上符合要求的点个数即为`min(a+b,cnt)`,加入到ans中即可
### 代码
```
class Solution {
public:
    int dis[3005];
    bool vis[3005];
    static const int N=1e5+5;
    int head[N];
    int cnt;
    struct edges
    {
        int to,next,w;
    }e[2*N];

    struct node
    {
        int n,w;
        node(int nn,int ww):n(nn),w(ww){}
        bool operator < (const node & t) const{
            return w>t.w;
        }
    };
    priority_queue<node> q;
    void add(int u,int v,int w)
    {
        ++cnt;
        e[cnt].to=v;
        e[cnt].w=w;
        e[cnt].next=head[u];
        head[u]=cnt;
    }
    int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) 
    {
        for (auto &e: edges) 
        {
            int u = e[0], v = e[1], cnt = e[2];
            add(u,v,cnt+1);
            add(v,u,cnt+1);
        }
        memset(dis,0x3f,sizeof(dis));
        int u,v,w;
        dis[0]=0;
        q.push(node(0,0));
        while(!q.empty())
        {
            node t=q.top();
            q.pop();
            u=t.n;
            if(!vis[u])
            {
                vis[u]=true;
                for(int i=head[u];i;i=e[i].next)
                {
                    v=e[i].to;
                    w=e[i].w;
                    if(dis[u]+w<dis[v])
                    {
                        dis[v]=dis[u]+w;
                        if(!vis[v])
                            q.push(node(v,dis[v]));
                    }
                }
            }
        }
        int ans=0;
        // return dis[2];
        for(int i=0;i<n;++i)
        {
            if(dis[i]<=maxMoves)
                ++ans;
        }

        for (auto &e: edges) 
        {
            int u = e[0], v = e[1], cnt = e[2];
            int a=max(maxMoves-dis[u],0);
            int b=max(maxMoves-dis[v],0);
            ans+=min(a+b,cnt);
        }
        return ans;
    }
};
```