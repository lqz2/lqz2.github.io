---
title: 常见问题
date: 2022-08-26 21:10:10
categories: 学习
math: true
tags:
---
<!-- TOC -->

- [Java](#java)
    - [JDK、JRE和JVM是什么？](#jdkjre和jvm是什么)
        - [JDK](#jdk)
        - [JRE](#jre)
        - [JVM](#jvm)
    - [字节码](#字节码)
    - [为什么说Java“编译与解释共存”？](#为什么说java编译与解释共存)
    - [AOT和JIT](#aot和jit)
    - [JVM内存区域](#jvm内存区域)
        - [程序计数器](#程序计数器)
        - [虚拟机栈](#虚拟机栈)
        - [本地方法栈](#本地方法栈)
        - [堆](#堆)
        - [方法区](#方法区)
        - [运行时常量池和字符串常量池](#运行时常量池和字符串常量池)
        - [直接内存](#直接内存)
        - [为什么要将永久代替换为元空间？](#为什么要将永久代替换为元空间)
    - [类加载](#类加载)
        - [什么是类加载器，类加载器有哪些？](#什么是类加载器类加载器有哪些)
        - [什么是双亲委派机制？为什么要用双亲委派机制？](#什么是双亲委派机制为什么要用双亲委派机制)
        - [JVM类加载的过程](#jvm类加载的过程)
    - [JVM垃圾回收](#jvm垃圾回收)
        - [内存分配和回收原则](#内存分配和回收原则)
        - [MinorGC、MixedGC、FullGC的区别是什么？](#minorgcmixedgcfullgc的区别是什么)
        - [FullGC什么时候触发？](#fullgc什么时候触发)
        - [死亡对象的判断方法](#死亡对象的判断方法)
        - [GC Roots包括哪些？](#gc-roots包括哪些)
        - [垃圾回收算法](#垃圾回收算法)
        - [垃圾回收器有哪些？](#垃圾回收器有哪些)
        - [详细介绍一下G1垃圾回收器](#详细介绍一下g1垃圾回收器)
        - [垃圾回收器CMS和G1的区别?](#垃圾回收器cms和g1的区别)
        - [如何选择合适的垃圾回收器？](#如何选择合适的垃圾回收器)
    - [JVM调优的参数有哪些？有哪些工具？](#jvm调优的参数有哪些有哪些工具)
    - [Java内存泄漏的排查思路？](#java内存泄漏的排查思路)
    - [CPU飙升的排查思路？](#cpu飙升的排查思路)
    - [JMM](#jmm)
        - [什么是JMM?](#什么是jmm)
        - [为什么说JMM抽象了线程和主内存之间的关系？](#为什么说jmm抽象了线程和主内存之间的关系)
        - [happens-before原则是什么？](#happens-before原则是什么)
    - [基础数据类型](#基础数据类型)
    - [有一个学生类，想按照分数排序，再按学号排序，应该怎么做？](#有一个学生类想按照分数排序再按学号排序应该怎么做)
    - [Java集合](#java集合)
        - [数组和集合的区别？](#数组和集合的区别)
        - [ArrayList和LinkedList的区别？](#arraylist和linkedlist的区别)
        - [List中遍历删除元素会有哪些问题？](#list中遍历删除元素会有哪些问题)
        - [ArrayList的扩容机制是什么？](#arraylist的扩容机制是什么)
        - [CopyonWriteArraylist是如何实现线程安全的？](#copyonwritearraylist是如何实现线程安全的)
        - [HashMap实现原理介绍一下？](#hashmap实现原理介绍一下)
        - [HashMap为什么线程不安全？](#hashmap为什么线程不安全)
        - [解决哈希冲突的方法有哪些？](#解决哈希冲突的方法有哪些)
        - [HashMap的put过程？](#hashmap的put过程)
        - [为什么HashMap用红黑树不用平衡二叉树？](#为什么hashmap用红黑树不用平衡二叉树)
        - [HashMap key可以为null吗？](#hashmap-key可以为null吗)
        - [重写HashMap的equals和hashCode方法时，要注意什么？](#重写hashmap的equals和hashcode方法时要注意什么)
        - [为什么HashMap的大小是2的幂次方？](#为什么hashmap的大小是2的幂次方)
        - [ConcurrentHashMap是如何实现线程安全的？](#concurrenthashmap是如何实现线程安全的)
        - [分段锁是怎么加锁的？](#分段锁是怎么加锁的)
        - [ConcurrentHashMap用的是乐观锁还是悲观锁？](#concurrenthashmap用的是乐观锁还是悲观锁)
        - [hashtable和ConcurrentHashMap的区别？](#hashtable和concurrenthashmap的区别)
    - [面向对象](#面向对象)
        - [面向对象的设计原则有哪些？](#面向对象的设计原则有哪些)
        - [抽象类和接口的区别](#抽象类和接口的区别)
        - [抽象类可以被实例化吗？](#抽象类可以被实例化吗)
        - [Java深拷贝的方式有哪些？](#java深拷贝的方式有哪些)
    - [Java中的对象](#java中的对象)
        - [Java中创建对象有哪些方式？](#java中创建对象有哪些方式)
        - [new的对象什么时候回收？](#new的对象什么时候回收)
    - [反射机制](#反射机制)
        - [什么是反射机制？](#什么是反射机制)
        - [反射在你平时写代码或者框架中的应用场景有哪些?](#反射在你平时写代码或者框架中的应用场景有哪些)
    - [Java注解的原理](#java注解的原理)
    - [== 与 equals 有什么区别？](#-与-equals-有什么区别)
    - [StringBuffer和StringBuilder区别是什么？](#stringbuffer和stringbuilder区别是什么)
    - [并发](#并发)
        - [线程安全体现在哪些方面？](#线程安全体现在哪些方面)
        - [什么是CAS操作？](#什么是cas操作)
        - [CAS的缺点？](#cas的缺点)
        - [线程创建方式有哪些？](#线程创建方式有哪些)
        - [如何停止线程？](#如何停止线程)
        - [sleep和wait的区别？](#sleep和wait的区别)
        - [线程的状态有哪些？](#线程的状态有哪些)
        - [blocked和waiting的区别？](#blocked和waiting的区别)
        - [notify和notifyAll的区别？](#notify和notifyall的区别)
        - [写一段代码，实现线程交替打印奇偶数](#写一段代码实现线程交替打印奇偶数)
        - [怎么保证多线程安全？](#怎么保证多线程安全)
        - [java中有哪些常用的锁？使用场景是什么？](#java中有哪些常用的锁使用场景是什么)
        - [什么是公平锁和非公平锁？](#什么是公平锁和非公平锁)
        - [讲讲ReentrantLock？](#讲讲reentrantlock)
        - [synchronized和ReentrantLock的的应用场景有什么不同？](#synchronized和reentrantlock的的应用场景有什么不同)
        - [synchronized和ReentrantLock的区别？](#synchronized和reentrantlock的区别)
        - [介绍一下AQS?](#介绍一下aqs)
        - [volatile关键字的作用？](#volatile关键字的作用)
        - [死锁产生的条件？](#死锁产生的条件)
        - [线程池的提交任务流程？](#线程池的提交任务流程)
        - [线程池的参数有哪些？](#线程池的参数有哪些)
        - [线程池的拒绝策略有哪些？](#线程池的拒绝策略有哪些)
        - [核心线程数如何设置？](#核心线程数如何设置)
        - [线程池种类有哪些？](#线程池种类有哪些)
        - [线程池的阻塞队列有哪些？](#线程池的阻塞队列有哪些)
        - [多线程顺序执行的几种写法?](#多线程顺序执行的几种写法)
        - [线程池中shutdown和shutdownNow的区别？](#线程池中shutdown和shutdownnow的区别)
        - [提交给线程池的任务可以被撤回吗？](#提交给线程池的任务可以被撤回吗)
        - [线程池用到了哪些设计模式？](#线程池用到了哪些设计模式)
        - [ThreadLocal为什么会发生内存泄漏？](#threadlocal为什么会发生内存泄漏)
        - [ThreadLocal的继承性问题以及解决方法？](#threadlocal的继承性问题以及解决方法)
        - [CompletableFuture怎么用？](#completablefuture怎么用)
    - [MyBatis](#mybatis)
        - [MyBatis中#{}和${}的区别？](#mybatis中和的区别)
        - [MyBatis的延迟加载及其原理？](#mybatis的延迟加载及其原理)
        - [MyBatis的一级缓存和二级缓存的区别？](#mybatis的一级缓存和二级缓存的区别)
    - [MYSQL](#mysql)
        - [SQL注入是什么？举个例子？](#sql注入是什么举个例子)
        - [mysql的事务隔离级别](#mysql的事务隔离级别)
            - [事务的四个特性](#事务的四个特性)
            - [事务隔离解决的问题](#事务隔离解决的问题)
            - [事务隔离级别](#事务隔离级别)
        - [MYSQL具体怎么解决脏读、不可重复读、幻读的？](#mysql具体怎么解决脏读不可重复读幻读的)
        - [MYSQL的有哪几种引擎？](#mysql的有哪几种引擎)
        - [MYSQL了解哪些日志？](#mysql了解哪些日志)
        - [undolog和redolog的区别？](#undolog和redolog的区别)
        - [介绍一下redo log?](#介绍一下redo-log)
        - [redo log刷盘的时机](#redo-log刷盘的时机)
        - [介绍一下bin log？](#介绍一下bin-log)
        - [MYSQL怎么连表查询？](#mysql怎么连表查询)
        - [如何避免重复插入数据？](#如何避免重复插入数据)
        - [in和exists的区别？](#in和exists的区别)
        - [mysql的执行过程？](#mysql的执行过程)
        - [SQL查询语句的执行顺序？](#sql查询语句的执行顺序)
        - [为什么InnoDB是默认存储引擎？](#为什么innodb是默认存储引擎)
        - [InnoDB和MyISAM的区别？](#innodb和myisam的区别)
        - [索引的分类？](#索引的分类)
        - [聚簇索引选取的依据是什么？](#聚簇索引选取的依据是什么)
        - [聚簇索引和非聚簇索引的区别？](#聚簇索引和非聚簇索引的区别)
        - [B+树的特性？](#b树的特性)
        - [B+树和B树的区别？](#b树和b树的区别)
        - [为什么MYSQL不用跳表？](#为什么mysql不用跳表)
        - [为什么自增ID快一些？为什么不用UUID？](#为什么自增id快一些为什么不用uuid)
        - [什么是覆盖索引？超大分页怎么解决？](#什么是覆盖索引超大分页怎么解决)
        - [创建联合索引要注意什么？](#创建联合索引要注意什么)
        - [索引失效有那些情况？](#索引失效有那些情况)
        - [mysql如何定位慢查询？](#mysql如何定位慢查询)
        - [慢查询如何解决？](#慢查询如何解决)
        - [索引的缺点](#索引的缺点)
        - [什么时候适合建立索引？](#什么时候适合建立索引)
        - [什么时候不需要索引？](#什么时候不需要索引)
        - [如何对索引进行优化？](#如何对索引进行优化)
        - [事务的四个特性是如何实现的？](#事务的四个特性是如何实现的)
        - [讲讲MVCC?](#讲讲mvcc)
        - [当前读和快照读的区别？](#当前读和快照读的区别)
        - [MVCC的ReadView介绍一下？](#mvcc的readview介绍一下)
        - [事务特别多有哪些弊端？](#事务特别多有哪些弊端)
        - [MYSQL里有哪些锁？](#mysql里有哪些锁)
        - [MYSQL主从复制过程？](#mysql主从复制过程)
        - [主从延迟有哪些解决方法？](#主从延迟有哪些解决方法)
        - [分库和分表的区别？](#分库和分表的区别)
    - [Redis](#redis)
        - [Redis的数据结构以及应用场景？](#redis的数据结构以及应用场景)
            - [String](#string)
            - [List:](#list)
            - [Hash](#hash)
            - [Set](#set)
            - [zset](#zset)
            - [Bitmap](#bitmap)
            - [hyperloglog](#hyperloglog)
            - [GEO](#geo)
            - [Stream](#stream)
        - [redis的string实现原理](#redis的string实现原理)
        - [为什么Redis用跳表而不是B+树？](#为什么redis用跳表而不是b树)
        - [跳表的层数是怎么设置的？](#跳表的层数是怎么设置的)
        - [Redis的哈希表是怎么扩容的？](#redis的哈希表是怎么扩容的)
        - [Redis为什么快？](#redis为什么快)
        - [Redis哪里用到了多线程？](#redis哪里用到了多线程)
        - [IO多路复用怎么实现？](#io多路复用怎么实现)
        - [如何实现Redis的原子性？](#如何实现redis的原子性)
        - [Redis持久化之AOF？](#redis持久化之aof)
        - [AOF重写机制？](#aof重写机制)
        - [Redis持久化之RDB?](#redis持久化之rdb)
        - [bgsave时，数据能被修改吗？](#bgsave时数据能被修改吗)
        - [AOF和RDB的优缺点？](#aof和rdb的优缺点)
        - [讲讲Redis的内存淘汰策略？](#讲讲redis的内存淘汰策略)
        - [Redis的过期删除策略？](#redis的过期删除策略)
        - [为什么不立刻删除过期key？](#为什么不立刻删除过期key)
        - [Redis全量同步？](#redis全量同步)
        - [Redis增量同步？](#redis增量同步)
        - [介绍一下Redis哨兵机制？](#介绍一下redis哨兵机制)
        - [哨兵机制如何监控？](#哨兵机制如何监控)
        - [哨兵如何选择新的主服务器？](#哨兵如何选择新的主服务器)
        - [介绍一下分片集群？](#介绍一下分片集群)
        - [Redis分布式锁的原理？](#redis分布式锁的原理)
            - [加锁](#加锁)
            - [解锁](#解锁)
        - [redis实现的分布式锁有什么问题？](#redis实现的分布式锁有什么问题)
        - [redis分布式锁的互斥性问题怎么解决？](#redis分布式锁的互斥性问题怎么解决)
        - [基于redis实现分布式锁如何自动续期？](#基于redis实现分布式锁如何自动续期)
        - [什么是大Key问题？](#什么是大key问题)
        - [如何解决大Key问题？](#如何解决大key问题)
        - [如何解决热key问题？](#如何解决热key问题)
        - [缓存雪崩如何解决？](#缓存雪崩如何解决)
        - [如何设计秒杀场景处理高并发和超卖问题？](#如何设计秒杀场景处理高并发和超卖问题)
        - [如何处理重复下单问题？](#如何处理重复下单问题)
            - [基础性解决方案](#基础性解决方案)
            - [综合性解决方案](#综合性解决方案)
        - [如何保证双写一致性？](#如何保证双写一致性)
    - [介绍一下雪花算法？](#介绍一下雪花算法)
    - [动态代理](#动态代理)
        - [什么是动态代理？](#什么是动态代理)
        - [JDK动态代理的实现步骤？](#jdk动态代理的实现步骤)
        - [CGLIB动态代理的实现步骤？](#cglib动态代理的实现步骤)
    - [自定义注解的三个注解的含义？](#自定义注解的三个注解的含义)
    - [AOP](#aop)
        - [什么是AOP？](#什么是aop)
        - [AOP的一些术语有哪些？](#aop的一些术语有哪些)
        - [AOP的通知都有哪些类型？](#aop的通知都有哪些类型)
        - [AOP的应用场景？](#aop的应用场景)
        - [AOP实现日志记录怎么做？](#aop实现日志记录怎么做)
    - [设计模式](#设计模式)
        - [创建型模式](#创建型模式)
        - [结构型模式](#结构型模式)
        - [行为型模式](#行为型模式)
        - [实现一个单例模式](#实现一个单例模式)
    - [消息队列](#消息队列)
        - [消息队列怎么选型？](#消息队列怎么选型)
        - [消息队列的应用场景有哪些？](#消息队列的应用场景有哪些)
        - [消息丢失怎么解决？](#消息丢失怎么解决)
        - [消息队列的可靠性、顺序性怎么保证？](#消息队列的可靠性顺序性怎么保证)
    - [Spring](#spring)
        - [Spring的单例Bean是线程安全的吗？](#spring的单例bean是线程安全的吗)
        - [Spring中的事务是如何实现的？](#spring中的事务是如何实现的)
        - [Bean的生命周期？](#bean的生命周期)
        - [Bean的循环依赖怎么解决？](#bean的循环依赖怎么解决)
    - [介绍一下CAP和BASE理论](#介绍一下cap和base理论)
    - [介绍一下TCC模式](#介绍一下tcc模式)
    - [定时任务有哪些实现方式？](#定时任务有哪些实现方式)
    - [认证授权](#认证授权)
        - [介绍一下RBAC模型？](#介绍一下rbac模型)
- [CS基础](#cs基础)
    - [进程和线程的区别](#进程和线程的区别)
    - [硬链接和软链接的区别](#硬链接和软链接的区别)
        - [硬链接](#硬链接)
        - [软链接（符号链接）](#软链接符号链接)
        - [为什么硬连接不能跨文件系统？](#为什么硬连接不能跨文件系统)
    - [动态编译和静态编译](#动态编译和静态编译)
        - [静态编译](#静态编译)
        - [动态编译(运行时编译)](#动态编译运行时编译)
    - [TCP三次握手](#tcp三次握手)
        - [三次握手](#三次握手)
        - [为什么要三次握手？](#为什么要三次握手)
        - [第二次发送了ACK，为什么还要发送SYN？](#第二次发送了ack为什么还要发送syn)
        - [三次握手过程可以携带数据吗？](#三次握手过程可以携带数据吗)
    - [TCP四次挥手](#tcp四次挥手)
        - [四次挥手](#四次挥手)
        - [为什么要四次挥手？](#为什么要四次挥手)
        - [为什么服务端不把 ACK 和 FIN 一起发送，变成三次挥手？](#为什么服务端不把-ack-和-fin-一起发送变成三次挥手)
        - [第二次挥手服务端发送ACK没有到达会怎么样？](#第二次挥手服务端发送ack没有到达会怎么样)
        - [为什么第四次挥手，客户端要等待 2MSL（报文最长存活时间）才进入CLOSED状态？](#为什么第四次挥手客户端要等待-2msl报文最长存活时间才进入closed状态)
- [C++](#c)
    - [c++中的static关键字](#c中的static关键字)
    - [c++模板](#c模板)
    - [c++深拷贝和浅拷贝的区别](#c深拷贝和浅拷贝的区别)
    - [c++多态](#c多态)
    - [虚函数与纯虚函数](#虚函数与纯虚函数)
    - [c++智能指针](#c智能指针)
    - [const 和 volatile辨析](#const-和-volatile辨析)
    - [NULL 和 nullptr的区别是什么，为什么引入nulllptr？](#null-和-nullptr的区别是什么为什么引入nulllptr)
    - [git fetch和git pull的区别](#git-fetch和git-pull的区别)
    - [delete[]是怎样知道数组长度的？](#delete是怎样知道数组长度的)
    - [程序是从main 函数开始执行的吗？](#程序是从main-函数开始执行的吗)
- [python](#python)
    - [python的垃圾回收机制](#python的垃圾回收机制)
- [deep learning](#deep-learning)
    - [判别模型和生成模型](#判别模型和生成模型)
    - [转置卷积和空洞卷积](#转置卷积和空洞卷积)
    - [数据集不平衡的处理方式](#数据集不平衡的处理方式)
    - [tensorflow和pytorch的区别](#tensorflow和pytorch的区别)
    - [transformer中的位置编码](#transformer中的位置编码)
    - [自注意力和注意力的区别](#自注意力和注意力的区别)

<!-- /TOC -->
# Java
## JDK、JRE和JVM是什么？
### JDK
JDK（Java Development Kit）是一个功能齐全的 Java 开发工具包，供开发者使用，用于创建和编译 Java 程序。
它包含了 JRE（Java Runtime Environment），以及编译器 javac 和其他工具，如 javadoc（文档生成器）、jdb（调试器）、jconsole（监控工具）、javap（反编译工具）等。

### JRE
JRE 是运行已编译 Java 程序所需的环境，主要包含以下两个部分：
- JVM : 也就是我们上面提到的 Java 虚拟机。
- Java 基础类库（Class Library）：一组标准的类库，提供常用的功能和 API（如 I/O 操作、网络通信、数据结构等）。

### JVM
Java 虚拟机（Java Virtual Machine, JVM）是运行 Java 字节码的虚拟机。
JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。
字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。
不同编程语言（Java、Groovy、Kotlin、JRuby、Clojure ...）通过各自的编译器编译成 .class 文件，并最终通过 JVM 在不同平台（Windows、Mac、Linux）上运行。

## 字节码
在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。
Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。

Java程序运行流程如下图:
![Java程序运行流程](https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png)

需要格外注意的是 .class->机器码 这一步。
- 在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。
- 而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（Just in Time Compilation） 编译器，而 JIT 属于运行时编译。
- 当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。
- 机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言 。

## 为什么说Java“编译与解释共存”？

- 编译型语言：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。
- 解释型语言：解释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。

Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。

## AOT和JIT
- AOT（Ahead of Time）：提前编译，是指在程序运行之前，将字节码编译成机器码，然后直接运行机器码。这样做的好处是可以提高程序的启动速度，减少内存占用。

- JIT(Just in Time)：即时编译，是指在程序运行时，将热点代码（被频繁调用的代码）编译成机器码，然后再执行。这样做的好处是可以提高程序的执行效率。

为什么AOT没有完全代替JIT?
- AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。但是，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载等，很多框架和库都用到了这些特性。只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。



## JVM内存区域
JVM 在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域，主要包括以下几个区域：
- 线程私有的：程序计数器、虚拟机栈、本地方法栈
- 线程共享的：堆、方法区、直接内存

### 程序计数器
- 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
- 多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

>程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

### 虚拟机栈
- 虚拟机栈由一个个栈帧组成，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。

### 本地方法栈
- 本地方法栈和虚拟机栈所发挥的作用相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法(非Java语言编写的方法)服务。

### 堆
- 堆是 Java 虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，几乎所有的对象实例都在这里分配内存。
- 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”。
- 在jdk7及以前，堆中内存被分为新生代、老年代和永久代，实际上永久代处于方法区，与堆是隔离的，但是内存上是连续的。在jdk8中，**永久代被元空间取代**，元空间位于本地内存，因此堆中主要分为新生代和老年代。

### 方法区
- 方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域
- 当JVM要使用一个类时，会检查并解析字节码文件的相关信息，并将信息存储在方法区中

### 运行时常量池和字符串常量池
- 常量池表主要存放编译期生成的各种字面量和符号引用。
- 字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

jdk7中，运行时常量池存放在方法区中，而字符串常量池存放在堆中。在jdk8中，运行时常量池存放在元空间中。

### 直接内存
- 直接内存并不是虚拟机运行时数据区的一部分，也不是JVM中定义的内存区域。
- 直接内存是本地内存的一部分，本地内存包括直接内存和元空间

### 为什么要将永久代替换为元空间？
- 永久代有一个 JVM 本身设置的固定上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
- 永久代会为 GC 带来不必要的复杂度，例如永久代的 GC 会因为频繁的类加载而导致 Full GC，而元空间的 GC 将会更简单高效。

## 类加载

### 什么是类加载器，类加载器有哪些？
类加载器的作用是将字节码文件加载到JVM中，从而让Java程序启动起来
类加载器一共有四种：
- 启动类加载类BootStrap ClassLoader：负责加载Java的核心类库，通常是`JAVA_HOME/jre/lib/`下的库
- 扩展类加载器Extension ClassLoader：负责加载Java的扩展类库，通常是`JAVA_HOME/jre/lib/ext/`下的库
- 应用类加载器Application ClassLoader：负责加载用户类路径下的类，通常是`CLASSPATH`下的库
- 自定义类加载器：用户可以自定义类加载器

### 什么是双亲委派机制？为什么要用双亲委派机制？
加载某一个类时，会委托上一级的类加载器去加载，如果上级也有上级，则一直到上级去尝试加载，如果上级类加载器无法加载，才由当前类加载器去加载。

JVM使用双亲委派的原因：
- 避免类的重复加载，当父类已经加载后，子类就无需加载了
- 为了安全，保证核心类库的API不会被修改


### JVM类加载的过程
- 加载，即加载字节码文件
- 验证，确保字节码文件符合 JVM 规范
- 准备，为变量分配内存并设置初始值
- 解析，把类中的符号引用变为直接引用
- 初始化，为静态变量和静态代码块进行初始化
- 使用
- 卸载

## JVM垃圾回收
在堆的新生代中，由Eden 区、两个 Survivor 区组成， 两个 Survivor 区中包括S0 和 S1。
### 内存分配和回收原则
- 对象优先在 Eden 区分配，当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC，Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。
- 大对象直接进入老年代，大对象是指需要大量连续内存空间的对象，比如一个很长的字符串或数组。
- 长期存活的对象将进入老年代，虚拟机给每个对象定义了一个年龄计数器，对象在 Eden 区出生后，经过一次 Minor GC 仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 区，并且年龄设为 1，对象在 Survivor 区每熬过一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代。

### MinorGC、MixedGC、FullGC的区别是什么？
- MinorGC：发生在新生代的垃圾回收，回收停顿时间短。
- MixedGC：新生代+老年代部分区域的垃圾回收，G1回收器特有
- FullGC：新生代+老年代完整区域的垃圾回收，回收停顿时间长

### FullGC什么时候触发？
- 显式调用 System.gc()，建议JVM进行FullGC，但是不一定会执行
- 未设置堆的初始化大小
- 老年代空间不足，无法分配对象

### 死亡对象的判断方法
- 引用计数法：当对象被引用时，计数器加 1，当引用失效时，计数器减 1，当计数器为 0 时，说明对象不再被引用，可以被回收。但这种方法无法解决循环引用的问题。
- 可达性分析法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。即GC roots到某个对象不可达，则说明此对象是可以被回收的。
- 即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；

### GC Roots包括哪些？
- 全局性引用，如对方法区的静态属性、常量引用的对象
- 执行上下文，如本地方法栈中的引用的对象
- 已经启动且未停止的线程

### 垃圾回收算法
- 标记-清除算法：标记出所有活动对象，然后统一回收未标记对象。这种算法会产生大量不连续的内存碎片，导致以后在分配大对象时可能出现内存不足的情况。
- 复制算法：将内存分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，就将还存活的对象复制到另一块上面，然后把已使用的内存空间一次清理掉。这种算法没有内存碎片问题，但是会浪费一半的内存空间。
- 标记-整理算法：标记出所有活动对象，然后将存活的对象向一端移动，然后直接清理掉端边界以外的内存。这种算法没有内存碎片问题，也不会浪费内存，但是需要移动对象，所以比较耗时。
- 分代收集算法：根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，新生代由于每次收集会有大量对象死去，所以可选用复制算法，而老年代因为对象存活率高，所以可选用标记清除或标记整理算法。

### 垃圾回收器有哪些？
- Serial收集器 (复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；
- ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；
- Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；
- Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；
- Parallel Old收集器 (标记-整理算法): 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；
- CMS(Concurrent Mark Sweep)收集器 (标记-清除算法): 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。
- G1(Garbage First)收集器 (标记-整理算法): Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。
- ZGC: 低延迟垃圾收集器，回收停顿时间小于1ms，支持超大堆内存，适用于大规模服务


### 详细介绍一下G1垃圾回收器
G1垃圾回收器中，划分了多个区域，每个区域都可以充当eden区、survivor区和老年代

主要分3个阶段：
- 年轻代垃圾回收
当产生了一些对象，这些对象先被分配到eden区，当需要进行垃圾回收时，会进行minorGC，将存活的对象标记出来，复制到survivor区，标记和复制过程中，都会触发STW(stop the world)，但时间会很短，多次minorGC中还存活的对象会被放入老年代
- 并发标记阶段
当老年代内存超过阈值后，会进行并发标记，标记存活的对象，并发标记不会触发STW
- 混合收集阶段
混合收集阶段既进行年轻代的收集，又进行老年代的收集。因为G1回收器有一个**预设的回收停顿时间**，为了保证不超过这个时间，在进行老年代收集时，会优先收集回收价高的区域(存活对象少)。
- 如果回收速度赶不上创建对象的速度，会触发Full GC，回收时间会比较长。

### 垃圾回收器CMS和G1的区别?
1. 使用范围不同，CMS主要用于老年代收集，G1可以收集老年代和新生代
2. CMS基于“标记-清除”算法实现，G1基于“标记-整理”算法实现
3. CMS以最小停顿时间为目标，G1可设置垃圾回收的停顿时间
使用场景不同：
- CMS适合低延迟、老年代收集、对内存碎片不敏感的场景
- G1适合大堆内存，对内存碎片敏感，需要平衡性能的场景

### 如何选择合适的垃圾回收器？
- 小堆+单核心CPU使用Serial
- 高吞吐量（批处理任务）使用Parallel
- 低延迟应用使用CMS
- 大堆（大于10G）内存+综合场景使用G1
- 超大堆（大于100G）+低延迟使用ZGC




## JVM调优的参数有哪些？有哪些工具？

参数主要有：
- 堆的大小Xms和Xmx,分别表示初始堆大小和最大堆大小
- 虚拟机栈大小-Xss，一般256k或512k
- Eden区和两个Survivor区的比例，默认是8:1:1
- 新生代晋升老年代的阈值，不超过15
- 垃圾回收器的选择

工具主要有：
- jps：类似ps
- jstat：查看JVM的运行状态
- jmap：查看堆的内存快照
- jstack：查看线程的堆栈信息
- VisualVM：可视化工具，查看JVM的运行状态和内存使用情况

## Java内存泄漏的排查思路？
内存泄漏通常指的是堆上的一些对象没有被回收
排查思路如下：
- 通过jmap获取堆的内存快照dump
- 通过VisualVM分析dump文件
- 查看堆中信息，定位出问题的代码

## CPU飙升的排查思路？
- 先通过top查看那个进程占用cpu最高，获取他的进程id
- 通过ps和grep查看进程中的线程信息，找到占用cpu最高的线程id
- 通过jstack查看进程，定位出问题的代码


## JMM 
### 什么是JMM?
JMM指的是java内存模型，它定义了java并发编程相关的一些规范，抽象了线程和主内存之间的关系，主要目的是为了规范和简化并发编程。
### 为什么说JMM抽象了线程和主内存之间的关系？
- 线程之间的共享变量必须存储在主内存中
- 每个线程都有自己的本地内存，本地内存中主内存中共享变量的副本，线程只能操作本地内存中的变量，不能直接操作主内存中的变量。
- 线程之间的通信必须通过主内存来完成。

### happens-before原则是什么？
是一种设计思想，主要用于解决多线程之间的可见性和有序性问题。
他的设计思想是：
- 只要不改变程序的执行结果，编译器和处理器怎么进行重排序优化都行。
- 对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序


## 基础数据类型
java中八种基础数据类型如下图：
![基础数据类型](https://cdn.xiaolincoding.com//picgo/1715930589177-73932d2c-b0c0-4f58-a5c1-ab514b1a389c.png)

值得注意的是：
- 1个字节的有boolean和byte,2个字节的有short和char,4个字节的有int和float,8个字节的有long和double。
- 浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）。
- 整数的默认类型为int（声明Long型在末尾加上l或者L）
- 8种基本类型的包装类，除了char是Character，int是Integer，其余的都是首字母大写。
- char是无符号的，最小值是0

long和int可以互转吗？
答：可以，long的范围更大，int可以直接赋值给long,long转int需要强制类型转换。

字节支付实习一面：String类可以被继承吗？
答：String类是final类，不可以被继承。所有基本数据类型对应的包装类都是final类，不可以被继承。

为什么用bigDecimal 不用double ？
答：double类型是不精确的，因为double类型是采用二进制浮点数进行计算的，而二进制浮点数无法精确表示大部分的十进制小数，所以在计算时会有精度丢失的问题。而BigDecimal是采用十进制浮点数进行计算的，可以精确表示大部分的十进制小数。

为什么要有Integer？
答：Integer是int的包装类，封装之后包含一些数据处理的方法，便于处理数据;
Java中大部分方法和类以及集合只能处理类型对象，比如ArrayList；
基本类型和引用类型不能直接转换，比如int要转为String类需要先专程Integer。

## 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？
答：可以让学生类实现Comparable接口，重写compareTo方法，然后在compareTo方法中按照分数排序，再按照学号排序。

```
public class Student implements Comparable<Student>{

    public int compareTo(Student t){
        if(this.score!=t.score){
            return Integer.compare(t.score,this.score); //按分数降序
        }else{
            return Integer.compare(this.id,t.id); //分数相同按学号升序
        }
    }
}
List<Student> st = new ArrayList<>();
Collections.sort(st);
```
## Java集合
### 数组和集合的区别？
- 数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素。
- 数组可以包含基本数据类型和对象，而集合只能包含对象。
- 数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。

### ArrayList和LinkedList的区别？
- ArrayList基于数组，而LinkedList基于链表实现。
- 插入删除、随机访问效率不同
- ArrayList创建时要分配一段连续空间，占用空间更大
- 前者适合需要频繁随机访问的场景，后者适合需要频繁插入删除的场景。

### List中遍历删除元素会有哪些问题？
- 使用for循环按照下标删除元素时，会导致后面的元素向前移动，导致元素漏删。
- 如果使用iterator遍历删除元素，使用list的remove方法，会抛出ConcurrentModificationException异常。
这是因为，List自身会维护一个modCount计数器，使用`list.remove()`方法时，会修改modCount，而iterator在创建时会记录最开始的modCount，如果遍历过程中iterator检查到modCount不一致，就会抛出异常。

- 正确的删除方法是使用iterator的remove方法，这样不会抛出异常。

### ArrayList的扩容机制是什么？
如果当前元素数量达到内部数组容量上限，就会触发扩容机制。分以下几步骤：
- 计算新的容量，一般会扩大1.5倍
- 创建新的数组
- 将旧数组元素复制到新数组
- 更新引用指向新数组

之所以扩容是 1.5 倍，是因为 1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。

### CopyonWriteArraylist是如何实现线程安全的？
- CopyonWriteArraylist底层也是通过一个数组保存数据，使用volatile修饰，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。
- 对读操作没有加锁，对写操作加了一个ReentrantLock锁，保证写操作的线程安全。

### HashMap实现原理介绍一下？
- 早期HashMap是数组+链表，通过哈希算法将元素映射到数组中，如果发生冲突，就会在链表中存储多个元素，当链表元素过多查询效率会降低很多。
- JDK1.8之后，HashMap引入了红黑树，当链表长度超过8时，链表会转换为红黑树，提高查询效率（查询复杂度`log n`）,数量少于6会转回链表。

### HashMap为什么线程不安全？
HashMap线程不安全主要是由于多个线程对HashMap的put操作引起的，有下面两种情况：
- 一种是两个线程同时put，假如线程1先完成了哈希冲突判断后，时间片耗尽挂起，线程2进行哈希冲突判断然后put，如果发生了哈希冲突，线程1是感知不到的，它轮到时间片后会继续put,这样导致了数据覆盖。
- 一种是两个线程同时put,同时读到当前size为10，这样线程1读完size后时间片耗尽挂起，线程2完成put,size变为11，线程1继续执行put，size还是改成11，这样导致增加了两个元素，但size只增加了1。

### 解决哈希冲突的方法有哪些？
- 链地址法：将哈希冲突的元素存储的在链表或其他数据结构中
- 开放寻址法：找到另一个可用的位置来存储，包括线性探测、二次探测、双重散列等。
- 再哈希法：使用另一个哈希函数计算新的哈希值。
- 哈希桶扩容：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对。

### HashMap的put过程？
1. 计算要添加的key的哈希值，找到在数组中的索引
2. 如果该索引位置没有元素，直接添加
3. 如果该索引位置有元素，检查key是否相等，如果相等，直接覆盖value，如果不相等，发生哈希冲突，通过链表或红黑树中查找这个key，找到则更新value，为找到则添加
4. 检查链表长度是否超过8，超过则转换为红黑树
5. 检查负载因子是否超过0.75，超过则扩容
6. 扩容时，首先创建一个新的数组，大小是原数组的2倍，然后重新计算旧数组的哈希值分配到新数组中，更新引用。

### 为什么HashMap用红黑树不用平衡二叉树？
- 平衡二叉树追求完全平衡的状态，左右子树的高度差不超过1，每次插入删除都需要左旋右旋调整，效率很低
- 红黑树追求一种弱平衡状态，整个树的最长路径不超过最短路径的2倍，插入删除效率更高。
### HashMap key可以为null吗？
答：HashMap的key可以为null，HashMap使用hash()方法计算key的哈希值，如果key为null，哈希值为0。不会去调用hashCode()方法。

### 重写HashMap的equals和hashCode方法时，要注意什么？
- HashMap在比较元素时，一般先比较hashCode，如果hashCode相等，再通过equals方法比较。
- hashCode相等，equals不一定相等，但是equals相等，hashCode一定相等。
- 重写了equals方法，如果不重写hashCode方法，可能会导致相等的两个对象的hashCode不相等，从而导致相同的key被重复添加。

### 为什么HashMap的大小是2的幂次方？
答：为了加速计算以及减少哈希冲突，计算哈希时一般按照`hash(key)%n`计算索引，如果n是2的幂次方，等价于`hash(key)&(n-1)`，这样可以加快计算速度;
此外，这种与运算的方式可以让元素分布更加均匀，减少哈希冲突。

### ConcurrentHashMap是如何实现线程安全的？
ConcurrentHashMap主要通过volatile+CAS或者synchronized来保证线程安全。
添加元素时，先判断容器是否为空？
- 为空则用volatile和CAS来初始化
- 不为空则计算该位置是否为空
    - 为空则用CAS添加元素
    - 不为空则使用synchronized来更新或添加元素

锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。

### 分段锁是怎么加锁的？
- ConcurrentHashMap在JDK1.7之前使用分段锁，将整个数据分为若干个Segment，每个Segment都是一个小的HashMap，每个Segment都有自己的锁，不同 Segment 之间的操作互不影响，从而提高并发性能。
- 当进行增删改操作时，首先定位到具体的Segment，然后对这个Segment加锁，其他Segment不受影响，可以并发操作。

### ConcurrentHashMap用的是乐观锁还是悲观锁？
答：都有用到。
- 初始化时如果容器为空，通过volatile+CAS(乐观锁)初始化
- 如果不为空，则判断元素要添加的位置是否为空，为空则用CAS添加，不为空则用synchronized(悲观锁)添加或更新。

### hashtable和ConcurrentHashMap的区别？
- 从结构上看，hashtable是数组+链表，ConcurrentHashMap是数组+链表/红黑树
- 都是线程安全的，但hashtable所有方法都是synchronized，效率低，ConcurrentHashMap使用volatile+CAS或synchronized，效率更高

## 面向对象

### 面向对象的设计原则有哪些？
- 单一职责原则（SRP）：一个类只负责一个功能领域中的相应职责。
- 开放封闭原则（OCP）：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
- 里氏替换原则（LSP）：子类对象应该能够替换掉所有父类对象。
- 依赖隔离原则（ISP）：客户端不应该依赖那些它不需要的接口，接口应该而专。
- 依赖倒置原则（DIP）：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
- 最少知识原则（迪米特法则，LoD）：一个对象应该对其他对象有最少的了解。

### 抽象类和接口的区别
抽象类：
- 抽象类是包含至少一个抽象方法的类，抽象方法是没有方法体的方法。
- 抽象类可以包含具体的方法（有方法体的），也可以包含成员变量。
- 抽象类可以被继承，一个子类必须实现抽象类中的所有抽象方法，除非该子类也是抽象类。

接口：
- 接口是一个完全抽象的类，所有的方法默认是抽象的（Java 8 后，可以包含默认方法和静态方法）。
- 接口只能包含常量和抽象方法（除非定义了默认方法和静态方法）。

特点：
- 抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。
- 接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。适用于定义类的能力或功能

区别：
- 实现方式：实现接口的关键字为 implements，继承抽象类的关键字为 extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
- 方法方式：接口只有定义，不能有方法的实现，java 1.8 中可以定义 default 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
- 访问修饰符：接口成员变量默认为 public static final，必须赋初值，不能被修改；其所有的成员方法都是 public、abstract 的。抽象类中成员变量默认 default，可在子类中被重新定义，也可被重新赋值；抽象方法被 abstract 修饰，不能被 private、static、synchronized 和 native 等修饰，必须以分号结尾，不带花括号。
- 变量：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态常量）。

### 抽象类可以被实例化吗？
答：抽象类不能被实例化，通常由子类继承实现。**抽象类中可以有构造方法**，但是构造方法实例化的是子类对象。接口没有构造方法。

### Java深拷贝的方式有哪些？
- 实现Cloneable接口，重写clone()方法
- 使用序列化和反序列化
- 手动递归复制

## Java中的对象
### Java中创建对象有哪些方式？
- 使用new关键字:通过new关键字直接调用类的构造方法来创建对象。
```
MyClass obj = new MyClass();
```
- 使用Class类的newInstance()方法:通过反射机制调用newInstance()方法来创建对象。
```
MyClass obj = (MyClass) Class.forName("com.example.MyClass").newInstance();
```
- 使用Constructor类的newInstance()方法：同样通过反射机制调用Constructor类的newInstance()方法来创建对象。
```
Constructor<MyClass> constructor = MyClass.class.getConstructor();
MyClass obj = constructor.newInstance();
```
- 使用clone()方法：如果类实现了Cloneable接口，可以使用clone()方法复制对象。
```
MyClass obj1 = new MyClass();
MyClass obj2 = (MyClass) obj1.clone();
```
- 使用反序列化

### new的对象什么时候回收？
主要由GC回收，分为以下几种情况：
1. 引用计数法：某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。
2. 可达性分析算法：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。
3. 终结器（Finalizer）：如果对象重写了finalize()方法，垃圾回收器会在回收该对象之前调用finalize()方法，对象可以在finalize()方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。

## 反射机制
### 什么是反射机制？
Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；
对于任意一个对象，都能够调用它的任意一个方法和属性；
这种**动态获取的信息以及动态调用对象的方法**的功能称为 Java 语言的反射机制。

反射具有以下特性：
- 运行时类信息访问：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。
- 动态对象创建：可以使用反射 API 动态地创建对象实例，即使在编译时不知道具体的类名。这是通过 Class 类的 newInstance() 方法或 Constructor 对象的 newInstance() 方法实现的。
- 动态方法调用：可以在运行时动态地调用对象的方法，包括私有方法。这通过 Method 类的 invoke() 方法实现，允许你传入对象实例和参数值来执行方法。
- 访问和修改字段值：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过 Field 类的 get() 和 set() 方法完成的。

### 反射在你平时写代码或者框架中的应用场景有哪些?
1. 加载数据库驱动
```
Class.forName("com.mysql.cj.jdbc.Driver");
```
2. 配置文件加载
Spring 通过 XML 配置模式装载 Bean 的过程：
- 将程序中所有 XML 或 properties 配置文件加载入内存
- Java 类里面解析 xml 或者 properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息
- 使用反射机制，根据这个字符串获得某个类的 Class 实例
- 动态配置实例的属性

## Java注解的原理
注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。

我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。
通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。
该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。

## == 与 equals 有什么区别？
==对于基本数据类型和引用类型有不同的作用：
- 对于基本数据类型，==比较的是值是否相等。
- 对于引用类型，==比较的是对象的内存地址

equals不能比较基本数据类型，只能用来判断两个对象是否相等
- 当类没有重写equals方法时，equals方法比较的是两个对象的内存地址
- 当类重写了equals方法时，equals方法一般比较的是两个对象的属性是否相等

一般String类、Integer类等都重写了equals方法，比较的是对象的属性是否相等。

## StringBuffer和StringBuilder区别是什么？
区别：
- String 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以**拼接字符串时会产生很多无用的中间对象，如果频繁地进行这样的操作对性能有所影响**。
- StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个**线程安全**的可修改的字符序列。在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。
- StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是**去掉了保证线程安全**的那部分，减少了开销。

>一般情况下，速度从快到慢为 StringBuilder > StringBuffer > String，当然这是相对的，不是绝对的。


## 并发
### 线程安全体现在哪些方面？
- 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作；
- 可见性：一个线程对主内存的修改可以及时地被其他线程看到；
- 有序性：保证线程按照代码顺序执行。

### 什么是CAS操作？
CAS叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：

- V：要更新的值
- A：预期值
- B：新值
当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。

### CAS的缺点？
- ABA问题：如果一个值原来是A，准备修改前短暂变成了B，然后又变成了A，那么CAS操作会错误地认为这个值没有发生变化；解决方法是加入预期标志和更新后标志，更新时不光检查值，还要检查标志是否相等。
- 循环时间长开销大：CAS操作如果长时间不成功，会一直自旋，占用CPU，降低性能。
- 只能保证一个共享变量的原子操作：对多个共享变量操作时，需要加锁。


### 线程创建方式有哪些？
- 继承 Thread 类
```
class MyThread extends Thread{
    public void run(){
        System.out.println("MyThread run");
    }
}

public static void main(String[] args) {
    MyThread t=new MyThread();
    t.start();
}
```
- 实现 Runnable 接口
```
class MyRunnable implements Runnable{
    public void run(){
        System.out.println("MyRunnable run");
    }
}
public static void main(String[] args){
    Thread t=new Thread(new MyRunnable());
    t.start();
}
```
- 实现Callable接口与FutureTask
- 使用线程池
### 如何停止线程？
- 通过退出标志位，让线程正常退出
- stop()暴力停止
- 使用interrupt()方法中断线程
    - 如果打断阻塞的线程(sleep,wait,join)，会抛出InterruptedException异常
    - 如果打断正常线程，会根据中断标记为判断是否退出

### sleep和wait的区别？
- sleep是Thread类的静态方法，wait是Object类的方法
- sleep方法不会释放锁，wait方法会释放锁
- sleep方法可以在任何地方调用，wait方法只能在同步方法或同步块中调用
- sleep方法在指定时间后自动唤醒或通过interrupt中断，wait方法需要其他线程调用notify或notifyAll方法唤醒

### 线程的状态有哪些？
- NEW：新创建的线程，还未执行
- RUNNABLE：就绪和正在执行的线程
- BLOCKED：阻塞状态，等待锁的释放
- WAITING：等待状态，等待其他线程的通知
- TIMED_WAITING：具有指定等待时间的等待状态
- TERMINATED：线程执行完毕

### blocked和waiting的区别？
- blocked 一般是因为获取锁失败，在等待其他线程释放锁后，会重新进入runnable状态
- waiting 状态不参与锁的竞争，而是在等待其他线程的通知，比如调用wait()方法，join()方法，或者LockSupport.park()方法，不会占用CPU资源，当其他线程调用notify()方法后，会重新进入runnable状态

### notify和notifyAll的区别？
- notify()方法会随机唤醒一个处于waitting的线程，其他线程仍然处于waiting状态。
- notifyAll()方法会唤醒所有waitting的线程，让他们开始竞争锁

### 写一段代码，实现线程交替打印奇偶数
```
public class PrintEvenOdd{
    private static int cnt=1;
    private static final Object lock=new Object();
    private static final int MX=100;
    public static void main(String[] args){
        Runnable printOdd=()->{
            synchronized(lock){
                    while(cnt<=MX){
                    if(cnt%2!=0){
                        System.out.println(Thread.currentThread().getName()+":"+cnt++);
                        lock.notify();
                    }else{
                        try{
                            lock.wait();
                        }catch(InterruptedException e){
                            e.printStackTrace();
                        }
                    }     
                }
            }
        };

        Runnable printEven=()->{
            synchronized(lock){
                while(cnt<=MX){
                    if(cnt%2==0){
                        System.out.println(Thread.currentThread().getName()+":"+cnt++);
                        lock.notify();
                    }else{
                        try{
                            lock.wait();
                        }catch(InterruptedException e){
                            e.printStackTrace();
                        }
                    }
                }
            }
        }

        Thread t1=new Thread(printOdd,"奇数线程");
        Thread t2=new Thread(printEven,"偶数线程");
        t1.start();
        t2.start();
    }
}
```
任意线程数顺序打印：
```
public class test {
    private static int cnt = 0;
    private static int threadNum = 3;
    private static final Lock lock = new ReentrantLock();
    private static final Condition condition = lock.newCondition();

    static class MyThread implements Runnable {
        private int id;

        public MyThread(int id) {
            this.id = id;
        }

        @Override
        public void run() {
            while (true) {
                lock.lock();
                try {
                    while (cnt < 100 && cnt % threadNum != id) {
                        condition.await();
                    }
                    if (cnt >= 100) {
                        break;
                    }
                    ++cnt;
                    System.out.println("Thread " + id + " : " + cnt);
                    condition.signalAll();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                } finally {
                    lock.unlock();
                }
            }
        }
    }

    public static void main(String[] args) {
        for (int i = threadNum - 1; i >= 0; i--) {
            Thread t = new Thread(new MyThread(i));
            t.start();
        }
    }
}
```
### 怎么保证多线程安全？
- 使用synchronized关键字，保证同一时刻只有一个线程访问共享资源
- 使用volatile关键字，保证变量的可见性
- 使用Lock接口，比如ReentrantLock类就是Lock接口的一个实现
- 使用原子类，比如AtomicInteger类
- 使用TreadLocal
- 使用线程安全的集合类，比如ConcurrentHashMap、CopyOnWriteArrayList等

### java中有哪些常用的锁？使用场景是什么？
- synchronized：用于修饰代码块或方法，保证同一时刻只有一个线程访问共享资源。
- ReentrantLock：是Lock接口的一个实现，提供了更多的功能，比如可以设置超时时间、中断等待锁的线程、公平锁等。
- 读写锁：允许多个线程读，但只允许一个线程写，适用于读多写少的场景。
- 乐观锁和悲观锁：乐观锁不锁定资源，**只在写数据时**检查资源是否被其他线程修改；悲观锁在访问数据时会锁定资源，总是假设最坏的情况。
- 自旋锁：未获取到锁时线程不会放弃CPU资源，而是一直循环检查锁是否可用，直到获取到锁，通常用CAS实现。

### 什么是公平锁和非公平锁？
- 公平锁：按照线程请求的顺序来获取锁，先到先得，整体执行速度慢，吞吐量小，因为涉及线程从休眠到运行状态的转换。
- 非公平锁：多个线程争抢锁，整体执行速度快，吞吐量大。
### 讲讲ReentrantLock？
ReentrantLock底层主要依赖AQS抽象类，AQS提供了一些基本的同步机制如队列、状态等。ReentrantLock具有以下特性：
- 可中断：线程在等待锁的过程中，可以被其他线程中断而提前结束等待。
- 设置超时时间：尝试获取锁时，可以设置超时时间，超过时间后自动放弃等待。
- 公平锁和非公平锁：ReentrantLock默认是非公平锁，可以通过传入true参数创建公平锁。如`ReentrantLock lock=new ReentrantLock(true);`
- 支持多个条件变量，可以更灵活的执行等待与唤醒操作。主要通过Condition接口实现。
```
ReentrantLock lock=new ReentrantLock();
Condition condition=lock.newCondition();
//等待与唤醒
condition.await();
condition.signal();
```
- 支持可重入性，同一个线程可以多次获取同一把锁，不会造成死锁。每次获取锁时，holdCount递增，释放锁时递减，当holdCount为0时，其他线程才能获取锁。

### synchronized和ReentrantLock的的应用场景有什么不同？
- synchronized适合简单的同步场景，代码块或方法级别的同步，使用方便，但功能有限。
- ReentrantLock适合复杂同步的场景，提供了一些高级功能，如可中断、超时、公平锁、多条件变量等。


### synchronized和ReentrantLock的区别？
- synchronized可修饰代码块和方法，ReentrantLock只能修饰代码块
- synchronized可以自动加锁和释放锁，ReentrantLock需要手动加锁和释放锁
- 前者只能是非公平锁，后者可以是公平锁或非公平锁
- 前者不能响应中断，后者可以响应中断
- synchronized是JVM层面通过监视器实现的锁，ReentrantLock是基于AQS实现的锁

### 介绍一下AQS?
答：AQS是Java中的一个抽象类，提供了一些基本的锁机制，AQS的核心思想是：
- 如果被请求的资源空闲，就将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态；
- 如果被请求的资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制是通过内部的双向队列来实现的。

工作机制：
AQS内部有一个state，被volatile修饰，0表示无锁，1表示有锁
- 当一个线程到来时，他会尝试将state改为1，表示获取到了资源
- 如果state已经为1了，他会被放入一个双向队列，排队等待锁的分配
- 如果多个线程同时抢夺资源，为了保证原子性，修改state要用CAS操作

AQS是公平锁还是非公平锁？
都有
- 如果新的线程与队列头部的线程争抢资源，那么属于非公平锁
- 如果由于state为1,新线程放入到队列中等待，那么属于公平锁



### volatile关键字的作用？
- 保证变量对所有线程的可见性
- 禁止指令重排序

指令重排序是编译器为了提升指令执行效率而做的优化，一般需要两个条件：
- 单线程下不会改变程序执行结果
- 重排序的指令不存在数据的相互依赖

### 死锁产生的条件？
- 互斥条件：多个线程不能同时使用同一资源
- 持有和等待条件：线程持有资源，同时等待其他线程持有的资源
- 不可剥夺条件：线程持有的资源在使用完之前不能被其他线程抢占
- 循环等待条件：多个线程形成循环等待资源的关系

### 线程池的提交任务流程？
```
提交任务 -> 核心线程是否已满？

├── 未满 -> 创建核心线程执行

└── 已满 -> 任务入队

    ├── 队列未满 -> 等待执行

    └── 队列已满 -> 创建非核心线程

        ├── 未达最大线程数 -> 执行任务

        └── 已达最大线程数 -> 执行拒绝策略

```
### 线程池的参数有哪些？
- corePoolSize：核心线程数，线程池中一直存活的线程数量
- maximumPoolSize：最大线程数，线程池中最大的线程数量
- keepAliveTime：线程空闲时间，超过这个时间，多余的线程会被回收
- unit：时间单位
- workQueue：工作队列，存放等待执行的任务

### 线程池的拒绝策略有哪些？
- CallerRunsPolicy：使用线程池的调用者所在线程去执行对应任务
- AbortPolicy：拒绝并抛出异常
- DiscardPolicy：不做任何处理，直接拒绝
- DiscardOldestPolicy：抛弃最老的任务执行该任务。
- 自定义策略

### 核心线程数如何设置？
- 对于高并发，执行时间短的任务，核心线程数设置为CPU核心数+1
- 对于并发不高，执行时间长的任务
    - CPU密集型任务：核心线程数设置为CPU核心数+1
    - IO密集型任务：核心线程数设置为CPU核心数*2
- 对于高并发，执行时间长的任务，首先要看数据能不能做缓存，其次看能不能增加服务器

### 线程池种类有哪些？
- ScheduledThreadPool：支持定时和周期性执行任务
- FixedThreadPool：核心线程数和最大线程数相等，最大线程数满了后会进入队列等待
- CachedThreadPool：核心线程数为0，最大线程数为Integer.MAX_VALUE，适用于执行大量短期异步任务
- SingleThreadPool：只有一个核心线程，确保所有任务按照指定顺序执行

### 线程池的阻塞队列有哪些？
- ArrayBlockingQueue，有界队列，容量固定
- LinkedBlockingQueue，无界队列，容量无上限，适用于FixedThreadPool和SingleThreadPool
- SynchronousQueue，同步队列，容量为0，CachedThreadPool使用的队列
- DelayedWorkQueue，延迟阻塞队列，按照延迟时间排序，ScheduledThreadPool使用的队列


### 多线程顺序执行的几种写法?
- 使用join方法，join方法会阻塞当前线程，等待调用join方法的线程执行完毕，类似于让调用join方法的线程“插队”。
- 使用线程池，将核心线程数和最大线程数都设置为1，然后按顺序提交任务。
- 使用wait()和notify，创建两个lock，分别是lock1和lock2，线程1和线程2共用lock1,线程2和线程3共用lock2。实现如下：
```
public class PrintOrder{
    private static Object lock1=new Object();
    private static Object lock2=new Object();

    static class MyThread implements Runnable{
        String name;
        Object preLock;
        Object postLock;
        public MyThread(String name,Object preLock, Object postLock){
            this.name=name;
            this.preLock=preLock;
            this.postLock=postLock;
        }
        public run(){
            if(preLock!=null){
                synchronized(preLock){
                    preLock.wait();
                }
            }
            System.out.println(name+"执行");
            Thread.sleep(1000);
            if(postLock!=null){
                synchronized(postLock){
                    postLock.notify();
                }
            }
        }
    }

    public static void main(String[] args){
        Thread t1=new Thread(new MyThread("线程1",null,lock1));
        Thread t2=new Thread(new MyThread("线程2",lock1,lock2));
        Thread t3=new Thread(new MyThread("线程3",lock2,null));
        t2.start();
        t1.start();
        t3.start();
    }
}
```
- 使用countDownLatch，通过await()方法阻塞线程，通过countDown()方法将计数器减1。实现方式和wait()和notify()类似，把wait()换成了await()，把notify()换成了countdown()。

### 线程池中shutdown和shutdownNow的区别？
- shutdown会将状态置为SHUTDOWN状态，正在执行的任务会继续执行，无法向线程池添加新任务。
- shutdownNow会将状态置为STOP状态，会尝试中断正在执行的任务。

### 提交给线程池的任务可以被撤回吗？
答：可以。向线程池提交任务后，会返回一个Future对象，通过Future对象的cancel()方法可以取消任务的执行。

### 线程池用到了哪些设计模式？
- 工厂模式：创建线程会用到
- 策略模式：包含多种拒绝策略
- 单例模式：线程池一般是单例的
- 模板方法模式：runWorker()方法定义了工作线程执行任务的核心逻辑骨架


### ThreadLocal为什么会发生内存泄漏？
ThreadLocalMap的键为ThreadLocal的弱引用，而值是强引用。如果ThreadLocal对象被回收，其对应的Entry键会变为null，如果此时不删除对应的Entry，则Value仍然被Thread上的ThreadLocalMap引用，而Value往往占用较大内存，这就会导致内存泄漏。

为了解决这个问题，ThreadLocal在调用set、get、remove方法时，会清理掉ThreadLocalMap中所有键为null的Entry。但如果没有调用这些方法，那么清理工作就不会进行，从而可能导致内存泄漏。
### ThreadLocal的继承性问题以及解决方法？
- 同一个ThreadLocal变量在父线程中设置值，在子线程中获取不到值。
- 解决方法：使用InheritableThreadLocal类，它是ThreadLocal的子类，可以在子线程中获取父线程中设置的值。

### CompletableFuture怎么用？
CompletableFuture相比Future，优势就在于可以灵活的编排异步任务

>创建CompletableFuture对象
- runAsync：不关心返回结果时使用
- （常用）supplyAsync：关心返回结果时使用，例如
```
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "hello!");
```
>获取结果后进一步处理
- thenApply：从回调函数中获取结果后进一步处理
```
CompletableFuture<String> future = CompletableFuture.completedFuture("hello!")
        .thenApply(s -> s + "world!").thenApply(s -> s + "nice!");
assertEquals("hello!world!nice!", future.get());
```
- thenAccept: 不需要从回调函数中获取回调结果, 可以访问异步计算结果
- thenRun: 不需要从回调函数中获取回调结果, 不能访问异步计算结果

> 组合多个CompletableFuture
- thenCombine: 将两个任务的结果组合在一起，两个任务之间没有先后顺序。
- thenCompose: 将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。

>并行运行多个任务
- allOf: 等待所有任务完成再返回
- anyOf: 等待任意一个任务完成就返回


## MyBatis
### MyBatis中#{}和${}的区别？
- `#{}：预编译处理，会将#{}替换为?，然后使用PreparedStatement的set方法设置参数，可以防止SQL注入。`
- `${}：字符串替换，会将${}替换为实际的值，存在SQL注入的风险。`
- `#{}不用加单引号，${}需要加单引号`

### MyBatis的延迟加载及其原理？
延迟加载指的是查询数据时，需要用到数据时才加载，不需要用到数据时就不加载，可以在配置文件中配置

原理：
- 通过cglib动态代理实现
- 调用目标方法时，实际上调用invoke方法，当发现目标值为null，就去执行sql查询

### MyBatis的一级缓存和二级缓存的区别？

MyBatis的一级二级缓存都是本地缓存，都是基于HashMap的

- 一级缓存：SqlSession级别的缓存，默认开启，存储在SqlSession中，SqlSession关闭后缓存失效
- 二级缓存：Mapper级别的缓存，默认关闭，存储在SqlSessionFactory中，SqlSession关闭后缓存不失效

二级缓存什么时候清除缓存中的数据呢？
- 当某个作用域进行了增删改操作时，清除该作用域的缓存

## MYSQL

### SQL注入是什么？举个例子？
指的是攻击者通过恶意构造输入参数，使得正常SQL语句被修改

例如`SELECT * FROM Users WHERE Username = '' AND Password = '' OR '' = ''`
由于`"="`永远为真，所以这个SQL语句会返回所有的用户信息

### mysql的事务隔离级别
#### 事务的四个特性
- 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
- 一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另一个一致性状态。
- 隔离性（Isolation）：一个事务的执行不能被其他事务干扰。
- 持久性（Durability）：事务一旦提交，它对数据库的改变就应该是永久性的。

#### 事务隔离解决的问题
- 脏读：一个事务读取到另一个事务未提交的数据，读到了最终可能不存在的数据
- 可重复读：同一事务中多次读取同一数据时，结果是一致的，即使其他事务修改了该数据，当前事务仍然看到最初读取的值
- 不可重复读：同一事务在不同的时刻读到的同一批数据可能是不一样的，比如其他事务改了这批数据并提交了（针对update）
- 幻读：同一事务在不同的时刻读到的同一批数据可能是不一样的，比如其他事务插入了一些数据并提交了（针对insert）


#### 事务隔离级别
mysql中有四种事务隔离级别，级别由低到高分别是：
- 读未提交（Read Uncommitted）：允许脏读，一个事务还没提交时，另一个事务就可以看到它做的变更，存在脏读、不可重复读、幻读的问题
- 读提交（Read Committed）：只能读取已经提交的数据，可以避免脏读，但是不可重复读和幻读仍然存在
- 可重复读（Repeatable Read）：对同一字段的多次读取结果是一致的，除非数据被当前事务自己改变，可以避免脏读和不可重复读，但幻读仍然存在
- 串行化（Serializable）：最高的隔离级别，所有事务依次执行，可以避免脏读、不可重复读、幻读

### MYSQL具体怎么解决脏读、不可重复读、幻读的？
- 脏读：可以通过select for update ,加独占锁（排他锁）解决，事务提交前，会一直持有排他锁。通常通过MVCC实现，读提交隔离级别下，每次读数据时，都会生产一个ReadView，只能看到已经提交的数据版本
- 不可重复读：也是基于MVCC，可重复读隔离级别下，第一次读数据时，会产生一个ReadView，意味着事务后续的读操作只能看到第一次读到的数据版本
- 幻读：对读取的数据加共享锁，然后通过间隙锁，防止在某个范围内插入数据

### MYSQL的有哪几种引擎？
- InnoDB：InnoDB是MySQL的默认存储引擎，具有ACID事务支持、行级锁、外键约束等特性。它适用于高并发的读写操作，支持较好的数据完整性和并发控制。
- MyISAM：MyISAM是MySQL的另一种常见的存储引擎，具有较低的存储空间和内存消耗，适用于大量读操作的场景。然而，MyISAM不支持事务、行级锁和外键约束，因此在并发写入和数据完整性方面有一定的限制。
- Memory：Memory引擎将数据存储在内存中，适用于对性能要求较高的读操作，但是在服务器重启或崩溃时数据会丢失。它不支持事务、行级锁和外键约束。

### MYSQL了解哪些日志？
- redo log 重做日志，是 InnoDB 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复，是循环写；
- undo log 回滚日志，是 InnoDB 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。
- bin log 二进制日志，是 Server 层生成的日志，主要用于数据备份和主从复制，是追加写；
- relay log 中继日志，用于主从复制场景下，slave 通过 io 线程拷贝 master 的 bin log 后本地生成的日志
- 慢查询日志，用于记录执行时间过长的 SQL，需要设置阈值后手动开启

### undolog和redolog的区别？
- redolog记录的是数据页的物理变化，发生故障时可用来同步数据
- undolog记录的是逻辑日志，用于事务回滚和mvcc,通过逆操作恢复数据


### 介绍一下redo log?
redo log用于mysql宕机时的恢复

- 一般查询数据时，会把数据放到buffer pool中，后续查询可以在buffer pool中寻找
- 更新数据时，如果在buffer pool中完成了更新，就会把修改内容记录到redo log buffer中
- 最后清空redo log buffer，**刷盘**到redo log中

如果没有redo log，每次直接把数据刷盘，这样性能会很差

### redo log刷盘的时机
一般以下几种情况会触发刷盘
- 事务提交时
- redo log buffer 快满时
- 后台线程周期性刷盘


### 介绍一下bin log？
MySQL 在完成一条更新操作后，会生成一条 binlog
binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、MIXED，区别如下：

- STATEMENT：记录的内容是SQL语句原文，但是如果运用了`now()`这种函数，可能造成不一致
- ROW：除了记录SQL语句，还记录了所有字段的具体数据
- MIXED：是两种格式的混合，判断SQL语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式。

### MYSQL怎么连表查询？
- 内连接：返回两个表中有匹配关系的行
- 左外连接：返回左表所有的行，右表中没有匹配的行返回 NULL
- 右外连接：返回右表所有的行，左表中没有匹配的行返回 NULL
- 全外连接：返回两个表中所有的行，没有匹配的行返回 NULL

### 如何避免重复插入数据？
- 使用unique约束
- 使用insert .. on duplicate key update，当key冲突时，执行update操作
- 使用insert ignore，忽略因key重复导致的错误

### in和exists的区别？
- in用于检查左边的表达式存在于某结果集中的数据
- exists不关心具体数据，只关心结果集是否为空

### mysql的执行过程？
- 连接器：身份认证和权限管理
- 查询缓存：尝试查询缓存，8.0版本移除
- 分析器：分析sql语句是否正确
- 优化器：优化sql语句，选择最优的执行计划
- 执行器：执行sql语句


### SQL查询语句的执行顺序？
- from：指定要查询的表
- on: 主表保留
- join: 连接其他表
- where: 对表进行筛选
- group by: 分组
- AGG FUNC：聚合函数（AVG,COUNT,MAX,MIN,SUM）
- having: 对分组后的结果进行筛选
- select: 选择要查询的列
- distinct: 去重
- order by: 对结果进行排序
- limit: 限制返回结果的数量，分页

### 为什么InnoDB是默认存储引擎？
InnoDB在事务支持、并发性能、崩溃恢复能力等方面具有良好特性：
- 事务支持：支持事务的ACID特性，保证数据的一致性和完整性
- 并发性能：支持行级锁，而MyISAM只支持表级锁，锁粒度更小，并发性能更好
- 崩溃恢复：通过redolog实现崩溃恢复，保证数据的持久性

### InnoDB和MyISAM的区别？
- 事务：InnoDB支持事务，MyISAM不支持事务
- 索引结构：InnoDB使用聚簇索引，索引建立在主键上，MyISAM使用非聚簇索引
- 锁粒度：InnoDB支持行级锁，MyISAM支持表级锁
- count效率：InnoDB执行count要做全表扫描，MyISAM用一个变量保存了整个表行数，count效率更高

### 索引的分类？
- 按数据结构分类：B+树索引、哈希索引、全文索引
- 按物理存储分类：聚簇索引、非聚簇索引
- 按字段特性分类: 分为主键索引、唯一索引、普通索引、前缀索引
- 按索引的数量分类：单列索引、联合索引


### 聚簇索引选取的依据是什么？
- 如果有主键，默认使用主键索引作为聚簇索引
- 如果没有主键，使用第一个唯一索引作为聚簇索引
- 如果都没有，innoDB会生成一个隐藏的自增ID作为聚簇索引


### 聚簇索引和非聚簇索引的区别？
- 数据存储：聚簇索引的叶子节点存储了数据行，非聚簇索引的叶子节点存储了指向数据行的指针或者主键
- 索引与数据的关系：聚簇索引可以直接查找到数据行，非聚簇索引需要先查找到主键，再通过主键回溯到聚簇索引中查找数据行，称为回表。
- 唯一性：聚簇索引建立在主键上是唯一的，非聚簇索引可以有多个
- 查询效率：对于需要回表的查询，聚簇索引效率更高，对于不需要回表的查询，非聚簇索引效率更高

### B+树的特性？
- 所有叶子节点都在同一层，叶子节点之间形成双向链表，便于范围查询和排序
- 非叶子节点不存储数据，只存储主键和子节点的指针
- 叶子节点储存实际的数据行
- 在插入、删除、更新后会进行平衡操作，保证树的高度相对稳定，每个节点最少有`M/2`个子节点，最多有`M`个子节点，M是树的阶数

### B+树和B树的区别？
- B+树的非叶子节点不存储数据，而B树的非叶子节点会存储部分数据
- B+树的叶子节点之间形成双向链表，便于范围查询和排序，B树叶子节点没有链表
- B+树每次都要查到叶子节点，B树可能会在非叶子节点找到数据

### 为什么MYSQL不用跳表？
B+树在3层时存储的数据可以达到千万级别，跳表要维护同样级别的数据需要的层数更多，导致性能下降。

### 为什么自增ID快一些？为什么不用UUID？
自增ID更快的原因：
- 下一条记录会写入新的页中，提升了页面的利用率
- 新插入的记录一定会在原有最大ID的后面，便于定位和寻址
- 减少了页分裂

不用UUID的原因：
- 无序，每次插入数据可能插入到页面中间，导致页分裂
- 占用空间大，UUID是的长度更长，每个页能存放的记录数更少，导致树的高度更高，影响性能

### 什么是覆盖索引？超大分页怎么解决？
覆盖索引是指**索引包含了查询需要的所有字段，不需要回表查询**，减少了IO操作，提升了查询性能。

对于超大分页问题，可以用覆盖索引+子查询来优化：
- 先查询数据的id，因为有覆盖索引，所以会比较快
- 然后再用子查询来过滤


### 创建联合索引要注意什么？
`区分度=distinct(col)/count(*)`
- 建立联合索引时，要把区分度大(重复值少)的字段排在前面，这样可以过滤掉更多的数据，提升查询性能
- 如果区分度很小，比如性别字段，无论搜索哪一个值都会返回大量数据
- MYSQL有一个查询优化器，如果某个值在表中的出现比例很高（超过30%），那么就会不走索引而是全表扫描

### 索引失效有那些情况？
- 使用左或者左右模糊匹配的时候
- 在查询中对索引列使用函数时
- 联合索引没有遵循最左匹配原则
- 范围查询右边的条件，不能使用索引
- 查询字段发生类型转换

### mysql如何定位慢查询？
- 开源工具，如普罗米修斯、SkyWalking等发现比较慢的接口
- 使用慢查询日志，一般超过2秒就被视为慢查询

### 慢查询如何解决？
- 通过 explain 执行结果，查看 sql 是否走索引，如果不走索引，考虑增加索引。
- 可以通过建立联合索引，实现覆盖索引优化，减少回表，使用联合索引符合最左匹配原则，不然会索引失效
- 避免索引失效，比如不要用左模糊匹配、函数计算、表达式计算等等。
- 联表查询最好要以小表驱动大表，并且被驱动表的字段要有索引，当然最好通过冗余字段的设计，避免联表查询。
- 针对 limit n,y 深分页的查询优化，可以把 Limit 查询转换成某个位置的查询：select * from tb_sku where id>20000 limit 10，该方案适用于主键自增的表，
- 将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开

### 索引的缺点
- 占用存储空间
- 创建和维护索引需要时间
- 索引会降低表的增删改的性能

### 什么时候适合建立索引？
- 字段有唯一性限制
- 经常用于where查询条件的字段
- 经常用order by、group by的字段

### 什么时候不需要索引？
- where、group by、order by用不到的字段
- 字段存在大量重复值，区分度低
- 表数据很少，不需要创建索引
- 经常进行更新的字段不用建立索引

### 如何对索引进行优化？
- 前缀索引优化，前缀索引通过减少索引字段的长度，从而使索引页包含的索引键增多，提高查询效率
- 覆盖索引优化，减少回表操作
- 最好采用自增主键，减少页分裂
- 防止索引失效

### 事务的四个特性是如何实现的？
- 原子性：通过undo log实现，事务回滚时，通过undo log将数据恢复到事务开始之前的状态
- 持久性：通过redo log实现，事务提交时，将redo log写入磁盘，保证事务的持久性
- 隔离性：通过MVCC实现，每个事务都有自己的版本号，读取数据时，只能读取版本号小于等于当前事务版本号的数据
- 持久性: 通过原子性+持久性+隔离性实现

### 讲讲MVCC?
MVCC指的是多版本并发控制，维护一个数据的多个版本，使得读写没有冲突

MVCC的实现主要依赖于隐藏字段、undolog、以及readview
- 隐藏字段：每个数据行都有隐藏字段，包括最近修改事务ID，回滚指针等
- undolog: 用来存储MVCC的版本链，每次修改数据时，都会通过头插法将新的版本插入到链表的头部
- readView：用于**快照读**提取数据时判断数据的可见性，找到对应的数据版本

### 当前读和快照读的区别？
- 当前读：读数据的最新版本，通过加锁的方式保证线程安全
- 快照读：不加锁的读就是快照读，读的是数据的可见版本，可能是旧版本的数据。
    - 在读提交隔离级别下，每次select都会生成一个readView
    - 在可重复读隔离级别下，只有第一次select会生成readView，后续的select会使用第一次的readView


### MVCC的ReadView介绍一下？
有四个重要的字段：
- m_ids: 活跃且未提交的事务ID列表
- min_trx_id：m_ids中最小值
- max_trx_id：给下一个事务的id值，也就是最大事务的id+1
- creator_trx_id：创建该ReadView的事务ID
### 事务特别多有哪些弊端？
- 如果一个事务特别多，锁定的资源也会很多，容易造成死锁和锁超时
- 事务回滚记录会占用大量空间，回滚时间长
- 执行时间长，容易造成主从延迟

### MYSQL里有哪些锁？
- 全局锁，主要用于全库逻辑备份
- 表级锁，包括表锁和元数据锁和意向锁
- 行级锁，包括：
    - 记录锁，锁住某条记录
    - 间隙锁，锁定一个范围，不包括记录本身
    - next-key锁，记录锁和间隙锁的结合，锁定一个范围，包含记录本身，用于解决幻读

### MYSQL主从复制过程？
- 主库将数据写入binlog
- 从库通过IO线程连接主库，向主库请求binlog
- 主库创建一个线程将binlog发送给从库
- 从库的IO线程将binlog写入relay log
- 从库读取relay log，进行数据同步

### 主从延迟有哪些解决方法？
- 强制走主库，对于资源密集型操作，直接在主库上执行

### 分库和分表的区别？
分库将数据按照一定规则分布到不同的数据库中，分表是将单个表拆分成多个表

- 垂直分库指的是将数据按照业务和功能维度划分到不同的数据库中，但仍然会有单表数据量过大的问题
- 水平分库指的是将同一张表按照一定规则分布到不同的数据库中，每个数据库中的表结构相同，但数据不同
- 垂直分表针对单表字段过多的问题，一般将单表中比较独立的字段或者不常用的字段拆分到不同的表中
- 水平分表是在同一个数据库内，把一张大数据量的表按一定规则，切分成多个结构完全相同表。




## Redis
### Redis的数据结构以及应用场景？
#### String
基本的key-value结构，应用场景有：

- 缓存对象，有两种方式：
    - 直接缓存json字符串如`set user:1 {"name":"zhangsan","age":18}`
    - 使用Mset和Mget，如`mset user:1:name zhangsan user:1:age 18`
- 常规计数，比如点赞、阅读量、转发等,如`incr article:1:like`
- 分布式锁，通过NX参数实现key不存在才插入，key不存在则插入成功（加锁成功），否则插入失败（加锁失败）

#### List: 
简单的字符串列表，按照插入顺序排序，应用场景主要有消息队列

消息队列存取消息必须要满足三个需求，分别是**消息保序、处理重复消息、消息可靠性**
- 消息保序，通过lpush和rpop实现消息的先入先出，同时为了提高性能，可以使用BRPOP进行阻塞读取，也就是队列为空时自动阻塞
- 处理重复消息，需要为每个消息生成一个全局唯一ID，比如通过时间戳+计数器的方式生产全局唯一ID，然后将消息和全局唯一ID一起存入redis
- 为了保证消息可靠性，可以使用BRPOPLPUSH，每次取一个消息后，将消息放入一个备份队列，这样即使消费者没有读了消息没有成功处理，也可以从备份队列中重新读取消息

List实现消费队列有什么缺陷？
- 不允许多个消费者消费同一条消息
- 不支持消费组

#### Hash
键值对集合key-field-value，应用场景有：
- 缓存对象，通过HMSET进行缓存对象，如`hmset uid:1 name zhangsan age 18`
- 购物车，一般以用户id为key，商品id为field，商品数量为value，如`hset cart:1 1001 2`

#### Set
无序且唯一的键值集合，应用场景有：
- 点赞，以key为文章id，value为用户id，如`sadd article:1 uid:1`
- 共同关注，以用户id为key，以用户关注的公众号id为value，通过sinter可以求不同用户的交集
- 抽奖，因为set的不可重复性，一个用户不会被重复抽中，可以将抽奖活动名作为key，所有用户名作为value，如果是允许重复中奖就使用srandmember，如果不允许重复中奖就使用spop

#### zset
比set多了一个排序属性score，主要包括member和score两个属性，member是唯一的，应用场景有：
- 适合排序的场景，如排行榜，将用户id作为member，分数作为score，通过zadd添加分数，通过zrevrange获取排行榜

#### Bitmap
一串连续的二进制数组，通过offset定位元素，应用场景有：
- 用户签到，通过setbit设置用户签到，通过bitcount统计签到次数
- 判断登陆状态

如何统计当月首次签到时间？
通过bitpos获取第一个为1的位置，即为首次签到时间
`bitpos uid:sign:100:202403 1`

如何统计连续七天打卡的用户总数？
以每天的日期为key，以用户的id为offset，通过bitop AND将七天的bitmap进行按位与操作，如果某个位结果为1，说明这个用户连续七天打卡
然后通过bitcount统计七天连续打卡的用户总数

#### hyperloglog
用于提供不精确的去重计数

#### GEO
存储地理信息

#### Stream
用于实现消息队列，支持消息持久化、全局唯一ID自动生成、消息确认机制、消费组等功能

### redis的string实现原理
String的底层数据结构主要是SDS（简单动态字符串），他有以下特点：
- 不仅可以存储字符串，还可以存储二进制数据
- 获取字符串长度的时间复杂度是O(1)，len属性记录了长度
- API更安全，拼接字符串不会发生缓冲区溢出


### 为什么Redis用跳表而不是B+树？
- B+树目的是优化磁盘IO，通过降低树的高度来减少磁盘寻道次数，而Redis是基于内存的，更符合内存访问的局部性原理
- 跳表实现简单，而B+树节点分裂合并逻辑复杂
- 跳表插入删除效率更高，B+树插入删除需要维护平衡
- 跳表内存占用更紧凑，B+树索引页未填满可能存在内存碎片

### 跳表的层数是怎么设置的？
跳表创建节点时，会随机生产一个0-1之间的随机数，如果小于某个0.25，则层数+1，直到生成的随机数大于阈值，层数的最大值是64

### Redis的哈希表是怎么扩容的？
主要分三步：
- 创建新哈希表，一般大小为之前的2倍
- 将旧哈希表的数据重新迁移到新哈希表
- 释放旧哈希表，将新哈希表设置为当前哈希表

注意，如果旧哈希表数据量非常大，迁移过程中可能就会导致Redis阻塞，影响性能，所以采用**渐进式扩容**，步骤如下：
- 创建新哈希表，大小为旧哈希表的2倍
- 分多次迁移数据，期间如果有**删改查**请求，会先在旧哈希表操作，并将对应的数据迁移到新哈希表，如果数据已经迁移到新哈希表，就直接在新哈希表操作，**增**操作直接在新哈希表操作
- 迁移完成后，释放旧哈希表，将新哈希表设置为当前哈希表

### Redis为什么快？
- 基于内存，内存访问速度快
- 单线程，避免了多线程切换带来的开销
- IO多路复用，一个线程处理多个IO流

### Redis哪里用到了多线程？
Redis单线程一般指的是执行命令的线程是单线程，Redis6.0之后引入了多线程IO，主要用于网络IO，提升网络IO性能

### IO多路复用怎么实现？
- 多个客户端与redis服务端建立连接时，服务端会将每个客户端的socket对应的FD注册到一个事件监听器中
- 事件监听器会监听所有的FD，当有FD有事件发生时，会通知事件处理器处理该事件
- 避免了服务端一直等待某个客户端数据的问题

### 如何实现Redis的原子性？
- 如果执行一条命令，由于redis是单线程的，所以是原子性的
- 如果执行两个命令，可以通过lua脚本
- 如果执行多个命令，可以通过事务，如果事务正常执行，通过multi和exec命令，可以保证多个命令的原子性，如果某一个操作执行失败，就无法保证原子性了

### Redis持久化之AOF？
每执行一条写操作，就会将命令以追加写的方式写入AOF文件，当Redis重启时，会逐一执行AOF文件中的命令，恢复数据
有三种写回策略
- always：每次写操作都会同步写入AOF文件，保证数据的完整性
- everysec：每次写操作执行完后，先将命令写入内核缓冲区，然后每隔一秒将内核缓冲区的数据写入AOF文件
- no：每次写操作执行完后，将命令写入内核缓冲区，然后由操作系统决定何时将数据写入AOF文件


| 写回策略 | 写回时机         | 优点                           | 缺点                                       |
|----------|------------------|--------------------------------|--------------------------------------------|
| Always   | 同步写回         | 可靠性高、最大程度保证数据不丢失 | 每个写命令都要写回硬盘，性能开销大          |
| Everysec | 每秒写回         | 性能适中                       | 宕机时会丢失1秒内的数据                    |
| No       | 由操作系统控制写回 | 性能好                         | 宕机时丢失的数据可能会很多                 |

### AOF重写机制？
AOF文件会包含很多冗余或无效的命令，导致文件体积越来越大。AOF重写机制就是为了解决这个问题
- AOF重写不是基于旧的AOF文件进行修改，而是直接读取当前Redis数据库在内存中的状态，并为每个键值对生成最少的命令集合来恢复这个状态
- 一般主进程会fork一个子进程执行AOF重写
- AOF重写期间，如果遇到有新的写操作，主进程会按照之前的策略写入到AOF中，同时将这些命令记录在AOF重写缓冲区中
- 子进程完成AOF重写后，主进程会将AOF重写缓冲区中的所有命令追加到子进程生成的AOF文件的末尾

### Redis持久化之RDB?
将某一时刻的内存数据以二进制形式写入磁盘
Redis提供了save和bgsave两种方式生成RDB文件，他们的区别是是否在主进程中执行
- save会同步的执行保存操作，会阻塞主进程
- bgsave会在后台子进程执行，不会阻塞主进程(异步)
- RDB快照是全量快照，频繁执行会影响性能

### bgsave时，数据能被修改吗？
答：可以。bgsave时，Redis会fork一个子进程，子进程会复制父进程的页表，但是指向同一个物理内存。
但是当父进程数据要被修改时，会发生写时复制，数据所在的物理内存会被复制一份，然后主进程在数据的副本上修改，子进程仍然把旧的数据写入RDB。
所以如果修改的数据过多，就会导致bgsave过程中内存占用过多。

### AOF和RDB的优缺点？
AOF
- 优点：可靠性高，每次写操作都会写入AOF文件，即使服务器宕机，也只会丢失最后一次写操作，还可以通过选择合适的写回策略来平衡性能和可靠性
- 缺点：AOF文件体积更大，恢复速度慢，如果使用的是always策略，性能开销大

RDB：
- 优点：RDB文件体积小，恢复速度快
- 缺点：RDB是全量快照，如果宕机时，会丢失最后一次快照之后的数据，如果发生写时复制，会导致内存占用过多

### 讲讲Redis的内存淘汰策略？
不进行数据淘汰的策略：
- noeviction，当内存不足时，不淘汰任何数据。有新的输入写入会报错通知禁止写入
进行数据淘汰的策略：
- 针对设置了过期时间的数据：
    - volatile-random：随机淘汰设置了过期时间的数据
    - volatile-ttl：优先淘汰快过期的数据
    - volatile-lru：优先淘汰最久未使用的数据
    - volatile-lfu：优先淘汰最少使用的数据
- 针对所有范围数据：
    - allkeys-random：随机淘汰任意数据
    - allkeys-lru：优先淘汰最久未使用的数据
    - allkeys-lfu：优先淘汰最少使用的数据

### Redis的过期删除策略？
过期删除采用惰性删除和定期删除两种方式
- 惰性删除：只有在使用key时，才会检查key是否过期，如果过期才删除
- 定期删除：每隔一段时间（每秒10次，可以在redis.conf配置），会随机抽取一些key（一般为20个）检查是否过期，如果过期就删除

### 为什么不立刻删除过期key？
答：当过期的key很多时，立刻删除会占用一定CPU，影响性能

### Redis全量同步？
全量同步一般发生在下面的情况：
- 第一次同步
- 从服务器数据丢失
- 主从数据差异太大

全量同步的过程：
- 从服务器发送同步请求
- 主服务器生成RDB文件，发送给从服务器
- 从服务器接收RDB文件，并载入数据
- 主服务器生成和传输RDB期间，写操作会记录在replication backlog中
- 从服务器载入完RDB后，主服务器将replication backlog发送给从服务器，从服务器执行这些命令，保证数据一致

### Redis增量同步？
增量同步主要通过replication backlog和两个offset实现：
replication backlog实际上是一个环形数组，其中master offset记录了主服务器写的位置，slave offset记录了从服务器读的位置
如果主服务器写的太快，从服务器读的太慢（网络原因），那么slave offset就会被覆盖，这时候就会发生全量同步

### 介绍一下Redis哨兵机制？
哨兵机制主要用于监控Redis集群的状态，主要作用是`监控、故障转移、通知`
- 监控：哨兵会定时检查主从集群的状态
- 故障转移：当主服务器宕机时，哨兵会选举一个从服务器作为新的主服务器
- 通知：当主从集群状态发生变化时，哨兵会通知客户端

### 哨兵机制如何监控？
首先哨兵会基于心跳检测来判断节点状态
- 主观下线：如果某个哨兵发现某个节点长时间未响应，就会认为该节点主观下线
- 客观下线：当超过一定数量的哨兵认为某个节点主观下线，就会认为该节点客观下线

### 哨兵如何选择新的主服务器？
- 首先哨兵需要选出一个leader，当一个哨兵认为主节点主观下线了，它会请求其他哨兵选自己为leader,被请求的哨兵如果没有投过票，则当前哨兵票数+1，一般票数超过半数，则选举成功
- leader会根据策略选出新的主节点
    - 首先排除故障的节点
    - 选择优先级最大的节点
    - 如果优先级相同，选择复制偏移量最大的节点
    - 如果以上都相同，选择runid最小的节点

### 介绍一下分片集群？
redis分片集群主要用于解决单机内存有限的问题，通过分片将数据分布到多个节点中，提高了内存的使用率，提高了读写性能

分片集群一共有16384个槽，每个节点都包含若干个槽
当添加数据时，步骤如下：
- 通过CRC16算法计算key的哈希值
- 将哈希值对16384取模，得到槽号

如何将同一类数据固定的保存在同一个Redis节点？
答：使用`{}`将key中的部分字符串包裹，如`{user:101}:name`，这样只根据`user:101`来计算哈希值，保证`user:101`的数据都保存在同一个节点

### Redis分布式锁的原理？
#### 加锁
Redis分布式锁主要用于控制某个资源在同一时刻只能被一个应用使用。
NX参数实现**key不存在才插入**，可以通过它实现分布式锁
- key不存在，则插入成功，表示加锁成功
- key存在，则插入失败，表示加锁失败

使用分布式锁的条件：
- 加锁需要以原子操作完成，通过set 命令带上NX参数实现
- 锁需要设置过期时间，可以通过PX参数设置
- 锁需要区分不同的客户端，所以需要一个唯一ID来标识客户端

所以一个加锁的命令如下：
`set lock_key 101 NX PX 30000`

#### 解锁
解锁需要两步操作：
- 判断执行解锁操作的客户端就是加锁的客户端
- 删除lock_key

由于是两个操作，为了保证原子性，一般用lua脚本实现


### redis实现的分布式锁有什么问题？
- 锁的过期时间不好设置，过短可能任务没执行完就释放锁，过长可能影响性能
- 持有锁的客户端宕机，锁无法释放
- 时钟漂移，不同服务器的时钟可能不一致，导致锁的过期时间不准确
- redis的分布式锁不可重入，redisson可以重入
- 主从模式下，主节点获得锁之后宕机，此时新的主节点仍然可以获取锁，导致两个线程获取同一把锁

### redis分布式锁的互斥性问题怎么解决？
之前说分布式锁主从模式下，主节点获得锁之后宕机，此时新的主节点仍然可以获取锁，导致两个线程获取同一把锁，这样可能就导致**数据不一致**

要解决这个问题，可以考虑使用红锁
- 红锁的思想是，在多个redis节点上加锁，只有多数节点加锁成功（但不持有锁），才算加锁成功

红锁由于实现负责、性能开销大，所以一般不推荐使用，如果要保证强一致性，可以考虑使用zookeeper等分布式锁实现


### 基于redis实现分布式锁如何自动续期？
可以通过redisson实现，redisson提供了一个watch dog机制来监控和续期锁，watch dog的原理如下：
- 加锁成功后，每隔10s，看门狗就会通过lua脚本进行续期，每次续期前先判断是否为持锁线程，是则将超时时间设置为30s
- 使用redisson时，只需要调用lock.lock()方法，watch dog会自动续期，如果设置了过期时间，就不会用到watch dog自动续期





### 什么是大Key问题？
大Key问题指的是Redis中某个key的value过大，导致Redis处理这个key时，会占用大量的内存，影响Redis的性能
- 高并发、低延迟场景中，超过10kb可能就构成大key
- 低并发、高容量场景中，超过100kb可能才构成大key

一般会造成以下影响：
- 内存占用过大
- 读写性能下降
- 可能阻塞其他操作
- 造成网络拥塞
- 造成主从延迟
- 造成Redis集群不均衡

### 如何解决大Key问题？
- 对大key进行拆分
- 对大key进行删除，要用异步删除
- 监控redis内存状态，及时发现大key
- 对过期数据定期进行清理

### 如何解决热key问题？
热key指某个key的访问频率过高

解决方法：
- 将热key复制并迁移到多个数据分片
- 使用读写分离架构，将热key读请求分发到多个从节点



### 缓存雪崩如何解决？
缓存雪崩指的是大量key在同一时间失效，导致请求全部落到数据库上，引起数据库压力过大，甚至宕机

解决方法：
- 随机设置不同的过期时间，避免同一时间大量key失效
- 添加降级或者限流策略，保护数据库避免宕机
- 使用多级缓存，如本地缓存等，分担redis的压力

### 如何设计秒杀场景处理高并发和超卖问题？
- 在数据库层面，查询时通过for update增加排他锁，其他线程无法删改数据，更新库存时添加判断，保证库存为正数
- 利用Redis分布式锁，同一个时间只有一个客户端能获得锁
- 利用分布式锁+分段缓存，将数据分段，每个段拥有独立的锁，避免锁的粒度过大
- 利用incr、decr的原子性+异步队列，步骤如下：
    - 初始化时，将库存数量写入Redis
    - 用户请求时，通过decr预减库存，如果库存小于0，说明超卖，返回失败
    - 将请求放入异步队列
    - 从队列取出请求，更新数据库库存
    - 用户端通过轮询判断是否秒杀成功

### 如何处理重复下单问题？
重复下单问题，本质上就是幂等性问题，高并发下单，高并发抢红包，高并发支付等都属于这类问题

#### 基础性解决方案
- 全局唯一ID，如UUID，雪花算法，业务字段+时间戳等
- 唯一索引（去重表），如果重复创建，数据库会抛出异常
- 版本号

#### 综合性解决方案
**一锁二判三更新**
- 一锁：通过分布式锁，或者是分布式锁+分段锁
- 二判：进行幂等性判断如唯一ID、版本号等
- 三更新：更新数据

### 如何保证双写一致性？
双写一致性指的是更新数据时，数据库和redis的数据要保持一致

- 一般对于读操作，先从redis中读，如果命中直接返回，如果没有命中则查询数据库，写入缓存，并设置超时时间
- 对于写操作，采用延迟双删的策略，先更新数据库，再删除缓存

为什么要删除两次？
- 因为无论是先删除缓存再更新数据库，还是先更新数据库再删除缓存，都有可能出现脏数据的情况

为什么要延时双删？
- 一般数据库是主从模式，读写分离，需要延迟一会等数据同步到从节点，但延时的时间不好确定，所以仍然不能做到百分百一致性。

有没有更好的方案？
- 对于强一致性要求的场景，可以使用redis中的读写锁，但是性能会下降
- 对于最终一致性要求的场景
    - 可以使用异步消息队列，将删除缓存的消息放到消息队列中
    - 还可以使用canal订阅binlog的方式，把canal作为一个从节点，监听binlog的变更，然后删除缓存



## 介绍一下雪花算法？
雪花算法是 64 位 的二进制，一共包含了四部分：

- 1位是符号位，也就是最高位，始终是0，没有任何意义，因为要是唯一计算机二进制补码中就是负数，0才是正数。
- 41位是时间戳，具体到毫秒，41位的二进制可以使用69年，因为时间理论上永恒递增，所以根据这个排序是可以的。
- 10位是机器标识，可以全部用作机器ID，也可以用来标识机房ID + 机器ID，10位最多可以表示1024台机器。
- 12位是计数序列号，也就是同一台机器上同一时间，理论上还可以同时生成不同的ID，12位的序列号能够区分出4096个ID。
## 动态代理
### 什么是动态代理？
动态代理是一种在运行时创建代理对象的机制，主要用于在不修改原始类的情况下对方法调用进行拦截和增强
主要分为两种类型：
- JDK动态代理：这种类型要求目标类必须实现至少一个接口。通过Proxy类和InvocationHandler接口实现，当通过代理对象调用方法时，会转发到由InvocationHandler接口的invoke()方法调用。
- CGLIB动态代理：CGLIB可以在运行时动态生成一个目标类的子类，不需要目标类实现接口，而是通过继承的方式实现代理。
- ASM代理：使用字节码编程，操作字节码指令
- Byte-Buddy：也是字节码操作的类库，但通过API就能操作字节码，实现更加简单
- Javassist：也是字节码操作的类库，相对于ASM，Javassist更加简单易用

### JDK动态代理的实现步骤？

- 定义一个接口，以及实现类xxxserviceImpl
- 定义一个动态代理类并实现InvocationHandler接口，重写invoke方法
- 通过Proxy.newProxyInstance方法创建代理对象，这样就可以调用代理对象的方法，实际上是调用了invoke方法

### CGLIB动态代理的实现步骤？
Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。
- 定义一个类，不需要实现接口
- 自定义一个类实现MethodInterceptor接口，重写intercept方法
- 通过Enhancer类的create方法创建代理对象

## 自定义注解的三个注解的含义？
- @Retention：注解的生命周期，分为SOURCE、CLASS、RUNTIME
    - SOURCE：编译器会丢弃该注解
    - CLASS：编译器会保留该注解，但 JVM 会丢弃该注解
    - RUNTIME：编译器和 JVM 都会保留该注解，可以通过反射获取
- @Target：注解的作用范围，分为TYPE、FIELD、METHOD、PARAMETER等
    - TYPE：可以作用于类、接口、枚举等
    - FIELD：可以作用于属性
    - METHOD：可以作用于方法
    - PARAMETER：可以作用于参数
- @Documented：表示该注解会被包含在 Javadoc 中
## AOP
### 什么是AOP？
AOP是将一些横切关注点如日志、事务、权限控制等与核心业务逻辑分离，通过动态代理等技术实现代码的复用和解耦，提高代码的可维护性和可扩展性。

### AOP的一些术语有哪些？
- 横切关注点：多个类或者对象的公共行为，如日志、事务、权限控制等
- 切面：对横切关注点进行封装的类，一个切面是一个类
- 连接点：程序执行的某个特定的时刻，如方法的调用、异常的处理等
- 通知：在某个连接点要执行的操作
- 切点：一个切点是一个表达式，用来匹配连接点
- 织入：将切面和目标对象连接起来的过程

### AOP的通知都有哪些类型？
- 前置通知：在目标对象的方法调用前触发
- 后置通知：在目标对象的方法调用后触发
- 返回通知：目标对象的方法正常返回后触发
- 异常通知：目标对象的方法抛出异常后触发
- 环绕通知：手动控制触发的时机

### AOP的应用场景？
- 日志记录
- 性能统计
- 事务管理：如`@Transactional`注解就是基于AOP实现的
- 权限控制：利用 AOP 在目标方法执行前判断用户是否具备所需要的权限
- 接口限流

### AOP实现日志记录怎么做？
- 定义一个自定义的注解Log
- 定义一个切面类，通过切入点和通知指定什么时候进行日志记录
```
@Component
@Aspect
public class LogAspect {
  // 切入点，所有被 Log 注解标注的方法
  @Pointcut("@annotation(cn.javaguide.annotation.Log)")
  public void webLog() {
  }

   /**
   * 环绕通知
   */
  @Around("webLog()")
  public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {
    // 省略具体的处理逻辑
  }

  // 省略其他代码
}
```
- 在需要记录日志的方法上添加@Log注解即可

## 设计模式

### 创建型模式
- 工厂模式：在父类中提供一个创建对象的方法，由子类决定实例化对象的类型。
- 抽象工厂模式：创建一系列相关对象，无需指定具体类
- 建造者模式：将多个简单对象一步步组装成为一个复杂的对象
- 原型模式：通过clone现有对象来创建新对象
- 单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点

### 结构型模式
- 适配器模式：将原本不兼容的接口通过适配修改做到统一
- 代理模式：为某些对象的访问提供代理，通过代理去控制原始对象的访问
- 装饰器模式：在不改变原有类的情况下，给类新增功能
- 桥接模式：将抽象部分与它的实现部分分离，比如A类中含有B类的接口，通过构造函数传递B类的实现
- 组合模式：将相似对象组合成可被调用的结构树对象
- 外观模式：为复杂的类或框架提供一个简单的接口
- 享元模式：共享通用对象，减少内存的使用，提升系统的访问效率

### 行为型模式
- 责任链模式：解决一组服务中的先后执行处理关系，将请求沿着处理链传递
- 命令模式：以数据驱动的方式将命令对象，可以使用构造函数的方式传递给调用者。调用者再提供相应的实现为命令执行提供操作方法。
- 迭代器模式：以相同的方式去遍历不同的数据结构元素
- 中介者模式：解决复杂功能应用之间的重复调用，在这中间添加一层中介者包装服务，对外提供简单、通用、易扩展的服务能力。
- 备忘录模式：以不破坏原对象为基础增加备忘录操作类，记录原对象的行为
- 观察者模式：定义一种订阅机制，当对象事件发生时，通知所有订阅者
- 状态模式：让对象在不同状态下有不同的行为
- 策略模式：定义一系列算法， 并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。
- 模板方法模式：通过在抽象类中定义抽象方法的执行顺序，并将抽象方法设定为只有子类实现，但不设计独立访问的方法
- 访问者模式：在稳定的数据结构下，增加易变的业务访问逻辑，即同一个事物不同视角下的访问信息不同


### 实现一个单例模式
```
public class SingleTon{
    private static volatile SingleTon instance=null;
    private SingleTon(){}
    public static SingleTon getInstance(){
        if(instance==null){
            synchronized(SingleTon.class){
                if(instance==null){
                    instance=new SingleTon();
                }
            }
        }
        return instance;
    }
}
```
- 通过volatile关键字，禁止指令重排序，保证线程安全
- synchronized加在方法内部，提升执行效率
- 第一次判断非null直接返回，避免每次都加锁
- 第二次判断是为了保证线程安全，避免重复创建对象

## 消息队列

### 消息队列怎么选型？

几种常见的MQ对比如下：
| 特性         | ActiveMQ   | RabbitMQ  | RocketMQ           | Kafka             |
|--------------|------------|-----------|--------------------|-------------------|
| 单机吞吐量   | 万级       | 万级      | 10 万级            | 10 万级           |
| 时效性       | 毫秒级     | 微秒级    | 毫秒级             | 毫秒级            |
| 可用性       | 高（主从） | 高（主从）| 非常高（分布式）   | 非常高（分布式）  |
| 消息重复     | 至少一次   | 至少一次  | 至少一次 最多一次  | 至少一次最多一次  |
| 消息顺序性   | 有序       | 有序      | 有序               | 分区有序          |
| 支持主题数   | 千级       | 百万级    | 千级               | 百级，多了性能严重下滑 |
| 消息回溯     | 不支持     | 不支持    | 支持（按时间回溯） | 支持（按offset回溯） |
| 管理界面     | 普通       | 普通      | 完善               | 普通              |

- 对于大型秒杀场景，主要看吞吐量，选kafka和RocketMQ更好
- 如果做中台，对外提供能力，有很多主题接入，选RocketMQ和RabbitMQ
- 至于时效性，微妙和毫秒的差别并不大，加上网络的波动，在实际业务中反而不会作为重要的考量因素

### 消息队列的应用场景有哪些？
- 解耦：在多个系统之间进行解耦，将原本通过网络调用的方式改为通过消息队列进行异步调用
- 异步：一个操作如果分为多个步骤，可以把某些不需要同步的步骤放到消息队列中，比如下单后发送短信通知，修改用户积分等
- 削峰：比如秒杀场景，瞬间大量请求到来，可以先放入消息队列，然后系统根据自己的处理能力处理，同时跟进业务逻辑，给用户返回特定界面或稍后通知结果

### 消息丢失怎么解决？
主要从生产者、MQ、消费者三个方面解决
- 生产者：通过生产者确认机制，消息到达MQ后返回给生产者ack，返回异常可以考虑重发
- MQ：RabbitMQ通过持久化消息或者懒队列，保证消息可靠性，kafka可以在多个节点保存消息的副本
- 消费者：通过消费者确认机制和失败重试机制，保证消费者的可靠性，如果达到重试次数，有3种处理方式：1. 丢弃消息，reject 2. 返回nack,消息重新入队列 3. 将消息发送到指定队列

### 消息队列的可靠性、顺序性怎么保证？

可靠性：
- 消息持久化
- 消费者确认机制
- 消费者失败重试机制

顺序性：
- 首先明确需要哪些业务需要保证顺序性，比如转账操作的顺序性
- 有的消息队列本身就支持顺序性，如kafka按照消息的key将消息分区，每个分区内的消息按照写入顺序被消费
- 此外，如果多个消费者消费同一个队列，或者多线程消费同一个分区，那么就无法保证顺序性了，可以使用单线程或者使用线程池对消息进行串行化处理

## Spring

### Spring的单例Bean是线程安全的吗？

不是
Spring框架中有一个@Scope注解，默认就是单例的
- 一般注入对象都是无状态（不可修改）的对象，没有线程安全问题
- 但是如果在Bean中定义了可修改的成员变量，就有可能出现线程安全问题

### Spring中的事务是如何实现的？
Spring中提供两种事务实现方式，一种是编程式事务，一种是声明式事务
- 编程式事务：通过TransactionTemplate实现，对业务代码有侵入性
- 声明式事务：通过AOP实现，对方法前后进行拦截，将事务处理逻辑织入到业务代码中

### Bean的生命周期？
- 通过构造函数实例化Bean
- 进行依赖注入
- 处理Aware接口
- 前置的BeanPostProcessor，用于处理Bean的初始化前的操作
- 初始化Bean，自定义init-method方法
- 后置的BeanPostProcessor，初始化后做一些增强
- 销毁Bean

### Bean的循环依赖怎么解决？
循环依赖出现的原因是，如果A和B互相以来，当A到了依赖注入B的阶段，会去执行B的生命周期，此时B也要依赖注入A，这样就会造成循环依赖，这样导致双方都无法完成Bean的初始化。

通过三级缓存解决
- 一级缓存：sigleton objects，单例池，存放走完生命周期的Bean
- 二级缓存：early singleton objects，存放半成品的Bean，生命周期还没走完
- 三级缓存：singleton factories，存放Bean的工厂，用来创建对象

在A实例化后，会创建一个ObjectFactory，放入三级缓存中，当B需要注入A对象时，用A的ObjectFactory创建对象，并放入二级缓存，同时B获得A的对象后完成注入，然后B完成生命周期，放入单例池中，然后A也完成生命周期，放入单例池中

构造方法出现了循环依赖怎么办？
答：可以使用@Lazy注解，懒加载，等到需要使用的时候再去实例化对象，这样就不会出现循环依赖的问题了


## 介绍一下CAP和BASE理论
CAP分别对应了一致性、可用性和分区容错性
- 一般分布式系统中都会涉及分区问题P
- 当分区出现时，一致性C和可用性A就无法同时满足

BASE理论是CAP的一种解决思路，包括三个主要思想：
- 基本可用性：系统在出现故障时，仍然可以提供部分服务
- 软状态：允许临时的不一致状态
- 最终一致性：系统在经过一段时间后，最终会达到一致状态

## 介绍一下TCC模式
TCC是Try-Confirm-Cancel的缩写，是一种分布式事务解决方案
- Try：尝试执行，预留资源
- Confirm：完成资源操作业务，try成功confirm一定要成功
- Cancel：预留资源的释放，可理解为try反向操作

与XA和AT模式不同的是，TCC模式每一步都需要代码手动实现

## 定时任务有哪些实现方式？
- 单机定时任务：
    - Timer
    - ScheduledThreadPoolExecutor
    - DelayQueue
    - spring task，也就是用@Scheduled注解实现的定时任务，支持cron表达式
- 分布式定时任务：
    - redis过期事件监听
    - redisson内置的延时队列
    - MQ的延时消息
- 分布式任务调度框架
    - Quartz，比较早的定时任务框架，缺点是不支持可视化管理，使用
    - xxl-job，使用广泛，开箱即用
    - power job，使用广泛，开箱即用

## 认证授权

### 介绍一下RBAC模型？
- RBAC意思是基于角色的权限访问控制（Role-Based Access Control）
- 在RBAC中，用户与角色、角色与权限之间，都构成了多对多的关系
- 一般在数据库中，RBAC模型除了有用户表、角色表、权限表外，还有用户角色表和角色权限表两张中间表



# CS基础
## 进程和线程的区别
>进程是资源分配的基本单位，线程是资源调度的基本单位(轻量级进程)

* 多个线程共享地址空间/资源，而进程之间的地址空间/资源是独立的
* 一个线程只能属于一个进程，一个进程可以有多个线程
* 创建/撤销线程的系统开销明显小于进程

## 硬链接和软链接的区别
### 硬链接
- 在 Linux/类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。
- 硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删。
- 只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。
- 硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。
- `ln` 命令用于创建硬链接。

### 软链接（符号链接）
- 软链接和源文件的 inode 节点号不同，而是指向一个文件路径。
- 源文件删除后，软链接依然存在，但是指向的是一个无效的文件路径。
- 软连接类似于 Windows 系统中的快捷方式。
- 不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，软链接可以跨越文件系统。
- ln -s 命令用于创建软链接

### 为什么硬连接不能跨文件系统？
- 硬链接是通过 inode 节点号建立连接的，而硬链接和源文件共享相同的 inode 节点号。
- 然而，每个文件系统都有自己的独立 inode 表，且每个 inode 表只维护该文件系统内的 inode。
- 如果在不同的文件系统之间创建硬链接，可能会导致 inode 节点号冲突的问题，即目标文件的 inode 节点号已经在该文件系统中被使用。

## 动态编译和静态编译
### 静态编译
在编译时将程序与其所有依赖项（包括库）链接在一起，形成一个单独的可执行文件。这个可执行文件包含了所有代码和数据，因此它是一个完全独立的二进制文件。

静态编译启动速度快，不需要依赖外部库，但可执行文件体积较大。

### 动态编译(运行时编译)
在编译时只创建程序的框架，而不将所有依赖项包含在可执行文件中。实际的库文件是在运行时加载的，程序在需要时动态链接到这些库。

## TCP三次握手
### 三次握手
三次握手的过程如图：
![三次握手](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png)
- 一次握手:客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 SYN_SEND 状态，等待服务端的确认；
- 二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 SYN_RECV 状态；
- 三次握手:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务端都进入ESTABLISHED 状态，完成 TCP 三次握手。

### 为什么要三次握手？
三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。
- 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
- 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
- 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

### 第二次发送了ACK，为什么还要发送SYN？
服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。

### 三次握手过程可以携带数据吗？
在 TCP 三次握手过程中，第三次握手是可以携带数据的(客户端发送完 ACK 确认包之后就进入 ESTABLISHED 状态了)

如果第三次握手的 ACK 确认包丢失，但是客户端已经开始发送携带数据的包，那么服务端在收到这个携带数据的包时，如果该包中包含了 ACK 标记，服务端会将其视为有效的第三次握手确认。这样，连接就被认为是建立的，服务端会处理该数据包，并继续正常的数据传输流程。

## TCP四次挥手
### 四次挥手
TCP 四次挥手的过程如图：
![四次挥手](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png)

- 第一次挥手：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 FIN-WAIT-1 状态。
- 第二次挥手：服务端收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。
- 第三次挥手：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。
- 第四次挥手：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。
>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！

### 为什么要四次挥手？
TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

举个例子：A 和 B 打电话，通话即将结束后。
- 第一次挥手：A 说“我没啥要说的了”
- 第二次挥手：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话
- 第三次挥手：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”
- 第四次挥手：A 回答“知道了”，这样通话才算结束

### 为什么服务端不把 ACK 和 FIN 一起发送，变成三次挥手？
因为服务端收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务端到客户端的数据传送。

### 第二次挥手服务端发送ACK没有到达会怎么样？
客户端没有收到 ACK 确认，会重新发送 FIN 请求。

### 为什么第四次挥手，客户端要等待 2MSL（报文最长存活时间）才进入CLOSED状态？
第四次挥手时，客户端发送给服务端的 ACK 有可能丢失。
- 如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN
- 如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。



# C++
## c++中的static关键字

加载顺序（面向对象）
* 静态->非静态->构造方法
* 父类静态-子类静态-父类非静态-父类构造-子类非静态-子类构造

静态成员变量(面向对象)
* 所有对象共享,不属于某个对象，可以通过类名访问，也可通过对象访问
* 在编译阶段分配内存，分配在数据区（全局区）
* 类内声明，类外初始化(class::var)
* sizeof不会计算静态成员变量

静态成员函数(面向对象)
* 所有对象共享同一个函数
* 静态成员函数只能访问静态成员变量
* 不含this指针(不能被实例使用)

静态全局变量(面向过程)

* 在数据区分配内存
* 未初始化会自动初始化为0
* 整个文件内可见，文件外不可见

静态局部变量(面向过程)

* 在数据区分配内存 
* 一般在声明处初始化，未初始化会自动初始化为0
* 静态局部变量始终驻留在数据区，但他的作用域是局部作用域，当定义它的函数或语句块结束，其作用域随之结束

>总结：静态变量具有全局变量的生命周期，但只能作用于自己的作用域。

***

## c++模板

>模板是c++泛型编程的主要使用的技术

**函数模板**

创建一个通用的函数，函数返回值类型和形参可以不指定，用一个虚拟的类型来表示

声明一个模板`template<typename T>`或者`template<class T>`

示例：
```
#include<bits/stdc++.h>
using namespace std;
template<typename T>
T sum(T a,T b)
{
	return a+b;
}
int main()
{
	double a=10.5,b=20.00002;
	cout<<"自动类型推导"<<endl;
	printf("%lf\n",sum(a,b));
	cout<<"显示指定类型"<<endl;
	printf("%lf",sum<double>(a,b));
	return 0;
} 
```

注意
* 自动推导类型需要推导出一致的类型
* 函数模板使用时必须确定`T`的类型
* 普通函数和函数模板都可调用时，先调用普通函数
* 如果类型和函数模板更匹配，则优先调用函数模板

**类模板**

示例：
```
#include<bits/stdc++.h>
using namespace std;
template<class T,class M>
class person
{
public:
	T name;
	M age;
	person(T a,M b):name(a),age(b){}
};
int main()
{
	person<string,int> p("cndh",18);
	cout<<p.name<<endl;
	cout<<p.age<<endl;
	return 0;
} 
```
注意：
* 类模板不能自动推导类型
* 类模板可以在模板参数列表中指定默认类型
* 类模板中定义的函数在调用时才创建

---

## c++深拷贝和浅拷贝的区别

>**浅拷贝** （默认方式）：将原对象的引用直接赋给新对象，只是原对象的一个引用。

>**深拷贝**： 创建一个新的对象，将原对象的各项属性拷贝过来，深拷贝会在堆中额外申请内存来储存数据，当数据成员中有指针时，必须要用深拷贝。

* 因为申请了新的内存，所以深拷贝改变新对象的属性对原对象没有影响，但是浅拷贝会影响
* 当成员中有指针时，必须用深拷贝。因为浅拷贝的新指针和旧指针都指向同一块内存，在新对象和旧对象析构时，已经释放的内存会被再次释放，这时会出现错误。

***

## c++多态

编译时多态：

* 编译器多态是通过函数重载和模板实现的。在编译时，根据函数的参数类型或模板参数类型，编译器会选择合适的函数或模板实例化。
* 编译器多态是在编译时确定函数调用，因此它的性能较高。
* 编译器多态不需要使用虚函数和基类指针或引用，可以直接根据函数的参数类型或模板参数类型来确定函数调用。

运行时多态：
* 运行时多态是通过继承和虚函数实现的。当基类的指针或引用指向派生类对象时，通过虚函数的动态绑定，可以在运行时确定要调用的函数实现。
* 运行时多态需要使用虚函数和基类指针或引用来实现，这样可以在运行时根据实际对象的类型来确定调用哪个函数。
* 运行时多态在运行时才能确定具体的函数调用，因此它的性能相对较低。

***override的作用***

保证在派生类中声明的重载函数，与基类的虚函数有相同的签名，核心作用就是用于编译期代码检查。

***final***

阻止类的进一步派生和虚函数的进一步重写，同时也是一种名为去虚拟化的优化技巧，相当于把运行期多态转换为了编译期多态，提高了执行效率。

***多继承存在的问题***

命名冲突

***向上转型***

向上转型是子类指针转换成父类指针

`Parent* p =new son();`

***向下转型***

因为父类指针不能操作子类独有的函数，即使父类指针指向子类的对象也不行，所以需要向下转型

向下转型有两种方式`dynamic_cast`和`static_cast`,前者更加安全一些

例如：
```
Parent* pSon=new Son();
Son* s=dynamic_cast<Son*>(pSon);
```

***
## 虚函数与纯虚函数

**虚函数**
在类中声明时前面带有virtual关键字的函数，如：
```
class A {
	virtual void example();
}
```
**纯虚函数**
```
在虚函数后面加`=0`
class A {
	virtual void example() = 0;
}
```
* 虚函数可以在父类中实现，也可以被子类重写实现，是实现运行时多态的方式之一
* 纯虚函数不可以在父类实现，必须由子类重写
* 含有纯虚函数的类被称为抽象类，抽象类不能实例化
* 抽象类的子类如果要实例化，则必须重写纯虚函数

**虚函数怎么实现的？真的更慢吗？**
* 虚函数是通过虚函数表实现的，每个类都有自己的虚表，对象的首地址处存放有指向虚表的指针。
* 当具体调用哪个虚函数可以在编译期间确定的时候，虚函数不一定更慢。

## c++智能指针

**内存泄漏**：
* 指因某些原因造成程序未能释放已不再使用的内存。内存泄漏并不是内存消失了，而是由于程序设计的问题，失去对某块内存的控制，导致无法利用该块内存。

* 内存泄漏会导致程序响应越来越慢，甚至崩溃

* 一般有2种内存泄漏，一种是堆区分配的内存没有及时释放，一种是套接字、文件描述符等没有释放，2种情形都会导致资源的浪费

**RALL**

* RAII（Resource Acquisition Is Initialization）是一种将对象生命周期和资源绑定的技术
* 对象创建时获取资源，析构时释放资源

智能指针就具有RALL的特性

**auto_ptr**

c++98中就已经提供了智能指针auto_ptr

例如：`auto_ptr<int> p(new int)`就相当于 `int * p=new int`

auto_ptr的局限性：
* 拷贝或者赋值会导致原指针变为`NULL`，如`p1=p2`后，`p2变成了NULL`
* 不支持对象数组的内存管理

**unique_ptr**



不能直接进行赋值或者拷贝构造，如：`p1 = p2`和`unique_ptr<int> p1(p2)`

如果要强行执行的话要加上`move`，如：`p1 = std::move(p2)`和`unique_ptr<int> p1(std::move(p2))`

**shared_ptr**

通过**引用计数**(`use_count()`)的方式来实现多个`shared_ptr`对象之间共享资源

* shared_ptr在其内部，给每个资源都有一份计数表，用来记录该份资源被几个指针共享
* 在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一
* 如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源
* 如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了

注意：两个对象交叉使用**shared_ptr**(互相获得对方的share指针),会导致内存泄漏

**weak_ptr**

专门为了解决上面的**shared_ptr**的问题，不支持RALL，不释放资源，不增加或减少引用计数

具体参考[相关链接](https://blog.csdn.net/cpp_learner/article/details/118912592?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166191088916782414982504%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166191088916782414982504&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118912592-null-null.142^v42^pc_rank_34,185^v2^control&utm_term=c%2B%2B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&spm=1018.2226.3001.4187)

***

## const 和 volatile辨析

**const**
* 被const修饰的变量被视为一个常量，使得变量具有只读属性
* const修饰的变量不是一个真正的只读变量，它只是告诉编译器该变量**不能出现在赋值符号的左边**

***const修饰指针变量有以下3种情况***
1. const 修饰指针指向的内容，则内容为不可变量。
```
const int *p = 8; //指向的内容8不可变
*p=6; //错误
```
2. const 修饰指针，则指针不可变
```
int a=8;
int* const p = &a;
*p = 9; // 正确
int  b = 7;
p = &b; // 错误
```
3. const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。
```
int a = 8, b = 2;
const int * const  p = &a;
*p=1; //错误
p=&b; //错误
```

***const 修饰对象和成员函数***
* 被const修饰的对象(常对象)或者成员函数(常函数)内不能修改类的成员变量，如果要修改需要给对应的成员变量加mutable关键字
* 常对象只能修改常函数

**volatile**

本意为易变的，有以下特点

* volatile指出变量是随时可能变化的，每次使用需要重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。
* 被volatile修饰的变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

>***一个变量可以同时被const和volatile修饰吗？***

可以。const volatile表示一个变量在程序编译期不能被修改且不能被优化；在程序运行期，每次必须从内存中加载变量的值。

## NULL 和 nullptr的区别是什么，为什么引入nulllptr？
* 主流编译器中，`NULL`实际上是一个整数常量，被定义为 0，在 C++11 之前，当我们想要将一个指针初始化为空时，我们通常使用 NULL；
* `nullptr` 是 C++11 中引入的新的关键字，专门用于表示空指针，它不是整数类型，而是特殊的指针类型`nullptr_t`。

***引入nullptr的原因***
1. NULL是整数类型，用户调用foo(NULL)的时候，不能区分调用的是foo(int)还是foo(int*)函数；
2. 主流编译器中NULL值为0，通过0表示一个无效地址，但是有的架构下，0地址有特定用途，而`nullptr`指向的永远是一个无效地址。

## git fetch和git pull的区别
* git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。
* 而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。

>git 连接/添加远程仓库
git remote add 仓库名 地址

## delete[]是怎样知道数组长度的？
没有标准实现，一种常见的实现方法是，申请内存时，会在返回的指针前面存放这段内存的大小，调用delete[]的时候，就可以知道数组长度了。

## 程序是从main 函数开始执行的吗？
不是，程序在执行前，会经历一个从磁盘加载程序到内存的过程，这个过程会执行非静态全局变量的初始化。

# python
## python的垃圾回收机制
>python采用的是**引用计数**为主，**标记—清除**和**分代收集**为辅的策略。

**引用计数**
每个对象维护一个字段来记录对象被引用的次数，当新的引用指向该对象的时候，引用计数的值加1,当某个引用失效时，引用计数值减一。当引用计数的值为0时，会释放占用的内存空间。

缺点：
* 需要额外的空间维护引用次数
* 对象的循环引用会导致内存泄漏

引用计数增加的情况：

* 对象被创建，例如 a = 23
* 对象被引用，例如 b = a
* 对象被作为参数，传入到一个函数中，例如 fun(a)
* 对象被作为一个元素，存储在容器中

引用计数减少的情况：

* 对象的别名被显式销毁，例如 del a
* 对象的别名被赋予新的对象，例如 a = 24
* 一个对象离开它的作用域，例如 f 的函数执行完毕时，func函数中的局部变量
* 对象所在的容器被销毁，或从容器中删除对象

**分代回收**

* 分代回收是一种以空间换时间的方式，Python将内存根据对象的存活时间划分为不同的集合，每一个集合称为一个代，Python将内存分为了3“代”，分别代表**年轻代**（第0代）、**中年代**（第1代）、**老年代**（第2代），它们对应的是3个链表，它们的垃圾收集频率随着对象的存活时间的增大而减小

* 新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾回收机制就会被触发，把那些可以被回收的对象被回收掉，而那些不会被回收的对象就会被移动到中年代，依次类推， 老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期中。

**标记--清除**

是一种基于追踪回收（tracking GC）技术实现的垃圾回收算法。它分为两个阶段：
 1. 标记阶段，GC会把所有的活动对象打上标记
 2. 把那些没有标记的对象（非活动对象）进行回收

**如何判断哪些是活动对象，哪些是非活动对象？**

对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从跟对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。
# deep learning
## 判别模型和生成模型

判别模型：直接学习条件概率$P(y|x)$
生成模型：学习联合概率$P(x,y)$，然后可以计算条件概率$P(y|x)$以及其他信息，需要的数据量较大


简单说，要判断一个苹果是好是坏，判别模型会直接给出是好的概率和是坏的概率，而生成模型分别学习出两种苹果各自对应的模型，然后将要预测的苹果的特征分别输入不同模型，然后比较两个模型输出概率的大小，选出合适的类别

判别模型：
* 感知机
* k近邻
* 决策树
* 逻辑思蒂回归
* svm
* boosting
* 最大熵模型

生成模型：
* 朴素贝叶斯
* 混合高斯模型
* 隐马尔可夫模型

## 转置卷积和空洞卷积

***转置卷积***
>在语义分割中，会使用卷积层进行特征提取，然后通过转置卷积做上采样，恢复为原先的尺寸，这样才可以对原来的图像中每个像素都进行分类。**转置卷积不是卷积的逆运算**

基本步骤：

* 在特征图**中间**(元素和元素之间)填充s-1行，s为步长
* 在特征图**四周**填充k-p-1行，k为卷积核大小，p为padding
* 将kernel上下、左右翻转（中心对称，顺时针旋转180度）
* 做kernel_size不变，s和p均为1的卷积即可

***空洞卷积***
* 在卷积核相邻元素之间插入0,具体插入膨胀率(dilation rate)-1个0，然后再做卷积
* 主要目的是扩大感受野

## 数据集不平衡的处理方式

1. 数据增广
	* 进行一定的旋转缩放
	* RGB三通道提取三张图片
	* 高斯模糊
2. 人工合成数据
3. 给每种类别赋予权值，样本少的类别权值可以大一些，样本多的类别权值小一些

## tensorflow和pytorch的区别

1. tf是谷歌开源的深度学习框架，pytorch是facebook开源的深度学习框架
2. 在tf1.0时，tf只支持静态的计算图，而pytorch支持动态的计算图，但是tf2.0也支持动态计算图了
3. tf的api更详细更丰富，pytorch的代码更简洁
4. tf有tensorboard这样的可视化工具，但实际上现在pytorch也能使用tensorboard

## transformer中的位置编码

>为什么需要位置编码？
* 位置和词语的顺序是任何语言的重要组成部分。它们定义了语法，从而决定了句子的实际语义。循环神经网络（RNN）本质上考虑了词语的顺序；它们按照顺序逐个解析句子中的词语。这样可以将词语的顺序整合到RNN的主干中。
* Transformer架构放弃了循环机制，转而采用**多头自注意机制**，大大加快训练时间。从理论上讲，它可以捕捉到句子中更长的依赖关系。由于句子中的**每个词语同时通过Transformer的编码器/解码器，模型本身对于每个词语的位置/顺序没有任何概念。**

>位置编码的计算？

$$
\left.\overrightarrow{p_t}^{(i)}=f(t)^{(i)}:=\left\{\begin{array}{ll}\sin(\omega_k.t),&\mathrm{if~}i=2k\\\cos(\omega_k.t),&\mathrm{if~}i=2k+1\end{array}\right.\right.
$$
其中，t代表位置，i代表维度。p代表第t个位置，第i个维度的值。$\omega_k$的计算如下：
$$
\omega_k=\frac1{10000^{2k/d}}
$$

有以下特点：
* 奇数维度之间或者偶数维度之间周期不同。
* 除了表示绝对位置信息外，还可以很好的表示相对位置信息。给定k,存在一个固定的与k相关的线性变换矩阵，从而由pos的位置编码线性变换而得到pos+k的位置编码。这个相对位置信息可能可以被模型发现而利用。因为绝对位置信息只保证了各个位置不一样，但是并不是像0,1,2这样的有明确前后关系的编码。

>CV中使用位置编码

与nlp中类似，cv中的每个像素和patch也有自己的位置信息，通常cv中位置编码有以下两种：

* 绝对位置编码：一般是可学习的，实现非常简洁，初始化一个形状和经过patch_embedding后的输出x相同的参数，然后直接加到x上，在训练阶段一起训练，有点像加了一个可学习的bias，VIT中使用的就是这种方式。
* 相对位置编码：绝对位置编码是在patch_embedding之后，计算自注意力(Q,K,V)之前，而相对位置编码是在计算自注意力的时候加入的，如下式
$$
\text{Attention}(Q,K,V)=\text{SoftMax}(\frac{QK^T}{\sqrt{d}}+B)V
$$
在swin transformer中，将二维位置信息转换为一维位置信息，然后去根据相对位置偏移表查询具体的值，位置偏移表的值是训练出来的，在文章中，相对位置编码效果好于绝对位置编码。具体参考[这里](https://blog.csdn.net/qq_43733107/article/details/127077056)

>为什么往往小数据集上卷积效果好于tranformer?
* 在小数据集上，相比卷积transformer缺少内在偏置，因此需要加入相对位置编码来解决这个问题，而对于特大数据集，transformer就可以学习到卷积的内在偏置，即这也是为什么在小数据集上transformer的效果不如卷积，而在大数据集上，transformer效果优于卷积。

## 自注意力和注意力的区别

注意力机制的查询和键是不同来源的，而自注意力机制的查询和键则都是来自于同一组的元素，如对于一张图片，q和k都来自于这张图片的patch或者特征。

>个人对于DETR的decoder中的q，k,v的理解

query是每张图设置的预测的proposals的数量，例如一张图的gt有20个bbox，然后query为100，那么网络会产生100个proposals，然后用匈牙利算法求得100个query和20个bbox的最优匹配

对于decoder的多头注意力，我理解的是kv来自encoder是因为encoder中将图像的特征进行了编码，然后由于需要产生100个proposals，所以就用外部的q来计算encoder产生的k的权重信息，比如qk^T->[16,100,32]*[16,32,576]=[16,100,576]，这里[100,576]代表了100个query在576个特征上的权重或者相似度信息，然后乘v[16,576,32]，输出是[16,100,32]，reshape为[100,2,256]，encoder的输出[576,2,256]经过decoder后映射为[100,2,256]，因此加入的query可能是为了学习encoder的输出中的特征信息，然后将特征的维度降到100，然后从这100个proposals中取匹配最佳的gt。


