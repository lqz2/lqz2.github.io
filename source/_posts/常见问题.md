---
title: 常见问题
date: 2022-08-26 21:10:10
categories: 学习
math: true
tags:
---
<!-- TOC -->

- [Java](#java)
    - [JDK、JRE和JVM是什么？](#jdkjre和jvm是什么)
        - [JDK](#jdk)
        - [JRE](#jre)
        - [JVM](#jvm)
    - [字节码](#字节码)
    - [为什么说Java“编译与解释共存”？](#为什么说java编译与解释共存)
    - [AOT和JIT](#aot和jit)
    - [Java内存区域](#java内存区域)
        - [程序计数器](#程序计数器)
        - [虚拟机栈](#虚拟机栈)
        - [本地方法栈](#本地方法栈)
        - [堆](#堆)
        - [方法区](#方法区)
        - [运行时常量池和字符串常量池](#运行时常量池和字符串常量池)
        - [直接内存](#直接内存)
        - [为什么要将永久代替换为元空间？](#为什么要将永久代替换为元空间)
    - [JVM垃圾回收](#jvm垃圾回收)
        - [内存分配和回收原则](#内存分配和回收原则)
        - [死亡对象的判断方法](#死亡对象的判断方法)
        - [垃圾回收算法](#垃圾回收算法)
        - [垃圾回收器有哪些？](#垃圾回收器有哪些)
        - [垃圾回收器CMS和G1的区别?](#垃圾回收器cms和g1的区别)
    - [基础数据类型](#基础数据类型)
    - [有一个学生类，想按照分数排序，再按学号排序，应该怎么做？](#有一个学生类想按照分数排序再按学号排序应该怎么做)
    - [Java集合](#java集合)
        - [数组和集合的区别？](#数组和集合的区别)
        - [ArrayList和LinkedList的区别？](#arraylist和linkedlist的区别)
        - [ArrayList的扩容机制是什么？](#arraylist的扩容机制是什么)
        - [CopyonWriteArraylist是如何实现线程安全的？](#copyonwritearraylist是如何实现线程安全的)
        - [HashMap实现原理介绍一下？](#hashmap实现原理介绍一下)
        - [解决哈希冲突的方法有哪些？](#解决哈希冲突的方法有哪些)
        - [HashMap的put过程？](#hashmap的put过程)
        - [为什么HashMap用红黑树不用平衡二叉树？](#为什么hashmap用红黑树不用平衡二叉树)
        - [HashMap key可以为null吗？](#hashmap-key可以为null吗)
        - [重写HashMap的equals和hashCode方法时，要注意什么？](#重写hashmap的equals和hashcode方法时要注意什么)
        - [为什么HashMap的大小是2的幂次方？](#为什么hashmap的大小是2的幂次方)
        - [ConcurrentHashMap是如何实现线程安全的？](#concurrenthashmap是如何实现线程安全的)
        - [分段锁是怎么加锁的？](#分段锁是怎么加锁的)
        - [ConcurrentHashMap用的是乐观锁还是悲观锁？](#concurrenthashmap用的是乐观锁还是悲观锁)
        - [hashtable和ConcurrentHashMap的区别？](#hashtable和concurrenthashmap的区别)
    - [面向对象](#面向对象)
        - [面向对象的设计原则有哪些？](#面向对象的设计原则有哪些)
        - [抽象类和接口的区别](#抽象类和接口的区别)
        - [抽象类可以被实例化吗？](#抽象类可以被实例化吗)
        - [Java深拷贝的方式有哪些？](#java深拷贝的方式有哪些)
    - [Java中的对象](#java中的对象)
        - [Java中创建对象有哪些方式？](#java中创建对象有哪些方式)
        - [new的对象什么时候回收？](#new的对象什么时候回收)
    - [反射机制](#反射机制)
        - [什么是反射机制？](#什么是反射机制)
        - [反射在你平时写代码或者框架中的应用场景有哪些?](#反射在你平时写代码或者框架中的应用场景有哪些)
    - [Java注解的原理](#java注解的原理)
    - [== 与 equals 有什么区别？](#-与-equals-有什么区别)
    - [StringBuffer和StringBuilder区别是什么？](#stringbuffer和stringbuilder区别是什么)
    - [MYSQL的有哪几种引擎？](#mysql的有哪几种引擎)
    - [慢查询如何解决？](#慢查询如何解决)
    - [MYSQL的日志？](#mysql的日志)
        - [MYSQL了解哪些日志？](#mysql了解哪些日志)
        - [介绍一下bin log？](#介绍一下bin-log)
    - [并发](#并发)
        - [线程安全体现在哪些方面？](#线程安全体现在哪些方面)
        - [什么是CAS操作？](#什么是cas操作)
        - [CAS的缺点？](#cas的缺点)
        - [线程创建方式有哪些？](#线程创建方式有哪些)
        - [如何停止线程？](#如何停止线程)
        - [线程的状态有哪些？](#线程的状态有哪些)
        - [blocked和waiting的区别？](#blocked和waiting的区别)
        - [notify和notifyAll的区别？](#notify和notifyall的区别)
        - [写一段代码，实现线程交替打印奇偶数](#写一段代码实现线程交替打印奇偶数)
        - [怎么保证多线程安全？](#怎么保证多线程安全)
        - [java中有哪些常用的锁？使用场景是什么？](#java中有哪些常用的锁使用场景是什么)
        - [讲讲ReentrantLock？](#讲讲reentrantlock)
- [CS基础](#cs基础)
    - [进程和线程的区别](#进程和线程的区别)
    - [硬链接和软链接的区别](#硬链接和软链接的区别)
        - [硬链接](#硬链接)
        - [软链接（符号链接）](#软链接符号链接)
        - [为什么硬连接不能跨文件系统？](#为什么硬连接不能跨文件系统)
    - [动态编译和静态编译](#动态编译和静态编译)
        - [静态编译](#静态编译)
        - [动态编译(运行时编译)](#动态编译运行时编译)
    - [TCP三次握手](#tcp三次握手)
        - [三次握手](#三次握手)
        - [为什么要三次握手？](#为什么要三次握手)
        - [第二次发送了ACK，为什么还要发送SYN？](#第二次发送了ack为什么还要发送syn)
        - [三次握手过程可以携带数据吗？](#三次握手过程可以携带数据吗)
    - [TCP四次挥手](#tcp四次挥手)
        - [四次挥手](#四次挥手)
        - [为什么要四次挥手？](#为什么要四次挥手)
        - [为什么服务端不把 ACK 和 FIN 一起发送，变成三次挥手？](#为什么服务端不把-ack-和-fin-一起发送变成三次挥手)
        - [第二次挥手服务端发送ACK没有到达会怎么样？](#第二次挥手服务端发送ack没有到达会怎么样)
        - [为什么第四次挥手，客户端要等待 2MSL（报文最长存活时间）才进入CLOSED状态？](#为什么第四次挥手客户端要等待-2msl报文最长存活时间才进入closed状态)
    - [mysql的事务隔离级别](#mysql的事务隔离级别)
        - [事务的四个特性](#事务的四个特性)
        - [事务隔离解决的问题](#事务隔离解决的问题)
        - [事务隔离级别](#事务隔离级别)
- [C++](#c)
    - [c++中的static关键字](#c中的static关键字)
    - [c++模板](#c模板)
    - [c++深拷贝和浅拷贝的区别](#c深拷贝和浅拷贝的区别)
    - [c++多态](#c多态)
    - [虚函数与纯虚函数](#虚函数与纯虚函数)
    - [c++智能指针](#c智能指针)
    - [const 和 volatile辨析](#const-和-volatile辨析)
    - [NULL 和 nullptr的区别是什么，为什么引入nulllptr？](#null-和-nullptr的区别是什么为什么引入nulllptr)
    - [git fetch和git pull的区别](#git-fetch和git-pull的区别)
    - [delete[]是怎样知道数组长度的？](#delete是怎样知道数组长度的)
    - [程序是从main 函数开始执行的吗？](#程序是从main-函数开始执行的吗)
- [python](#python)
    - [python的垃圾回收机制](#python的垃圾回收机制)
- [deep learning](#deep-learning)
    - [判别模型和生成模型](#判别模型和生成模型)
    - [转置卷积和空洞卷积](#转置卷积和空洞卷积)
    - [数据集不平衡的处理方式](#数据集不平衡的处理方式)
    - [tensorflow和pytorch的区别](#tensorflow和pytorch的区别)
    - [transformer中的位置编码](#transformer中的位置编码)
    - [自注意力和注意力的区别](#自注意力和注意力的区别)

<!-- /TOC -->
# Java
## JDK、JRE和JVM是什么？
### JDK
JDK（Java Development Kit）是一个功能齐全的 Java 开发工具包，供开发者使用，用于创建和编译 Java 程序。
它包含了 JRE（Java Runtime Environment），以及编译器 javac 和其他工具，如 javadoc（文档生成器）、jdb（调试器）、jconsole（监控工具）、javap（反编译工具）等。

### JRE
JRE 是运行已编译 Java 程序所需的环境，主要包含以下两个部分：
- JVM : 也就是我们上面提到的 Java 虚拟机。
- Java 基础类库（Class Library）：一组标准的类库，提供常用的功能和 API（如 I/O 操作、网络通信、数据结构等）。

### JVM
Java 虚拟机（Java Virtual Machine, JVM）是运行 Java 字节码的虚拟机。
JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。
字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。
不同编程语言（Java、Groovy、Kotlin、JRuby、Clojure ...）通过各自的编译器编译成 .class 文件，并最终通过 JVM 在不同平台（Windows、Mac、Linux）上运行。

## 字节码
在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。
Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。

Java程序运行流程如下图:
![Java程序运行流程](https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png)

需要格外注意的是 .class->机器码 这一步。
- 在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。
- 而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（Just in Time Compilation） 编译器，而 JIT 属于运行时编译。
- 当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。
- 机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言 。

## 为什么说Java“编译与解释共存”？

- 编译型语言：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。
- 解释型语言：解释型语言会通过解释器一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。

Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。

## AOT和JIT
- AOT（Ahead of Time）：提前编译，是指在程序运行之前，将字节码编译成机器码，然后直接运行机器码。这样做的好处是可以提高程序的启动速度，减少内存占用。

- JIT(Just in Time)：即时编译，是指在程序运行时，将热点代码（被频繁调用的代码）编译成机器码，然后再执行。这样做的好处是可以提高程序的执行效率。

为什么AOT没有完全代替JIT?
- AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。但是，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载等，很多框架和库都用到了这些特性。只使用 AOT 编译，那就没办法使用这些框架和库了，或者说需要针对性地去做适配和优化。

## Java内存区域
JVM 在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域，主要包括以下几个区域：
- 线程私有的：程序计数器、虚拟机栈、本地方法栈
- 线程共享的：堆、方法区、直接内存

### 程序计数器
- 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
- 多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

>程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

### 虚拟机栈
- 虚拟机栈由一个个栈帧组成，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。

### 本地方法栈
- 本地方法栈和虚拟机栈所发挥的作用相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法(非Java语言编写的方法)服务。

### 堆
- 堆是 Java 虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，几乎所有的对象实例都在这里分配内存。
- 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”。
- 在jdk7及以前，堆中内存被分为新生代、老年代和永久代，实际上永久代处于方法区，与堆是隔离的，但是内存上是连续的。在jdk8中，**永久代被元空间取代**，元空间位于本地内存，因此堆中主要分为新生代和老年代。

### 方法区
- 方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域
- 当JVM要使用一个类时，会检查并解析字节码文件的相关信息，并将信息存储在方法区中

### 运行时常量池和字符串常量池
- 常量池表主要存放编译期生成的各种字面量和符号引用。
- 字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

jdk7中，运行时常量池存放在方法区中，而字符串常量池存放在堆中。在jdk8中，运行时常量池存放在元空间中。

### 直接内存
- 直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。
- 直接内存是本地内存的一部分。

### 为什么要将永久代替换为元空间？
- 永久代有一个 JVM 本身设置的固定上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
- 永久代会为 GC 带来不必要的复杂度，例如永久代的 GC 会因为频繁的类加载而导致 Full GC，而元空间的 GC 将会更简单高效。

## JVM垃圾回收
在堆的新生代中，由Eden 区、两个 Survivor 区组成， 两个 Survivor 区中包括S0 和 S1。
### 内存分配和回收原则
- 对象优先在 Eden 区分配，当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC，Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。
- 大对象直接进入老年代，大对象是指需要大量连续内存空间的对象，比如一个很长的字符串或数组。
- 长期存活的对象将进入老年代，虚拟机给每个对象定义了一个年龄计数器，对象在 Eden 区出生后，经过一次 Minor GC 仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 区，并且年龄设为 1，对象在 Survivor 区每熬过一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代。

### 死亡对象的判断方法
- 引用计数法：当对象被引用时，计数器加 1，当引用失效时，计数器减 1，当计数器为 0 时，说明对象不再被引用，可以被回收。但这种方法无法解决循环引用的问题。
- 可达性分析法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。即GC roots到某个对象不可达，则说明此对象是可以被回收的。
- 即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；

### 垃圾回收算法
- 标记-清除算法：标记出所有活动对象，然后统一回收未标记对象。这种算法会产生大量不连续的内存碎片，导致以后在分配大对象时可能出现内存不足的情况。
- 复制算法：将内存分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，就将还存活的对象复制到另一块上面，然后把已使用的内存空间一次清理掉。这种算法没有内存碎片问题，但是会浪费一半的内存空间。
- 标记-整理算法：标记出所有活动对象，然后将存活的对象向一端移动，然后直接清理掉端边界以外的内存。这种算法没有内存碎片问题，也不会浪费内存，但是需要移动对象，所以比较耗时。
- 分代收集算法：根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，新生代由于每次收集会有大量对象死去，所以可选用复制算法，而老年代因为对象存活率高，所以可选用标记清除或标记整理算法。

### 垃圾回收器有哪些？
- Serial收集器 (复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；
- ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；
- Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；
- Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；
- Parallel Old收集器 (标记-整理算法): 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；
- CMS(Concurrent Mark Sweep)收集器 (标记-清除算法): 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。
- G1(Garbage First)收集器 (标记-整理算法): Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。

### 垃圾回收器CMS和G1的区别?
1. 使用范围不同，CMS主要用于老年代收集，G1可以收集老年代和新生代
2. CMS基于“标记-清除”算法实现，G1基于“标记-整理”算法实现
3. CMS以最小停顿时间为目标，G1可预测垃圾回收的停顿时间

## 基础数据类型
java中八种基础数据类型如下图：
![基础数据类型](https://cdn.xiaolincoding.com//picgo/1715930589177-73932d2c-b0c0-4f58-a5c1-ab514b1a389c.png)

值得注意的是：
- 1个字节的有boolean和byte,2个字节的有short和char,4个字节的有int和float,8个字节的有long和double。
- 浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）。
- 整数的默认类型为int（声明Long型在末尾加上l或者L）
- 8种基本类型的包装类，除了char是Character，int是Integer，其余的都是首字母大写。
- char是无符号的，最小值是0

long和int可以互转吗？
答：可以，long的范围更大，int可以直接赋值给long,long转int需要强制类型转换。

字节支付实习一面：String类可以被继承吗？
答：String类是final类，不可以被继承。所有基本数据类型对应的包装类都是final类，不可以被继承。

为什么用bigDecimal 不用double ？
答：double类型是不精确的，因为double类型是采用二进制浮点数进行计算的，而二进制浮点数无法精确表示大部分的十进制小数，所以在计算时会有精度丢失的问题。而BigDecimal是采用十进制浮点数进行计算的，可以精确表示大部分的十进制小数。

为什么要有Integer？
答：Integer是int的包装类，封装之后包含一些数据处理的方法，便于处理数据;
Java中大部分方法和类以及集合只能处理类型对象，比如ArrayList；
基本类型和引用类型不能直接转换，比如int要转为String类需要先专程Integer。

## 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？
答：可以让学生类实现Comparable接口，重写compareTo方法，然后在compareTo方法中按照分数排序，再按照学号排序。

```
public class Student implements Comparable<Student>{

    public int compareTo(Student t){
        if(this.score!=t.score){
            return Integer.compare(t.score,this.score); //按分数降序
        }else{
            return Integer.compare(this.id,t.id); //分数相同按学号升序
        }
    }
}
List<Student> st = new ArrayList<>();
Collections.sort(st);
```
## Java集合
### 数组和集合的区别？
- 数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素。
- 数组可以包含基本数据类型和对象，而集合只能包含对象。
- 数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。

### ArrayList和LinkedList的区别？
- ArrayList基于数组，而LinkedList基于链表实现。
- 插入删除、随机访问效率不同
- ArrayList创建时要分配一段连续空间，占用空间更大
- 前者适合需要频繁随机访问的场景，后者适合需要频繁插入删除的场景。

### ArrayList的扩容机制是什么？
如果当前元素数量达到内部数组容量上限，就会触发扩容机制。分以下几步骤：
- 计算新的容量，一般会扩大1.5倍
- 创建新的数组
- 将旧数组元素复制到新数组
- 更新引用指向新数组

之所以扩容是 1.5 倍，是因为 1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。

### CopyonWriteArraylist是如何实现线程安全的？
- CopyonWriteArraylist底层也是通过一个数组保存数据，使用volatile修饰，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。
- 对读操作没有加锁，对写操作加了一个ReentrantLock锁，保证写操作的线程安全。

### HashMap实现原理介绍一下？
- 早期HashMap是数组+链表，通过哈希算法将元素映射到数组中，如果发生冲突，就会在链表中存储多个元素，当链表元素过多查询效率会降低很多。
- JDK1.8之后，HashMap引入了红黑树，当链表长度超过8时，链表会转换为红黑树，提高查询效率（查询复杂度`log n`）,数量少于6会转回链表。
### 解决哈希冲突的方法有哪些？
- 链地址法：将哈希冲突的元素存储的在链表或其他数据结构中
- 开放寻址法：找到另一个可用的位置来存储，包括线性探测、二次探测、双重散列等。
- 再哈希法：使用另一个哈希函数计算新的哈希值。
- 哈希桶扩容：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对。

### HashMap的put过程？
1. 计算要添加的key的哈希值，找到在数组中的索引
2. 如果该索引位置没有元素，直接添加
3. 如果该索引位置有元素，检查key是否相等，如果相等，直接覆盖value，如果不相等，发生哈希冲突，通过链表或红黑树中查找这个key，找到则更新value，为找到则添加
4. 检查链表长度是否超过8，超过则转换为红黑树
5. 检查负载因子是否超过0.75，超过则扩容
6. 扩容时，首先创建一个新的数组，大小是原数组的2倍，然后重新计算旧数组的哈希值分配到新数组中，更新引用。

### 为什么HashMap用红黑树不用平衡二叉树？
- 平衡二叉树追求完全平衡的状态，左右子树的高度差不超过1，每次插入删除都需要左旋右旋调整，效率很低
- 红黑树追求一种弱平衡状态，整个树的最长路径不超过最短路径的2倍，插入删除效率更高。
### HashMap key可以为null吗？
答：HashMap的key可以为null，HashMap使用hash()方法计算key的哈希值，如果key为null，哈希值为0。不会去调用hashCode()方法。

### 重写HashMap的equals和hashCode方法时，要注意什么？
- HashMap在比较元素时，一般先比较hashCode，如果hashCode相等，再通过equals方法比较。
- hashCode相等，equals不一定相等，但是equals相等，hashCode一定相等。
- 重写了equals方法，如果不重写hashCode方法，可能会导致相等的两个对象的hashCode不相等，从而导致相同的key被重复添加。

### 为什么HashMap的大小是2的幂次方？
答：为了加速计算以及减少哈希冲突，计算哈希时一般按照`hash(key)%n`计算索引，如果n是2的幂次方，等价于`hash(key)&(n-1)`，这样可以加快计算速度;
此外，这种与运算的方式可以让元素分布更加均匀，减少哈希冲突。

### ConcurrentHashMap是如何实现线程安全的？
ConcurrentHashMap主要通过volatile+CAS或者synchronized来保证线程安全。
添加元素时，先判断容器是否为空？
- 为空则用volatile和CAS来初始化
- 不为空则计算该位置是否为空
    - 为空则用CAS添加元素
    - 不为空则使用synchronized来更新或添加元素

锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。

### 分段锁是怎么加锁的？
- ConcurrentHashMap在JDK1.7之前使用分段锁，将整个数据分为若干个Segment，每个Segment都是一个小的HashMap，每个Segment都有自己的锁，不同 Segment 之间的操作互不影响，从而提高并发性能。
- 当进行增删改操作时，首先定位到具体的Segment，然后对这个Segment加锁，其他Segment不受影响，可以并发操作。

### ConcurrentHashMap用的是乐观锁还是悲观锁？
答：都有用到。
- 初始化时如果容器为空，通过volatile+CAS(乐观锁)初始化
- 如果不为空，则判断元素要添加的位置是否为空，为空则用CAS添加，不为空则用synchronized(悲观锁)添加或更新。

### hashtable和ConcurrentHashMap的区别？
- 从结构上看，hashtable是数组+链表，ConcurrentHashMap是数组+链表/红黑树
- 都是线程安全的，但hashtable所有方法都是synchronized，效率低，ConcurrentHashMap使用volatile+CAS或synchronized，效率更高

## 面向对象

### 面向对象的设计原则有哪些？
- 单一职责原则（SRP）：一个类只负责一个功能领域中的相应职责。
- 开放封闭原则（OCP）：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
- 里氏替换原则（LSP）：子类对象应该能够替换掉所有父类对象。
- 依赖隔离原则（ISP）：客户端不应该依赖那些它不需要的接口，接口应该而专。
- 依赖倒置原则（DIP）：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
- 最少知识原则（迪米特法则，LoD）：一个对象应该对其他对象有最少的了解。

### 抽象类和接口的区别
抽象类：
- 抽象类是包含至少一个抽象方法的类，抽象方法是没有方法体的方法。
- 抽象类可以包含具体的方法（有方法体的），也可以包含成员变量。
- 抽象类可以被继承，一个子类必须实现抽象类中的所有抽象方法，除非该子类也是抽象类。

接口：
- 接口是一个完全抽象的类，所有的方法默认是抽象的（Java 8 后，可以包含默认方法和静态方法）。
- 接口只能包含常量和抽象方法（除非定义了默认方法和静态方法）。

特点：
- 抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。
- 接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。适用于定义类的能力或功能

区别：
- 实现方式：实现接口的关键字为 implements，继承抽象类的关键字为 extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
- 方法方式：接口只有定义，不能有方法的实现，java 1.8 中可以定义 default 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
- 访问修饰符：接口成员变量默认为 public static final，必须赋初值，不能被修改；其所有的成员方法都是 public、abstract 的。抽象类中成员变量默认 default，可在子类中被重新定义，也可被重新赋值；抽象方法被 abstract 修饰，不能被 private、static、synchronized 和 native 等修饰，必须以分号结尾，不带花括号。
- 变量：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态常量）。

### 抽象类可以被实例化吗？
答：抽象类不能被实例化，通常由子类继承实现。**抽象类中可以有构造方法**，但是构造方法实例化的是子类对象。接口没有构造方法。

### Java深拷贝的方式有哪些？
- 实现Cloneable接口，重写clone()方法
- 使用序列化和反序列化
- 手动递归复制

## Java中的对象
### Java中创建对象有哪些方式？
- 使用new关键字:通过new关键字直接调用类的构造方法来创建对象。
```
MyClass obj = new MyClass();
```
- 使用Class类的newInstance()方法:通过反射机制调用newInstance()方法来创建对象。
```
MyClass obj = (MyClass) Class.forName("com.example.MyClass").newInstance();
```
- 使用Constructor类的newInstance()方法：同样通过反射机制调用Constructor类的newInstance()方法来创建对象。
```
Constructor<MyClass> constructor = MyClass.class.getConstructor();
MyClass obj = constructor.newInstance();
```
- 使用clone()方法：如果类实现了Cloneable接口，可以使用clone()方法复制对象。
```
MyClass obj1 = new MyClass();
MyClass obj2 = (MyClass) obj1.clone();
```
- 使用反序列化

### new的对象什么时候回收？
主要由GC回收，分为以下几种情况：
1. 引用计数法：某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。
2. 可达性分析算法：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。
3. 终结器（Finalizer）：如果对象重写了finalize()方法，垃圾回收器会在回收该对象之前调用finalize()方法，对象可以在finalize()方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。

## 反射机制
### 什么是反射机制？
Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；
对于任意一个对象，都能够调用它的任意一个方法和属性；
这种**动态获取的信息以及动态调用对象的方法**的功能称为 Java 语言的反射机制。

反射具有以下特性：
- 运行时类信息访问：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。
- 动态对象创建：可以使用反射 API 动态地创建对象实例，即使在编译时不知道具体的类名。这是通过 Class 类的 newInstance() 方法或 Constructor 对象的 newInstance() 方法实现的。
- 动态方法调用：可以在运行时动态地调用对象的方法，包括私有方法。这通过 Method 类的 invoke() 方法实现，允许你传入对象实例和参数值来执行方法。
- 访问和修改字段值：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过 Field 类的 get() 和 set() 方法完成的。

### 反射在你平时写代码或者框架中的应用场景有哪些?
1. 加载数据库驱动
```
Class.forName("com.mysql.cj.jdbc.Driver");
```
2. 配置文件加载
Spring 通过 XML 配置模式装载 Bean 的过程：
- 将程序中所有 XML 或 properties 配置文件加载入内存
- Java 类里面解析 xml 或者 properties 里面的内容，得到对应实体类的字节码字符串以及相关的属性信息
- 使用反射机制，根据这个字符串获得某个类的 Class 实例
- 动态配置实例的属性

## Java注解的原理
注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。

我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。
通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。
该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。

## == 与 equals 有什么区别？
对于字符串变量来说，使用 == 和 equals 比较字符串时，其比较方法不同。== 比较两个变量本身的值，即两个对象在内存中的首地址；equals 比较字符串包含的内容是否相同。

对于非字符串变量来说，如果没有对 equals() 进行重写的话，== 和 equals 方法的作用是相同的，都是用来比较对象在堆内存中的首地址，即用来比较两个引用变量是否指向同一个对象。

==：比较的是两个字符串内存地址（堆内存）的数值是否相等，属于数值比较；
equals()：比较的是两个字符串的内容，属于内容比较。

## StringBuffer和StringBuilder区别是什么？
区别：
- String 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以**拼接字符串时会产生很多无用的中间对象，如果频繁地进行这样的操作对性能有所影响**。
- StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个**线程安全**的可修改的字符序列。在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。
- StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是**去掉了保证线程安全**的那部分，减少了开销。

>一般情况下，速度从快到慢为 StringBuilder > StringBuffer > String，当然这是相对的，不是绝对的。

## MYSQL的有哪几种引擎？
- InnoDB：InnoDB是MySQL的默认存储引擎，具有ACID事务支持、行级锁、外键约束等特性。它适用于高并发的读写操作，支持较好的数据完整性和并发控制。
- MyISAM：MyISAM是MySQL的另一种常见的存储引擎，具有较低的存储空间和内存消耗，适用于大量读操作的场景。然而，MyISAM不支持事务、行级锁和外键约束，因此在并发写入和数据完整性方面有一定的限制。
- Memory：Memory引擎将数据存储在内存中，适用于对性能要求较高的读操作，但是在服务器重启或崩溃时数据会丢失。它不支持事务、行级锁和外键约束。
## 慢查询如何解决？
- 通过 explain 执行结果，查看 sql 是否走索引，如果不走索引，考虑增加索引。
- 可以通过建立联合索引，实现覆盖索引优化，减少回表，使用联合索引符合最左匹配原则，不然会索引失效
- 避免索引失效，比如不要用左模糊匹配、函数计算、表达式计算等等。
- 联表查询最好要以小表驱动大表，并且被驱动表的字段要有索引，当然最好通过冗余字段的设计，避免联表查询。
- 针对 limit n,y 深分页的查询优化，可以把 Limit 查询转换成某个位置的查询：select * from tb_sku where id>20000 limit 10，该方案适用于主键自增的表，
- 将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开
## MYSQL的日志？
### MYSQL了解哪些日志？
- redo log 重做日志，是 InnoDB 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复，是循环写；
- undo log 回滚日志，是 InnoDB 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。
- bin log 二进制日志，是 Server 层生成的日志，主要用于数据备份和主从复制，是追加写；
- relay log 中继日志，用于主从复制场景下，slave 通过 io 线程拷贝 master 的 bin log 后本地生成的日志
- 慢查询日志，用于记录执行时间过长的 SQL，需要设置阈值后手动开启

### 介绍一下bin log？
MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog
binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、MIXED，区别如下：

- STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式，binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；
- ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；
- MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；

## 并发
### 线程安全体现在哪些方面？
- 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作；
- 可见性：一个线程对主内存的修改可以及时地被其他线程看到；
- 有序性：保证线程按照代码顺序执行。

### 什么是CAS操作？
CAS叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：

- V：要更新的值
- A：预期值
- B：新值
当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。

### CAS的缺点？
- ABA问题：如果一个值原来是A，准备修改前短暂变成了B，然后又变成了A，那么CAS操作会错误地认为这个值没有发生变化；解决方法是加入预期标志和更新后标志，更新时不光检查值，还要检查标志是否相等。
- 循环时间长开销大：CAS操作如果长时间不成功，会一直自旋，占用CPU，降低性能。
- 只能保证一个共享变量的原子操作：对多个共享变量操作时，需要加锁。


### 线程创建方式有哪些？
- 继承 Thread 类
```
class MyThread extends Thread{
    public void run(){
        System.out.println("MyThread run");
    }
}

public static void main(String[] args) {
    MyThread t=new MyThread();
    t.start();
}
```
- 实现 Runnable 接口
```
class MyRunnable implements Runnable{
    public void run(){
        System.out.println("MyRunnable run");
    }
}
public static void main(String[] args){
    Thread t=new Thread(new MyRunnable());
    t.start();
}
```
- 实现Callable接口与FutureTask
- 使用线程池
### 如何停止线程？
- 调用interupt()方法, 判断当前对象的interrupted()状态，如果是中断状态则抛出异常，达到中断线程的效果。
- 先将线程sleep，然后调用interrupt标记中断状态，interrupt会将阻塞状态的线程中断。会抛出中断异常，达到停止线程的效果
- stop()暴力停止

### 线程的状态有哪些？
- NEW：新创建的线程，还未执行
- RUNNABLE：就绪和正在执行的线程
- BLOCKED：阻塞状态，等待锁的释放
- WAITING：等待状态，等待其他线程的通知
- TIMED_WAITING：具有指定等待时间的等待状态
- TERMINATED：线程执行完毕

### blocked和waiting的区别？
- blocked 一般是因为获取锁失败，在等待其他线程释放锁后，会重新进入runnable状态
- waiting 状态不参与锁的竞争，而是在等待其他线程的通知，比如调用wait()方法，join()方法，或者LockSupport.park()方法，不会占用CPU资源，当其他线程调用notify()方法后，会重新进入runnable状态

### notify和notifyAll的区别？
- notify()方法会随机唤醒一个处于waitting的线程，其他线程仍然处于waiting状态。
- notifyAll()方法会唤醒所有waitting的线程，让他们开始竞争锁

### 写一段代码，实现线程交替打印奇偶数
```
public class PrintEvenOdd{
    private static int cnt=1;
    private static final Object lock=new Object();
    private static final int MX=100;
    public static void main(String[] args){
        Runnable printOdd=()->{
            synchronized(lock){
                    while(cnt<=MX){
                    if(cnt%2!=0){
                        System.out.println(Thread.currentThread().getName()+":"+cnt++);
                        lock.notify();
                    }else{
                        try{
                            lock.wait();
                        }catch(InterruptedException e){
                            e.printStackTrace();
                        }
                    }     
                }
            }
        };

        Runnable printEven=()->{
            synchronized(lock){
                while(cnt<=MX){
                    if(cnt%2==0){
                        System.out.println(Thread.currentThread().getName()+":"+cnt++);
                        lock.notify();
                    }else{
                        try{
                            lock.wait();
                        }catch(InterruptedException e){
                            e.printStackTrace();
                        }
                    }
                }
            }
        }

        Thread t1=new Thread(printOdd,"奇数线程");
        Thread t2=new Thread(printEven,"偶数线程");
        t1.start();
        t2.start();
    }
}
```
### 怎么保证多线程安全？
- 使用synchronized关键字，保证同一时刻只有一个线程访问共享资源
- 使用volatile关键字，保证变量的可见性
- 使用Lock接口，比如ReentrantLock类就是Lock接口的一个实现
- 使用原子类，比如AtomicInteger类
- 使用TreadLocal
- 使用线程安全的集合类，比如ConcurrentHashMap、CopyOnWriteArrayList等

### java中有哪些常用的锁？使用场景是什么？
- synchronized：用于修饰代码块或方法，保证同一时刻只有一个线程访问共享资源。
- ReentrantLock：是Lock接口的一个实现，提供了更多的功能，比如可以设置超时时间、中断等待锁的线程、公平锁等。
- 读写锁：允许多个线程读，但只允许一个线程写，适用于读多写少的场景。
- 乐观锁和悲观锁：乐观锁不锁定资源，**只在写数据时**检查资源是否被其他线程修改；悲观锁在访问数据时会锁定资源，总是假设最坏的情况。
- 自旋锁：未获取到锁时线程不会放弃CPU资源，而是一直循环检查锁是否可用，直到获取到锁，通常用CAS实现。

### 讲讲ReentrantLock？
ReentrantLock底层主要依赖AQS抽象类，AQS提供了一些基本的同步机制如队列、状态等。


# CS基础
## 进程和线程的区别
>进程是资源分配的基本单位，线程是资源调度的基本单位(轻量级进程)

* 多个线程共享地址空间/资源，而进程之间的地址空间/资源是独立的
* 一个线程只能属于一个进程，一个进程可以有多个线程
* 创建/撤销线程的系统开销明显小于进程

## 硬链接和软链接的区别
### 硬链接
- 在 Linux/类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。
- 硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删。
- 只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。
- 硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。
- `ln` 命令用于创建硬链接。

### 软链接（符号链接）
- 软链接和源文件的 inode 节点号不同，而是指向一个文件路径。
- 源文件删除后，软链接依然存在，但是指向的是一个无效的文件路径。
- 软连接类似于 Windows 系统中的快捷方式。
- 不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，软链接可以跨越文件系统。
- ln -s 命令用于创建软链接

### 为什么硬连接不能跨文件系统？
- 硬链接是通过 inode 节点号建立连接的，而硬链接和源文件共享相同的 inode 节点号。
- 然而，每个文件系统都有自己的独立 inode 表，且每个 inode 表只维护该文件系统内的 inode。
- 如果在不同的文件系统之间创建硬链接，可能会导致 inode 节点号冲突的问题，即目标文件的 inode 节点号已经在该文件系统中被使用。

## 动态编译和静态编译
### 静态编译
在编译时将程序与其所有依赖项（包括库）链接在一起，形成一个单独的可执行文件。这个可执行文件包含了所有代码和数据，因此它是一个完全独立的二进制文件。

静态编译启动速度快，不需要依赖外部库，但可执行文件体积较大。

### 动态编译(运行时编译)
在编译时只创建程序的框架，而不将所有依赖项包含在可执行文件中。实际的库文件是在运行时加载的，程序在需要时动态链接到这些库。

## TCP三次握手
### 三次握手
三次握手的过程如图：
![三次握手](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png)
- 一次握手:客户端发送带有 SYN（SEQ=x） 标志的数据包 -> 服务端，然后客户端进入 SYN_SEND 状态，等待服务端的确认；
- 二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 SYN_RECV 状态；
- 三次握手:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务端都进入ESTABLISHED 状态，完成 TCP 三次握手。

### 为什么要三次握手？
三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。
- 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
- 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
- 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

### 第二次发送了ACK，为什么还要发送SYN？
服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。

### 三次握手过程可以携带数据吗？
在 TCP 三次握手过程中，第三次握手是可以携带数据的(客户端发送完 ACK 确认包之后就进入 ESTABLISHED 状态了)

如果第三次握手的 ACK 确认包丢失，但是客户端已经开始发送携带数据的包，那么服务端在收到这个携带数据的包时，如果该包中包含了 ACK 标记，服务端会将其视为有效的第三次握手确认。这样，连接就被认为是建立的，服务端会处理该数据包，并继续正常的数据传输流程。

## TCP四次挥手
### 四次挥手
TCP 四次挥手的过程如图：
![四次挥手](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png)

- 第一次挥手：客户端发送一个 FIN（SEQ=x） 标志的数据包->服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 FIN-WAIT-1 状态。
- 第二次挥手：服务端收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包->客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。
- 第三次挥手：服务端发送一个 FIN (SEQ=y)标志的数据包->客户端，请求关闭连接，然后服务端进入 LAST-ACK 状态。
- 第四次挥手：客户端发送 ACK (ACK=y+1)标志的数据包->服务端，然后客户端进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。
>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！

### 为什么要四次挥手？
TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

举个例子：A 和 B 打电话，通话即将结束后。
- 第一次挥手：A 说“我没啥要说的了”
- 第二次挥手：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话
- 第三次挥手：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”
- 第四次挥手：A 回答“知道了”，这样通话才算结束

### 为什么服务端不把 ACK 和 FIN 一起发送，变成三次挥手？
因为服务端收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务端到客户端的数据传送。

### 第二次挥手服务端发送ACK没有到达会怎么样？
客户端没有收到 ACK 确认，会重新发送 FIN 请求。

### 为什么第四次挥手，客户端要等待 2MSL（报文最长存活时间）才进入CLOSED状态？
第四次挥手时，客户端发送给服务端的 ACK 有可能丢失。
- 如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN
- 如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。


## mysql的事务隔离级别
### 事务的四个特性
- 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
- 一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另一个一致性状态。
- 隔离性（Isolation）：一个事务的执行不能被其他事务干扰。
- 持久性（Durability）：事务一旦提交，它对数据库的改变就应该是永久性的。

### 事务隔离解决的问题
- 脏读：一个事务读取到另一个事务未提交的数据，读到了最终可能不存在的数据
- 可重复读：同一事务中多次读取同一数据时，结果是一致的，即使其他事务修改了该数据，当前事务仍然看到最初读取的值
- 不可重复读：同一事务在不同的时刻读到的同一批数据可能是不一样的，比如其他事务改了这批数据并提交了（针对update）
- 幻读：同一事务在不同的时刻读到的同一批数据可能是不一样的，比如其他事务插入了一些数据并提交了（针对insert）
### 事务隔离级别
mysql中有四种事务隔离级别，级别由低到高分别是：
- 读未提交（Read Uncommitted）：允许脏读，一个事务还没提交时，另一个事务就可以看到它做的变更，存在脏读、不可重复读、幻读的问题
- 读提交（Read Committed）：只能读取已经提交的数据，可以避免脏读，但是不可重复读和幻读仍然存在
- 可重复读（Repeatable Read）：对同一字段的多次读取结果是一致的，除非数据被当前事务自己改变，可以避免脏读和不可重复读，但幻读仍然存在
- 串行化（Serializable）：最高的隔离级别，所有事务依次执行，可以避免脏读、不可重复读、幻读
# C++
## c++中的static关键字

加载顺序（面向对象）
* 静态->非静态->构造方法
* 父类静态-子类静态-父类非静态-父类构造-子类非静态-子类构造

静态成员变量(面向对象)
* 所有对象共享,不属于某个对象，可以通过类名访问，也可通过对象访问
* 在编译阶段分配内存，分配在数据区（全局区）
* 类内声明，类外初始化(class::var)
* sizeof不会计算静态成员变量

静态成员函数(面向对象)
* 所有对象共享同一个函数
* 静态成员函数只能访问静态成员变量
* 不含this指针(不能被实例使用)

静态全局变量(面向过程)

* 在数据区分配内存
* 未初始化会自动初始化为0
* 整个文件内可见，文件外不可见

静态局部变量(面向过程)

* 在数据区分配内存 
* 一般在声明处初始化，未初始化会自动初始化为0
* 静态局部变量始终驻留在数据区，但他的作用域是局部作用域，当定义它的函数或语句块结束，其作用域随之结束

>总结：静态变量具有全局变量的生命周期，但只能作用于自己的作用域。

***

## c++模板

>模板是c++泛型编程的主要使用的技术

**函数模板**

创建一个通用的函数，函数返回值类型和形参可以不指定，用一个虚拟的类型来表示

声明一个模板`template<typename T>`或者`template<class T>`

示例：
```
#include<bits/stdc++.h>
using namespace std;
template<typename T>
T sum(T a,T b)
{
	return a+b;
}
int main()
{
	double a=10.5,b=20.00002;
	cout<<"自动类型推导"<<endl;
	printf("%lf\n",sum(a,b));
	cout<<"显示指定类型"<<endl;
	printf("%lf",sum<double>(a,b));
	return 0;
} 
```

注意
* 自动推导类型需要推导出一致的类型
* 函数模板使用时必须确定`T`的类型
* 普通函数和函数模板都可调用时，先调用普通函数
* 如果类型和函数模板更匹配，则优先调用函数模板

**类模板**

示例：
```
#include<bits/stdc++.h>
using namespace std;
template<class T,class M>
class person
{
public:
	T name;
	M age;
	person(T a,M b):name(a),age(b){}
};
int main()
{
	person<string,int> p("cndh",18);
	cout<<p.name<<endl;
	cout<<p.age<<endl;
	return 0;
} 
```
注意：
* 类模板不能自动推导类型
* 类模板可以在模板参数列表中指定默认类型
* 类模板中定义的函数在调用时才创建

---

## c++深拷贝和浅拷贝的区别

>**浅拷贝** （默认方式）：将原对象的引用直接赋给新对象，只是原对象的一个引用。

>**深拷贝**： 创建一个新的对象，将原对象的各项属性拷贝过来，深拷贝会在堆中额外申请内存来储存数据，当数据成员中有指针时，必须要用深拷贝。

* 因为申请了新的内存，所以深拷贝改变新对象的属性对原对象没有影响，但是浅拷贝会影响
* 当成员中有指针时，必须用深拷贝。因为浅拷贝的新指针和旧指针都指向同一块内存，在新对象和旧对象析构时，已经释放的内存会被再次释放，这时会出现错误。

***

## c++多态

编译时多态：

* 编译器多态是通过函数重载和模板实现的。在编译时，根据函数的参数类型或模板参数类型，编译器会选择合适的函数或模板实例化。
* 编译器多态是在编译时确定函数调用，因此它的性能较高。
* 编译器多态不需要使用虚函数和基类指针或引用，可以直接根据函数的参数类型或模板参数类型来确定函数调用。

运行时多态：
* 运行时多态是通过继承和虚函数实现的。当基类的指针或引用指向派生类对象时，通过虚函数的动态绑定，可以在运行时确定要调用的函数实现。
* 运行时多态需要使用虚函数和基类指针或引用来实现，这样可以在运行时根据实际对象的类型来确定调用哪个函数。
* 运行时多态在运行时才能确定具体的函数调用，因此它的性能相对较低。

***override的作用***

保证在派生类中声明的重载函数，与基类的虚函数有相同的签名，核心作用就是用于编译期代码检查。

***final***

阻止类的进一步派生和虚函数的进一步重写，同时也是一种名为去虚拟化的优化技巧，相当于把运行期多态转换为了编译期多态，提高了执行效率。

***多继承存在的问题***

命名冲突

***向上转型***

向上转型是子类指针转换成父类指针

`Parent* p =new son();`

***向下转型***

因为父类指针不能操作子类独有的函数，即使父类指针指向子类的对象也不行，所以需要向下转型

向下转型有两种方式`dynamic_cast`和`static_cast`,前者更加安全一些

例如：
```
Parent* pSon=new Son();
Son* s=dynamic_cast<Son*>(pSon);
```

***
## 虚函数与纯虚函数

**虚函数**
在类中声明时前面带有virtual关键字的函数，如：
```
class A {
	virtual void example();
}
```
**纯虚函数**
```
在虚函数后面加`=0`
class A {
	virtual void example() = 0;
}
```
* 虚函数可以在父类中实现，也可以被子类重写实现，是实现运行时多态的方式之一
* 纯虚函数不可以在父类实现，必须由子类重写
* 含有纯虚函数的类被称为抽象类，抽象类不能实例化
* 抽象类的子类如果要实例化，则必须重写纯虚函数

**虚函数怎么实现的？真的更慢吗？**
* 虚函数是通过虚函数表实现的，每个类都有自己的虚表，对象的首地址处存放有指向虚表的指针。
* 当具体调用哪个虚函数可以在编译期间确定的时候，虚函数不一定更慢。

## c++智能指针

**内存泄漏**：
* 指因某些原因造成程序未能释放已不再使用的内存。内存泄漏并不是内存消失了，而是由于程序设计的问题，失去对某块内存的控制，导致无法利用该块内存。

* 内存泄漏会导致程序响应越来越慢，甚至崩溃

* 一般有2种内存泄漏，一种是堆区分配的内存没有及时释放，一种是套接字、文件描述符等没有释放，2种情形都会导致资源的浪费

**RALL**

* RAII（Resource Acquisition Is Initialization）是一种将对象生命周期和资源绑定的技术
* 对象创建时获取资源，析构时释放资源

智能指针就具有RALL的特性

**auto_ptr**

c++98中就已经提供了智能指针auto_ptr

例如：`auto_ptr<int> p(new int)`就相当于 `int * p=new int`

auto_ptr的局限性：
* 拷贝或者赋值会导致原指针变为`NULL`，如`p1=p2`后，`p2变成了NULL`
* 不支持对象数组的内存管理

**unique_ptr**



不能直接进行赋值或者拷贝构造，如：`p1 = p2`和`unique_ptr<int> p1(p2)`

如果要强行执行的话要加上`move`，如：`p1 = std::move(p2)`和`unique_ptr<int> p1(std::move(p2))`

**shared_ptr**

通过**引用计数**(`use_count()`)的方式来实现多个`shared_ptr`对象之间共享资源

* shared_ptr在其内部，给每个资源都有一份计数表，用来记录该份资源被几个指针共享
* 在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一
* 如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源
* 如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了

注意：两个对象交叉使用**shared_ptr**(互相获得对方的share指针),会导致内存泄漏

**weak_ptr**

专门为了解决上面的**shared_ptr**的问题，不支持RALL，不释放资源，不增加或减少引用计数

具体参考[相关链接](https://blog.csdn.net/cpp_learner/article/details/118912592?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166191088916782414982504%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166191088916782414982504&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118912592-null-null.142^v42^pc_rank_34,185^v2^control&utm_term=c%2B%2B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&spm=1018.2226.3001.4187)

***

## const 和 volatile辨析

**const**
* 被const修饰的变量被视为一个常量，使得变量具有只读属性
* const修饰的变量不是一个真正的只读变量，它只是告诉编译器该变量**不能出现在赋值符号的左边**

***const修饰指针变量有以下3种情况***
1. const 修饰指针指向的内容，则内容为不可变量。
```
const int *p = 8; //指向的内容8不可变
*p=6; //错误
```
2. const 修饰指针，则指针不可变
```
int a=8;
int* const p = &a;
*p = 9; // 正确
int  b = 7;
p = &b; // 错误
```
3. const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。
```
int a = 8, b = 2;
const int * const  p = &a;
*p=1; //错误
p=&b; //错误
```

***const 修饰对象和成员函数***
* 被const修饰的对象(常对象)或者成员函数(常函数)内不能修改类的成员变量，如果要修改需要给对应的成员变量加mutable关键字
* 常对象只能修改常函数

**volatile**

本意为易变的，有以下特点

* volatile指出变量是随时可能变化的，每次使用需要重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。
* 被volatile修饰的变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

>***一个变量可以同时被const和volatile修饰吗？***

可以。const volatile表示一个变量在程序编译期不能被修改且不能被优化；在程序运行期，每次必须从内存中加载变量的值。

## NULL 和 nullptr的区别是什么，为什么引入nulllptr？
* 主流编译器中，`NULL`实际上是一个整数常量，被定义为 0，在 C++11 之前，当我们想要将一个指针初始化为空时，我们通常使用 NULL；
* `nullptr` 是 C++11 中引入的新的关键字，专门用于表示空指针，它不是整数类型，而是特殊的指针类型`nullptr_t`。

***引入nullptr的原因***
1. NULL是整数类型，用户调用foo(NULL)的时候，不能区分调用的是foo(int)还是foo(int*)函数；
2. 主流编译器中NULL值为0，通过0表示一个无效地址，但是有的架构下，0地址有特定用途，而`nullptr`指向的永远是一个无效地址。

## git fetch和git pull的区别
* git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。
* 而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。

>git 连接/添加远程仓库
git remote add 仓库名 地址

## delete[]是怎样知道数组长度的？
没有标准实现，一种常见的实现方法是，申请内存时，会在返回的指针前面存放这段内存的大小，调用delete[]的时候，就可以知道数组长度了。

## 程序是从main 函数开始执行的吗？
不是，程序在执行前，会经历一个从磁盘加载程序到内存的过程，这个过程会执行非静态全局变量的初始化。

# python
## python的垃圾回收机制
>python采用的是**引用计数**为主，**标记—清除**和**分代收集**为辅的策略。

**引用计数**
每个对象维护一个字段来记录对象被引用的次数，当新的引用指向该对象的时候，引用计数的值加1,当某个引用失效时，引用计数值减一。当引用计数的值为0时，会释放占用的内存空间。

缺点：
* 需要额外的空间维护引用次数
* 对象的循环引用会导致内存泄漏

引用计数增加的情况：

* 对象被创建，例如 a = 23
* 对象被引用，例如 b = a
* 对象被作为参数，传入到一个函数中，例如 fun(a)
* 对象被作为一个元素，存储在容器中

引用计数减少的情况：

* 对象的别名被显式销毁，例如 del a
* 对象的别名被赋予新的对象，例如 a = 24
* 一个对象离开它的作用域，例如 f 的函数执行完毕时，func函数中的局部变量
* 对象所在的容器被销毁，或从容器中删除对象

**分代回收**

* 分代回收是一种以空间换时间的方式，Python将内存根据对象的存活时间划分为不同的集合，每一个集合称为一个代，Python将内存分为了3“代”，分别代表**年轻代**（第0代）、**中年代**（第1代）、**老年代**（第2代），它们对应的是3个链表，它们的垃圾收集频率随着对象的存活时间的增大而减小

* 新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾回收机制就会被触发，把那些可以被回收的对象被回收掉，而那些不会被回收的对象就会被移动到中年代，依次类推， 老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期中。

**标记--清除**

是一种基于追踪回收（tracking GC）技术实现的垃圾回收算法。它分为两个阶段：
 1. 标记阶段，GC会把所有的活动对象打上标记
 2. 把那些没有标记的对象（非活动对象）进行回收

**如何判断哪些是活动对象，哪些是非活动对象？**

对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从跟对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。
# deep learning
## 判别模型和生成模型

判别模型：直接学习条件概率$P(y|x)$
生成模型：学习联合概率$P(x,y)$，然后可以计算条件概率$P(y|x)$以及其他信息，需要的数据量较大


简单说，要判断一个苹果是好是坏，判别模型会直接给出是好的概率和是坏的概率，而生成模型分别学习出两种苹果各自对应的模型，然后将要预测的苹果的特征分别输入不同模型，然后比较两个模型输出概率的大小，选出合适的类别

判别模型：
* 感知机
* k近邻
* 决策树
* 逻辑思蒂回归
* svm
* boosting
* 最大熵模型

生成模型：
* 朴素贝叶斯
* 混合高斯模型
* 隐马尔可夫模型

## 转置卷积和空洞卷积

***转置卷积***
>在语义分割中，会使用卷积层进行特征提取，然后通过转置卷积做上采样，恢复为原先的尺寸，这样才可以对原来的图像中每个像素都进行分类。**转置卷积不是卷积的逆运算**

基本步骤：

* 在特征图**中间**(元素和元素之间)填充s-1行，s为步长
* 在特征图**四周**填充k-p-1行，k为卷积核大小，p为padding
* 将kernel上下、左右翻转（中心对称，顺时针旋转180度）
* 做kernel_size不变，s和p均为1的卷积即可

***空洞卷积***
* 在卷积核相邻元素之间插入0,具体插入膨胀率(dilation rate)-1个0，然后再做卷积
* 主要目的是扩大感受野

## 数据集不平衡的处理方式

1. 数据增广
	* 进行一定的旋转缩放
	* RGB三通道提取三张图片
	* 高斯模糊
2. 人工合成数据
3. 给每种类别赋予权值，样本少的类别权值可以大一些，样本多的类别权值小一些

## tensorflow和pytorch的区别

1. tf是谷歌开源的深度学习框架，pytorch是facebook开源的深度学习框架
2. 在tf1.0时，tf只支持静态的计算图，而pytorch支持动态的计算图，但是tf2.0也支持动态计算图了
3. tf的api更详细更丰富，pytorch的代码更简洁
4. tf有tensorboard这样的可视化工具，但实际上现在pytorch也能使用tensorboard

## transformer中的位置编码

>为什么需要位置编码？
* 位置和词语的顺序是任何语言的重要组成部分。它们定义了语法，从而决定了句子的实际语义。循环神经网络（RNN）本质上考虑了词语的顺序；它们按照顺序逐个解析句子中的词语。这样可以将词语的顺序整合到RNN的主干中。
* Transformer架构放弃了循环机制，转而采用**多头自注意机制**，大大加快训练时间。从理论上讲，它可以捕捉到句子中更长的依赖关系。由于句子中的**每个词语同时通过Transformer的编码器/解码器，模型本身对于每个词语的位置/顺序没有任何概念。**

>位置编码的计算？

$$
\left.\overrightarrow{p_t}^{(i)}=f(t)^{(i)}:=\left\{\begin{array}{ll}\sin(\omega_k.t),&\mathrm{if~}i=2k\\\cos(\omega_k.t),&\mathrm{if~}i=2k+1\end{array}\right.\right.
$$
其中，t代表位置，i代表维度。p代表第t个位置，第i个维度的值。$\omega_k$的计算如下：
$$
\omega_k=\frac1{10000^{2k/d}}
$$

有以下特点：
* 奇数维度之间或者偶数维度之间周期不同。
* 除了表示绝对位置信息外，还可以很好的表示相对位置信息。给定k,存在一个固定的与k相关的线性变换矩阵，从而由pos的位置编码线性变换而得到pos+k的位置编码。这个相对位置信息可能可以被模型发现而利用。因为绝对位置信息只保证了各个位置不一样，但是并不是像0,1,2这样的有明确前后关系的编码。

>CV中使用位置编码

与nlp中类似，cv中的每个像素和patch也有自己的位置信息，通常cv中位置编码有以下两种：

* 绝对位置编码：一般是可学习的，实现非常简洁，初始化一个形状和经过patch_embedding后的输出x相同的参数，然后直接加到x上，在训练阶段一起训练，有点像加了一个可学习的bias，VIT中使用的就是这种方式。
* 相对位置编码：绝对位置编码是在patch_embedding之后，计算自注意力(Q,K,V)之前，而相对位置编码是在计算自注意力的时候加入的，如下式
$$
\text{Attention}(Q,K,V)=\text{SoftMax}(\frac{QK^T}{\sqrt{d}}+B)V
$$
在swin transformer中，将二维位置信息转换为一维位置信息，然后去根据相对位置偏移表查询具体的值，位置偏移表的值是训练出来的，在文章中，相对位置编码效果好于绝对位置编码。具体参考[这里](https://blog.csdn.net/qq_43733107/article/details/127077056)

>为什么往往小数据集上卷积效果好于tranformer?
* 在小数据集上，相比卷积transformer缺少内在偏置，因此需要加入相对位置编码来解决这个问题，而对于特大数据集，transformer就可以学习到卷积的内在偏置，即这也是为什么在小数据集上transformer的效果不如卷积，而在大数据集上，transformer效果优于卷积。

## 自注意力和注意力的区别

注意力机制的查询和键是不同来源的，而自注意力机制的查询和键则都是来自于同一组的元素，如对于一张图片，q和k都来自于这张图片的patch或者特征。

>个人对于DETR的decoder中的q，k,v的理解

query是每张图设置的预测的proposals的数量，例如一张图的gt有20个bbox，然后query为100，那么网络会产生100个proposals，然后用匈牙利算法求得100个query和20个bbox的最优匹配

对于decoder的多头注意力，我理解的是kv来自encoder是因为encoder中将图像的特征进行了编码，然后由于需要产生100个proposals，所以就用外部的q来计算encoder产生的k的权重信息，比如qk^T->[16,100,32]*[16,32,576]=[16,100,576]，这里[100,576]代表了100个query在576个特征上的权重或者相似度信息，然后乘v[16,576,32]，输出是[16,100,32]，reshape为[100,2,256]，encoder的输出[576,2,256]经过decoder后映射为[100,2,256]，因此加入的query可能是为了学习encoder的输出中的特征信息，然后将特征的维度降到100，然后从这100个proposals中取匹配最佳的gt。


