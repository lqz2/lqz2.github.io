---
title: 龙与地下城游戏问题
date: 2022-09-16 21:22:56
categories: 机试
math:
tags:
---
<!-- TOC -->

- [龙与地下城迷宫问题](#龙与地下城迷宫问题)
- [思路](#思路)

<!-- /TOC -->
## 龙与地下城迷宫问题

[题目链接](https://www.nowcoder.com/practice/c0ca4c9e65144af69ada03febaa0e33a?tpId=230&tqId=537494&ru=/exam/oj&qru=/ta/dynamic-programming/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D230)

**题目描述**

给定一个二维数组map，含义是一张地图

游戏的规则如下:
1）骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。
2）地图中每个位置的值代表骑士要遭遇的事情。如果是负数，说明此处有怪兽，要让骑士损失血量。如果是非负数，代表此处有血瓶，能让骑士回血。
3）骑士从左上角到右下角的过程中，走到任何一个位置时，血量都不能少于1。为了保证骑土能见到公主，初始血量至少是多少?

根据map,输出初始血量。

输入第一行`n,m`，表示矩阵大小
然后输入矩阵

输出初始血量

input:
```
3 3
-2 -3 3
-5 -10 1
0 30 -5
```
output:
```
7
```
## 思路

这道题也属于dp，但是有意思的是，如果我们选择 `自顶向下` 的方式，即从左上角出发，在前进过程中，每一个位置的最小血量是由后面的路径决定的，因此`自顶向下` 方法是不行的，那么我们可以选择` 自底向上` 的方式，从右下角出发。

`dp[i][j]`可理解为，走`a[i][j]`之前，至少要拥有的血量，且这个血量始终不能小于1

所以`dp[n][m]`初始化为`max(1-a[n][m],1)`

然后从右下角到左上角更新dp数组即可

**代码**
```
#include <bits/stdc++.h>
using namespace std;

const int N=1e3+5;
int a[N][N],dp[N][N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
            cin>>a[i][j];
    }
    dp[n][m]=max(1-a[n][m],1);
    for(int i=n-1;i>=1;--i)
        dp[i][m]=max(dp[i+1][m]-a[i][m],1);
    for(int i=m-1;i>=1;--i)
        dp[n][i]=max(dp[n][i+1]-a[n][i],1);
    for(int i=n-1;i>=1;--i)
    {
        for(int j=m-1;j>=1;--j)
        {
            int t=min(dp[i+1][j]-a[i][j],dp[i][j+1]-a[i][j]);
            dp[i][j]=max(t,1);
        }
    }
    
    cout<<dp[1][1]<<endl;
    return 0;
}
```
