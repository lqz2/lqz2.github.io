---
title: 最少步行次数
date: 2025-08-31 18:17:39
categories:
math:
tags:
---
## 最少步行次数

<!-- TOC -->

- [最少步行次数](#最少步行次数)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->

[原题](https://niumacode.com/training/185/problem/P1832)


### 题目描述
在一片神奇的魔法森林中，有 n 个魔法节点，每个节点都有一个传送门。第 i 个节点的传送门会把你传送到 ai号节点。多多每次可以选择坐传送门从 i 节点传送到 ai 节点，或者选择步行到相邻的节点 i−1 或 i+1 节点。当然多多是个喜欢偷懒的人，所以它能坐传送门就尽量不步行。现在多多从 1 号节点出发，想知道到达每个节点需要经过的最少步行次数。

输入：

第一行一个整数 n (1≤n≤2×10^5)，表示节点数。第二行 n 个整数 a1,a2,…,an (1≤ai≤n)，表示第 i 个节点的传送门会把你传送到 ai 号节点。

输出：

输出一行 n 个整数，第 i 个整数表示多多从 1 号节点出发到达 i 号节点需要经过的最少步行次数。
  
### 思路

0-1 权图最短路问题，需要用到双端队列。
- 首先将第一个节点加入队列，步行次数为 0。
- 然后每次从队列头部取出一个节点，尝试更新右侧和左侧节点的最少步行次数，如果更新成功则将该节点加入队列尾部
- 更新完左右两侧节点后，再尝试当前节点对应的传送位置的最少步行次数，如果更新成功则将该节点加入队列头部。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin>>n;
    vector<int> a(n);
    for(int i=0;i<n;++i){
        cin>>a[i];
        a[i]--;
    }
    int inf=1e9;
    vector<int> dis(n,inf);
    deque<int> dq;

    dis[0] = 0;
    dq.push_front(0);

    while(!dq.empty()){
        int u = dq.front();
        dq.pop_front();
        if(u + 1 < n && dis[u] + 1 < dis[u+1]){
            dis[u+1] = dis[u] + 1;
            dq.push_back(u+1);
        }
        if(u - 1 >= 0 && dis[u] + 1 < dis[u-1]){
            dis[u-1] = dis[u] + 1;
            dq.push_back(u-1);
        }
        int v = a[u];
        if(dis[u] < dis[v]){
            dis[v] = dis[u];
            dq.push_front(v);
        }
    }
    
    for(int t:dis){
        cout<<t<<' ';
    }
    cout << endl;
}
```