---
title: 获取所有钥匙的最短路径
date: 2022-11-10 09:47:49
categories: 机试
math:
tags:
---
<!-- TOC -->

- [获取所有钥匙的最短路径](#获取所有钥匙的最短路径)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 获取所有钥匙的最短路径
[题目链接](https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/)
### 题目描述
给定一个二维网格 grid ，其中：

'.' 代表一个空房间
'#' 代表一堵
'@' 是起点
小写字母代表钥匙
大写字母代表锁
我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。

假设 k 为 钥匙/锁 的个数，且满足 1 <= k <= 6，字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。

返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。

示例：
```
输入：grid = ["@.a.#","###.#","b.A.B"]
输出：8
解释：目标是获得所有钥匙，而不是打开所有锁
```
### 思路
用一个三元组`(x,y,status)` 表示当前的状态，其中 `(x,y)` 表示当前所处的位置，`status` 是一个二进制数，长度恰好等于网格中钥匙的数目，`status` 的第 i 个二进制位为 1，当且仅当我们已经获得了网格中的第 i 把钥匙。

这样一来，我们就可以使用上述的状态进行广度优先搜索。初始时，我们把 `(srcx,srcy,0)`加入队列，其中 `srcx,srcy)` 为起点。在搜索的过程中，我们可以向上下左右四个方向进行扩展：

如果对应方向是空房间，那么 `status` 的值不变；

如果对应方向是第 i 把钥匙，那么将 `status` 的第 i 位置为 111；

如果对应方向是第 i 把锁，那么只有在 `status` 的第 i 位为 1 时，才可以通过。

当 `status` 每一位都为1时，说明获取了所有钥匙，此时就可以返回最短路作为答案。


### 代码
```
int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
class Solution {
public:
    unordered_map<char,int> mp;
    queue<tuple<int,int,int>> q;
    int shortestPathAllKeys(vector<string>& grid) {
        int m=grid.size(),n=grid[0].size();
        int srcx,srcy,dx,dy;
        for(int i=0;i<m;++i)
        {
            for(int j=0;j<n;++j)
            {
                if(grid[i][j]=='@')
                {
                    srcx=i;
                    srcy=j;
                }
                else if(grid[i][j]>='a'&&grid[i][j]<='z')
                {
                    if(!mp.count(grid[i][j]))
                        mp[grid[i][j]]=mp.size();
                }
            }
        }
        vector<vector<vector<int>>> dis(m,vector<vector<int>>(n,vector<int>(1<<mp.size(),-1)));
        q.push({srcx,srcy,0});
        dis[srcx][srcy][0]=0;
        while(!q.empty())
        {   
            auto[x,y,status]=q.front();
            q.pop();
            for(int i=0;i<4;++i)
            {
                dx=x+dir[i][0];
                dy=y+dir[i][1];
                if(dx>=0&&dx<m&&dy>=0&&dy<n&&grid[dx][dy]!='#')
                {
                    if(grid[dx][dy]=='.'||grid[dx][dy]=='@')
                    {
                        if(dis[dx][dy][status]==-1)
                        {
                            dis[dx][dy][status]=dis[x][y][status]+1;
                            q.push({dx,dy,status});
                        }
                    }
                    else if(grid[dx][dy]>='a'&&grid[dx][dy]<='z')
                    {
                        int idx=mp[grid[dx][dy]];
                        if(dis[dx][dy][status|(1<<idx)]==-1)
                        {
                            dis[dx][dy][status|(1<<idx)]=dis[x][y][status]+1;
                            if((status|(1<<idx))==(1<<mp.size())-1)
                                return dis[dx][dy][status|(1<<idx)];
                            q.push({dx,dy,status|(1<<idx)});
                        }
                    }
                    else
                    {
                        int idx=mp[grid[dx][dy]+32];
                        if((status & (1<<idx)) && dis[dx][dy][status]==-1)
                        {
                            dis[dx][dy][status]=dis[x][y][status]+1;
                            q.push({dx,dy,status});
                        }
                    }
                }
            }
        }
        return -1;
    }

};
```
