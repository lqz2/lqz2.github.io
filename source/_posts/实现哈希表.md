---
title: 实现哈希表
date: 2025-04-09 09:51:42
categories: 机试
math:
tags:
---
## 实现哈希表

<!-- TOC -->

- [实现哈希表](#实现哈希表)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->

[原题](https://leetcode.cn/problems/design-hashmap/description/)


### 题目描述
不使用任何内建的哈希表库设计一个哈希映射（HashMap）。

实现 MyHashMap 类：

MyHashMap() 用空映射初始化对象
void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。
int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。
void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。

```
输入：
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
输出：
[null, null, null, 1, -1, null, 1, null, -1]
```

### 思路
之前面试中让现场写，没准备过，手写的数组+链表，链表实现有些不完善的地方，这里重新做一遍，链表直接用的c++的list
总体思路就是无论什么操作，都是先获取哈希值，然后找到索引，遍历链表，找到对应的值
### 代码
```
class MyHashMap {
public:
    vector<list<pair<int,int>>> mp;
    static const int sz=1e5+7;

    MyHashMap():mp(sz) {}

    int hash(int key){
        return key%sz;
    }
    
    void put(int key, int value) {
        int idx=hash(key);
        for(auto it=mp[idx].begin();it!=mp[idx].end();++it){
            if((*it).first==key){
                (*it).second=value;
                return;
            }
        }
        mp[idx].push_back({key,value});
    }
    
    int get(int key) {
        int idx=hash(key);
        for(auto it=mp[idx].begin();it!=mp[idx].end();++it){
            if((*it).first==key){
                return (*it).second;
            }
        }
        return -1;
    }
    
    void remove(int key) {
        int idx=hash(key);
        for(auto it=mp[idx].begin();it!=mp[idx].end();++it){
            if((*it).first==key){
                mp[idx].erase(it);
                return;
            }
        }
    }
};

```