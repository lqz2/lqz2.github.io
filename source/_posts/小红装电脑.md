---
title: 小红装电脑
date: 2025-03-10 16:14:49
categories: 机试
math:
tags:
---
## 小红装电脑

<!-- TOC -->

- [小红装电脑](#小红装电脑)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->



### 题目描述
小红准备买一些零件来组装电脑。已知电脑一共有n个零件，每个零件有若干个型号。
小红现在知道了每个型号的对应价格a_i​以及性能v_i。小红需要每个零件选择一个型号，在总价格不超过x元的前提下，最终的总性能尽可能大。
你能帮帮她吗？

输入格式
```
第一行输入两个正整数n和x，代表电脑的零件数量以及小红最大的预算。
接下来的3*n行，每三行用来描述一个零件的不同型号的价格和性能。
对于每个零件，第一行输入一个正整数m，代表该零件有多少种型号。
第二行输入m个正整数a_i，代表该零件第i中型号的价格。
第三行输入m个正整数v_i，代表该零件第i中型号的性能。
1<=n,m<=40
1<= a_i,v_i,x <= 10^9
```
输出
```
如果无法完成组装，则直接输出-1。
否则输出一个正整数，代表最终最大的性能。
```
样例
```
输入例子：
2 4
2
1 2
3 5
3
3 2 3
5 6 7
输出例子：
11
例子说明：
一共需要两个零件。
第一个零件选择第二个型号，第二个零件也选择第二个型号。
这样总价格为4，总性能为11。

```
### 思路
第一眼看到就感觉是01背包，但是没有找到合适的dp数组来表示，后来看了大佬的思路感觉 dfs 简单明了。

主要思路就是dfs逆序遍历，每次dfs过程中，遍历当前零件的所有型号，如果当前预算大于等于该型号的价格，那么即可对当前型号进行dfs。
当dfs完所有零件后，更新ans即可。


### 代码
```
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=45;
ll num[N], v[N][N], w[N][N], x;
ll ans=-1;
void dfs(int n, ll cost, ll sum){
    if(n==0){
        ans=max(ans,sum);
        return ;
    }
    for(int i=1;i<=num[n];++i){
        if(cost>=v[n][i]){
            dfs(n-1,cost-v[n][i],sum+w[n][i]);
        }
    }
}
int main() {
    int n;
    cin>>n>>x;
    for(int i=1;i<=n;++i){
        int m;
        cin>>m;
        num[i]=m;
        for(int j=1;j<=m;++j)
            cin>>v[i][j];
        for(int j=1;j<=m;++j)
            cin>>w[i][j];
    }
    dfs(n,x,0);
    cout<<ans<<endl;
    
}
// 64 位输出请用 printf("%lld")
```