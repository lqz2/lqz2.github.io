---
title: 最小区间
date: 2024-05-23 11:09:24
categories:
math:
tags:
---
## 最小区间
<!-- TOC -->

- [最小区间](#最小区间)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
[原题](https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/description)

### 题目描述
你有 k 个 非递减排列 的整数列表。找到一个 最小 区间，使得 k 个列表中的每个列表至少有一个数包含在其中。

我们定义如果 b-a < d-c 或者在 b-a == d-c 时 a < c，则区间 [a,b] 比 [c,d] 小

e.g.
```
输入：nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
输出：[20,24]
解释： 
列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。
列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。
列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。
```

### 思路
这道题自己看的时候没什么头绪，看了官方题解才明白。主要思路就是滑动窗口和哈系表。首先，创建一个哈系表来储存每个数字各自属于哪个数组，如 mp[i]=[0,1,2] 表示数字 i 在第 [0,1,2] 个数组中都出现过，遍历过程中确定出所有数字的最大值和最小值，作为初始答案。接下来，用一个数组freq统计每个数组的出现次数，cnt表示覆盖的数组个数, 初始化滑窗左端点 l=min，右端点r=l-1，首先扩张右端点，当r存在于mp中，将r出现过的所有数组 freq+1，如果freq为1,说明该数组第一次出现，cnt+1。然后，当cnt==n时，已经满足题目要求，先更新最小区间，然后开始收缩左端点，同理，当l存在于mp中，将l出现过的所有数组 freq-1，如果freq为 0,说明该数组没有被覆盖，cnt-1，开始新的扩张阶段，直到r达到所有数字最大值。具体细节参考代码。
### 代码
```
class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& nums) {
        int n=nums.size();
        unordered_map<int,vector<int>> mp;//记录某元素都在哪些数组出现过
        int xmin=INT_MAX,xmax=INT_MIN;
        for(int i=0;i<n;++i)
        {
            for(int & t:nums[i])
            {
                mp[t].push_back(i);
                xmin=min(xmin,t);
                xmax=max(xmax,t);
            }
        }
        vector<int> freq(n);//统计每个数组的统计次数
        int cnt=0; //cnt==n时视为满足条件
        int l=xmin,r=xmin-1,res_l=xmin,res_r=xmax;
        while(r<xmax) //开始滑窗，先向右扩张，再向左收缩
        {
            ++r;
            if(mp.count(r))
            {
                for(int &t:mp[r]) //统计当前数在哪些数组出现过，如果在某数组出现则freq++
                {
                    ++freq[t];
                    if(freq[t]==1) //至少出现一次cnt+1
                        ++cnt;
                }
                while(cnt==n)//满足条件时更新答案，收缩左区间
                {
                    if(r-l<res_r-res_l) 
                    {
                        res_r=r;
                        res_l=l;
                    }
                    if(mp.count(l))
                    {
                        for(int &t:mp[l])
                        {
                            --freq[t];
                            if(freq[t]==0)//如果某数组没有数在当前区间出现，退出收缩阶段，继续扩张
                                --cnt;
                        }
                    }
                    ++l;
                }
            }
        }
        return {res_l,res_r};
    }
};
```