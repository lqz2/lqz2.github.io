---
title: 最长重复子串
date: 2024-09-27 10:33:59
categories: 机试
math:
tags:
---
## 最长重复子串

<!-- TOC -->

- [最长重复子串](#最长重复子串)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)
    - [tips](#tips)

<!-- /TOC -->

[原题](https://leetcode.cn/problems/longest-duplicate-substring/description/)


### 题目描述
给你一个字符串 s ，考虑其所有 重复子串 ：即 s 的（连续）子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。

返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 "" 。

e.g.
```
输入：s = "banana"
输出："ana"
```
### 思路
参考大佬的题解，主要思路是字符串哈希 + 二分。用二分搜索数组的长度，然后check长度为len的子串是否重复出现，如果是，返回该子串，否则，返回空串。二分过程中如果返回空串，缩短长度继续二分，否则扩大长度继续二分。

现在难点在于如何在O(n)复杂度内执行check,这里用到字符串哈希：
创建数组h和p，P是一个质数(一般要尽可能大一点)
h：用于存储前缀哈希值的数组。
p：存储每个位置的幂次的数组，方便计算哈希值。
初始化:
```
for (int i = 0; i < n; i++) {
            p[i + 1] = p[i] * P;
            h[i + 1] = h[i] * P + s[i];
        }
```
`h[i]`是子串从 第一个位置 到 第 i 个 的哈希值
从位置 i 到 j 的子串的哈希值的表达式为：
```
h[j] - h[i - 1] * p[j - i + 1]
```
把这些哈希值存在set里，可以判断子串是否重复出现

PS:大佬的java代码long long就能过，我写的c++用long long都会爆，必须用unsigned long long
### 代码
```
class Solution {
public:
    typedef unsigned long long ULL;
    int P=1313131;
    vector<ULL> h,p;
    string check(string &s,int len){
        int n=s.size();
        unordered_set<ULL> st;
        for(int i=1;i+len-1<=n;++i){
            int j=i+len-1;
            ULL t=h[j]-h[i-1]*p[j-i+1];//i~j子串的哈希值
            if(st.count(t))
                return s.substr(i-1,len);
            st.insert(t);
        }
        return "";
    }
    string longestDupSubstring(string s) {
        int n=s.size();
        h.resize(n+1);
        p.resize(n+1);
        p[0]=1;
        for(int i=0;i<n;++i){
            p[i+1]=p[i]*P;
            h[i+1]=h[i]*P+s[i];
        }
        int l=0,r=n;
        string ans;
        while(l<r){
            int mid=l+(r-l)/2;
            string t=check(s,mid);
            int tlen=t.size();
            if(tlen==0)
                r=mid;
            else
                l=mid+1;
            ans=tlen>ans.size()?t:ans;
        }
        return ans;
    }
};
```
### tips
最长公共子序列和最长公共子串的区别是：后者是连续的，当前字符不相等时`dp[i][j]=0`