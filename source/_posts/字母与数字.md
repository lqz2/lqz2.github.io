---
title: 字母与数字
date: 2023-03-11 08:21:28
categories: 机试
math: true
tags:
---
<!-- TOC -->

- [字母与数字](#字母与数字)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 字母与数字
[原题](https://leetcode.cn/problems/find-longest-subarray-lcci/description/)
### 题目描述
给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。

返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。

e.g.
```
输入: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]

输出: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7"]
```
### 思路
用到前缀和的思想，当元素为字母时加1，为数字时减1，当`i`和`j`位置处的前缀和相等，说明他们之间的子数组满足要求。用哈系表保存每一个前缀和的值第一次出现时对应的数组下标，并遍历数组，如果前缀和的值已经出现过，那么记录子数组的起始位置，更新最大长度，否则在哈系表中记录该下标。
### 代码
```
class Solution {
public:
    vector<string> findLongestSubarray(vector<string>& array) {
        unordered_map<int,int> mp;
        mp[0]=-1;
        int sum=0,maxlen=0,start=0;
        int n=array.size();
        for(int i=0;i<n;++i)
        {
            if(isalpha(array[i][0]))
                ++sum;
            else
                --sum;
            if(mp.count(sum))
            {
                int preidx=mp[sum];
                if(i-preidx>maxlen)
                {
                    maxlen=i-preidx;
                    start=preidx+1;
                }    
            }
            else
                mp[sum]=i;
        }
        if(maxlen==0)
            return {};
        
        return vector<string>(array.begin()+start,array.begin()+start+maxlen);
    }   
};
```