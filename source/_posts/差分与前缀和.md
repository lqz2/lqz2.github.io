---
title: 差分与前缀和
date: 2022-08-24 10:54:34
categories: 机试
tags:
---
<!-- TOC -->

- [前缀和](#前缀和)
- [一维前缀和](#一维前缀和)
- [二维前缀和](#二维前缀和)
- [例题](#例题)
- [差分](#差分)
- [一维差分](#一维差分)
- [例题](#例题-1)
- [二维差分](#二维差分)
- [例题](#例题-2)

<!-- /TOC -->
### 前缀和
>前缀和指的是序列的前n项和

### 一维前缀和
先看一个例题：
输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。
如果使用暴力枚举，时间复杂度为 `O(n*m)`,但是使用前缀和的话，时间复杂度可降为 `O(n)`
input:
```
5 3
2 1 3 6 4
1 2
1 3
2 4
```

output:
```
3
6
10
```


代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5;
int a[N]; 
int main()
{
	int n,m,l,r;
	cin>>n>>m;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];
		a[i]+=a[i-1];
	}
	while(m--)
	{
		cin>>l>>r;
		cout<<a[r]-a[l-1]<<endl;
	}
	return 0;
}
```

### 二维前缀和

每一个元素`a[i][j]`表示左上角和第`i`行，第`j`列围成的元素之和

更新方式： `a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]`


### 例题

输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。
对于每个询问输出子矩阵中所有数的和

input:
```
3 4 3
1 7 2 4
3 6 2 8
2 1 2 3
1 1 2 2
2 1 3 4
1 3 3 4
```
output:
```
17
27
21
```

代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e3;
int a[N][N]; 
int main()
{
	int n,m,q;
	int x1,y1,x2,y2;
	cin>>n>>m>>q;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			cin>>a[i][j];
			a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
		}
	}
	while(q--)
	{
		cin>>x1>>y1>>x2>>y2;
		cout<<a[x2][y2]-a[x1-1][y2]-a[x2][y1-1]+a[x1-1][y1-1]<<endl;
	}
	return 0;
}
```
### 差分
>可以看作前缀和的逆运算

### 一维差分

常用于给数组的某个区间段`[l,r]`加上某个数`c`，可以减小时间复杂度

* 先构造差分数组：`b[i]=a[i]-a[i-1]`
* 构造好之后 `b[l]+=c`,`b[r+1]-=c`
* 然后根据`b[i]+=b[i-1]`计算前缀和数组，就是最终答案

### 例题

输入一个长度为n的整数序列。
接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。
请你输出进行完所有操作后的序列。

input:
```
6 3
1 2 2 1 2 1
1 3 1
3 5 1
1 6 1
```
output:
```
3 4 5 3 4 2
```

代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e3;
int a[N],b[N]; 
int main()
{
	int n,m,l,r,c;
	cin>>n>>m;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];
		b[i]=a[i]-a[i-1];
	}
	while(m--)
	{
		cin>>l>>r>>c;
		b[l]+=c;
		b[r+1]-=c;
	}
	for(int i=1;i<=n;++i)
		b[i]+=b[i-1];
	for(int i=1;i<=n;++i)
		cout<<b[i]<<' ';
	return 0;
}
```

### 二维差分

常用于给某个子矩阵的每个元素加上 c

* 二维差分数组的构造：
    `b[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]`
* 修改差分数组：
    ```
    b[x1][y1]+=c;
    b[x1][y2+1]-=c;
    b[x2+1][y1]-=c;
    b[x2+1][y2+1]+=c;
    ```
* 生成前缀和数组：
    `b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];`

### 例题

输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。
每个操作都要将选中的子矩阵中的每个元素的值加上c。
请你将进行完所有操作后的矩阵输出。

input:
```
3 4 3
1 2 2 1
3 2 2 1
1 1 1 1
1 1 2 2 1
1 3 2 3 2
3 1 3 4 1
```
output:
```
2 3 4 1
4 3 4 1
2 2 2 2
```
代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e3;
int a[N][N],b[N][N]; 
int main()
{
	int n,m,q;
	int x1,y1,x2,y2,c;
	cin>>n>>m>>q;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
		{
			cin>>a[i][j];
			b[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1];
		}
	}
	while(q--)
	{
		cin>>x1>>y1>>x2>>y2>>c;
		b[x1][y1]+=c;
		b[x1][y2+1]-=c;
		b[x2+1][y1]-=c;
		b[x2+1][y2+1]+=c;
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
			b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
			cout<<b[i][j]<<' ';
		cout<<endl;
	}
	return 0;
}
```
