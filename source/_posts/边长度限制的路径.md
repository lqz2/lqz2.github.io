---
title: 边长度限制的路径
date: 2022-12-14 11:56:50
categories: 机试
math:
tags:
---

<!-- TOC -->

- [边长度限制的路径](#边长度限制的路径)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 边长度限制的路径
[原题](https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/description/)
### 题目描述
给你一个 n 个点组成的无向图边集 edgeList ，其中 edgeList[i] = [ui, vi, disi] 表示点 ui 和点 vi 之间有一条长度为 disi 的边。请注意，两个点之间可能有 超过一条边 。

给你一个查询数组queries ，其中 queries[j] = [pj, qj, limitj] ，你的任务是对于每个查询 queries[j] ，判断是否存在从 pj 到 qj 的路径，且这条路径上的每一条边都 严格小于 limitj 。

请你返回一个 布尔数组 answer ，其中 answer.length == queries.length ，当 queries[j] 的查询结果为 true 时， answer 第 j 个值为 true ，否则为 false 。
### 思路
>主要用到并查集的思想，先将edgelist和queries中的边按长度升序排序，对于queries的每条边，先将edgelist中长度小于limit的边加入并查集，然后再判断queries的p,q是否连通，如果是，说明存在p到q的路径，而且因为当前并查集中的边都小于此query的limit，所以p到q路径上的所有边也小于limit，该query的结果为true，否则为false。

### 代码
我在实现并查集时习惯初始化为-1，但这道题不知道为什么不能初始化为-1，后面后机会再看吧:cry:
```
class Solution {
public:
    int find(vector<int>& vset,int a)
    {
        if(vset[a]==a)
            return a;
        else
            return vset[a]=find(vset,vset[a]);
    }
    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {
        sort(edgeList.begin(),edgeList.end(),[](vector<int>& a,vector<int>& b){
            return a[2]<b[2];
        });
        vector<int> vset(n);
        iota(vset.begin(),vset.end(),0);
        vector<int> idx(queries.size());
        iota(idx.begin(),idx.end(),0);
        sort(idx.begin(),idx.end(),[&](int a,int b){
            return queries[a][2]<queries[b][2];
        });
        int k=0;
        vector<bool> ans(queries.size());
        int sz=edgeList.size();
        for(int i:idx)
        {
            while(k<sz&&edgeList[k][2]<queries[i][2])
            {
                int x=find(vset,edgeList[k][0]);
                int y=find(vset,edgeList[k][1]);
                vset[x]=y;
                ++k;
            }
            if(find(vset,queries[i][0])==find(vset,queries[i][1]))
                ans[i]=true;
        }
        return ans;
    }
};
```
