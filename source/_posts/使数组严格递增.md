---
title: 使数组严格递增
date: 2023-04-20 08:43:24
categories: 机试
math:
tags:
---
<!-- TOC -->

- [使数组严格递增](#使数组严格递增)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->
## 使数组严格递增
[原题](https://leetcode.cn/problems/make-array-strictly-increasing/)
### 题目描述
给你两个整数数组 arr1 和 arr2，返回使 arr1 严格递增所需要的最小「操作」数（可能为 0）。

每一步「操作」中，你可以分别从 arr1 和 arr2 中各选出一个索引，分别为 i 和 j，0 <= i < arr1.length 和 0 <= j < arr2.length，然后进行赋值运算 arr1[i] = arr2[j]。

如果无法让 arr1 严格递增，请返回 -1。

e.g.
```
输入：arr1 = [1,5,3,6,7], arr2 = [4,3,1]
输出：2
解释：用 3 来替换 5，然后用 4 来替换 3，得到 arr1 = [1, 3, 4, 6, 7]。
```
### 思路
用`dfs（i,r）`表示`0~i`区间严格递增，且`a[i]<r`的最小操作次数，对于`i`位置的数，记它右边的数是`r`，那么`i`位置分替换和不替换两种情况

* 不替换：`a[i]<r`，`dfs(i,r)=dfs(i-1,a[i])`
* 替换：`a[i]>=r`，通过二分查找在b中找到小于r的最大数`b[k]`，然后替换，dfs(i,pre)=dfs(i-1,b[k])+1;

为了减少时间，还可以用一个哈系表记录每个位置的值，如果i已经访问过则直接返回结果即可。
### 代码
```
class Solution {
public:
    int makeArrayIncreasing(vector<int>& a, vector<int>& b) {
        sort(b.begin(),b.end());
        int n=a.size();
        unordered_map<int,int> m[n];
        function<int(int,int)> dfs=[&](int i,int r)->int{
            if(i<0)
                return 0;
            auto it=m[i].find(r);
            // 计算过直接用之前的结果
            if(it!=m[i].end())
                return it->second;
            int res=a[i]<r ? dfs(i-1,a[i]):INT_MAX/2;
            // 二分查找b中第一个大于等于r的位置
            auto k=lower_bound(b.begin(),b.end(),r);
            if(k!=b.begin())
                res=min(res,dfs(i-1,*(--k))+1);
            m[i][r]=res;
            return res;
        };
        int ans=dfs(n-1,INT_MAX);
        return ans>n ? -1:ans;
    }
};
```