---
title: 简化路径
date: 2024-09-21 09:34:28
categories: 机试
math:
tags:
---
## 简化路径

<!-- TOC -->

- [简化路径](#简化路径)
    - [题目描述](#题目描述)
    - [思路](#思路)
    - [代码](#代码)

<!-- /TOC -->

[原题](https://leetcode.cn/problems/simplify-path/description)


### 题目描述
给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为 更加简洁的规范路径。

在 Unix 风格的文件系统中规则如下：

一个点 '.' 表示当前目录本身。
此外，两个点 '..' 表示将目录切换到上一级（指向父目录）。
任意多个连续的斜杠（即，'//' 或 '///'）都被视为单个斜杠 '/'。
任何其他格式的点（例如，'...' 或 '....'）均被视为有效的文件/目录名称。
返回的 简化路径 必须遵循下述格式：

始终以斜杠 '/' 开头。
两个目录名之间必须只有一个斜杠 '/' 。
最后一个目录名（如果存在）不能 以 '/' 结尾。
此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
返回简化后得到的 规范路径 。

```
输入：path = "/home//foo/"

输出："/home/foo"
```
### 思路
先按`/`分割字符串，这个python一行就搞定了。然后将分割后的数组按规则入栈：
- 如果为`..`，则弹出栈顶字符串
- 如果为空或者为`.`，则跳过
- 其他情况入栈

最后遍历栈内字符串元素，将他们拼接。
### 代码
```
class Solution {
public:
    string simplifyPath(string path) {
        auto split=[&](string& s, char c)->vector<string>{
            vector<string> res;
            string cur;
            for(char t:s){
                if(t==c){
                    res.push_back(cur);
                    cur.clear();
                }else{
                    cur+=t;
                }
            }
            res.push_back(cur);
            return res;
        };
        vector<string> sr=split(path,'/');
        vector<string> st;
        for(string& t: sr){
            if(t==".."){
                if(!st.empty())
                    st.pop_back();
            }else if(!t.empty()&&t!=".")
                st.push_back(t);
        }
        string ans;
        if(st.empty())
            ans+='/';
        else{
            for(string t: st)
                ans+='/'+t;
        }
        return ans;
    }
};
```