---
title: 背包问题
date: 2022-08-22 15:08:09
categories: 机试
tags:
---
<!-- TOC -->

- [思路](#思路)
- [例题1：01背包](#例题101背包)
- [例题2：完全背包](#例题2完全背包)

<!-- /TOC -->

>***背包问题*** 是经典的一类动态规划类型的题目，一般是有n种物品，每个物品有对应的价值w，然后背包体积为V，求能装入的物品的最大价值。

#### 思路
设 **dp[i][j]** 为前 i 个物品，背包容量为 j 的最大价值。

那么考虑第i个物品是否放入，有两种情况：
* 如果不放，那么等同于前 **i−1** 个物品，容量为j的背包的最优方案。
* 如果放，那么等同于前 **i−1** 个物品，容量为 **j−v[i]** 的背包的最优方案，再加上第i个物品的价值。

那么可以得到转移方程：

***dp[i][j]=max(dp[i−1][j],dp[i−1][j−v[i]]+w[i])***

最终的答案就是 **dp[n][V]**

观察到dp数组，第i行仅跟上一行有关系，故可以压缩一维，为了防止dp[i−1][j−v[i]]被覆盖掉，第二维度须**反向枚举**。

#### 例题1：01背包
你有一个背包，最多能容纳的体积是V，现在有n个物品，第i个物品的体积为vi,价值为wi。
1. 求这个背包至多能装多大价值的物品？
2. 若背包恰好装满，求至多能装多大价值的物品？

输入第一行n,V
后面n行，输入第i件物品的体积vi和价值wi
输出：两个问题的答案，各占一行，如果无解输出0

input:
```
3 5
2 10
4 5
1 4
```
output:
```
14
9
```
题解：
```
#include<bits/stdc++.h>
using namespace std;
int n,V;
const int N=1005;
int v[N],w[N];
int dp[N];
int main()
{
    cin>>n>>V;
    for(int i=1;i<=n;++i)
    {
        cin>>v[i];
        cin>>w[i];
    }
    //不要求装满
    for(int i=1;i<=n;++i)
    {
        for(int j=V;j>=v[i];--j)
            dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
    }
    cout<<dp[V]<<endl;
    
    //要求装满
    memset(dp,-0x3f,sizeof(dp));
    dp[0]=0;
    for(int i=1;i<=n;++i)
    {
        for(int j=V;j>=v[i];--j)
            dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
    }
    if(dp[V]>0)
        cout<<dp[V]<<endl;
    else
        cout<<0<<endl;
    return 0;
}
```
#### 例题2：完全背包
描述与例题1相同，不过每种物品有**任意**个

input:
```
6 13
13 189
17 360
19 870
14 184
6 298
16 242
```
output:
```
596
189
```
题解：
```
#include<bits/stdc++.h>
using namespace std;
int n,V;
const int N=1005;
int v[N],w[N];
int dp[N];
int main()
{
    cin>>n>>V;
    for(int i=1;i<=n;++i)
    {
        cin>>v[i];
        cin>>w[i];
    }
    //不要求装满
    for(int i=1;i<=n;++i)
    {
        for(int j=v[i];j<=V;++j)
            dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
    }
    cout<<dp[V]<<endl;
    
    //要求装满
    memset(dp,-0x3f,sizeof(dp));
    dp[0]=0;
    for(int i=1;i<=n;++i)
    {
        for(int j=v[i];j<=V;++j)
            dp[j]=max(dp[j],dp[j-v[i]]+w[i]);
    }
    if(dp[V]>0)
        cout<<dp[V]<<endl;
    else
        cout<<0<<endl;
    return 0;
}
```

